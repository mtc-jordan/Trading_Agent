var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// drizzle/schema.ts
var schema_exports = {};
__export(schema_exports, {
  activityFeed: () => activityFeed,
  agentAnalyses: () => agentAnalyses,
  agentPerformance: () => agentPerformance,
  alertHistory: () => alertHistory,
  backgroundJobs: () => backgroundJobs,
  backtestResults: () => backtestResults,
  backtests: () => backtests,
  badgeDefinitions: () => badgeDefinitions,
  botBenchmarks: () => botBenchmarks,
  botCopies: () => botCopies,
  botExecutionLogs: () => botExecutionLogs,
  botRiskRules: () => botRiskRules,
  botSchedules: () => botSchedules,
  brokerAccountSnapshots: () => brokerAccountSnapshots,
  brokerActivityLogs: () => brokerActivityLogs,
  brokerConnections: () => brokerConnections,
  brokerOrders: () => brokerOrders,
  brokerPerformanceMetrics: () => brokerPerformanceMetrics,
  brokerPositions: () => brokerPositions,
  brokerWatchlists: () => brokerWatchlists,
  copySettings: () => copySettings,
  copyTraders: () => copyTraders,
  copyTrades: () => copyTrades,
  cryptoWatchlist: () => cryptoWatchlist,
  discussionComments: () => discussionComments,
  discussionThreads: () => discussionThreads,
  earningsCallTranscripts: () => earningsCallTranscripts,
  earningsSentimentHistory: () => earningsSentimentHistory,
  emailConfig: () => emailConfig,
  emailQueue: () => emailQueue,
  emailTemplates: () => emailTemplates,
  emailVerifications: () => emailVerifications,
  exchangeConnections: () => exchangeConnections,
  exchangeOrders: () => exchangeOrders,
  investmentTheses: () => investmentTheses,
  jobHistory: () => jobHistory,
  journalEntries: () => journalEntries,
  llmPricing: () => llmPricing,
  llmProviderConfigs: () => llmProviderConfigs,
  llmUsageLogs: () => llmUsageLogs,
  marketplaceListings: () => marketplaceListings,
  oauthStates: () => oauthStates,
  orderExecutions: () => orderExecutions,
  paperTradingAccounts: () => paperTradingAccounts,
  paperTradingHistory: () => paperTradingHistory,
  paperTradingOrders: () => paperTradingOrders,
  paperTradingPositions: () => paperTradingPositions,
  performanceReports: () => performanceReports,
  portfolioAllocations: () => portfolioAllocations,
  portfolioSnapshots: () => portfolioSnapshots,
  portfolioValueSnapshots: () => portfolioValueSnapshots,
  predictionAccuracy: () => predictionAccuracy,
  priceAlerts: () => priceAlerts,
  priceTracking: () => priceTracking,
  realtimeSubscriptions: () => realtimeSubscriptions,
  rebalancingHistory: () => rebalancingHistory,
  regimeAlerts: () => regimeAlerts,
  rlAgentModels: () => rlAgentModels,
  rlExperiences: () => rlExperiences,
  rlTrainingHistory: () => rlTrainingHistory,
  savedComparisons: () => savedComparisons,
  scenarioImports: () => scenarioImports,
  scenarioLikes: () => scenarioLikes,
  sentimentAlerts: () => sentimentAlerts,
  sharedScenarios: () => sharedScenarios,
  strategyComparisons: () => strategyComparisons,
  strategyRatings: () => strategyRatings,
  subscriptionTierLimits: () => subscriptionTierLimits,
  templatePerformance: () => templatePerformance,
  thesisPerformance: () => thesisPerformance,
  trades: () => trades,
  tradingAccounts: () => tradingAccounts,
  tradingBots: () => tradingBots,
  userBadges: () => userBadges,
  userEmailPreferences: () => userEmailPreferences,
  userFallbackSettings: () => userFallbackSettings,
  userFollows: () => userFollows,
  userLlmSettings: () => userLlmSettings,
  userNotifications: () => userNotifications,
  userProfiles: () => userProfiles,
  userRoutingPreferences: () => userRoutingPreferences,
  users: () => users,
  watchlistAlerts: () => watchlistAlerts,
  watchlists: () => watchlists
});
import { int, mysqlEnum, mysqlTable, text, timestamp, varchar, decimal, boolean, json, date } from "drizzle-orm/mysql-core";
var users, tradingAccounts, tradingBots, trades, backtests, portfolioSnapshots, agentAnalyses, marketplaceListings, botCopies, watchlists, subscriptionTierLimits, userLlmSettings, llmProviderConfigs, llmUsageLogs, userFallbackSettings, llmPricing, priceTracking, predictionAccuracy, savedComparisons, watchlistAlerts, alertHistory, userNotifications, realtimeSubscriptions, botSchedules, botRiskRules, botExecutionLogs, botBenchmarks, userProfiles, userFollows, discussionThreads, discussionComments, strategyRatings, activityFeed, userBadges, badgeDefinitions, emailTemplates, emailQueue, userEmailPreferences, backgroundJobs, jobHistory, performanceReports, portfolioValueSnapshots, emailConfig, emailVerifications, rlAgentModels, rlTrainingHistory, rlExperiences, backtestResults, strategyComparisons, paperTradingAccounts, paperTradingOrders, paperTradingPositions, paperTradingHistory, priceAlerts, regimeAlerts, sentimentAlerts, cryptoWatchlist, copyTraders, copySettings, copyTrades, journalEntries, exchangeConnections, exchangeOrders, brokerConnections, oauthStates, brokerOrders, brokerPositions, orderExecutions, brokerAccountSnapshots, portfolioAllocations, rebalancingHistory, brokerPerformanceMetrics, sharedScenarios, scenarioLikes, scenarioImports, templatePerformance, brokerWatchlists, brokerActivityLogs, userRoutingPreferences, investmentTheses, thesisPerformance, agentPerformance, earningsCallTranscripts, earningsSentimentHistory;
var init_schema = __esm({
  "drizzle/schema.ts"() {
    "use strict";
    users = mysqlTable("users", {
      id: int("id").autoincrement().primaryKey(),
      openId: varchar("openId", { length: 64 }).notNull().unique(),
      name: text("name"),
      email: varchar("email", { length: 320 }),
      loginMethod: varchar("loginMethod", { length: 64 }),
      role: mysqlEnum("role", ["user", "admin"]).default("user").notNull(),
      // Subscription fields
      subscriptionTier: mysqlEnum("subscriptionTier", ["free", "starter", "pro", "elite"]).default("free").notNull(),
      stripeCustomerId: varchar("stripeCustomerId", { length: 255 }),
      stripeSubscriptionId: varchar("stripeSubscriptionId", { length: 255 }),
      subscriptionStatus: mysqlEnum("subscriptionStatus", ["active", "canceled", "past_due", "trialing", "incomplete"]).default("active"),
      subscriptionEndsAt: timestamp("subscriptionEndsAt"),
      // Email verification
      isEmailVerified: boolean("isEmailVerified").default(false).notNull(),
      emailVerifiedAt: timestamp("emailVerifiedAt"),
      // Timestamps
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
      lastSignedIn: timestamp("lastSignedIn").defaultNow().notNull()
    });
    tradingAccounts = mysqlTable("trading_accounts", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      type: mysqlEnum("type", ["paper", "live"]).default("paper").notNull(),
      balance: decimal("balance", { precision: 18, scale: 2 }).default("100000.00").notNull(),
      initialBalance: decimal("initialBalance", { precision: 18, scale: 2 }).default("100000.00").notNull(),
      currency: varchar("currency", { length: 10 }).default("USD").notNull(),
      isActive: boolean("isActive").default(true).notNull(),
      brokerConnection: json("brokerConnection"),
      // For live accounts
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    tradingBots = mysqlTable("trading_bots", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      accountId: int("accountId").notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      status: mysqlEnum("status", ["active", "paused", "stopped", "error"]).default("stopped").notNull(),
      strategy: json("strategy").notNull(),
      // Strategy configuration
      symbols: json("symbols").notNull(),
      // Array of trading symbols
      riskSettings: json("riskSettings").notNull(),
      // Risk management config
      // Performance metrics
      totalTrades: int("totalTrades").default(0).notNull(),
      winningTrades: int("winningTrades").default(0).notNull(),
      totalPnl: decimal("totalPnl", { precision: 18, scale: 2 }).default("0.00").notNull(),
      sharpeRatio: decimal("sharpeRatio", { precision: 10, scale: 4 }),
      maxDrawdown: decimal("maxDrawdown", { precision: 10, scale: 4 }),
      // Marketplace
      isPublic: boolean("isPublic").default(false).notNull(),
      copyCount: int("copyCount").default(0).notNull(),
      rating: decimal("rating", { precision: 3, scale: 2 }),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    trades = mysqlTable("trades", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      accountId: int("accountId").notNull(),
      botId: int("botId"),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      side: mysqlEnum("side", ["buy", "sell"]).notNull(),
      type: mysqlEnum("type", ["market", "limit", "stop", "stop_limit"]).notNull(),
      status: mysqlEnum("status", ["pending", "filled", "partial", "canceled", "rejected"]).notNull(),
      quantity: decimal("quantity", { precision: 18, scale: 8 }).notNull(),
      price: decimal("price", { precision: 18, scale: 8 }),
      filledPrice: decimal("filledPrice", { precision: 18, scale: 8 }),
      filledQuantity: decimal("filledQuantity", { precision: 18, scale: 8 }),
      pnl: decimal("pnl", { precision: 18, scale: 2 }),
      fees: decimal("fees", { precision: 18, scale: 4 }).default("0.00"),
      // AI agent analysis that led to this trade
      agentAnalysis: json("agentAnalysis"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      filledAt: timestamp("filledAt"),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    backtests = mysqlTable("backtests", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      botId: int("botId"),
      name: varchar("name", { length: 255 }).notNull(),
      status: mysqlEnum("status", ["pending", "running", "completed", "failed"]).default("pending").notNull(),
      strategy: json("strategy").notNull(),
      symbols: json("symbols").notNull(),
      startDate: timestamp("startDate").notNull(),
      endDate: timestamp("endDate").notNull(),
      initialCapital: decimal("initialCapital", { precision: 18, scale: 2 }).notNull(),
      // Results
      finalCapital: decimal("finalCapital", { precision: 18, scale: 2 }),
      totalReturn: decimal("totalReturn", { precision: 10, scale: 4 }),
      sharpeRatio: decimal("sharpeRatio", { precision: 10, scale: 4 }),
      maxDrawdown: decimal("maxDrawdown", { precision: 10, scale: 4 }),
      winRate: decimal("winRate", { precision: 10, scale: 4 }),
      profitFactor: decimal("profitFactor", { precision: 10, scale: 4 }),
      totalTrades: int("totalTrades"),
      results: json("results"),
      // Detailed backtest results
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      completedAt: timestamp("completedAt"),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    portfolioSnapshots = mysqlTable("portfolio_snapshots", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      accountId: int("accountId").notNull(),
      snapshotDate: timestamp("snapshotDate").notNull(),
      totalValue: decimal("totalValue", { precision: 18, scale: 2 }).notNull(),
      cashBalance: decimal("cashBalance", { precision: 18, scale: 2 }).notNull(),
      positions: json("positions").notNull(),
      // Array of positions
      dailyPnl: decimal("dailyPnl", { precision: 18, scale: 2 }),
      dailyReturn: decimal("dailyReturn", { precision: 10, scale: 4 }),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    agentAnalyses = mysqlTable("agent_analyses", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      botId: int("botId"),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      // Individual agent scores/signals (-1 to 1)
      technicalScore: decimal("technicalScore", { precision: 5, scale: 4 }),
      fundamentalScore: decimal("fundamentalScore", { precision: 5, scale: 4 }),
      sentimentScore: decimal("sentimentScore", { precision: 5, scale: 4 }),
      riskScore: decimal("riskScore", { precision: 5, scale: 4 }),
      microstructureScore: decimal("microstructureScore", { precision: 5, scale: 4 }),
      macroScore: decimal("macroScore", { precision: 5, scale: 4 }),
      quantScore: decimal("quantScore", { precision: 5, scale: 4 }),
      // Consensus
      consensusScore: decimal("consensusScore", { precision: 5, scale: 4 }),
      consensusAction: mysqlEnum("consensusAction", ["strong_buy", "buy", "hold", "sell", "strong_sell"]),
      confidence: decimal("confidence", { precision: 5, scale: 4 }),
      // Detailed analysis
      analysisDetails: json("analysisDetails"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    marketplaceListings = mysqlTable("marketplace_listings", {
      id: int("id").autoincrement().primaryKey(),
      botId: int("botId").notNull(),
      userId: int("userId").notNull(),
      // Creator
      title: varchar("title", { length: 255 }).notNull(),
      description: text("description"),
      category: mysqlEnum("category", ["momentum", "mean_reversion", "trend_following", "arbitrage", "ml_based", "other"]).notNull(),
      price: decimal("price", { precision: 10, scale: 2 }).default("0.00").notNull(),
      // 0 = free
      subscriptionPrice: decimal("subscriptionPrice", { precision: 10, scale: 2 }),
      // Monthly subscription
      // Stats
      totalCopies: int("totalCopies").default(0).notNull(),
      totalRevenue: decimal("totalRevenue", { precision: 18, scale: 2 }).default("0.00").notNull(),
      rating: decimal("rating", { precision: 3, scale: 2 }),
      reviewCount: int("reviewCount").default(0).notNull(),
      // Performance (last 30 days)
      monthlyReturn: decimal("monthlyReturn", { precision: 10, scale: 4 }),
      monthlyTrades: int("monthlyTrades"),
      winRate: decimal("winRate", { precision: 10, scale: 4 }),
      // Accuracy metrics
      accuracyScore: decimal("accuracyScore", { precision: 5, scale: 4 }),
      // AI prediction accuracy
      totalPredictions: int("totalPredictions").default(0).notNull(),
      correctPredictions: int("correctPredictions").default(0).notNull(),
      isActive: boolean("isActive").default(true).notNull(),
      isFeatured: boolean("isFeatured").default(false).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    botCopies = mysqlTable("bot_copies", {
      id: int("id").autoincrement().primaryKey(),
      originalBotId: int("originalBotId").notNull(),
      copiedBotId: int("copiedBotId").notNull(),
      userId: int("userId").notNull(),
      // User who copied
      listingId: int("listingId"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    watchlists = mysqlTable("watchlists", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      symbols: json("symbols").notNull(),
      // Array of symbols
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    subscriptionTierLimits = {
      free: {
        maxBots: 1,
        maxAccounts: 1,
        liveTrading: false,
        backtestYears: 0.25,
        // 3 months
        aiAgents: 2,
        apiAccess: false,
        prioritySupport: false
      },
      starter: {
        maxBots: 3,
        maxAccounts: 2,
        liveTrading: true,
        backtestYears: 1,
        aiAgents: 4,
        apiAccess: false,
        prioritySupport: false
      },
      pro: {
        maxBots: 10,
        maxAccounts: 5,
        liveTrading: true,
        backtestYears: 5,
        aiAgents: 7,
        apiAccess: true,
        prioritySupport: true
      },
      elite: {
        maxBots: -1,
        // Unlimited
        maxAccounts: -1,
        liveTrading: true,
        backtestYears: 15,
        // Since 2010
        aiAgents: 7,
        apiAccess: true,
        prioritySupport: true
      }
    };
    userLlmSettings = mysqlTable("user_llm_settings", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull().unique(),
      // Provider selection
      activeProvider: mysqlEnum("activeProvider", ["openai", "deepseek", "claude", "gemini"]).default("openai").notNull(),
      // API Keys (encrypted)
      openaiApiKey: text("openaiApiKey"),
      deepseekApiKey: text("deepseekApiKey"),
      claudeApiKey: text("claudeApiKey"),
      geminiApiKey: text("geminiApiKey"),
      // Model preferences
      openaiModel: varchar("openaiModel", { length: 100 }).default("gpt-4-turbo"),
      deepseekModel: varchar("deepseekModel", { length: 100 }).default("deepseek-reasoner"),
      claudeModel: varchar("claudeModel", { length: 100 }).default("claude-sonnet-4-20250514"),
      geminiModel: varchar("geminiModel", { length: 100 }).default("gemini-2.0-flash"),
      // Settings
      temperature: decimal("temperature", { precision: 3, scale: 2 }).default("0.7"),
      maxTokens: int("maxTokens").default(4096),
      // Usage tracking
      totalTokensUsed: int("totalTokensUsed").default(0),
      lastUsedAt: timestamp("lastUsedAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    llmProviderConfigs = {
      openai: {
        name: "OpenAI",
        models: [
          { id: "gpt-4-turbo", name: "GPT-4 Turbo", description: "Most capable model, best for complex analysis" },
          { id: "gpt-4o", name: "GPT-4o", description: "Optimized for speed and quality balance" },
          { id: "gpt-4o-mini", name: "GPT-4o Mini", description: "Fast and cost-effective" },
          { id: "o1-preview", name: "O1 Preview", description: "Advanced reasoning capabilities" },
          { id: "o1-mini", name: "O1 Mini", description: "Fast reasoning model" }
        ],
        baseUrl: "https://api.openai.com/v1"
      },
      deepseek: {
        name: "DeepSeek",
        models: [
          { id: "deepseek-reasoner", name: "DeepSeek R1", description: "Advanced reasoning with chain-of-thought" },
          { id: "deepseek-chat", name: "DeepSeek Chat", description: "General purpose chat model" },
          { id: "deepseek-coder", name: "DeepSeek Coder", description: "Specialized for code analysis" }
        ],
        baseUrl: "https://api.deepseek.com/v1"
      },
      claude: {
        name: "Anthropic Claude",
        models: [
          { id: "claude-sonnet-4-20250514", name: "Claude Sonnet 4", description: "Best balance of speed and intelligence" },
          { id: "claude-3-5-sonnet-20241022", name: "Claude 3.5 Sonnet", description: "Previous generation, very capable" },
          { id: "claude-3-5-haiku-20241022", name: "Claude 3.5 Haiku", description: "Fast and efficient" },
          { id: "claude-3-opus-20240229", name: "Claude 3 Opus", description: "Most powerful for complex tasks" }
        ],
        baseUrl: "https://api.anthropic.com/v1"
      },
      gemini: {
        name: "Google Gemini",
        models: [
          { id: "gemini-2.0-flash", name: "Gemini 2.0 Flash", description: "Latest fast model with multimodal" },
          { id: "gemini-1.5-pro", name: "Gemini 1.5 Pro", description: "Advanced reasoning and long context" },
          { id: "gemini-1.5-flash", name: "Gemini 1.5 Flash", description: "Fast and efficient" }
        ],
        baseUrl: "https://generativelanguage.googleapis.com/v1beta"
      }
    };
    llmUsageLogs = mysqlTable("llm_usage_logs", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      // Provider and model info
      provider: mysqlEnum("provider", ["openai", "deepseek", "claude", "gemini"]).notNull(),
      model: varchar("model", { length: 100 }).notNull(),
      // Token usage
      promptTokens: int("promptTokens").notNull(),
      completionTokens: int("completionTokens").notNull(),
      totalTokens: int("totalTokens").notNull(),
      // Cost calculation (in USD cents for precision)
      costCents: int("costCents").notNull(),
      // Context
      analysisType: mysqlEnum("analysisType", ["technical", "fundamental", "sentiment", "risk", "microstructure", "macro", "quant", "consensus"]),
      symbol: varchar("symbol", { length: 20 }),
      // Fallback tracking
      wasFallback: boolean("wasFallback").default(false).notNull(),
      originalProvider: mysqlEnum("originalProvider", ["openai", "deepseek", "claude", "gemini"]),
      fallbackReason: varchar("fallbackReason", { length: 255 }),
      // Response info
      responseTimeMs: int("responseTimeMs"),
      success: boolean("success").default(true).notNull(),
      errorMessage: text("errorMessage"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    userFallbackSettings = mysqlTable("user_fallback_settings", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull().unique(),
      // Fallback enabled
      fallbackEnabled: boolean("fallbackEnabled").default(true).notNull(),
      // Priority order (JSON array of provider names) - no default, set in application
      fallbackPriority: json("fallbackPriority"),
      // Retry settings
      maxRetries: int("maxRetries").default(2),
      retryDelayMs: int("retryDelayMs").default(1e3),
      // Notifications
      notifyOnFallback: boolean("notifyOnFallback").default(true).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    llmPricing = {
      openai: {
        "gpt-4-turbo": { input: 1e3, output: 3e3 },
        // $10/$30 per 1M tokens
        "gpt-4o": { input: 250, output: 1e3 },
        // $2.50/$10 per 1M tokens
        "gpt-4o-mini": { input: 15, output: 60 },
        // $0.15/$0.60 per 1M tokens
        "o1-preview": { input: 1500, output: 6e3 },
        // $15/$60 per 1M tokens
        "o1-mini": { input: 300, output: 1200 }
        // $3/$12 per 1M tokens
      },
      deepseek: {
        "deepseek-reasoner": { input: 55, output: 219 },
        // $0.55/$2.19 per 1M tokens
        "deepseek-chat": { input: 14, output: 28 },
        // $0.14/$0.28 per 1M tokens
        "deepseek-coder": { input: 14, output: 28 }
      },
      claude: {
        "claude-sonnet-4-20250514": { input: 300, output: 1500 },
        // $3/$15 per 1M tokens
        "claude-3-5-sonnet": { input: 300, output: 1500 },
        "claude-3-opus": { input: 1500, output: 7500 },
        // $15/$75 per 1M tokens
        "claude-3-haiku": { input: 25, output: 125 }
        // $0.25/$1.25 per 1M tokens
      },
      gemini: {
        "gemini-2.0-flash": { input: 10, output: 40 },
        // $0.10/$0.40 per 1M tokens
        "gemini-1.5-pro": { input: 125, output: 500 },
        // $1.25/$5 per 1M tokens
        "gemini-1.5-flash": { input: 8, output: 30 }
        // $0.075/$0.30 per 1M tokens
      }
    };
    priceTracking = mysqlTable("price_tracking", {
      id: int("id").autoincrement().primaryKey(),
      analysisId: int("analysisId").notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      // Price at recommendation time
      priceAtRecommendation: decimal("priceAtRecommendation", { precision: 18, scale: 6 }).notNull(),
      recommendedAction: mysqlEnum("recommendedAction", ["strong_buy", "buy", "hold", "sell", "strong_sell"]).notNull(),
      confidence: decimal("confidence", { precision: 5, scale: 4 }).notNull(),
      // Tracked prices over time
      price1Day: decimal("price1Day", { precision: 18, scale: 6 }),
      price3Day: decimal("price3Day", { precision: 18, scale: 6 }),
      price7Day: decimal("price7Day", { precision: 18, scale: 6 }),
      price14Day: decimal("price14Day", { precision: 18, scale: 6 }),
      price30Day: decimal("price30Day", { precision: 18, scale: 6 }),
      // Calculated returns
      return1Day: decimal("return1Day", { precision: 10, scale: 4 }),
      return3Day: decimal("return3Day", { precision: 10, scale: 4 }),
      return7Day: decimal("return7Day", { precision: 10, scale: 4 }),
      return14Day: decimal("return14Day", { precision: 10, scale: 4 }),
      return30Day: decimal("return30Day", { precision: 10, scale: 4 }),
      // Accuracy flags
      wasAccurate1Day: boolean("wasAccurate1Day"),
      wasAccurate7Day: boolean("wasAccurate7Day"),
      wasAccurate30Day: boolean("wasAccurate30Day"),
      // Timestamps
      recommendedAt: timestamp("recommendedAt").notNull(),
      lastUpdatedAt: timestamp("lastUpdatedAt").defaultNow().onUpdateNow().notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    predictionAccuracy = mysqlTable("prediction_accuracy", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId"),
      // Scope
      agentType: mysqlEnum("agentType", ["technical", "fundamental", "sentiment", "risk", "microstructure", "macro", "quant", "consensus"]),
      symbol: varchar("symbol", { length: 20 }),
      // NULL for overall
      timeframe: mysqlEnum("timeframe", ["1day", "7day", "30day"]).notNull(),
      // Metrics
      totalPredictions: int("totalPredictions").default(0).notNull(),
      correctPredictions: int("correctPredictions").default(0).notNull(),
      accuracyRate: decimal("accuracyRate", { precision: 5, scale: 4 }),
      avgConfidence: decimal("avgConfidence", { precision: 5, scale: 4 }),
      avgReturn: decimal("avgReturn", { precision: 10, scale: 4 }),
      // By action type
      buyAccuracy: decimal("buyAccuracy", { precision: 5, scale: 4 }),
      sellAccuracy: decimal("sellAccuracy", { precision: 5, scale: 4 }),
      holdAccuracy: decimal("holdAccuracy", { precision: 5, scale: 4 }),
      // Period
      periodStart: timestamp("periodStart").notNull(),
      periodEnd: timestamp("periodEnd").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    savedComparisons = mysqlTable("saved_comparisons", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      analysisIds: json("analysisIds").notNull(),
      // Array of analysis IDs
      // Metadata
      symbolsIncluded: json("symbolsIncluded"),
      // Array of symbols for quick filtering
      dateRange: json("dateRange"),
      // { start, end }
      isPinned: boolean("isPinned").default(false).notNull(),
      lastViewedAt: timestamp("lastViewedAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    watchlistAlerts = mysqlTable("watchlist_alerts", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      // Alert settings
      alertOnRecommendationChange: boolean("alertOnRecommendationChange").default(true).notNull(),
      alertOnConfidenceChange: boolean("alertOnConfidenceChange").default(false).notNull(),
      confidenceThreshold: decimal("confidenceThreshold", { precision: 5, scale: 4 }).default("0.1"),
      // Alert if confidence changes by this much
      alertOnPriceTarget: boolean("alertOnPriceTarget").default(false).notNull(),
      priceTargetHigh: decimal("priceTargetHigh", { precision: 18, scale: 6 }),
      priceTargetLow: decimal("priceTargetLow", { precision: 18, scale: 6 }),
      // Notification preferences
      emailNotification: boolean("emailNotification").default(true).notNull(),
      pushNotification: boolean("pushNotification").default(true).notNull(),
      // Last known state
      lastRecommendation: mysqlEnum("lastRecommendation", ["strong_buy", "buy", "hold", "sell", "strong_sell"]),
      lastConfidence: decimal("lastConfidence", { precision: 5, scale: 4 }),
      lastPrice: decimal("lastPrice", { precision: 18, scale: 6 }),
      lastAlertAt: timestamp("lastAlertAt"),
      isActive: boolean("isActive").default(true).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    alertHistory = mysqlTable("alert_history", {
      id: int("id").autoincrement().primaryKey(),
      uniqueId: varchar("uniqueId", { length: 64 }),
      // For new alert system
      userId: int("userId").notNull(),
      alertId: int("alertId").notNull(),
      alertIdStr: varchar("alertIdStr", { length: 64 }),
      // For new alert system
      symbol: varchar("symbol", { length: 20 }).notNull(),
      alertType: mysqlEnum("alertType", ["recommendation_change", "confidence_change", "price_target", "bot_status", "analysis_complete", "price", "regime", "sentiment"]).notNull(),
      // Alert content
      title: varchar("title", { length: 255 }),
      message: text("message").notNull(),
      // Previous and new values
      previousValue: varchar("previousValue", { length: 100 }),
      newValue: varchar("newValue", { length: 100 }),
      details: json("details"),
      // For new alert system
      isRead: boolean("isRead").default(false).notNull(),
      // Delivery status
      emailSent: boolean("emailSent").default(false).notNull(),
      pushSent: boolean("pushSent").default(false).notNull(),
      readAt: timestamp("readAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    userNotifications = mysqlTable("user_notifications", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      type: mysqlEnum("type", ["info", "success", "warning", "error", "alert", "trade", "analysis", "social"]).notNull(),
      category: mysqlEnum("category", ["system", "trading", "analysis", "social", "billing"]).notNull(),
      title: varchar("title", { length: 255 }).notNull(),
      message: text("message").notNull(),
      // Action link
      actionUrl: varchar("actionUrl", { length: 500 }),
      actionLabel: varchar("actionLabel", { length: 100 }),
      // Related entities
      relatedEntityType: varchar("relatedEntityType", { length: 50 }),
      relatedEntityId: int("relatedEntityId"),
      // Status
      isRead: boolean("isRead").default(false).notNull(),
      readAt: timestamp("readAt"),
      isPinned: boolean("isPinned").default(false).notNull(),
      expiresAt: timestamp("expiresAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    realtimeSubscriptions = mysqlTable("realtime_subscriptions", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      socketId: varchar("socketId", { length: 100 }),
      subscriptionType: mysqlEnum("subscriptionType", ["price", "portfolio", "bot_status", "analysis", "notifications"]).notNull(),
      // Subscription target
      symbols: json("symbols"),
      // Array of symbols for price subscriptions
      botIds: json("botIds"),
      // Array of bot IDs for bot status
      accountIds: json("accountIds"),
      // Array of account IDs for portfolio
      // Status
      isActive: boolean("isActive").default(true).notNull(),
      lastHeartbeat: timestamp("lastHeartbeat"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    botSchedules = mysqlTable("bot_schedules", {
      id: int("id").autoincrement().primaryKey(),
      botId: int("botId").notNull(),
      userId: int("userId").notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      // Schedule type
      scheduleType: mysqlEnum("scheduleType", ["once", "daily", "weekly", "monthly", "cron"]).notNull(),
      // Schedule details
      cronExpression: varchar("cronExpression", { length: 100 }),
      // For cron type
      runTime: varchar("runTime", { length: 10 }),
      // HH:MM format for daily
      daysOfWeek: json("daysOfWeek"),
      // Array of days (0-6) for weekly
      dayOfMonth: int("dayOfMonth"),
      // For monthly
      timezone: varchar("timezone", { length: 50 }).default("UTC").notNull(),
      // Execution settings
      maxExecutionTime: int("maxExecutionTime").default(300),
      // seconds
      retryOnFailure: boolean("retryOnFailure").default(true).notNull(),
      maxRetries: int("maxRetries").default(3),
      // Status
      isActive: boolean("isActive").default(true).notNull(),
      lastRunAt: timestamp("lastRunAt"),
      nextRunAt: timestamp("nextRunAt"),
      lastRunStatus: mysqlEnum("lastRunStatus", ["success", "failed", "timeout", "skipped"]),
      lastRunError: text("lastRunError"),
      totalRuns: int("totalRuns").default(0).notNull(),
      successfulRuns: int("successfulRuns").default(0).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    botRiskRules = mysqlTable("bot_risk_rules", {
      id: int("id").autoincrement().primaryKey(),
      botId: int("botId").notNull(),
      userId: int("userId").notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      ruleType: mysqlEnum("ruleType", ["stop_loss", "take_profit", "trailing_stop", "max_position", "max_daily_loss", "max_drawdown", "position_sizing"]).notNull(),
      // Rule parameters
      triggerValue: decimal("triggerValue", { precision: 18, scale: 6 }),
      // Percentage or absolute value
      triggerType: mysqlEnum("triggerType", ["percentage", "absolute", "atr_multiple"]).default("percentage"),
      // Position sizing
      positionSizeType: mysqlEnum("positionSizeType", ["fixed", "percentage", "risk_based"]),
      positionSizeValue: decimal("positionSizeValue", { precision: 18, scale: 6 }),
      maxPositionSize: decimal("maxPositionSize", { precision: 18, scale: 6 }),
      // Action on trigger
      actionOnTrigger: mysqlEnum("actionOnTrigger", ["close_position", "reduce_position", "pause_bot", "notify_only"]).default("close_position"),
      reduceByPercentage: decimal("reduceByPercentage", { precision: 5, scale: 2 }),
      // Status
      isActive: boolean("isActive").default(true).notNull(),
      triggeredCount: int("triggeredCount").default(0).notNull(),
      lastTriggeredAt: timestamp("lastTriggeredAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    botExecutionLogs = mysqlTable("bot_execution_logs", {
      id: int("id").autoincrement().primaryKey(),
      botId: int("botId").notNull(),
      userId: int("userId").notNull(),
      scheduleId: int("scheduleId"),
      // Execution info
      executionType: mysqlEnum("executionType", ["scheduled", "manual", "triggered"]).notNull(),
      status: mysqlEnum("status", ["running", "completed", "failed", "timeout", "cancelled"]).notNull(),
      // Timing
      startedAt: timestamp("startedAt").notNull(),
      completedAt: timestamp("completedAt"),
      durationMs: int("durationMs"),
      // Results
      symbolsAnalyzed: json("symbolsAnalyzed"),
      tradesExecuted: int("tradesExecuted").default(0),
      ordersPlaced: int("ordersPlaced").default(0),
      // AI Analysis
      analysisResults: json("analysisResults"),
      // Summary of AI consensus
      // Errors
      errorMessage: text("errorMessage"),
      errorStack: text("errorStack"),
      // Performance
      pnlResult: decimal("pnlResult", { precision: 18, scale: 6 }),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    botBenchmarks = mysqlTable("bot_benchmarks", {
      id: int("id").autoincrement().primaryKey(),
      botId: int("botId").notNull(),
      userId: int("userId").notNull(),
      // Benchmark
      benchmarkSymbol: varchar("benchmarkSymbol", { length: 20 }).default("SPY").notNull(),
      // S&P 500 ETF
      // Period
      periodStart: timestamp("periodStart").notNull(),
      periodEnd: timestamp("periodEnd").notNull(),
      periodDays: int("periodDays").notNull(),
      // Bot performance
      botReturn: decimal("botReturn", { precision: 10, scale: 4 }).notNull(),
      botSharpe: decimal("botSharpe", { precision: 10, scale: 4 }),
      botMaxDrawdown: decimal("botMaxDrawdown", { precision: 10, scale: 4 }),
      botWinRate: decimal("botWinRate", { precision: 5, scale: 4 }),
      botTotalTrades: int("botTotalTrades"),
      // Benchmark performance
      benchmarkReturn: decimal("benchmarkReturn", { precision: 10, scale: 4 }).notNull(),
      benchmarkSharpe: decimal("benchmarkSharpe", { precision: 10, scale: 4 }),
      benchmarkMaxDrawdown: decimal("benchmarkMaxDrawdown", { precision: 10, scale: 4 }),
      // Comparison
      alpha: decimal("alpha", { precision: 10, scale: 4 }),
      // Excess return vs benchmark
      beta: decimal("beta", { precision: 10, scale: 4 }),
      // Correlation with benchmark
      informationRatio: decimal("informationRatio", { precision: 10, scale: 4 }),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    userProfiles = mysqlTable("user_profiles", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull().unique(),
      // Profile info
      displayName: varchar("displayName", { length: 100 }),
      bio: text("bio"),
      avatarUrl: varchar("avatarUrl", { length: 500 }),
      location: varchar("location", { length: 100 }),
      website: varchar("website", { length: 255 }),
      twitterHandle: varchar("twitterHandle", { length: 50 }),
      // Privacy settings
      isPublic: boolean("isPublic").default(true).notNull(),
      showTradingStats: boolean("showTradingStats").default(true).notNull(),
      showPortfolio: boolean("showPortfolio").default(false).notNull(),
      allowFollowers: boolean("allowFollowers").default(true).notNull(),
      // Trading stats (aggregated)
      totalTrades: int("totalTrades").default(0).notNull(),
      winRate: decimal("winRate", { precision: 5, scale: 4 }),
      totalReturn: decimal("totalReturn", { precision: 10, scale: 4 }),
      avgReturn: decimal("avgReturn", { precision: 10, scale: 4 }),
      bestTrade: decimal("bestTrade", { precision: 10, scale: 4 }),
      worstTrade: decimal("worstTrade", { precision: 10, scale: 4 }),
      sharpeRatio: decimal("sharpeRatio", { precision: 10, scale: 4 }),
      // Social stats
      followersCount: int("followersCount").default(0).notNull(),
      followingCount: int("followingCount").default(0).notNull(),
      strategiesShared: int("strategiesShared").default(0).notNull(),
      // Reputation
      reputationScore: int("reputationScore").default(0).notNull(),
      badges: json("badges"),
      // Array of badge IDs
      // Activity
      lastActiveAt: timestamp("lastActiveAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    userFollows = mysqlTable("user_follows", {
      id: int("id").autoincrement().primaryKey(),
      followerId: int("followerId").notNull(),
      // User who is following
      followingId: int("followingId").notNull(),
      // User being followed
      // Notification preferences
      notifyOnTrade: boolean("notifyOnTrade").default(false).notNull(),
      notifyOnAnalysis: boolean("notifyOnAnalysis").default(true).notNull(),
      notifyOnStrategy: boolean("notifyOnStrategy").default(true).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    discussionThreads = mysqlTable("discussion_threads", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      // Author
      // Thread type and target
      threadType: mysqlEnum("threadType", ["analysis", "strategy", "bot", "general", "market"]).notNull(),
      relatedEntityId: int("relatedEntityId"),
      // Analysis ID, Bot ID, etc.
      symbol: varchar("symbol", { length: 20 }),
      // Content
      title: varchar("title", { length: 255 }).notNull(),
      content: text("content").notNull(),
      // Engagement
      viewCount: int("viewCount").default(0).notNull(),
      likeCount: int("likeCount").default(0).notNull(),
      commentCount: int("commentCount").default(0).notNull(),
      // Status
      isPinned: boolean("isPinned").default(false).notNull(),
      isLocked: boolean("isLocked").default(false).notNull(),
      isDeleted: boolean("isDeleted").default(false).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    discussionComments = mysqlTable("discussion_comments", {
      id: int("id").autoincrement().primaryKey(),
      threadId: int("threadId").notNull(),
      userId: int("userId").notNull(),
      parentCommentId: int("parentCommentId"),
      // For nested replies
      // Content
      content: text("content").notNull(),
      // Engagement
      likeCount: int("likeCount").default(0).notNull(),
      // Status
      isEdited: boolean("isEdited").default(false).notNull(),
      isDeleted: boolean("isDeleted").default(false).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    strategyRatings = mysqlTable("strategy_ratings", {
      id: int("id").autoincrement().primaryKey(),
      listingId: int("listingId").notNull(),
      // Marketplace listing
      userId: int("userId").notNull(),
      // Rating
      rating: int("rating").notNull(),
      // 1-5 stars
      review: text("review"),
      // Helpful votes
      helpfulCount: int("helpfulCount").default(0).notNull(),
      // Status
      isVerifiedPurchase: boolean("isVerifiedPurchase").default(false).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    activityFeed = mysqlTable("activity_feed", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      activityType: mysqlEnum("activityType", ["trade", "analysis", "strategy_share", "follow", "comment", "like", "achievement", "bot_created"]).notNull(),
      // Activity details
      title: varchar("title", { length: 255 }).notNull(),
      description: text("description"),
      // Related entities
      relatedEntityType: varchar("relatedEntityType", { length: 50 }),
      relatedEntityId: int("relatedEntityId"),
      symbol: varchar("symbol", { length: 20 }),
      // Visibility
      isPublic: boolean("isPublic").default(true).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    userBadges = mysqlTable("user_badges", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      badgeId: varchar("badgeId", { length: 50 }).notNull(),
      // Badge info
      badgeName: varchar("badgeName", { length: 100 }).notNull(),
      badgeDescription: text("badgeDescription"),
      badgeIcon: varchar("badgeIcon", { length: 100 }),
      badgeColor: varchar("badgeColor", { length: 20 }),
      // Achievement
      earnedAt: timestamp("earnedAt").defaultNow().notNull(),
      earnedReason: text("earnedReason"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    badgeDefinitions = {
      first_trade: { name: "First Trade", description: "Completed your first trade", icon: "trophy", color: "bronze" },
      profitable_week: { name: "Profitable Week", description: "Had a profitable trading week", icon: "trending-up", color: "green" },
      profitable_month: { name: "Profitable Month", description: "Had a profitable trading month", icon: "calendar-check", color: "gold" },
      accuracy_80: { name: "Sharp Shooter", description: "Achieved 80%+ prediction accuracy", icon: "target", color: "purple" },
      accuracy_90: { name: "Master Predictor", description: "Achieved 90%+ prediction accuracy", icon: "bullseye", color: "diamond" },
      bot_creator: { name: "Bot Creator", description: "Created your first trading bot", icon: "robot", color: "blue" },
      strategy_sharer: { name: "Strategy Sharer", description: "Shared a strategy on marketplace", icon: "share", color: "teal" },
      top_performer: { name: "Top Performer", description: "Ranked in top 10% of traders", icon: "crown", color: "gold" },
      community_helper: { name: "Community Helper", description: "Received 50+ helpful votes", icon: "heart", color: "red" },
      early_adopter: { name: "Early Adopter", description: "Joined during beta", icon: "rocket", color: "orange" },
      whale: { name: "Whale", description: "Portfolio value over $1M", icon: "fish", color: "blue" },
      streak_7: { name: "Week Warrior", description: "7-day profitable streak", icon: "flame", color: "orange" },
      streak_30: { name: "Month Master", description: "30-day profitable streak", icon: "fire", color: "red" },
      diversified: { name: "Diversified", description: "Traded 20+ different symbols", icon: "pie-chart", color: "purple" },
      risk_manager: { name: "Risk Manager", description: "Never exceeded 5% drawdown", icon: "shield", color: "green" }
    };
    emailTemplates = mysqlTable("email_templates", {
      id: int("id").autoincrement().primaryKey(),
      templateKey: varchar("templateKey", { length: 100 }).notNull().unique(),
      name: varchar("name", { length: 255 }).notNull(),
      subject: varchar("subject", { length: 500 }).notNull(),
      htmlContent: text("htmlContent").notNull(),
      textContent: text("textContent"),
      // Variables that can be replaced
      variables: json("variables"),
      // Array of variable names
      // Status
      isActive: boolean("isActive").default(true).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    emailQueue = mysqlTable("email_queue", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      toEmail: varchar("toEmail", { length: 320 }).notNull(),
      templateId: int("templateId"),
      // Email content
      subject: varchar("subject", { length: 500 }).notNull(),
      htmlContent: text("htmlContent").notNull(),
      textContent: text("textContent"),
      // Template variables
      templateVariables: json("templateVariables"),
      // Priority and scheduling
      priority: mysqlEnum("priority", ["low", "normal", "high", "urgent"]).default("normal").notNull(),
      scheduledAt: timestamp("scheduledAt"),
      // Status
      status: mysqlEnum("status", ["pending", "processing", "sent", "failed", "cancelled"]).default("pending").notNull(),
      attempts: int("attempts").default(0).notNull(),
      maxAttempts: int("maxAttempts").default(3).notNull(),
      lastAttemptAt: timestamp("lastAttemptAt"),
      sentAt: timestamp("sentAt"),
      errorMessage: text("errorMessage"),
      // Tracking
      messageId: varchar("messageId", { length: 255 }),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    userEmailPreferences = mysqlTable("user_email_preferences", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull().unique(),
      // Notification types
      botExecutionComplete: boolean("botExecutionComplete").default(true).notNull(),
      botExecutionError: boolean("botExecutionError").default(true).notNull(),
      priceTargetAlert: boolean("priceTargetAlert").default(true).notNull(),
      recommendationChange: boolean("recommendationChange").default(true).notNull(),
      weeklyReport: boolean("weeklyReport").default(true).notNull(),
      monthlyReport: boolean("monthlyReport").default(true).notNull(),
      marketingEmails: boolean("marketingEmails").default(false).notNull(),
      // Frequency settings
      digestFrequency: mysqlEnum("digestFrequency", ["immediate", "hourly", "daily", "weekly"]).default("immediate").notNull(),
      quietHoursStart: varchar("quietHoursStart", { length: 5 }),
      // HH:MM format
      quietHoursEnd: varchar("quietHoursEnd", { length: 5 }),
      timezone: varchar("timezone", { length: 50 }).default("UTC").notNull(),
      // Status
      isUnsubscribed: boolean("isUnsubscribed").default(false).notNull(),
      unsubscribedAt: timestamp("unsubscribedAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    backgroundJobs = mysqlTable("background_jobs", {
      id: int("id").autoincrement().primaryKey(),
      jobType: mysqlEnum("jobType", [
        "bot_execution",
        "price_tracking",
        "accuracy_calculation",
        "weekly_report",
        "monthly_report",
        "watchlist_check",
        "email_send",
        "cleanup"
      ]).notNull(),
      // Job configuration
      payload: json("payload").notNull(),
      // Job-specific data
      // Scheduling
      scheduledAt: timestamp("scheduledAt").notNull(),
      priority: int("priority").default(5).notNull(),
      // 1-10, lower is higher priority
      // Execution
      status: mysqlEnum("status", ["pending", "running", "completed", "failed", "cancelled"]).default("pending").notNull(),
      startedAt: timestamp("startedAt"),
      completedAt: timestamp("completedAt"),
      // Results
      result: json("result"),
      errorMessage: text("errorMessage"),
      // Retry logic
      attempts: int("attempts").default(0).notNull(),
      maxAttempts: int("maxAttempts").default(3).notNull(),
      nextRetryAt: timestamp("nextRetryAt"),
      // Tracking
      workerId: varchar("workerId", { length: 100 }),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    jobHistory = mysqlTable("job_history", {
      id: int("id").autoincrement().primaryKey(),
      jobId: int("jobId").notNull(),
      jobType: varchar("jobType", { length: 50 }).notNull(),
      // Execution details
      status: mysqlEnum("status", ["completed", "failed"]).notNull(),
      startedAt: timestamp("startedAt").notNull(),
      completedAt: timestamp("completedAt").notNull(),
      durationMs: int("durationMs").notNull(),
      // Results
      payload: json("payload"),
      result: json("result"),
      errorMessage: text("errorMessage"),
      // Metrics
      itemsProcessed: int("itemsProcessed").default(0).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    performanceReports = mysqlTable("performance_reports", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      reportType: mysqlEnum("reportType", ["weekly", "monthly", "quarterly", "annual"]).notNull(),
      // Report period
      periodStart: timestamp("periodStart").notNull(),
      periodEnd: timestamp("periodEnd").notNull(),
      // Performance metrics
      totalTrades: int("totalTrades").default(0).notNull(),
      winningTrades: int("winningTrades").default(0).notNull(),
      losingTrades: int("losingTrades").default(0).notNull(),
      winRate: decimal("winRate", { precision: 5, scale: 4 }),
      totalProfitLoss: decimal("totalProfitLoss", { precision: 18, scale: 2 }),
      percentageReturn: decimal("percentageReturn", { precision: 8, scale: 4 }),
      // Risk metrics
      maxDrawdown: decimal("maxDrawdown", { precision: 8, scale: 4 }),
      sharpeRatio: decimal("sharpeRatio", { precision: 6, scale: 4 }),
      // AI accuracy
      totalPredictions: int("totalPredictions").default(0).notNull(),
      correctPredictions: int("correctPredictions").default(0).notNull(),
      predictionAccuracy: decimal("predictionAccuracy", { precision: 5, scale: 4 }),
      // Benchmark comparison
      benchmarkReturn: decimal("benchmarkReturn", { precision: 8, scale: 4 }),
      alphaGenerated: decimal("alphaGenerated", { precision: 8, scale: 4 }),
      // Report content
      summaryHtml: text("summaryHtml"),
      detailedJson: json("detailedJson"),
      // Email tracking
      emailSent: boolean("emailSent").default(false).notNull(),
      emailSentAt: timestamp("emailSentAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    portfolioValueSnapshots = mysqlTable("portfolio_value_snapshots", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      accountId: int("accountId").notNull(),
      // Value at snapshot time
      totalValue: decimal("totalValue", { precision: 18, scale: 2 }).notNull(),
      cashBalance: decimal("cashBalance", { precision: 18, scale: 2 }).notNull(),
      positionsValue: decimal("positionsValue", { precision: 18, scale: 2 }).notNull(),
      // Change from previous
      valueChange: decimal("valueChange", { precision: 18, scale: 2 }),
      percentChange: decimal("percentChange", { precision: 8, scale: 4 }),
      // Snapshot type
      snapshotType: mysqlEnum("snapshotType", ["realtime", "hourly", "daily", "weekly"]).default("realtime").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    emailConfig = mysqlTable("email_config", {
      id: int("id").autoincrement().primaryKey(),
      // SendGrid settings
      sendgridApiKey: text("sendgridApiKey"),
      // Encrypted
      senderEmail: varchar("senderEmail", { length: 320 }),
      senderName: varchar("senderName", { length: 255 }),
      replyToEmail: varchar("replyToEmail", { length: 320 }),
      // Email settings
      isEnabled: boolean("isEnabled").default(false).notNull(),
      dailyLimit: int("dailyLimit").default(1e3),
      // Test mode
      testMode: boolean("testMode").default(true).notNull(),
      testEmail: varchar("testEmail", { length: 320 }),
      // Stats
      emailsSentToday: int("emailsSentToday").default(0),
      lastResetAt: timestamp("lastResetAt"),
      // Metadata
      configuredBy: int("configuredBy"),
      // Admin user ID
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    emailVerifications = mysqlTable("email_verifications", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      email: varchar("email", { length: 320 }).notNull(),
      token: varchar("token", { length: 64 }).notNull().unique(),
      // Status
      isVerified: boolean("isVerified").default(false).notNull(),
      verifiedAt: timestamp("verifiedAt"),
      // Expiration
      expiresAt: timestamp("expiresAt").notNull(),
      // Tracking
      sentAt: timestamp("sentAt").defaultNow().notNull(),
      resendCount: int("resendCount").default(0),
      lastResendAt: timestamp("lastResendAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    rlAgentModels = mysqlTable("rl_agent_models", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      // Model configuration
      modelData: json("modelData").notNull(),
      // Q-table, network weights, etc.
      config: json("config"),
      // Hyperparameters
      // Performance metrics
      totalEpisodes: int("totalEpisodes").default(0).notNull(),
      avgReward: decimal("avgReward", { precision: 18, scale: 6 }),
      bestReward: decimal("bestReward", { precision: 18, scale: 6 }),
      winRate: decimal("winRate", { precision: 5, scale: 4 }),
      sharpeRatio: decimal("sharpeRatio", { precision: 10, scale: 4 }),
      // Status
      status: mysqlEnum("status", ["training", "ready", "deployed", "archived"]).default("training").notNull(),
      lastTrainedAt: timestamp("lastTrainedAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    rlTrainingHistory = mysqlTable("rl_training_history", {
      id: int("id").autoincrement().primaryKey(),
      modelId: int("modelId").notNull(),
      episode: int("episode").notNull(),
      // Episode metrics
      totalReward: decimal("totalReward", { precision: 18, scale: 6 }).notNull(),
      avgLoss: decimal("avgLoss", { precision: 18, scale: 6 }),
      steps: int("steps").notNull(),
      // Trading metrics
      trades: int("trades").default(0).notNull(),
      winningTrades: int("winningTrades").default(0).notNull(),
      totalReturn: decimal("totalReturn", { precision: 10, scale: 4 }),
      maxDrawdown: decimal("maxDrawdown", { precision: 10, scale: 4 }),
      // Exploration
      epsilon: decimal("epsilon", { precision: 5, scale: 4 }),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    rlExperiences = mysqlTable("rl_experiences", {
      id: int("id").autoincrement().primaryKey(),
      modelId: int("modelId").notNull(),
      // State-Action-Reward-NextState tuple
      state: json("state").notNull(),
      action: int("action").notNull(),
      reward: decimal("reward", { precision: 18, scale: 6 }).notNull(),
      nextState: json("nextState").notNull(),
      done: boolean("done").default(false).notNull(),
      // Metadata
      timestamp: timestamp("timestamp").defaultNow().notNull(),
      symbol: varchar("symbol", { length: 20 }),
      price: decimal("price", { precision: 18, scale: 6 })
    });
    backtestResults = mysqlTable("backtest_results", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      // Configuration
      symbol: varchar("symbol", { length: 20 }).notNull(),
      startDate: timestamp("startDate").notNull(),
      endDate: timestamp("endDate").notNull(),
      initialCapital: decimal("initialCapital", { precision: 18, scale: 2 }).notNull(),
      strategyType: mysqlEnum("strategyType", ["standard", "enhanced", "rl", "custom"]).notNull(),
      strategyConfig: json("strategyConfig"),
      // Results
      finalCapital: decimal("finalCapital", { precision: 18, scale: 2 }),
      totalReturn: decimal("totalReturn", { precision: 10, scale: 4 }),
      annualizedReturn: decimal("annualizedReturn", { precision: 10, scale: 4 }),
      sharpeRatio: decimal("sharpeRatio", { precision: 10, scale: 4 }),
      sortinoRatio: decimal("sortinoRatio", { precision: 10, scale: 4 }),
      maxDrawdown: decimal("maxDrawdown", { precision: 10, scale: 4 }),
      winRate: decimal("winRate", { precision: 5, scale: 4 }),
      profitFactor: decimal("profitFactor", { precision: 10, scale: 4 }),
      // Trade statistics
      totalTrades: int("totalTrades").default(0).notNull(),
      winningTrades: int("winningTrades").default(0).notNull(),
      losingTrades: int("losingTrades").default(0).notNull(),
      avgWin: decimal("avgWin", { precision: 18, scale: 6 }),
      avgLoss: decimal("avgLoss", { precision: 18, scale: 6 }),
      // Detailed data
      equityCurve: json("equityCurve"),
      // Array of { date, value }
      trades: json("trades"),
      // Array of trade details
      // Status
      status: mysqlEnum("status", ["running", "completed", "failed"]).default("running").notNull(),
      errorMessage: text("errorMessage"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      completedAt: timestamp("completedAt")
    });
    strategyComparisons = mysqlTable("strategy_comparisons", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      // Comparison setup
      symbol: varchar("symbol", { length: 20 }).notNull(),
      startDate: timestamp("startDate").notNull(),
      endDate: timestamp("endDate").notNull(),
      initialCapital: decimal("initialCapital", { precision: 18, scale: 2 }).notNull(),
      // Strategies being compared
      strategies: json("strategies").notNull(),
      // Array of { type, config, backtestId }
      // Comparison results
      results: json("results"),
      // Comparative metrics
      winner: varchar("winner", { length: 50 }),
      // Status
      status: mysqlEnum("status", ["pending", "running", "completed", "failed"]).default("pending").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      completedAt: timestamp("completedAt")
    });
    paperTradingAccounts = mysqlTable("paper_trading_accounts", {
      id: varchar("id", { length: 64 }).primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      initialBalance: decimal("initialBalance", { precision: 18, scale: 2 }).notNull(),
      currentBalance: decimal("currentBalance", { precision: 18, scale: 2 }).notNull(),
      totalEquity: decimal("totalEquity", { precision: 18, scale: 2 }).notNull(),
      totalPnL: decimal("totalPnL", { precision: 18, scale: 2 }).default("0").notNull(),
      totalPnLPercent: decimal("totalPnLPercent", { precision: 10, scale: 4 }).default("0").notNull(),
      totalTrades: int("totalTrades").default(0).notNull(),
      winningTrades: int("winningTrades").default(0).notNull(),
      losingTrades: int("losingTrades").default(0).notNull(),
      winRate: decimal("winRate", { precision: 10, scale: 4 }).default("0").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    paperTradingOrders = mysqlTable("paper_trading_orders", {
      id: varchar("id", { length: 64 }).primaryKey(),
      accountId: varchar("accountId", { length: 64 }).notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      assetType: mysqlEnum("assetType", ["stock", "crypto"]).notNull(),
      side: mysqlEnum("side", ["buy", "sell"]).notNull(),
      type: mysqlEnum("type", ["market", "limit", "stop_loss", "take_profit", "stop_limit"]).notNull(),
      quantity: decimal("quantity", { precision: 18, scale: 8 }).notNull(),
      price: decimal("price", { precision: 18, scale: 8 }),
      stopPrice: decimal("stopPrice", { precision: 18, scale: 8 }),
      takeProfitPrice: decimal("takeProfitPrice", { precision: 18, scale: 8 }),
      stopLossPrice: decimal("stopLossPrice", { precision: 18, scale: 8 }),
      status: mysqlEnum("status", ["pending", "filled", "partially_filled", "cancelled", "expired", "rejected"]).default("pending").notNull(),
      filledQuantity: decimal("filledQuantity", { precision: 18, scale: 8 }).default("0").notNull(),
      filledPrice: decimal("filledPrice", { precision: 18, scale: 8 }),
      commission: decimal("commission", { precision: 18, scale: 8 }).default("0").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
      expiresAt: timestamp("expiresAt")
    });
    paperTradingPositions = mysqlTable("paper_trading_positions", {
      id: varchar("id", { length: 64 }).primaryKey(),
      accountId: varchar("accountId", { length: 64 }).notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      assetType: mysqlEnum("assetType", ["stock", "crypto"]).notNull(),
      quantity: decimal("quantity", { precision: 18, scale: 8 }).notNull(),
      averagePrice: decimal("averagePrice", { precision: 18, scale: 8 }).notNull(),
      currentPrice: decimal("currentPrice", { precision: 18, scale: 8 }).notNull(),
      marketValue: decimal("marketValue", { precision: 18, scale: 2 }).notNull(),
      unrealizedPnL: decimal("unrealizedPnL", { precision: 18, scale: 2 }).notNull(),
      unrealizedPnLPercent: decimal("unrealizedPnLPercent", { precision: 10, scale: 4 }).notNull(),
      realizedPnL: decimal("realizedPnL", { precision: 18, scale: 2 }).default("0").notNull(),
      openedAt: timestamp("openedAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    paperTradingHistory = mysqlTable("paper_trading_history", {
      id: varchar("id", { length: 64 }).primaryKey(),
      accountId: varchar("accountId", { length: 64 }).notNull(),
      orderId: varchar("orderId", { length: 64 }).notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      assetType: mysqlEnum("assetType", ["stock", "crypto"]).notNull(),
      side: mysqlEnum("side", ["buy", "sell"]).notNull(),
      quantity: decimal("quantity", { precision: 18, scale: 8 }).notNull(),
      price: decimal("price", { precision: 18, scale: 8 }).notNull(),
      commission: decimal("commission", { precision: 18, scale: 8 }).notNull(),
      pnl: decimal("pnl", { precision: 18, scale: 2 }).default("0").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    priceAlerts = mysqlTable("price_alerts", {
      id: varchar("id", { length: 64 }).primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      assetType: mysqlEnum("assetType", ["stock", "crypto"]).notNull(),
      alertType: mysqlEnum("alertType", ["price_above", "price_below", "percent_change", "volume_spike"]).notNull(),
      targetValue: decimal("targetValue", { precision: 18, scale: 8 }).notNull(),
      currentValue: decimal("currentValue", { precision: 18, scale: 8 }),
      message: text("message"),
      isActive: boolean("isActive").default(true).notNull(),
      isTriggered: boolean("isTriggered").default(false).notNull(),
      triggeredAt: timestamp("triggeredAt"),
      notifyEmail: boolean("notifyEmail").default(true).notNull(),
      notifyPush: boolean("notifyPush").default(true).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    regimeAlerts = mysqlTable("regime_alerts", {
      id: varchar("id", { length: 64 }).primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      fromRegime: mysqlEnum("fromRegime", ["bull", "bear", "sideways", "volatile"]),
      toRegime: mysqlEnum("toRegime", ["bull", "bear", "sideways", "volatile"]).notNull(),
      isActive: boolean("isActive").default(true).notNull(),
      isTriggered: boolean("isTriggered").default(false).notNull(),
      triggeredAt: timestamp("triggeredAt"),
      notifyEmail: boolean("notifyEmail").default(true).notNull(),
      notifyPush: boolean("notifyPush").default(true).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    sentimentAlerts = mysqlTable("sentiment_alerts", {
      id: varchar("id", { length: 64 }).primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      alertType: mysqlEnum("alertType", ["sentiment_bullish", "sentiment_bearish", "fear_greed_extreme", "sentiment_shift"]).notNull(),
      threshold: decimal("threshold", { precision: 10, scale: 4 }),
      isActive: boolean("isActive").default(true).notNull(),
      isTriggered: boolean("isTriggered").default(false).notNull(),
      triggeredAt: timestamp("triggeredAt"),
      notifyEmail: boolean("notifyEmail").default(true).notNull(),
      notifyPush: boolean("notifyPush").default(true).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    cryptoWatchlist = mysqlTable("crypto_watchlist", {
      id: varchar("id", { length: 64 }).primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      notes: text("notes"),
      targetBuyPrice: decimal("targetBuyPrice", { precision: 18, scale: 8 }),
      targetSellPrice: decimal("targetSellPrice", { precision: 18, scale: 8 }),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    copyTraders = mysqlTable("copy_traders", {
      id: varchar("id", { length: 64 }).primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      name: varchar("name", { length: 100 }).notNull(),
      bio: text("bio"),
      totalReturn: decimal("totalReturn", { precision: 10, scale: 2 }).default("0").notNull(),
      winRate: decimal("winRate", { precision: 5, scale: 2 }).default("0").notNull(),
      totalTrades: int("totalTrades").default(0).notNull(),
      followers: int("followers").default(0).notNull(),
      riskScore: int("riskScore").default(5).notNull(),
      sharpeRatio: decimal("sharpeRatio", { precision: 6, scale: 3 }).default("0").notNull(),
      maxDrawdown: decimal("maxDrawdown", { precision: 6, scale: 2 }).default("0").notNull(),
      tradingStyle: mysqlEnum("tradingStyle", ["day_trader", "swing_trader", "position_trader", "scalper"]).default("swing_trader").notNull(),
      isVerified: boolean("isVerified").default(false).notNull(),
      isActive: boolean("isActive").default(true).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    copySettings = mysqlTable("copy_settings", {
      id: varchar("id", { length: 64 }).primaryKey(),
      followerId: varchar("followerId", { length: 64 }).notNull(),
      traderId: varchar("traderId", { length: 64 }).notNull(),
      allocationMode: mysqlEnum("allocationMode", ["fixed", "percentage", "proportional"]).default("fixed").notNull(),
      allocationAmount: decimal("allocationAmount", { precision: 18, scale: 2 }).default("1000").notNull(),
      maxPositionSize: decimal("maxPositionSize", { precision: 18, scale: 2 }).default("10000").notNull(),
      maxDailyLoss: decimal("maxDailyLoss", { precision: 18, scale: 2 }).default("500").notNull(),
      copyStopLoss: boolean("copyStopLoss").default(true).notNull(),
      copyTakeProfit: boolean("copyTakeProfit").default(true).notNull(),
      excludeSymbols: json("excludeSymbols").$type(),
      status: mysqlEnum("status", ["active", "paused", "stopped"]).default("active").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    copyTrades = mysqlTable("copy_trades", {
      id: varchar("id", { length: 64 }).primaryKey(),
      copySettingsId: varchar("copySettingsId", { length: 64 }).notNull(),
      originalTradeId: varchar("originalTradeId", { length: 64 }),
      followerId: varchar("followerId", { length: 64 }).notNull(),
      traderId: varchar("traderId", { length: 64 }).notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      side: mysqlEnum("side", ["buy", "sell"]).notNull(),
      originalQuantity: decimal("originalQuantity", { precision: 18, scale: 8 }).notNull(),
      copiedQuantity: decimal("copiedQuantity", { precision: 18, scale: 8 }).notNull(),
      originalPrice: decimal("originalPrice", { precision: 18, scale: 8 }).notNull(),
      copiedPrice: decimal("copiedPrice", { precision: 18, scale: 8 }).notNull(),
      slippage: decimal("slippage", { precision: 8, scale: 4 }).default("0").notNull(),
      pnl: decimal("pnl", { precision: 18, scale: 2 }),
      status: mysqlEnum("status", ["pending", "executed", "failed", "cancelled"]).default("pending").notNull(),
      executedAt: timestamp("executedAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    journalEntries = mysqlTable("journal_entries", {
      id: varchar("id", { length: 64 }).primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      tradeId: varchar("tradeId", { length: 64 }),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      side: mysqlEnum("side", ["long", "short"]).notNull(),
      entryPrice: decimal("entryPrice", { precision: 18, scale: 8 }).notNull(),
      exitPrice: decimal("exitPrice", { precision: 18, scale: 8 }),
      quantity: decimal("quantity", { precision: 18, scale: 8 }).notNull(),
      entryDate: timestamp("entryDate").notNull(),
      exitDate: timestamp("exitDate"),
      setup: mysqlEnum("setup", ["breakout", "pullback", "reversal", "trend_following", "range_bound", "news_based", "technical", "fundamental", "other"]).default("other").notNull(),
      emotionBefore: mysqlEnum("emotionBefore", ["confident", "anxious", "greedy", "fearful", "neutral", "excited", "frustrated", "calm"]).default("neutral").notNull(),
      emotionDuring: mysqlEnum("emotionDuring", ["confident", "anxious", "greedy", "fearful", "neutral", "excited", "frustrated", "calm"]),
      emotionAfter: mysqlEnum("emotionAfter", ["confident", "anxious", "greedy", "fearful", "neutral", "excited", "frustrated", "calm"]),
      confidenceLevel: int("confidenceLevel").default(5).notNull(),
      planFollowed: boolean("planFollowed").default(true).notNull(),
      notes: text("notes").notNull(),
      lessonsLearned: text("lessonsLearned"),
      mistakes: json("mistakes").$type(),
      tags: json("tags").$type(),
      screenshots: json("screenshots").$type(),
      outcome: mysqlEnum("outcome", ["win", "loss", "breakeven", "open"]).default("open"),
      pnl: decimal("pnl", { precision: 18, scale: 2 }),
      pnlPercent: decimal("pnlPercent", { precision: 8, scale: 4 }),
      riskRewardRatio: decimal("riskRewardRatio", { precision: 6, scale: 2 }),
      holdingPeriod: int("holdingPeriod"),
      // in minutes
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    exchangeConnections = mysqlTable("exchange_connections", {
      id: varchar("id", { length: 64 }).primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      exchange: mysqlEnum("exchange", ["binance", "coinbase", "alpaca", "interactive_brokers"]).notNull(),
      status: mysqlEnum("status", ["connected", "disconnected", "error", "pending"]).default("pending").notNull(),
      apiKeyEncrypted: text("apiKeyEncrypted"),
      apiSecretEncrypted: text("apiSecretEncrypted"),
      passphraseEncrypted: text("passphraseEncrypted"),
      accountId: varchar("accountId", { length: 64 }),
      permissions: json("permissions").$type(),
      error: text("error"),
      lastSyncAt: timestamp("lastSyncAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    exchangeOrders = mysqlTable("exchange_orders", {
      id: varchar("id", { length: 64 }).primaryKey(),
      connectionId: varchar("connectionId", { length: 64 }).notNull(),
      userId: varchar("userId", { length: 64 }).notNull(),
      exchangeOrderId: varchar("exchangeOrderId", { length: 128 }),
      exchange: mysqlEnum("exchange", ["binance", "coinbase", "alpaca", "interactive_brokers"]).notNull(),
      symbol: varchar("symbol", { length: 20 }).notNull(),
      side: mysqlEnum("side", ["buy", "sell"]).notNull(),
      orderType: mysqlEnum("orderType", ["market", "limit", "stop", "stop_limit"]).notNull(),
      quantity: decimal("quantity", { precision: 18, scale: 8 }).notNull(),
      price: decimal("price", { precision: 18, scale: 8 }),
      stopPrice: decimal("stopPrice", { precision: 18, scale: 8 }),
      filledQuantity: decimal("filledQuantity", { precision: 18, scale: 8 }).default("0").notNull(),
      avgFillPrice: decimal("avgFillPrice", { precision: 18, scale: 8 }),
      status: mysqlEnum("status", ["pending", "open", "filled", "partially_filled", "cancelled", "rejected"]).default("pending").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    brokerConnections = mysqlTable("broker_connections", {
      id: varchar("id", { length: 64 }).primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      brokerType: mysqlEnum("brokerType", ["alpaca", "interactive_brokers", "binance", "coinbase", "schwab"]).notNull(),
      isPaper: boolean("isPaper").default(true).notNull(),
      isActive: boolean("isActive").default(true).notNull(),
      // OAuth tokens (encrypted)
      accessTokenEncrypted: text("accessTokenEncrypted"),
      refreshTokenEncrypted: text("refreshTokenEncrypted"),
      accessTokenSecretEncrypted: text("accessTokenSecretEncrypted"),
      // For OAuth1
      tokenExpiresAt: timestamp("tokenExpiresAt"),
      // Live Session Token for IBKR
      liveSessionTokenEncrypted: text("liveSessionTokenEncrypted"),
      liveSessionTokenExpiresAt: timestamp("liveSessionTokenExpiresAt"),
      // Account info
      accountId: varchar("accountId", { length: 128 }),
      accountNumber: varchar("accountNumber", { length: 64 }),
      accountType: varchar("accountType", { length: 32 }),
      // Connection metadata
      lastConnectedAt: timestamp("lastConnectedAt"),
      lastSyncAt: timestamp("lastSyncAt"),
      connectionError: text("connectionError"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    oauthStates = mysqlTable("oauth_states", {
      id: varchar("id", { length: 64 }).primaryKey(),
      state: varchar("state", { length: 128 }).notNull().unique(),
      userId: varchar("userId", { length: 64 }).notNull(),
      brokerType: mysqlEnum("brokerType", ["alpaca", "interactive_brokers", "binance", "coinbase", "schwab"]).notNull(),
      isPaper: boolean("isPaper").default(true).notNull(),
      // For PKCE (OAuth2)
      codeVerifier: varchar("codeVerifier", { length: 128 }),
      // For OAuth1
      requestToken: varchar("requestToken", { length: 256 }),
      requestTokenSecret: varchar("requestTokenSecret", { length: 256 }),
      expiresAt: timestamp("expiresAt").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    brokerOrders = mysqlTable("broker_orders", {
      id: varchar("id", { length: 64 }).primaryKey(),
      connectionId: varchar("connectionId", { length: 64 }).notNull(),
      userId: varchar("userId", { length: 64 }).notNull(),
      brokerOrderId: varchar("brokerOrderId", { length: 128 }),
      clientOrderId: varchar("clientOrderId", { length: 128 }),
      symbol: varchar("symbol", { length: 32 }).notNull(),
      side: mysqlEnum("side", ["buy", "sell"]).notNull(),
      orderType: mysqlEnum("orderType", ["market", "limit", "stop", "stop_limit", "trailing_stop"]).notNull(),
      timeInForce: mysqlEnum("timeInForce", ["day", "gtc", "ioc", "fok", "opg", "cls"]).default("day").notNull(),
      quantity: decimal("quantity", { precision: 18, scale: 8 }).notNull(),
      price: decimal("price", { precision: 18, scale: 8 }),
      stopPrice: decimal("stopPrice", { precision: 18, scale: 8 }),
      trailPercent: decimal("trailPercent", { precision: 8, scale: 4 }),
      filledQuantity: decimal("filledQuantity", { precision: 18, scale: 8 }).default("0").notNull(),
      avgFillPrice: decimal("avgFillPrice", { precision: 18, scale: 8 }),
      status: mysqlEnum("status", ["new", "pending", "accepted", "partially_filled", "filled", "cancelled", "rejected", "expired", "replaced"]).default("new").notNull(),
      extendedHours: boolean("extendedHours").default(false).notNull(),
      filledAt: timestamp("filledAt"),
      cancelledAt: timestamp("cancelledAt"),
      expiredAt: timestamp("expiredAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    brokerPositions = mysqlTable("broker_positions", {
      id: varchar("id", { length: 64 }).primaryKey(),
      connectionId: varchar("connectionId", { length: 64 }).notNull(),
      userId: varchar("userId", { length: 64 }).notNull(),
      symbol: varchar("symbol", { length: 32 }).notNull(),
      quantity: decimal("quantity", { precision: 18, scale: 8 }).notNull(),
      side: mysqlEnum("side", ["long", "short"]).notNull(),
      avgEntryPrice: decimal("avgEntryPrice", { precision: 18, scale: 8 }).notNull(),
      marketValue: decimal("marketValue", { precision: 18, scale: 8 }),
      costBasis: decimal("costBasis", { precision: 18, scale: 8 }),
      unrealizedPL: decimal("unrealizedPL", { precision: 18, scale: 8 }),
      unrealizedPLPercent: decimal("unrealizedPLPercent", { precision: 8, scale: 4 }),
      currentPrice: decimal("currentPrice", { precision: 18, scale: 8 }),
      lastSyncAt: timestamp("lastSyncAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    orderExecutions = mysqlTable("order_executions", {
      id: varchar("id", { length: 64 }).primaryKey(),
      orderId: varchar("orderId", { length: 64 }).notNull(),
      connectionId: varchar("connectionId", { length: 64 }).notNull(),
      userId: varchar("userId", { length: 64 }).notNull(),
      // Order details
      symbol: varchar("symbol", { length: 32 }).notNull(),
      side: mysqlEnum("side", ["buy", "sell"]).notNull(),
      orderType: varchar("orderType", { length: 32 }).notNull(),
      // Execution details
      executionId: varchar("executionId", { length: 128 }),
      executedQuantity: decimal("executedQuantity", { precision: 18, scale: 8 }).notNull(),
      executedPrice: decimal("executedPrice", { precision: 18, scale: 8 }).notNull(),
      executionValue: decimal("executionValue", { precision: 18, scale: 2 }).notNull(),
      // Fees and costs
      commission: decimal("commission", { precision: 18, scale: 4 }).default("0").notNull(),
      fees: decimal("fees", { precision: 18, scale: 4 }).default("0").notNull(),
      totalCost: decimal("totalCost", { precision: 18, scale: 2 }).notNull(),
      // P&L tracking (for closing trades)
      isClosingTrade: boolean("isClosingTrade").default(false).notNull(),
      openingExecutionId: varchar("openingExecutionId", { length: 64 }),
      realizedPL: decimal("realizedPL", { precision: 18, scale: 2 }),
      realizedPLPercent: decimal("realizedPLPercent", { precision: 8, scale: 4 }),
      holdingPeriodDays: int("holdingPeriodDays"),
      // Market context at execution
      marketPrice: decimal("marketPrice", { precision: 18, scale: 8 }),
      slippage: decimal("slippage", { precision: 8, scale: 4 }),
      executedAt: timestamp("executedAt").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    brokerAccountSnapshots = mysqlTable("broker_account_snapshots", {
      id: varchar("id", { length: 64 }).primaryKey(),
      connectionId: varchar("connectionId", { length: 64 }).notNull(),
      userId: varchar("userId", { length: 64 }).notNull(),
      // Account values
      equity: decimal("equity", { precision: 18, scale: 2 }).notNull(),
      cash: decimal("cash", { precision: 18, scale: 2 }).notNull(),
      buyingPower: decimal("buyingPower", { precision: 18, scale: 2 }).notNull(),
      portfolioValue: decimal("portfolioValue", { precision: 18, scale: 2 }).notNull(),
      // Margin metrics
      marginUsed: decimal("marginUsed", { precision: 18, scale: 2 }).default("0").notNull(),
      marginAvailable: decimal("marginAvailable", { precision: 18, scale: 2 }),
      marginUtilization: decimal("marginUtilization", { precision: 8, scale: 4 }),
      // Performance metrics
      dayPL: decimal("dayPL", { precision: 18, scale: 2 }).default("0").notNull(),
      dayPLPercent: decimal("dayPLPercent", { precision: 8, scale: 4 }),
      totalPL: decimal("totalPL", { precision: 18, scale: 2 }).default("0").notNull(),
      totalPLPercent: decimal("totalPLPercent", { precision: 8, scale: 4 }),
      // Trading activity
      tradesCount: int("tradesCount").default(0).notNull(),
      winningTrades: int("winningTrades").default(0).notNull(),
      losingTrades: int("losingTrades").default(0).notNull(),
      tradingVolume: decimal("tradingVolume", { precision: 18, scale: 2 }).default("0").notNull(),
      // Position metrics
      positionsCount: int("positionsCount").default(0).notNull(),
      longPositions: int("longPositions").default(0).notNull(),
      shortPositions: int("shortPositions").default(0).notNull(),
      snapshotDate: timestamp("snapshotDate").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    portfolioAllocations = mysqlTable("portfolio_allocations", {
      id: varchar("id", { length: 64 }).primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      // Target allocations (JSON: { symbol: percentage })
      targetAllocations: json("targetAllocations").notNull(),
      // Rebalancing settings
      rebalanceThreshold: decimal("rebalanceThreshold", { precision: 5, scale: 2 }).default("5.00").notNull(),
      // % drift before rebalancing
      rebalanceFrequency: mysqlEnum("rebalanceFrequency", ["manual", "daily", "weekly", "monthly", "quarterly"]).default("manual").notNull(),
      lastRebalancedAt: timestamp("lastRebalancedAt"),
      nextRebalanceAt: timestamp("nextRebalanceAt"),
      // Broker preferences for rebalancing
      preferredBrokers: json("preferredBrokers"),
      // Array of connectionIds in priority order
      isActive: boolean("isActive").default(true).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    rebalancingHistory = mysqlTable("rebalancing_history", {
      id: varchar("id", { length: 64 }).primaryKey(),
      allocationId: varchar("allocationId", { length: 64 }).notNull(),
      userId: varchar("userId", { length: 64 }).notNull(),
      // Pre-rebalance state
      preAllocations: json("preAllocations").notNull(),
      // { symbol: { actual: %, target: %, value: $ } }
      totalPortfolioValue: decimal("totalPortfolioValue", { precision: 18, scale: 2 }).notNull(),
      // Trades executed
      tradesExecuted: json("tradesExecuted").notNull(),
      // Array of trade details
      tradesCount: int("tradesCount").default(0).notNull(),
      totalTradingVolume: decimal("totalTradingVolume", { precision: 18, scale: 2 }).default("0").notNull(),
      totalFees: decimal("totalFees", { precision: 18, scale: 4 }).default("0").notNull(),
      // Post-rebalance state
      postAllocations: json("postAllocations").notNull(),
      // Status
      status: mysqlEnum("status", ["pending", "in_progress", "completed", "partial", "failed", "cancelled"]).default("pending").notNull(),
      errorMessage: text("errorMessage"),
      triggeredBy: mysqlEnum("triggeredBy", ["manual", "scheduled", "threshold"]).default("manual").notNull(),
      startedAt: timestamp("startedAt"),
      completedAt: timestamp("completedAt"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    brokerPerformanceMetrics = mysqlTable("broker_performance_metrics", {
      id: varchar("id", { length: 64 }).primaryKey(),
      connectionId: varchar("connectionId", { length: 64 }).notNull(),
      userId: varchar("userId", { length: 64 }).notNull(),
      // Time period
      periodType: mysqlEnum("periodType", ["daily", "weekly", "monthly", "yearly", "all_time"]).notNull(),
      periodStart: timestamp("periodStart").notNull(),
      periodEnd: timestamp("periodEnd").notNull(),
      // Returns
      totalReturn: decimal("totalReturn", { precision: 18, scale: 2 }).default("0").notNull(),
      totalReturnPercent: decimal("totalReturnPercent", { precision: 8, scale: 4 }),
      // Risk metrics
      sharpeRatio: decimal("sharpeRatio", { precision: 8, scale: 4 }),
      sortinoRatio: decimal("sortinoRatio", { precision: 8, scale: 4 }),
      maxDrawdown: decimal("maxDrawdown", { precision: 8, scale: 4 }),
      maxDrawdownDuration: int("maxDrawdownDuration"),
      // days
      volatility: decimal("volatility", { precision: 8, scale: 4 }),
      // Trading stats
      totalTrades: int("totalTrades").default(0).notNull(),
      winningTrades: int("winningTrades").default(0).notNull(),
      losingTrades: int("losingTrades").default(0).notNull(),
      winRate: decimal("winRate", { precision: 5, scale: 2 }),
      profitFactor: decimal("profitFactor", { precision: 8, scale: 4 }),
      avgWin: decimal("avgWin", { precision: 18, scale: 2 }),
      avgLoss: decimal("avgLoss", { precision: 18, scale: 2 }),
      largestWin: decimal("largestWin", { precision: 18, scale: 2 }),
      largestLoss: decimal("largestLoss", { precision: 18, scale: 2 }),
      // Volume and activity
      totalVolume: decimal("totalVolume", { precision: 18, scale: 2 }).default("0").notNull(),
      avgTradeSize: decimal("avgTradeSize", { precision: 18, scale: 2 }),
      avgHoldingPeriod: decimal("avgHoldingPeriod", { precision: 8, scale: 2 }),
      // days
      calculatedAt: timestamp("calculatedAt").defaultNow().notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    sharedScenarios = mysqlTable("shared_scenarios", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      scenarioData: json("scenarioData").notNull(),
      trades: json("trades").notNull(),
      positions: json("positions"),
      cash: decimal("cash", { precision: 18, scale: 2 }).default("0"),
      category: varchar("category", { length: 50 }).default("general"),
      tags: json("tags"),
      isPublic: boolean("isPublic").default(true),
      likesCount: int("likesCount").default(0),
      importsCount: int("importsCount").default(0),
      viewsCount: int("viewsCount").default(0),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    scenarioLikes = mysqlTable("scenario_likes", {
      id: int("id").autoincrement().primaryKey(),
      scenarioId: int("scenarioId").notNull(),
      userId: int("userId").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    scenarioImports = mysqlTable("scenario_imports", {
      id: int("id").autoincrement().primaryKey(),
      scenarioId: int("scenarioId").notNull(),
      userId: int("userId").notNull(),
      importedAt: timestamp("importedAt").defaultNow().notNull()
    });
    templatePerformance = mysqlTable("template_performance", {
      id: int("id").autoincrement().primaryKey(),
      templateId: varchar("templateId", { length: 100 }).notNull(),
      snapshotDate: date("snapshotDate").notNull(),
      portfolioValue: decimal("portfolioValue", { precision: 18, scale: 2 }).notNull(),
      dailyReturn: decimal("dailyReturn", { precision: 10, scale: 6 }),
      cumulativeReturn: decimal("cumulativeReturn", { precision: 10, scale: 6 }),
      volatility: decimal("volatility", { precision: 10, scale: 6 }),
      sharpeRatio: decimal("sharpeRatio", { precision: 10, scale: 4 }),
      maxDrawdown: decimal("maxDrawdown", { precision: 10, scale: 6 }),
      winRate: decimal("winRate", { precision: 10, scale: 4 }),
      totalTrades: int("totalTrades").default(0),
      positions: json("positions"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    brokerWatchlists = mysqlTable("broker_watchlists", {
      id: int("id").autoincrement().primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      connectionId: varchar("connectionId", { length: 64 }),
      name: varchar("name", { length: 100 }).notNull(),
      symbols: json("symbols").notNull(),
      // Array of symbols
      // Sync with broker
      brokerWatchlistId: varchar("brokerWatchlistId", { length: 100 }),
      isSynced: boolean("isSynced").default(false),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    brokerActivityLogs = mysqlTable("broker_activity_logs", {
      id: int("id").autoincrement().primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull(),
      connectionId: varchar("connectionId", { length: 64 }),
      // Activity type
      activityType: mysqlEnum("activityType", [
        "connect",
        "disconnect",
        "order_placed",
        "order_filled",
        "order_cancelled",
        "order_rejected",
        "position_opened",
        "position_closed",
        "deposit",
        "withdrawal",
        "dividend",
        "split",
        "error"
      ]).notNull(),
      // Details
      symbol: varchar("symbol", { length: 50 }),
      orderId: varchar("orderId", { length: 64 }),
      description: text("description"),
      metadata: json("metadata"),
      // Status
      success: boolean("success").default(true).notNull(),
      errorMessage: text("errorMessage"),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    userRoutingPreferences = mysqlTable("user_routing_preferences", {
      id: int("id").autoincrement().primaryKey(),
      userId: varchar("userId", { length: 64 }).notNull().unique(),
      // Preferred brokers by asset class
      preferredStockBroker: mysqlEnum("preferredStockBroker", ["alpaca", "interactive_brokers"]),
      preferredCryptoBroker: mysqlEnum("preferredCryptoBroker", ["binance", "coinbase", "alpaca"]),
      preferredForexBroker: mysqlEnum("preferredForexBroker", ["interactive_brokers"]),
      preferredOptionsBroker: mysqlEnum("preferredOptionsBroker", ["interactive_brokers"]),
      // Routing behavior
      enableSmartRouting: boolean("enableSmartRouting").default(true).notNull(),
      prioritizeLowFees: boolean("prioritizeLowFees").default(false).notNull(),
      prioritizeFastExecution: boolean("prioritizeFastExecution").default(false).notNull(),
      allowFallback: boolean("allowFallback").default(true).notNull(),
      // Confirmation settings
      confirmBeforeRouting: boolean("confirmBeforeRouting").default(true).notNull(),
      showRoutingDecision: boolean("showRoutingDecision").default(true).notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    investmentTheses = mysqlTable("investment_theses", {
      id: int("id").autoincrement().primaryKey(),
      userId: int("userId").notNull(),
      // Thesis details
      ticker: varchar("ticker", { length: 20 }).notNull(),
      rating: mysqlEnum("rating", ["strong_buy", "buy", "hold", "sell", "strong_sell"]).notNull(),
      convictionScore: decimal("convictionScore", { precision: 5, scale: 2 }).notNull(),
      // 0-100
      targetPrice: decimal("targetPrice", { precision: 18, scale: 4 }),
      targetDate: timestamp("targetDate"),
      timeHorizon: mysqlEnum("timeHorizon", ["short", "medium", "long"]).default("medium"),
      // Price at thesis creation
      entryPrice: decimal("entryPrice", { precision: 18, scale: 4 }).notNull(),
      // Agent signals at time of thesis
      agentSignals: json("agentSignals").notNull(),
      // Snapshot of all agent signals
      consensusDetails: json("consensusDetails"),
      // Full consensus breakdown
      // Thesis content
      executiveSummary: text("executiveSummary"),
      fullThesis: text("fullThesis"),
      // Markdown content
      riskFactors: json("riskFactors"),
      counterThesis: text("counterThesis"),
      // Status
      status: mysqlEnum("status", ["pending", "approved", "rejected", "closed"]).default("pending").notNull(),
      approvedAt: timestamp("approvedAt"),
      closedAt: timestamp("closedAt"),
      closeReason: varchar("closeReason", { length: 255 }),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    thesisPerformance = mysqlTable("thesis_performance", {
      id: int("id").autoincrement().primaryKey(),
      thesisId: int("thesisId").notNull(),
      // Performance snapshot
      snapshotDate: timestamp("snapshotDate").notNull(),
      currentPrice: decimal("currentPrice", { precision: 18, scale: 4 }).notNull(),
      // Returns
      absoluteReturn: decimal("absoluteReturn", { precision: 18, scale: 4 }),
      // Dollar return
      percentReturn: decimal("percentReturn", { precision: 10, scale: 4 }),
      // Percentage return
      // Benchmark comparison
      benchmarkReturn: decimal("benchmarkReturn", { precision: 10, scale: 4 }),
      // S&P 500 return
      alphaGenerated: decimal("alphaGenerated", { precision: 10, scale: 4 }),
      // Return vs benchmark
      // Target progress
      targetProgress: decimal("targetProgress", { precision: 10, scale: 4 }),
      // % toward target price
      // Risk metrics
      maxDrawdown: decimal("maxDrawdown", { precision: 10, scale: 4 }),
      volatility: decimal("volatility", { precision: 10, scale: 4 }),
      sharpeRatio: decimal("sharpeRatio", { precision: 10, scale: 4 }),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    agentPerformance = mysqlTable("agent_performance", {
      id: int("id").autoincrement().primaryKey(),
      // Agent identification
      agentType: varchar("agentType", { length: 50 }).notNull(),
      // fundamental, technical, sentiment, macro, portfolio
      // Performance period
      periodStart: timestamp("periodStart").notNull(),
      periodEnd: timestamp("periodEnd").notNull(),
      // Accuracy metrics
      totalSignals: int("totalSignals").default(0).notNull(),
      correctSignals: int("correctSignals").default(0).notNull(),
      accuracy: decimal("accuracy", { precision: 5, scale: 4 }),
      // 0-1
      // Performance by signal type
      bullishAccuracy: decimal("bullishAccuracy", { precision: 5, scale: 4 }),
      bearishAccuracy: decimal("bearishAccuracy", { precision: 5, scale: 4 }),
      neutralAccuracy: decimal("neutralAccuracy", { precision: 5, scale: 4 }),
      // Market condition performance
      marketCondition: mysqlEnum("marketCondition", ["bull", "bear", "sideways", "volatile"]),
      conditionAccuracy: decimal("conditionAccuracy", { precision: 5, scale: 4 }),
      // Weight recommendation
      recommendedWeight: decimal("recommendedWeight", { precision: 5, scale: 4 }),
      currentWeight: decimal("currentWeight", { precision: 5, scale: 4 }),
      // Additional metrics
      avgConfidence: decimal("avgConfidence", { precision: 5, scale: 2 }),
      avgReturnWhenCorrect: decimal("avgReturnWhenCorrect", { precision: 10, scale: 4 }),
      avgReturnWhenWrong: decimal("avgReturnWhenWrong", { precision: 10, scale: 4 }),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
    earningsCallTranscripts = mysqlTable("earnings_call_transcripts", {
      id: int("id").autoincrement().primaryKey(),
      // Company identification
      ticker: varchar("ticker", { length: 20 }).notNull(),
      companyName: varchar("companyName", { length: 255 }),
      // Call details
      callDate: timestamp("callDate").notNull(),
      fiscalQuarter: varchar("fiscalQuarter", { length: 10 }),
      // Q1, Q2, Q3, Q4
      fiscalYear: int("fiscalYear"),
      callType: mysqlEnum("callType", ["earnings", "guidance", "analyst_day", "special"]).default("earnings"),
      // Transcript content
      fullTranscript: text("fullTranscript"),
      preparedRemarks: text("preparedRemarks"),
      qaSection: text("qaSection"),
      // Participants
      participants: json("participants"),
      // CEO, CFO, analysts, etc.
      // Sentiment analysis
      overallSentiment: decimal("overallSentiment", { precision: 5, scale: 4 }),
      // -1 to 1
      managementTone: decimal("managementTone", { precision: 5, scale: 4 }),
      // -1 to 1
      analystTone: decimal("analystTone", { precision: 5, scale: 4 }),
      // -1 to 1
      // Detailed sentiment breakdown
      sentimentBreakdown: json("sentimentBreakdown"),
      // By section, by speaker
      // Key phrases and topics
      keyPhrases: json("keyPhrases"),
      // Important phrases extracted
      forwardGuidance: json("forwardGuidance"),
      // Forward-looking statements
      riskMentions: json("riskMentions"),
      // Risk-related mentions
      // Metrics mentioned
      metricsDiscussed: json("metricsDiscussed"),
      // Revenue, margins, etc.
      // Source
      sourceUrl: varchar("sourceUrl", { length: 500 }),
      sourceProvider: varchar("sourceProvider", { length: 100 }),
      createdAt: timestamp("createdAt").defaultNow().notNull(),
      updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull()
    });
    earningsSentimentHistory = mysqlTable("earnings_sentiment_history", {
      id: int("id").autoincrement().primaryKey(),
      ticker: varchar("ticker", { length: 20 }).notNull(),
      transcriptId: int("transcriptId").notNull(),
      // Sentiment metrics
      sentimentScore: decimal("sentimentScore", { precision: 5, scale: 4 }).notNull(),
      // -1 to 1
      confidenceScore: decimal("confidenceScore", { precision: 5, scale: 4 }),
      // 0 to 1
      // Comparison to previous
      sentimentChange: decimal("sentimentChange", { precision: 5, scale: 4 }),
      // Change from last call
      trendDirection: mysqlEnum("trendDirection", ["improving", "declining", "stable"]),
      // Correlation with price
      priceAtCall: decimal("priceAtCall", { precision: 18, scale: 4 }),
      priceAfter1Day: decimal("priceAfter1Day", { precision: 18, scale: 4 }),
      priceAfter1Week: decimal("priceAfter1Week", { precision: 18, scale: 4 }),
      priceAfter1Month: decimal("priceAfter1Month", { precision: 18, scale: 4 }),
      // Signal generated
      signalGenerated: mysqlEnum("signalGenerated", ["bullish", "bearish", "neutral"]),
      signalAccuracy: boolean("signalAccuracy"),
      // Was the signal correct?
      callDate: timestamp("callDate").notNull(),
      createdAt: timestamp("createdAt").defaultNow().notNull()
    });
  }
});

// server/_core/env.ts
var ENV;
var init_env = __esm({
  "server/_core/env.ts"() {
    "use strict";
    ENV = {
      appId: process.env.VITE_APP_ID ?? "",
      cookieSecret: process.env.JWT_SECRET ?? "",
      databaseUrl: process.env.DATABASE_URL ?? "",
      oAuthServerUrl: process.env.OAUTH_SERVER_URL ?? "",
      ownerOpenId: process.env.OWNER_OPEN_ID ?? "",
      isProduction: process.env.NODE_ENV === "production",
      forgeApiUrl: process.env.BUILT_IN_FORGE_API_URL ?? "",
      forgeApiKey: process.env.BUILT_IN_FORGE_API_KEY ?? ""
    };
  }
});

// server/db.ts
var db_exports = {};
__export(db_exports, {
  canSendEmail: () => canSendEmail,
  checkTierLimit: () => checkTierLimit,
  createActivityFeedItem: () => createActivityFeedItem,
  createAgentAnalysis: () => createAgentAnalysis,
  createAlertHistory: () => createAlertHistory,
  createBacktest: () => createBacktest,
  createBotBenchmark: () => createBotBenchmark,
  createBotCopy: () => createBotCopy,
  createBotExecutionLog: () => createBotExecutionLog,
  createBotRiskRule: () => createBotRiskRule,
  createBotSchedule: () => createBotSchedule,
  createDiscussionComment: () => createDiscussionComment,
  createDiscussionThread: () => createDiscussionThread,
  createEmailConfig: () => createEmailConfig,
  createEmailVerification: () => createEmailVerification,
  createMarketplaceListing: () => createMarketplaceListing,
  createPortfolioSnapshot: () => createPortfolioSnapshot,
  createPredictionAccuracy: () => createPredictionAccuracy,
  createPriceTracking: () => createPriceTracking,
  createRealtimeSubscription: () => createRealtimeSubscription,
  createSavedComparison: () => createSavedComparison,
  createStrategyRating: () => createStrategyRating,
  createTrade: () => createTrade,
  createTradingAccount: () => createTradingAccount,
  createTradingBot: () => createTradingBot,
  createUserBadge: () => createUserBadge,
  createUserFallbackSettings: () => createUserFallbackSettings,
  createUserFollow: () => createUserFollow,
  createUserLlmSettings: () => createUserLlmSettings,
  createUserNotification: () => createUserNotification,
  createUserProfile: () => createUserProfile,
  createWatchlist: () => createWatchlist,
  createWatchlistAlert: () => createWatchlistAlert,
  deleteBotRiskRule: () => deleteBotRiskRule,
  deleteBotSchedule: () => deleteBotSchedule,
  deleteDiscussionComment: () => deleteDiscussionComment,
  deleteExpiredVerifications: () => deleteExpiredVerifications,
  deleteNotification: () => deleteNotification,
  deleteRealtimeSubscription: () => deleteRealtimeSubscription,
  deleteSavedComparison: () => deleteSavedComparison,
  deleteUserLlmSettings: () => deleteUserLlmSettings,
  deleteWatchlist: () => deleteWatchlist,
  deleteWatchlistAlert: () => deleteWatchlistAlert,
  getAccountTrades: () => getAccountTrades,
  getActiveBotSchedules: () => getActiveBotSchedules,
  getActiveWatchlistAlerts: () => getActiveWatchlistAlerts,
  getAdminLlmUsageStats: () => getAdminLlmUsageStats,
  getAdminStats: () => getAdminStats,
  getAgentAccuracyStats: () => getAgentAccuracyStats,
  getAgentAnalysisHistory: () => getAgentAnalysisHistory,
  getAllBadgeDefinitions: () => getAllBadgeDefinitions,
  getAllUsers: () => getAllUsers,
  getAnalysisById: () => getAnalysisById,
  getAnalysisStats: () => getAnalysisStats,
  getBacktestById: () => getBacktestById,
  getBadgeDefinition: () => getBadgeDefinition,
  getBotBenchmarks: () => getBotBenchmarks,
  getBotExecutionLogs: () => getBotExecutionLogs,
  getBotRiskRules: () => getBotRiskRules,
  getBotSchedules: () => getBotSchedules,
  getBotTrades: () => getBotTrades,
  getDb: () => getDb,
  getDiscussionThreadById: () => getDiscussionThreadById,
  getDiscussionThreads: () => getDiscussionThreads,
  getEmailConfig: () => getEmailConfig,
  getEmailVerificationByToken: () => getEmailVerificationByToken,
  getEmailVerificationByUserId: () => getEmailVerificationByUserId,
  getFeaturedListings: () => getFeaturedListings,
  getFilteredAnalysisHistory: () => getFilteredAnalysisHistory,
  getLatestAgentAnalysis: () => getLatestAgentAnalysis,
  getLatestBotBenchmark: () => getLatestBotBenchmark,
  getLeaderboard: () => getLeaderboard,
  getMarketplaceListings: () => getMarketplaceListings,
  getPendingPriceTrackings: () => getPendingPriceTrackings,
  getPortfolioSnapshots: () => getPortfolioSnapshots,
  getPriceTrackingByAnalysis: () => getPriceTrackingByAnalysis,
  getPublicActivityFeed: () => getPublicActivityFeed,
  getPublicBots: () => getPublicBots,
  getPublicUserProfile: () => getPublicUserProfile,
  getRLModelById: () => getRLModelById,
  getRecentUsageSummary: () => getRecentUsageSummary,
  getSavedComparisonById: () => getSavedComparisonById,
  getStrategyComparisonById: () => getStrategyComparisonById,
  getStrategyRatings: () => getStrategyRatings,
  getThreadComments: () => getThreadComments,
  getTierLimits: () => getTierLimits,
  getTopTraders: () => getTopTraders,
  getTradingAccountById: () => getTradingAccountById,
  getTradingBotById: () => getTradingBotById,
  getUniqueSymbols: () => getUniqueSymbols,
  getUnreadNotificationCount: () => getUnreadNotificationCount,
  getUserActivityFeed: () => getUserActivityFeed,
  getUserAlertHistory: () => getUserAlertHistory,
  getUserBacktests: () => getUserBacktests,
  getUserBadges: () => getUserBadges,
  getUserBotCopies: () => getUserBotCopies,
  getUserById: () => getUserById,
  getUserByOpenId: () => getUserByOpenId,
  getUserFallbackSettings: () => getUserFallbackSettings,
  getUserFollowers: () => getUserFollowers,
  getUserFollowing: () => getUserFollowing,
  getUserLlmSettings: () => getUserLlmSettings,
  getUserLlmUsageLogs: () => getUserLlmUsageLogs,
  getUserNotifications: () => getUserNotifications,
  getUserPredictionAccuracy: () => getUserPredictionAccuracy,
  getUserProfile: () => getUserProfile,
  getUserRLModels: () => getUserRLModels,
  getUserRealtimeSubscriptions: () => getUserRealtimeSubscriptions,
  getUserSavedComparisons: () => getUserSavedComparisons,
  getUserStrategyComparisons: () => getUserStrategyComparisons,
  getUserStrategyRating: () => getUserStrategyRating,
  getUserTrades: () => getUserTrades,
  getUserTradingAccounts: () => getUserTradingAccounts,
  getUserTradingBots: () => getUserTradingBots,
  getUserUsageStats: () => getUserUsageStats,
  getUserWatchlistAlerts: () => getUserWatchlistAlerts,
  getUserWatchlists: () => getUserWatchlists,
  hasBadge: () => hasBadge,
  incrementEmailsSentToday: () => incrementEmailsSentToday,
  incrementResendCount: () => incrementResendCount,
  incrementThreadViews: () => incrementThreadViews,
  isFollowing: () => isFollowing,
  isUserEmailVerified: () => isUserEmailVerified,
  logLlmUsage: () => logLlmUsage,
  markAllNotificationsRead: () => markAllNotificationsRead,
  markEmailVerified: () => markEmailVerified,
  markNotificationRead: () => markNotificationRead,
  saveStrategyComparison: () => saveStrategyComparison,
  unfollowUser: () => unfollowUser,
  updateBacktestResults: () => updateBacktestResults,
  updateBotExecutionLog: () => updateBotExecutionLog,
  updateBotPerformance: () => updateBotPerformance,
  updateBotRiskRule: () => updateBotRiskRule,
  updateBotSchedule: () => updateBotSchedule,
  updateDiscussionComment: () => updateDiscussionComment,
  updateDiscussionThread: () => updateDiscussionThread,
  updateEmailConfig: () => updateEmailConfig,
  updateListingStats: () => updateListingStats,
  updateLlmUsage: () => updateLlmUsage,
  updatePriceTracking: () => updatePriceTracking,
  updateRLModel: () => updateRLModel,
  updateSavedComparison: () => updateSavedComparison,
  updateStrategyRating: () => updateStrategyRating,
  updateTradeStatus: () => updateTradeStatus,
  updateTradingAccountBalance: () => updateTradingAccountBalance,
  updateTradingBot: () => updateTradingBot,
  updateUserFallbackSettings: () => updateUserFallbackSettings,
  updateUserLlmSettings: () => updateUserLlmSettings,
  updateUserProfile: () => updateUserProfile,
  updateUserRole: () => updateUserRole,
  updateUserSubscription: () => updateUserSubscription,
  updateWatchlist: () => updateWatchlist,
  updateWatchlistAlert: () => updateWatchlistAlert,
  upsertEmailConfig: () => upsertEmailConfig,
  upsertUser: () => upsertUser,
  upsertUserFallbackSettings: () => upsertUserFallbackSettings,
  upsertUserLlmSettings: () => upsertUserLlmSettings,
  upsertUserProfile: () => upsertUserProfile
});
import { eq, sql, desc, gte, lte, or, inArray, and, lt, asc } from "drizzle-orm";
import { drizzle } from "drizzle-orm/mysql2";
async function getDb() {
  if (!_db && process.env.DATABASE_URL) {
    try {
      _db = drizzle(process.env.DATABASE_URL);
    } catch (error) {
      console.warn("[Database] Failed to connect:", error);
      _db = null;
    }
  }
  return _db;
}
async function upsertUser(user) {
  if (!user.openId) {
    throw new Error("User openId is required for upsert");
  }
  const db = await getDb();
  if (!db) {
    console.warn("[Database] Cannot upsert user: database not available");
    return;
  }
  try {
    const values = {
      openId: user.openId
    };
    const updateSet = {};
    const textFields = ["name", "email", "loginMethod"];
    const assignNullable = (field) => {
      const value = user[field];
      if (value === void 0) return;
      const normalized = value ?? null;
      values[field] = normalized;
      updateSet[field] = normalized;
    };
    textFields.forEach(assignNullable);
    if (user.lastSignedIn !== void 0) {
      values.lastSignedIn = user.lastSignedIn;
      updateSet.lastSignedIn = user.lastSignedIn;
    }
    if (user.role !== void 0) {
      values.role = user.role;
      updateSet.role = user.role;
    } else if (user.openId === ENV.ownerOpenId) {
      values.role = "admin";
      updateSet.role = "admin";
    }
    if (!values.lastSignedIn) {
      values.lastSignedIn = /* @__PURE__ */ new Date();
    }
    if (Object.keys(updateSet).length === 0) {
      updateSet.lastSignedIn = /* @__PURE__ */ new Date();
    }
    await db.insert(users).values(values).onDuplicateKeyUpdate({
      set: updateSet
    });
  } catch (error) {
    console.error("[Database] Failed to upsert user:", error);
    throw error;
  }
}
async function getUserByOpenId(openId) {
  const db = await getDb();
  if (!db) {
    console.warn("[Database] Cannot get user: database not available");
    return void 0;
  }
  const result = await db.select().from(users).where(eq(users.openId, openId)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function getUserById(id) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(users).where(eq(users.id, id)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function getAllUsers() {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(users).orderBy(desc(users.createdAt));
}
async function updateUserSubscription(userId, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(users).set(data).where(eq(users.id, userId));
}
async function updateUserRole(userId, role) {
  const db = await getDb();
  if (!db) return;
  await db.update(users).set({ role }).where(eq(users.id, userId));
}
async function createTradingAccount(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(tradingAccounts).values(data);
  return result[0].insertId;
}
async function getUserTradingAccounts(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(tradingAccounts).where(eq(tradingAccounts.userId, userId)).orderBy(desc(tradingAccounts.createdAt));
}
async function getTradingAccountById(id, userId) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(tradingAccounts).where(and(eq(tradingAccounts.id, id), eq(tradingAccounts.userId, userId))).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function updateTradingAccountBalance(id, balance) {
  const db = await getDb();
  if (!db) return;
  await db.update(tradingAccounts).set({ balance }).where(eq(tradingAccounts.id, id));
}
async function createTradingBot(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(tradingBots).values(data);
  return result[0].insertId;
}
async function getUserTradingBots(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(tradingBots).where(eq(tradingBots.userId, userId)).orderBy(desc(tradingBots.createdAt));
}
async function getTradingBotById(id, userId) {
  const db = await getDb();
  if (!db) return void 0;
  const conditions = userId ? and(eq(tradingBots.id, id), eq(tradingBots.userId, userId)) : eq(tradingBots.id, id);
  const result = await db.select().from(tradingBots).where(conditions).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function updateTradingBot(id, userId, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(tradingBots).set(data).where(and(eq(tradingBots.id, id), eq(tradingBots.userId, userId)));
}
async function updateBotPerformance(id, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(tradingBots).set(data).where(eq(tradingBots.id, id));
}
async function getPublicBots() {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(tradingBots).where(eq(tradingBots.isPublic, true)).orderBy(desc(tradingBots.totalPnl));
}
async function createTrade(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(trades).values(data);
  return result[0].insertId;
}
async function getUserTrades(userId, limit = 50) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(trades).where(eq(trades.userId, userId)).orderBy(desc(trades.createdAt)).limit(limit);
}
async function getAccountTrades(accountId, userId, limit = 50) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(trades).where(and(eq(trades.accountId, accountId), eq(trades.userId, userId))).orderBy(desc(trades.createdAt)).limit(limit);
}
async function getBotTrades(botId, limit = 100) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(trades).where(eq(trades.botId, botId)).orderBy(desc(trades.createdAt)).limit(limit);
}
async function updateTradeStatus(id, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(trades).set(data).where(eq(trades.id, id));
}
async function createBacktest(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(backtests).values(data);
  return result[0].insertId;
}
async function getUserBacktests(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(backtests).where(eq(backtests.userId, userId)).orderBy(desc(backtests.createdAt));
}
async function getBacktestById(id, userId) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(backtests).where(and(eq(backtests.id, id), eq(backtests.userId, userId))).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function updateBacktestResults(id, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(backtests).set(data).where(eq(backtests.id, id));
}
async function createPortfolioSnapshot(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  await db.insert(portfolioSnapshots).values(data);
}
async function getPortfolioSnapshots(accountId, userId, days = 30) {
  const db = await getDb();
  if (!db) return [];
  const startDate = /* @__PURE__ */ new Date();
  startDate.setDate(startDate.getDate() - days);
  return db.select().from(portfolioSnapshots).where(and(
    eq(portfolioSnapshots.accountId, accountId),
    eq(portfolioSnapshots.userId, userId),
    gte(portfolioSnapshots.snapshotDate, startDate)
  )).orderBy(portfolioSnapshots.snapshotDate);
}
async function createAgentAnalysis(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(agentAnalyses).values(data);
  return result[0].insertId;
}
async function getLatestAgentAnalysis(symbol, userId) {
  const db = await getDb();
  if (!db) return void 0;
  const conditions = userId ? and(eq(agentAnalyses.symbol, symbol), eq(agentAnalyses.userId, userId)) : eq(agentAnalyses.symbol, symbol);
  const result = await db.select().from(agentAnalyses).where(conditions).orderBy(desc(agentAnalyses.createdAt)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function getAgentAnalysisHistory(symbol, userId, limit = 10) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(agentAnalyses).where(and(eq(agentAnalyses.symbol, symbol), eq(agentAnalyses.userId, userId))).orderBy(desc(agentAnalyses.createdAt)).limit(limit);
}
async function getFilteredAnalysisHistory(filters) {
  const db = await getDb();
  if (!db) return { analyses: [], total: 0 };
  const conditions = [eq(agentAnalyses.userId, filters.userId)];
  if (filters.symbol) {
    conditions.push(eq(agentAnalyses.symbol, filters.symbol));
  }
  if (filters.consensusAction) {
    conditions.push(eq(agentAnalyses.consensusAction, filters.consensusAction));
  }
  if (filters.startDate) {
    conditions.push(gte(agentAnalyses.createdAt, filters.startDate));
  }
  if (filters.endDate) {
    conditions.push(lte(agentAnalyses.createdAt, filters.endDate));
  }
  if (filters.minConfidence !== void 0) {
    conditions.push(gte(agentAnalyses.confidence, filters.minConfidence.toString()));
  }
  const whereClause = conditions.length > 1 ? and(...conditions) : conditions[0];
  const [countResult] = await db.select({ count: sql`count(*)` }).from(agentAnalyses).where(whereClause);
  const analyses = await db.select().from(agentAnalyses).where(whereClause).orderBy(desc(agentAnalyses.createdAt)).limit(filters.limit || 20).offset(filters.offset || 0);
  return {
    analyses,
    total: countResult?.count || 0
  };
}
async function getAnalysisById(id, userId) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(agentAnalyses).where(and(eq(agentAnalyses.id, id), eq(agentAnalyses.userId, userId))).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function getAnalysisStats(userId) {
  const db = await getDb();
  if (!db) return null;
  const [totalCount] = await db.select({ count: sql`count(*)` }).from(agentAnalyses).where(eq(agentAnalyses.userId, userId));
  const actionCounts = await db.select({
    action: agentAnalyses.consensusAction,
    count: sql`count(*)`
  }).from(agentAnalyses).where(eq(agentAnalyses.userId, userId)).groupBy(agentAnalyses.consensusAction);
  const symbolCounts = await db.select({
    symbol: agentAnalyses.symbol,
    count: sql`count(*)`
  }).from(agentAnalyses).where(eq(agentAnalyses.userId, userId)).groupBy(agentAnalyses.symbol).orderBy(desc(sql`count(*)`));
  const [avgConfidence] = await db.select({
    avg: sql`AVG(confidence)`
  }).from(agentAnalyses).where(eq(agentAnalyses.userId, userId));
  return {
    totalAnalyses: totalCount?.count || 0,
    byAction: actionCounts,
    bySymbol: symbolCounts.slice(0, 10),
    // Top 10 symbols
    avgConfidence: avgConfidence?.avg || 0
  };
}
async function getUniqueSymbols(userId) {
  const db = await getDb();
  if (!db) return [];
  const result = await db.selectDistinct({ symbol: agentAnalyses.symbol }).from(agentAnalyses).where(eq(agentAnalyses.userId, userId)).orderBy(agentAnalyses.symbol);
  return result.map((r) => r.symbol);
}
async function createMarketplaceListing(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(marketplaceListings).values(data);
  return result[0].insertId;
}
async function getMarketplaceListings(category) {
  const db = await getDb();
  if (!db) return [];
  const conditions = category ? and(eq(marketplaceListings.isActive, true), eq(marketplaceListings.category, category)) : eq(marketplaceListings.isActive, true);
  return db.select().from(marketplaceListings).where(conditions).orderBy(desc(marketplaceListings.totalCopies));
}
async function getFeaturedListings() {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(marketplaceListings).where(and(eq(marketplaceListings.isActive, true), eq(marketplaceListings.isFeatured, true))).orderBy(desc(marketplaceListings.rating));
}
async function getLeaderboard(limit = 20) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(marketplaceListings).where(eq(marketplaceListings.isActive, true)).orderBy(desc(marketplaceListings.monthlyReturn)).limit(limit);
}
async function updateListingStats(id, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(marketplaceListings).set(data).where(eq(marketplaceListings.id, id));
}
async function createBotCopy(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  await db.insert(botCopies).values(data);
}
async function getUserBotCopies(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(botCopies).where(eq(botCopies.userId, userId)).orderBy(desc(botCopies.createdAt));
}
async function createWatchlist(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(watchlists).values(data);
  return result[0].insertId;
}
async function getUserWatchlists(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(watchlists).where(eq(watchlists.userId, userId)).orderBy(desc(watchlists.createdAt));
}
async function updateWatchlist(id, userId, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(watchlists).set(data).where(and(eq(watchlists.id, id), eq(watchlists.userId, userId)));
}
async function deleteWatchlist(id, userId) {
  const db = await getDb();
  if (!db) return;
  await db.delete(watchlists).where(and(eq(watchlists.id, id), eq(watchlists.userId, userId)));
}
function getTierLimits(tier) {
  return subscriptionTierLimits[tier];
}
async function checkTierLimit(userId, limitType) {
  const db = await getDb();
  if (!db) return { allowed: false, current: 0, limit: 0 };
  const user = await getUserById(userId);
  if (!user) return { allowed: false, current: 0, limit: 0 };
  const limits = getTierLimits(user.subscriptionTier);
  const limit = limits[limitType];
  if (typeof limit === "boolean") {
    return { allowed: limit, current: 0, limit: limit ? 1 : 0 };
  }
  if (limit === -1) {
    return { allowed: true, current: 0, limit: -1 };
  }
  let current = 0;
  if (limitType === "maxBots") {
    const bots = await getUserTradingBots(userId);
    current = bots.length;
  } else if (limitType === "maxAccounts") {
    const accounts = await getUserTradingAccounts(userId);
    current = accounts.length;
  }
  return { allowed: current < limit, current, limit };
}
async function getAdminStats() {
  const db = await getDb();
  if (!db) return null;
  const [userCount] = await db.select({ count: sql`count(*)` }).from(users);
  const [botCount] = await db.select({ count: sql`count(*)` }).from(tradingBots);
  const [tradeCount] = await db.select({ count: sql`count(*)` }).from(trades);
  const [backtestCount] = await db.select({ count: sql`count(*)` }).from(backtests);
  const tierCounts = await db.select({
    tier: users.subscriptionTier,
    count: sql`count(*)`
  }).from(users).groupBy(users.subscriptionTier);
  return {
    totalUsers: userCount?.count || 0,
    totalBots: botCount?.count || 0,
    totalTrades: tradeCount?.count || 0,
    totalBacktests: backtestCount?.count || 0,
    usersByTier: tierCounts
  };
}
async function getUserLlmSettings(userId) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(userLlmSettings).where(eq(userLlmSettings.userId, userId)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function createUserLlmSettings(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(userLlmSettings).values(data);
  return result[0].insertId;
}
async function updateUserLlmSettings(userId, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(userLlmSettings).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq(userLlmSettings.userId, userId));
}
async function upsertUserLlmSettings(userId, data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const existing = await getUserLlmSettings(userId);
  if (existing) {
    await updateUserLlmSettings(userId, data);
  } else {
    await createUserLlmSettings({ userId, ...data });
  }
}
async function updateLlmUsage(userId, tokensUsed) {
  const db = await getDb();
  if (!db) return;
  const existing = await getUserLlmSettings(userId);
  if (existing) {
    await db.update(userLlmSettings).set({
      totalTokensUsed: (existing.totalTokensUsed || 0) + tokensUsed,
      lastUsedAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq(userLlmSettings.userId, userId));
  }
}
async function deleteUserLlmSettings(userId) {
  const db = await getDb();
  if (!db) return;
  await db.delete(userLlmSettings).where(eq(userLlmSettings.userId, userId));
}
async function logLlmUsage(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(llmUsageLogs).values(data);
  return result[0].insertId;
}
async function getUserLlmUsageLogs(userId, options) {
  const db = await getDb();
  if (!db) return [];
  let query = db.select().from(llmUsageLogs).where(eq(llmUsageLogs.userId, userId)).orderBy(desc(llmUsageLogs.createdAt));
  if (options?.limit) {
    query = query.limit(options.limit);
  }
  if (options?.offset) {
    query = query.offset(options.offset);
  }
  return query;
}
async function getUserUsageStats(userId, startDate, endDate) {
  const db = await getDb();
  if (!db) {
    return {
      totalTokens: 0,
      totalCostCents: 0,
      callCount: 0,
      avgResponseTimeMs: 0,
      successRate: 100,
      fallbackRate: 0,
      byProvider: {},
      byDay: []
    };
  }
  const conditions = [eq(llmUsageLogs.userId, userId)];
  if (startDate) {
    conditions.push(gte(llmUsageLogs.createdAt, startDate));
  }
  if (endDate) {
    conditions.push(lte(llmUsageLogs.createdAt, endDate));
  }
  const logs = await db.select().from(llmUsageLogs).where(and(...conditions)).orderBy(desc(llmUsageLogs.createdAt));
  let totalTokens = 0;
  let totalCostCents = 0;
  let totalResponseTime = 0;
  let successCount = 0;
  let fallbackCount = 0;
  const byProvider = {};
  const byDayMap = {};
  for (const log of logs) {
    totalTokens += log.totalTokens;
    totalCostCents += log.costCents;
    totalResponseTime += log.responseTimeMs || 0;
    if (log.success) successCount++;
    if (log.wasFallback) fallbackCount++;
    if (!byProvider[log.provider]) {
      byProvider[log.provider] = { tokens: 0, costCents: 0, calls: 0 };
    }
    byProvider[log.provider].tokens += log.totalTokens;
    byProvider[log.provider].costCents += log.costCents;
    byProvider[log.provider].calls++;
    const dateKey = log.createdAt.toISOString().split("T")[0];
    if (!byDayMap[dateKey]) {
      byDayMap[dateKey] = { tokens: 0, costCents: 0, calls: 0 };
    }
    byDayMap[dateKey].tokens += log.totalTokens;
    byDayMap[dateKey].costCents += log.costCents;
    byDayMap[dateKey].calls++;
  }
  const callCount = logs.length;
  return {
    totalTokens,
    totalCostCents,
    callCount,
    avgResponseTimeMs: callCount > 0 ? Math.round(totalResponseTime / callCount) : 0,
    successRate: callCount > 0 ? Math.round(successCount / callCount * 100) : 100,
    fallbackRate: callCount > 0 ? Math.round(fallbackCount / callCount * 100) : 0,
    byProvider,
    byDay: Object.entries(byDayMap).map(([date2, stats]) => ({ date: date2, ...stats })).sort((a, b) => a.date.localeCompare(b.date))
  };
}
async function getRecentUsageSummary(userId, days = 30) {
  const startDate = /* @__PURE__ */ new Date();
  startDate.setDate(startDate.getDate() - days);
  const stats = await getUserUsageStats(userId, startDate);
  let topProvider = null;
  let maxCalls = 0;
  for (const [provider, data] of Object.entries(stats.byProvider)) {
    if (data.calls > maxCalls) {
      maxCalls = data.calls;
      topProvider = provider;
    }
  }
  return {
    totalCostCents: stats.totalCostCents,
    totalTokens: stats.totalTokens,
    callCount: stats.callCount,
    topProvider,
    dailyAvgCostCents: days > 0 ? Math.round(stats.totalCostCents / days) : 0
  };
}
async function getUserFallbackSettings(userId) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(userFallbackSettings).where(eq(userFallbackSettings.userId, userId)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function createUserFallbackSettings(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(userFallbackSettings).values(data);
  return result[0].insertId;
}
async function updateUserFallbackSettings(userId, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(userFallbackSettings).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq(userFallbackSettings.userId, userId));
}
async function upsertUserFallbackSettings(userId, data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const existing = await getUserFallbackSettings(userId);
  if (existing) {
    await updateUserFallbackSettings(userId, data);
  } else {
    const defaultPriority = ["openai", "claude", "deepseek", "gemini"];
    await createUserFallbackSettings({
      userId,
      fallbackPriority: data.fallbackPriority || defaultPriority,
      ...data
    });
  }
}
async function getAdminLlmUsageStats() {
  const db = await getDb();
  if (!db) {
    return {
      totalCostCents: 0,
      totalTokens: 0,
      totalCalls: 0,
      byProvider: {},
      topUsers: []
    };
  }
  const logs = await db.select().from(llmUsageLogs);
  let totalCostCents = 0;
  let totalTokens = 0;
  const byProvider = {};
  const byUser = {};
  for (const log of logs) {
    totalCostCents += log.costCents;
    totalTokens += log.totalTokens;
    if (!byProvider[log.provider]) {
      byProvider[log.provider] = { tokens: 0, costCents: 0, calls: 0 };
    }
    byProvider[log.provider].tokens += log.totalTokens;
    byProvider[log.provider].costCents += log.costCents;
    byProvider[log.provider].calls++;
    if (!byUser[log.userId]) {
      byUser[log.userId] = { costCents: 0, calls: 0 };
    }
    byUser[log.userId].costCents += log.costCents;
    byUser[log.userId].calls++;
  }
  const topUsers = Object.entries(byUser).map(([userId, stats]) => ({ userId: parseInt(userId), ...stats })).sort((a, b) => b.costCents - a.costCents).slice(0, 10);
  return {
    totalCostCents,
    totalTokens,
    totalCalls: logs.length,
    byProvider,
    topUsers
  };
}
async function createPriceTracking(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(priceTracking).values(data);
  return result[0].insertId;
}
async function getPriceTrackingByAnalysis(analysisId) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(priceTracking).where(eq(priceTracking.analysisId, analysisId)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function updatePriceTracking(id, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(priceTracking).set({ ...data, lastUpdatedAt: /* @__PURE__ */ new Date() }).where(eq(priceTracking.id, id));
}
async function getPendingPriceTrackings() {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(priceTracking).where(sql`price_30_day IS NULL`).orderBy(asc(priceTracking.createdAt));
}
async function createPredictionAccuracy(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(predictionAccuracy).values(data);
  return result[0].insertId;
}
async function getUserPredictionAccuracy(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(predictionAccuracy).where(eq(predictionAccuracy.userId, userId)).orderBy(desc(predictionAccuracy.updatedAt));
}
async function getAgentAccuracyStats(userId) {
  const db = await getDb();
  if (!db) return { overall: { correct: 0, total: 0, accuracy: 0 }, byAgent: {}, byTimeframe: {} };
  const records = await db.select().from(predictionAccuracy).where(eq(predictionAccuracy.userId, userId));
  let totalCorrect = 0;
  let totalCount = 0;
  const byAgent = {};
  const byTimeframe = {};
  for (const record of records) {
    totalCount += record.totalPredictions;
    totalCorrect += record.correctPredictions;
    const agentKey = record.agentType || "consensus";
    if (!byAgent[agentKey]) {
      byAgent[agentKey] = { correct: 0, total: 0 };
    }
    byAgent[agentKey].total += record.totalPredictions;
    byAgent[agentKey].correct += record.correctPredictions;
    const tfKey = record.timeframe;
    if (!byTimeframe[tfKey]) {
      byTimeframe[tfKey] = { correct: 0, total: 0 };
    }
    byTimeframe[tfKey].total += record.totalPredictions;
    byTimeframe[tfKey].correct += record.correctPredictions;
  }
  const calcAccuracy = (c, t2) => t2 > 0 ? Math.round(c / t2 * 100) : 0;
  return {
    overall: { correct: totalCorrect, total: totalCount, accuracy: calcAccuracy(totalCorrect, totalCount) },
    byAgent: Object.fromEntries(
      Object.entries(byAgent).map(([k, v]) => [k, { ...v, accuracy: calcAccuracy(v.correct, v.total) }])
    ),
    byTimeframe: Object.fromEntries(
      Object.entries(byTimeframe).map(([k, v]) => [k, { ...v, accuracy: calcAccuracy(v.correct, v.total) }])
    )
  };
}
async function createSavedComparison(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(savedComparisons).values(data);
  return result[0].insertId;
}
async function getUserSavedComparisons(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(savedComparisons).where(eq(savedComparisons.userId, userId)).orderBy(desc(savedComparisons.updatedAt));
}
async function getSavedComparisonById(id, userId) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(savedComparisons).where(and(eq(savedComparisons.id, id), eq(savedComparisons.userId, userId))).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function updateSavedComparison(id, userId, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(savedComparisons).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(and(eq(savedComparisons.id, id), eq(savedComparisons.userId, userId)));
}
async function deleteSavedComparison(id, userId) {
  const db = await getDb();
  if (!db) return;
  await db.delete(savedComparisons).where(and(eq(savedComparisons.id, id), eq(savedComparisons.userId, userId)));
}
async function createWatchlistAlert(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(watchlistAlerts).values(data);
  return result[0].insertId;
}
async function getUserWatchlistAlerts(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(watchlistAlerts).where(eq(watchlistAlerts.userId, userId)).orderBy(desc(watchlistAlerts.createdAt));
}
async function getActiveWatchlistAlerts() {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(watchlistAlerts).where(eq(watchlistAlerts.isActive, true)).orderBy(asc(watchlistAlerts.createdAt));
}
async function updateWatchlistAlert(id, userId, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(watchlistAlerts).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(and(eq(watchlistAlerts.id, id), eq(watchlistAlerts.userId, userId)));
}
async function deleteWatchlistAlert(id, userId) {
  const db = await getDb();
  if (!db) return;
  await db.delete(watchlistAlerts).where(and(eq(watchlistAlerts.id, id), eq(watchlistAlerts.userId, userId)));
}
async function createAlertHistory(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(alertHistory).values(data);
  return result[0].insertId;
}
async function getUserAlertHistory(userId, limit = 50) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(alertHistory).where(eq(alertHistory.userId, userId)).orderBy(desc(alertHistory.createdAt)).limit(limit);
}
async function createUserNotification(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(userNotifications).values(data);
  return result[0].insertId;
}
async function getUserNotifications(userId, unreadOnly = false) {
  const db = await getDb();
  if (!db) return [];
  const conditions = unreadOnly ? and(eq(userNotifications.userId, userId), eq(userNotifications.isRead, false)) : eq(userNotifications.userId, userId);
  return db.select().from(userNotifications).where(conditions).orderBy(desc(userNotifications.createdAt)).limit(100);
}
async function markNotificationRead(id, userId) {
  const db = await getDb();
  if (!db) return;
  await db.update(userNotifications).set({ isRead: true, readAt: /* @__PURE__ */ new Date() }).where(and(eq(userNotifications.id, id), eq(userNotifications.userId, userId)));
}
async function markAllNotificationsRead(userId) {
  const db = await getDb();
  if (!db) return;
  await db.update(userNotifications).set({ isRead: true, readAt: /* @__PURE__ */ new Date() }).where(and(eq(userNotifications.userId, userId), eq(userNotifications.isRead, false)));
}
async function deleteNotification(id, userId) {
  const db = await getDb();
  if (!db) return;
  await db.delete(userNotifications).where(and(eq(userNotifications.id, id), eq(userNotifications.userId, userId)));
}
async function getUnreadNotificationCount(userId) {
  const db = await getDb();
  if (!db) return 0;
  const [result] = await db.select({ count: sql`count(*)` }).from(userNotifications).where(and(eq(userNotifications.userId, userId), eq(userNotifications.isRead, false)));
  return result?.count || 0;
}
async function createRealtimeSubscription(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(realtimeSubscriptions).values(data);
  return result[0].insertId;
}
async function getUserRealtimeSubscriptions(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(realtimeSubscriptions).where(and(eq(realtimeSubscriptions.userId, userId), eq(realtimeSubscriptions.isActive, true)));
}
async function deleteRealtimeSubscription(id, userId) {
  const db = await getDb();
  if (!db) return;
  await db.delete(realtimeSubscriptions).where(and(eq(realtimeSubscriptions.id, id), eq(realtimeSubscriptions.userId, userId)));
}
async function createBotSchedule(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(botSchedules).values(data);
  return result[0].insertId;
}
async function getBotSchedules(botId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(botSchedules).where(eq(botSchedules.botId, botId)).orderBy(desc(botSchedules.createdAt));
}
async function getActiveBotSchedules() {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(botSchedules).where(eq(botSchedules.isActive, true));
}
async function updateBotSchedule(id, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(botSchedules).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq(botSchedules.id, id));
}
async function deleteBotSchedule(id) {
  const db = await getDb();
  if (!db) return;
  await db.delete(botSchedules).where(eq(botSchedules.id, id));
}
async function createBotRiskRule(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(botRiskRules).values(data);
  return result[0].insertId;
}
async function getBotRiskRules(botId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(botRiskRules).where(eq(botRiskRules.botId, botId)).orderBy(desc(botRiskRules.createdAt));
}
async function updateBotRiskRule(id, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(botRiskRules).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq(botRiskRules.id, id));
}
async function deleteBotRiskRule(id) {
  const db = await getDb();
  if (!db) return;
  await db.delete(botRiskRules).where(eq(botRiskRules.id, id));
}
async function createBotExecutionLog(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(botExecutionLogs).values(data);
  return result[0].insertId;
}
async function getBotExecutionLogs(botId, userId, limit = 100) {
  const db = await getDb();
  if (!db) return [];
  if (botId) {
    return db.select().from(botExecutionLogs).where(eq(botExecutionLogs.botId, botId)).orderBy(desc(botExecutionLogs.startedAt)).limit(limit);
  }
  const userBots = await db.select({ id: tradingBots.id }).from(tradingBots).where(eq(tradingBots.userId, userId));
  if (userBots.length === 0) return [];
  const botIds = userBots.map((b) => b.id);
  return db.select().from(botExecutionLogs).where(inArray(botExecutionLogs.botId, botIds)).orderBy(desc(botExecutionLogs.startedAt)).limit(limit);
}
async function updateBotExecutionLog(id, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(botExecutionLogs).set(data).where(eq(botExecutionLogs.id, id));
}
async function createBotBenchmark(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(botBenchmarks).values(data);
  return result[0].insertId;
}
async function getBotBenchmarks(botId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(botBenchmarks).where(eq(botBenchmarks.botId, botId)).orderBy(desc(botBenchmarks.periodEnd));
}
async function getLatestBotBenchmark(botId) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(botBenchmarks).where(eq(botBenchmarks.botId, botId)).orderBy(desc(botBenchmarks.periodEnd)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function createUserProfile(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(userProfiles).values(data);
  return result[0].insertId;
}
async function getUserProfile(userId) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(userProfiles).where(eq(userProfiles.userId, userId)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function getPublicUserProfile(userId) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(userProfiles).where(and(eq(userProfiles.userId, userId), eq(userProfiles.isPublic, true))).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function updateUserProfile(userId, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(userProfiles).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq(userProfiles.userId, userId));
}
async function upsertUserProfile(userId, data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const existing = await getUserProfile(userId);
  if (existing) {
    await updateUserProfile(userId, data);
  } else {
    await createUserProfile({ userId, ...data });
  }
}
async function getTopTraders(limit = 20) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(userProfiles).where(eq(userProfiles.isPublic, true)).orderBy(desc(userProfiles.totalReturn)).limit(limit);
}
async function createUserFollow(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(userFollows).values(data);
  return result[0].insertId;
}
async function getUserFollowers(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(userFollows).where(eq(userFollows.followingId, userId)).orderBy(desc(userFollows.createdAt));
}
async function getUserFollowing(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(userFollows).where(eq(userFollows.followerId, userId)).orderBy(desc(userFollows.createdAt));
}
async function isFollowing(followerId, followingId) {
  const db = await getDb();
  if (!db) return false;
  const result = await db.select().from(userFollows).where(and(eq(userFollows.followerId, followerId), eq(userFollows.followingId, followingId))).limit(1);
  return result.length > 0;
}
async function unfollowUser(followerId, followingId) {
  const db = await getDb();
  if (!db) return;
  await db.delete(userFollows).where(and(eq(userFollows.followerId, followerId), eq(userFollows.followingId, followingId)));
}
async function createDiscussionThread(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(discussionThreads).values(data);
  return result[0].insertId;
}
async function getDiscussionThreads(options) {
  const db = await getDb();
  if (!db) return [];
  const conditions = [];
  if (options.threadType) conditions.push(eq(discussionThreads.threadType, options.threadType));
  if (options.symbol) conditions.push(eq(discussionThreads.symbol, options.symbol));
  if (options.relatedEntityId) conditions.push(eq(discussionThreads.relatedEntityId, options.relatedEntityId));
  let query = db.select().from(discussionThreads);
  if (conditions.length > 0) {
    query = query.where(and(...conditions));
  }
  return query.orderBy(desc(discussionThreads.isPinned), desc(discussionThreads.updatedAt)).limit(options.limit || 50).offset(options.offset || 0);
}
async function getDiscussionThreadById(id) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(discussionThreads).where(eq(discussionThreads.id, id)).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function updateDiscussionThread(id, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(discussionThreads).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq(discussionThreads.id, id));
}
async function incrementThreadViews(id) {
  const db = await getDb();
  if (!db) return;
  await db.update(discussionThreads).set({ viewCount: sql`view_count + 1` }).where(eq(discussionThreads.id, id));
}
async function createDiscussionComment(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(discussionComments).values(data);
  await db.update(discussionThreads).set({
    commentCount: sql`comment_count + 1`,
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq(discussionThreads.id, data.threadId));
  return result[0].insertId;
}
async function getThreadComments(threadId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(discussionComments).where(eq(discussionComments.threadId, threadId)).orderBy(asc(discussionComments.createdAt));
}
async function updateDiscussionComment(id, userId, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(discussionComments).set({ ...data, isEdited: true, updatedAt: /* @__PURE__ */ new Date() }).where(and(eq(discussionComments.id, id), eq(discussionComments.userId, userId)));
}
async function deleteDiscussionComment(id, userId) {
  const db = await getDb();
  if (!db) return;
  const comment = await db.select().from(discussionComments).where(and(eq(discussionComments.id, id), eq(discussionComments.userId, userId))).limit(1);
  if (comment.length > 0) {
    await db.delete(discussionComments).where(eq(discussionComments.id, id));
    await db.update(discussionThreads).set({ commentCount: sql`comment_count - 1` }).where(eq(discussionThreads.id, comment[0].threadId));
  }
}
async function createStrategyRating(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(strategyRatings).values(data);
  return result[0].insertId;
}
async function getStrategyRatings(listingId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(strategyRatings).where(eq(strategyRatings.listingId, listingId)).orderBy(desc(strategyRatings.createdAt));
}
async function getUserStrategyRating(listingId, userId) {
  const db = await getDb();
  if (!db) return void 0;
  const result = await db.select().from(strategyRatings).where(and(eq(strategyRatings.listingId, listingId), eq(strategyRatings.userId, userId))).limit(1);
  return result.length > 0 ? result[0] : void 0;
}
async function updateStrategyRating(id, userId, data) {
  const db = await getDb();
  if (!db) return;
  await db.update(strategyRatings).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(and(eq(strategyRatings.id, id), eq(strategyRatings.userId, userId)));
}
async function createActivityFeedItem(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(activityFeed).values(data);
  return result[0].insertId;
}
async function getUserActivityFeed(userId, limit = 50) {
  const db = await getDb();
  if (!db) return [];
  const following = await getUserFollowing(userId);
  const followingIds = following.map((f) => f.followingId);
  if (followingIds.length === 0) {
    return db.select().from(activityFeed).where(eq(activityFeed.userId, userId)).orderBy(desc(activityFeed.createdAt)).limit(limit);
  }
  return db.select().from(activityFeed).where(or(
    eq(activityFeed.userId, userId),
    inArray(activityFeed.userId, followingIds)
  )).orderBy(desc(activityFeed.createdAt)).limit(limit);
}
async function getPublicActivityFeed(limit = 50) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(activityFeed).where(eq(activityFeed.isPublic, true)).orderBy(desc(activityFeed.createdAt)).limit(limit);
}
async function createUserBadge(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(userBadges).values(data);
  return result[0].insertId;
}
async function getUserBadges(userId) {
  const db = await getDb();
  if (!db) return [];
  return db.select().from(userBadges).where(eq(userBadges.userId, userId)).orderBy(desc(userBadges.earnedAt));
}
async function hasBadge(userId, badgeId) {
  const db = await getDb();
  if (!db) return false;
  const result = await db.select().from(userBadges).where(and(eq(userBadges.userId, userId), eq(userBadges.badgeId, badgeId))).limit(1);
  return result.length > 0;
}
async function getBadgeDefinition(badgeId) {
  return badgeDefinitions[badgeId];
}
async function getAllBadgeDefinitions() {
  return badgeDefinitions;
}
async function getEmailConfig() {
  const db = await getDb();
  if (!db) return void 0;
  const results = await db.select().from(emailConfig).limit(1);
  return results[0];
}
async function createEmailConfig(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(emailConfig).values(data);
  return Number(result[0].insertId);
}
async function updateEmailConfig(id, data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  await db.update(emailConfig).set(data).where(eq(emailConfig.id, id));
}
async function upsertEmailConfig(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const existing = await getEmailConfig();
  if (existing) {
    await updateEmailConfig(existing.id, data);
    return existing.id;
  } else {
    return await createEmailConfig(data);
  }
}
async function incrementEmailsSentToday() {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const config = await getEmailConfig();
  if (!config) return;
  const now = /* @__PURE__ */ new Date();
  const lastReset = config.lastResetAt ? new Date(config.lastResetAt) : null;
  const isNewDay = !lastReset || lastReset.toDateString() !== now.toDateString();
  if (isNewDay) {
    await updateEmailConfig(config.id, {
      emailsSentToday: 1,
      lastResetAt: now
    });
  } else {
    await db.update(emailConfig).set({ emailsSentToday: (config.emailsSentToday || 0) + 1 }).where(eq(emailConfig.id, config.id));
  }
}
async function canSendEmail() {
  const config = await getEmailConfig();
  if (!config) {
    return { allowed: false, reason: "Email not configured" };
  }
  if (!config.isEnabled) {
    return { allowed: false, reason: "Email sending is disabled" };
  }
  if (!config.sendgridApiKey) {
    return { allowed: false, reason: "SendGrid API key not configured" };
  }
  const dailyLimit = config.dailyLimit || 1e3;
  const sentToday = config.emailsSentToday || 0;
  const now = /* @__PURE__ */ new Date();
  const lastReset = config.lastResetAt ? new Date(config.lastResetAt) : null;
  const isNewDay = !lastReset || lastReset.toDateString() !== now.toDateString();
  if (isNewDay) {
    return { allowed: true };
  }
  if (sentToday >= dailyLimit) {
    return { allowed: false, reason: `Daily email limit (${dailyLimit}) reached` };
  }
  return { allowed: true };
}
async function createEmailVerification(data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const result = await db.insert(emailVerifications).values(data);
  return Number(result[0].insertId);
}
async function getEmailVerificationByToken(token) {
  const db = await getDb();
  if (!db) return void 0;
  const results = await db.select().from(emailVerifications).where(eq(emailVerifications.token, token));
  return results[0];
}
async function getEmailVerificationByUserId(userId) {
  const db = await getDb();
  if (!db) return void 0;
  const results = await db.select().from(emailVerifications).where(eq(emailVerifications.userId, userId)).orderBy(desc(emailVerifications.createdAt)).limit(1);
  return results[0];
}
async function markEmailVerified(token) {
  const db = await getDb();
  if (!db) return false;
  const verification = await getEmailVerificationByToken(token);
  if (!verification) return false;
  if (new Date(verification.expiresAt) < /* @__PURE__ */ new Date()) {
    return false;
  }
  await db.update(emailVerifications).set({
    isVerified: true,
    verifiedAt: /* @__PURE__ */ new Date()
  }).where(eq(emailVerifications.token, token));
  return true;
}
async function incrementResendCount(userId) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const verification = await getEmailVerificationByUserId(userId);
  if (!verification) return;
  await db.update(emailVerifications).set({
    resendCount: (verification.resendCount || 0) + 1,
    lastResendAt: /* @__PURE__ */ new Date()
  }).where(eq(emailVerifications.id, verification.id));
}
async function deleteExpiredVerifications() {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  await db.delete(emailVerifications).where(
    and(
      eq(emailVerifications.isVerified, false),
      lt(emailVerifications.expiresAt, /* @__PURE__ */ new Date())
    )
  );
}
async function isUserEmailVerified(userId) {
  const verification = await getEmailVerificationByUserId(userId);
  return verification?.isVerified === true;
}
async function getUserRLModels(userId, limit = 20) {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select().from(rlAgentModels).where(eq(rlAgentModels.userId, userId)).orderBy(desc(rlAgentModels.createdAt)).limit(limit);
  return results;
}
async function getRLModelById(modelId, userId) {
  const db = await getDb();
  if (!db) return void 0;
  const [result] = await db.select().from(rlAgentModels).where(and(
    eq(rlAgentModels.id, modelId),
    eq(rlAgentModels.userId, userId)
  ));
  return result;
}
async function updateRLModel(modelId, data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  await db.update(rlAgentModels).set(data).where(eq(rlAgentModels.id, modelId));
}
async function saveStrategyComparison(data) {
  const db = await getDb();
  if (!db) return null;
  const [result] = await db.insert(strategyComparisons).values({
    userId: data.userId,
    name: data.name,
    symbol: data.symbol,
    startDate: data.startDate,
    endDate: data.endDate,
    initialCapital: data.initialCapital.toString(),
    strategies: data.strategies,
    results: data.results,
    winner: data.winner,
    status: "completed",
    completedAt: /* @__PURE__ */ new Date()
  });
  return { id: Number(result.insertId) };
}
async function getUserStrategyComparisons(userId, limit = 20) {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select().from(strategyComparisons).where(eq(strategyComparisons.userId, userId)).orderBy(desc(strategyComparisons.createdAt)).limit(limit);
  return results;
}
async function getStrategyComparisonById(comparisonId, userId) {
  const db = await getDb();
  if (!db) return void 0;
  const [result] = await db.select().from(strategyComparisons).where(and(
    eq(strategyComparisons.id, comparisonId),
    eq(strategyComparisons.userId, userId)
  ));
  return result;
}
var _db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    init_env();
    init_schema();
    _db = null;
  }
});

// server/_core/websocket.ts
import { Server } from "socket.io";
import jwt from "jsonwebtoken";
function initializeWebSocket(httpServer) {
  io = new Server(httpServer, {
    cors: {
      origin: "*",
      methods: ["GET", "POST"]
    },
    path: "/socket.io",
    transports: ["websocket", "polling"]
  });
  io.use(async (socket, next) => {
    try {
      const token = socket.handshake.auth.token || socket.handshake.query.token;
      if (!token) {
        socket.data.userId = null;
        socket.data.authenticated = false;
        return next();
      }
      const decoded = jwt.verify(token, ENV.cookieSecret);
      socket.data.userId = decoded.userId;
      socket.data.authenticated = true;
      next();
    } catch (err) {
      socket.data.userId = null;
      socket.data.authenticated = false;
      next();
    }
  });
  io.on("connection", (socket) => {
    console.log(`[WebSocket] Client connected: ${socket.id}, authenticated: ${socket.data.authenticated}`);
    if (socket.data.authenticated && socket.data.userId) {
      const userId = socket.data.userId;
      if (!connectedUsers.has(userId)) {
        connectedUsers.set(userId, /* @__PURE__ */ new Set());
      }
      connectedUsers.get(userId).add(socket.id);
    }
    socket.on("subscribe:prices", (symbols) => {
      symbols.forEach((symbol) => {
        const upperSymbol = symbol.toUpperCase();
        if (!priceSubscriptions.has(upperSymbol)) {
          priceSubscriptions.set(upperSymbol, /* @__PURE__ */ new Set());
        }
        priceSubscriptions.get(upperSymbol).add(socket.id);
        socket.join(`price:${upperSymbol}`);
      });
      console.log(`[WebSocket] ${socket.id} subscribed to prices: ${symbols.join(", ")}`);
    });
    socket.on("unsubscribe:prices", (symbols) => {
      symbols.forEach((symbol) => {
        const upperSymbol = symbol.toUpperCase();
        priceSubscriptions.get(upperSymbol)?.delete(socket.id);
        socket.leave(`price:${upperSymbol}`);
      });
    });
    socket.on("subscribe:bot", (botId) => {
      if (!socket.data.authenticated) {
        socket.emit("error", { message: "Authentication required for bot subscriptions" });
        return;
      }
      if (!botSubscriptions.has(botId)) {
        botSubscriptions.set(botId, /* @__PURE__ */ new Set());
      }
      botSubscriptions.get(botId).add(socket.id);
      socket.join(`bot:${botId}`);
      console.log(`[WebSocket] ${socket.id} subscribed to bot: ${botId}`);
    });
    socket.on("unsubscribe:bot", (botId) => {
      botSubscriptions.get(botId)?.delete(socket.id);
      socket.leave(`bot:${botId}`);
    });
    socket.on("subscribe:portfolio", () => {
      if (!socket.data.authenticated) {
        socket.emit("error", { message: "Authentication required for portfolio updates" });
        return;
      }
      socket.join(`portfolio:${socket.data.userId}`);
      console.log(`[WebSocket] ${socket.id} subscribed to portfolio updates`);
    });
    socket.on("subscribe:notifications", () => {
      if (!socket.data.authenticated) {
        socket.emit("error", { message: "Authentication required for notifications" });
        return;
      }
      socket.join(`notifications:${socket.data.userId}`);
      console.log(`[WebSocket] ${socket.id} subscribed to notifications`);
    });
    socket.on("disconnect", () => {
      console.log(`[WebSocket] Client disconnected: ${socket.id}`);
      if (socket.data.userId) {
        const userSockets = connectedUsers.get(socket.data.userId);
        if (userSockets) {
          userSockets.delete(socket.id);
          if (userSockets.size === 0) {
            connectedUsers.delete(socket.data.userId);
          }
        }
      }
      priceSubscriptions.forEach((sockets, symbol) => {
        sockets.delete(socket.id);
        if (sockets.size === 0) {
          priceSubscriptions.delete(symbol);
        }
      });
      botSubscriptions.forEach((sockets, botId) => {
        sockets.delete(socket.id);
        if (sockets.size === 0) {
          botSubscriptions.delete(botId);
        }
      });
    });
    socket.on("ping", () => {
      socket.emit("pong", { timestamp: Date.now() });
    });
  });
  console.log("[WebSocket] Socket.IO server initialized");
  return io;
}
function broadcastPriceUpdate(update) {
  if (!io) return;
  io.to(`price:${update.symbol.toUpperCase()}`).emit("price:update", update);
}
function broadcastPriceUpdates(updates) {
  if (!io) return;
  updates.forEach((update) => {
    io.to(`price:${update.symbol.toUpperCase()}`).emit("price:update", update);
  });
}
function getActiveSymbolSubscriptions() {
  return Array.from(priceSubscriptions.keys());
}
var io, connectedUsers, priceSubscriptions, botSubscriptions;
var init_websocket = __esm({
  "server/_core/websocket.ts"() {
    "use strict";
    init_env();
    io = null;
    connectedUsers = /* @__PURE__ */ new Map();
    priceSubscriptions = /* @__PURE__ */ new Map();
    botSubscriptions = /* @__PURE__ */ new Map();
  }
});

// server/_core/llm.ts
async function invokeLLM(params) {
  assertApiKey();
  const {
    messages,
    tools,
    toolChoice,
    tool_choice,
    outputSchema,
    output_schema,
    responseFormat,
    response_format
  } = params;
  const payload = {
    model: "gemini-2.5-flash",
    messages: messages.map(normalizeMessage)
  };
  if (tools && tools.length > 0) {
    payload.tools = tools;
  }
  const normalizedToolChoice = normalizeToolChoice(
    toolChoice || tool_choice,
    tools
  );
  if (normalizedToolChoice) {
    payload.tool_choice = normalizedToolChoice;
  }
  payload.max_tokens = 32768;
  payload.thinking = {
    "budget_tokens": 128
  };
  const normalizedResponseFormat = normalizeResponseFormat({
    responseFormat,
    response_format,
    outputSchema,
    output_schema
  });
  if (normalizedResponseFormat) {
    payload.response_format = normalizedResponseFormat;
  }
  const response = await fetch(resolveApiUrl(), {
    method: "POST",
    headers: {
      "content-type": "application/json",
      authorization: `Bearer ${ENV.forgeApiKey}`
    },
    body: JSON.stringify(payload)
  });
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(
      `LLM invoke failed: ${response.status} ${response.statusText} \u2013 ${errorText}`
    );
  }
  return await response.json();
}
var ensureArray, normalizeContentPart, normalizeMessage, normalizeToolChoice, resolveApiUrl, assertApiKey, normalizeResponseFormat;
var init_llm = __esm({
  "server/_core/llm.ts"() {
    "use strict";
    init_env();
    ensureArray = (value) => Array.isArray(value) ? value : [value];
    normalizeContentPart = (part) => {
      if (typeof part === "string") {
        return { type: "text", text: part };
      }
      if (part.type === "text") {
        return part;
      }
      if (part.type === "image_url") {
        return part;
      }
      if (part.type === "file_url") {
        return part;
      }
      throw new Error("Unsupported message content part");
    };
    normalizeMessage = (message) => {
      const { role, name, tool_call_id } = message;
      if (role === "tool" || role === "function") {
        const content = ensureArray(message.content).map((part) => typeof part === "string" ? part : JSON.stringify(part)).join("\n");
        return {
          role,
          name,
          tool_call_id,
          content
        };
      }
      const contentParts = ensureArray(message.content).map(normalizeContentPart);
      if (contentParts.length === 1 && contentParts[0].type === "text") {
        return {
          role,
          name,
          content: contentParts[0].text
        };
      }
      return {
        role,
        name,
        content: contentParts
      };
    };
    normalizeToolChoice = (toolChoice, tools) => {
      if (!toolChoice) return void 0;
      if (toolChoice === "none" || toolChoice === "auto") {
        return toolChoice;
      }
      if (toolChoice === "required") {
        if (!tools || tools.length === 0) {
          throw new Error(
            "tool_choice 'required' was provided but no tools were configured"
          );
        }
        if (tools.length > 1) {
          throw new Error(
            "tool_choice 'required' needs a single tool or specify the tool name explicitly"
          );
        }
        return {
          type: "function",
          function: { name: tools[0].function.name }
        };
      }
      if ("name" in toolChoice) {
        return {
          type: "function",
          function: { name: toolChoice.name }
        };
      }
      return toolChoice;
    };
    resolveApiUrl = () => ENV.forgeApiUrl && ENV.forgeApiUrl.trim().length > 0 ? `${ENV.forgeApiUrl.replace(/\/$/, "")}/v1/chat/completions` : "https://forge.manus.im/v1/chat/completions";
    assertApiKey = () => {
      if (!ENV.forgeApiKey) {
        throw new Error("OPENAI_API_KEY is not configured");
      }
    };
    normalizeResponseFormat = ({
      responseFormat,
      response_format,
      outputSchema,
      output_schema
    }) => {
      const explicitFormat = responseFormat || response_format;
      if (explicitFormat) {
        if (explicitFormat.type === "json_schema" && !explicitFormat.json_schema?.schema) {
          throw new Error(
            "responseFormat json_schema requires a defined schema object"
          );
        }
        return explicitFormat;
      }
      const schema = outputSchema || output_schema;
      if (!schema) return void 0;
      if (!schema.name || !schema.schema) {
        throw new Error("outputSchema requires both name and schema");
      }
      return {
        type: "json_schema",
        json_schema: {
          name: schema.name,
          schema: schema.schema,
          ...typeof schema.strict === "boolean" ? { strict: schema.strict } : {}
        }
      };
    };
  }
});

// server/_core/dataApi.ts
async function callDataApi(apiId, options = {}) {
  if (!ENV.forgeApiUrl) {
    throw new Error("BUILT_IN_FORGE_API_URL is not configured");
  }
  if (!ENV.forgeApiKey) {
    throw new Error("BUILT_IN_FORGE_API_KEY is not configured");
  }
  const baseUrl = ENV.forgeApiUrl.endsWith("/") ? ENV.forgeApiUrl : `${ENV.forgeApiUrl}/`;
  const fullUrl = new URL("webdevtoken.v1.WebDevService/CallApi", baseUrl).toString();
  const response = await fetch(fullUrl, {
    method: "POST",
    headers: {
      accept: "application/json",
      "content-type": "application/json",
      "connect-protocol-version": "1",
      authorization: `Bearer ${ENV.forgeApiKey}`
    },
    body: JSON.stringify({
      apiId,
      query: options.query,
      body: options.body,
      path_params: options.pathParams,
      multipart_form_data: options.formData
    })
  });
  if (!response.ok) {
    const detail = await response.text().catch(() => "");
    throw new Error(
      `Data API request failed (${response.status} ${response.statusText})${detail ? `: ${detail}` : ""}`
    );
  }
  const payload = await response.json().catch(() => ({}));
  if (payload && typeof payload === "object" && "jsonData" in payload) {
    try {
      return JSON.parse(payload.jsonData ?? "{}");
    } catch {
      return payload.jsonData;
    }
  }
  return payload;
}
var init_dataApi = __esm({
  "server/_core/dataApi.ts"() {
    "use strict";
    init_env();
  }
});

// server/services/enhancedAnalysis.ts
var enhancedAnalysis_exports = {};
__export(enhancedAnalysis_exports, {
  calculateKellyPosition: () => calculateKellyPosition,
  calculateTechnicalIndicators: () => calculateTechnicalIndicators,
  detectMarketRegime: () => detectMarketRegime,
  runEnhancedAnalysis: () => runEnhancedAnalysis
});
function calculateTechnicalIndicators(prices, volumes, highs, lows) {
  const n = prices.length;
  const currentPrice = prices[n - 1];
  const rsiPeriod = 14;
  let gains = 0, losses = 0;
  for (let i = n - rsiPeriod; i < n; i++) {
    const change = prices[i] - prices[i - 1];
    if (change > 0) gains += change;
    else losses -= change;
  }
  const avgGain = gains / rsiPeriod;
  const avgLoss = losses / rsiPeriod;
  const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
  const rsi = 100 - 100 / (1 + rs);
  const ema12 = calculateEMA(prices, 12);
  const ema26 = calculateEMA(prices, 26);
  const macdLine = ema12 - ema26;
  const macdHistory = prices.slice(-35).map((_, i) => {
    const e12 = calculateEMA(prices.slice(0, n - 35 + i + 1), 12);
    const e26 = calculateEMA(prices.slice(0, n - 35 + i + 1), 26);
    return e12 - e26;
  });
  const signalLine = calculateEMA(macdHistory, 9);
  const histogram = macdLine - signalLine;
  const bbPeriod = 20;
  const bbPrices = prices.slice(-bbPeriod);
  const bbMiddle = bbPrices.reduce((a, b) => a + b, 0) / bbPeriod;
  const bbStdDev = Math.sqrt(bbPrices.reduce((sum2, p) => sum2 + Math.pow(p - bbMiddle, 2), 0) / bbPeriod);
  const bbUpper = bbMiddle + 2 * bbStdDev;
  const bbLower = bbMiddle - 2 * bbStdDev;
  const percentB = (currentPrice - bbLower) / (bbUpper - bbLower);
  const atrPeriod = 14;
  let atrSum = 0;
  for (let i = n - atrPeriod; i < n; i++) {
    const tr = Math.max(
      highs[i] - lows[i],
      Math.abs(highs[i] - prices[i - 1]),
      Math.abs(lows[i] - prices[i - 1])
    );
    atrSum += tr;
  }
  const atr = atrSum / atrPeriod;
  const adx = calculateADX(highs, lows, prices, 14);
  const stochPeriod = 14;
  const stochHighs = highs.slice(-stochPeriod);
  const stochLows = lows.slice(-stochPeriod);
  const highestHigh = Math.max(...stochHighs);
  const lowestLow = Math.min(...stochLows);
  const stochK = (currentPrice - lowestLow) / (highestHigh - lowestLow) * 100;
  const stochD = stochK;
  const ema20 = calculateEMA(prices, 20);
  const ema50 = calculateEMA(prices, 50);
  const ema200 = calculateEMA(prices, Math.min(200, n - 1));
  const vwapPrices = prices.slice(-20);
  const vwapVolumes = volumes.slice(-20);
  const vwapSum = vwapPrices.reduce((sum2, p, i) => sum2 + p * vwapVolumes[i], 0);
  const volumeSum = vwapVolumes.reduce((a, b) => a + b, 0);
  const vwap = vwapSum / volumeSum;
  let obv = 0;
  for (let i = 1; i < n; i++) {
    if (prices[i] > prices[i - 1]) obv += volumes[i];
    else if (prices[i] < prices[i - 1]) obv -= volumes[i];
  }
  const avgVolume = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;
  const volumeRatio = volumes[n - 1] / avgVolume;
  return {
    rsi,
    macd: { value: macdLine, signal: signalLine, histogram },
    bollingerBands: { upper: bbUpper, middle: bbMiddle, lower: bbLower, percentB },
    atr,
    adx,
    stochastic: { k: stochK, d: stochD },
    ema20,
    ema50,
    ema200,
    vwap,
    obv,
    volumeRatio
  };
}
function calculateEMA(prices, period) {
  const k = 2 / (period + 1);
  let ema = prices[0];
  for (let i = 1; i < prices.length; i++) {
    ema = prices[i] * k + ema * (1 - k);
  }
  return ema;
}
function calculateADX(highs, lows, closes, period) {
  const n = closes.length;
  if (n < period + 1) return 25;
  let plusDMSum = 0, minusDMSum = 0, trSum = 0;
  for (let i = n - period; i < n; i++) {
    const highDiff = highs[i] - highs[i - 1];
    const lowDiff = lows[i - 1] - lows[i];
    const plusDM = highDiff > lowDiff && highDiff > 0 ? highDiff : 0;
    const minusDM = lowDiff > highDiff && lowDiff > 0 ? lowDiff : 0;
    const tr = Math.max(
      highs[i] - lows[i],
      Math.abs(highs[i] - closes[i - 1]),
      Math.abs(lows[i] - closes[i - 1])
    );
    plusDMSum += plusDM;
    minusDMSum += minusDM;
    trSum += tr;
  }
  const plusDI = plusDMSum / trSum * 100;
  const minusDI = minusDMSum / trSum * 100;
  const dx = Math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100;
  return dx;
}
function detectMarketRegime(prices, indicators) {
  const n = prices.length;
  const currentPrice = prices[n - 1];
  const shortTrend = currentPrice > indicators.ema20 ? 1 : -1;
  const mediumTrend = currentPrice > indicators.ema50 ? 1 : -1;
  const longTrend = currentPrice > indicators.ema200 ? 1 : -1;
  const trendScore = shortTrend + mediumTrend + longTrend;
  const priceRange = Math.max(...prices.slice(-20)) - Math.min(...prices.slice(-20));
  const avgPrice = prices.slice(-20).reduce((a, b) => a + b, 0) / 20;
  const volatilityPercent = priceRange / avgPrice * 100;
  const trendStrength = indicators.adx;
  let type;
  let confidence;
  if (volatilityPercent > 15) {
    type = "high_volatility";
    confidence = Math.min(volatilityPercent / 20, 1);
  } else if (volatilityPercent < 5) {
    type = "low_volatility";
    confidence = 1 - volatilityPercent / 5;
  } else if (trendScore >= 2 && trendStrength > 25) {
    type = "bull";
    confidence = trendStrength / 50 * (trendScore / 3);
  } else if (trendScore <= -2 && trendStrength > 25) {
    type = "bear";
    confidence = trendStrength / 50 * (Math.abs(trendScore) / 3);
  } else {
    type = "sideways";
    confidence = 1 - trendStrength / 50;
  }
  return {
    type,
    confidence: Math.min(Math.max(confidence, 0.1), 0.95),
    trendStrength,
    volatilityLevel: volatilityPercent
  };
}
function calculateKellyPosition(winRate, avgWin, avgLoss, accountBalance, maxRiskPercent = 0.02) {
  const b = avgWin / avgLoss;
  const p = winRate;
  const q = 1 - winRate;
  let kellyFraction = (b * p - q) / b;
  kellyFraction = kellyFraction * 0.25;
  kellyFraction = Math.min(Math.max(kellyFraction, 0), maxRiskPercent);
  const recommendedSize = accountBalance * kellyFraction;
  const riskRewardRatio = avgWin / avgLoss;
  return {
    kellyFraction,
    recommendedSize,
    maxRisk: accountBalance * maxRiskPercent,
    riskRewardRatio
  };
}
async function runTechnicalAgent2(symbol, currentPrice, indicators, regime) {
  const signals = [];
  const factors = [];
  if (indicators.rsi < 30) {
    signals.push(1);
    factors.push("RSI oversold (<30)");
  } else if (indicators.rsi > 70) {
    signals.push(-1);
    factors.push("RSI overbought (>70)");
  } else {
    signals.push(0);
  }
  if (indicators.macd.histogram > 0 && indicators.macd.value > indicators.macd.signal) {
    signals.push(1);
    factors.push("MACD bullish crossover");
  } else if (indicators.macd.histogram < 0 && indicators.macd.value < indicators.macd.signal) {
    signals.push(-1);
    factors.push("MACD bearish crossover");
  } else {
    signals.push(0);
  }
  if (indicators.bollingerBands.percentB < 0.2) {
    signals.push(1);
    factors.push("Price near lower Bollinger Band");
  } else if (indicators.bollingerBands.percentB > 0.8) {
    signals.push(-1);
    factors.push("Price near upper Bollinger Band");
  } else {
    signals.push(0);
  }
  if (currentPrice > indicators.ema20 && indicators.ema20 > indicators.ema50) {
    signals.push(1);
    factors.push("Price above rising EMAs");
  } else if (currentPrice < indicators.ema20 && indicators.ema20 < indicators.ema50) {
    signals.push(-1);
    factors.push("Price below falling EMAs");
  } else {
    signals.push(0);
  }
  if (indicators.stochastic.k < 20) {
    signals.push(1);
    factors.push("Stochastic oversold");
  } else if (indicators.stochastic.k > 80) {
    signals.push(-1);
    factors.push("Stochastic overbought");
  } else {
    signals.push(0);
  }
  if (indicators.volumeRatio > 1.5) {
    factors.push("High volume confirmation");
  }
  const avgSignal = signals.reduce((a, b) => a + b, 0) / signals.length;
  const confidence = Math.abs(avgSignal) * 0.6 + 0.3;
  let recommendation;
  if (avgSignal > 0.5) recommendation = "strong_buy";
  else if (avgSignal > 0.2) recommendation = "buy";
  else if (avgSignal < -0.5) recommendation = "strong_sell";
  else if (avgSignal < -0.2) recommendation = "sell";
  else recommendation = "hold";
  const stopLoss = currentPrice - indicators.atr * 2;
  const takeProfit = currentPrice + indicators.atr * 3;
  return {
    agentType: "Technical Analysis",
    recommendation,
    confidence,
    reasoning: `Technical indicators suggest ${recommendation} based on ${factors.length} key signals.`,
    keyFactors: factors,
    priceTarget: takeProfit,
    stopLoss,
    takeProfit
  };
}
async function runFundamentalAgent2(symbol, stockData) {
  const prompt = `Analyze the fundamental data for ${symbol} and provide a trading recommendation.

Stock Data:
- Current Price: $${stockData.currentPrice}
- 52-Week High: $${stockData.fiftyTwoWeekHigh}
- 52-Week Low: $${stockData.fiftyTwoWeekLow}
- Market Cap: ${stockData.marketCap}
- P/E Ratio: ${stockData.peRatio || "N/A"}
- Volume: ${stockData.volume}

Provide your analysis in JSON format:
{
  "recommendation": "strong_buy" | "buy" | "hold" | "sell" | "strong_sell",
  "confidence": 0.0-1.0,
  "reasoning": "Brief explanation",
  "keyFactors": ["factor1", "factor2", "factor3"],
  "priceTarget": number
}`;
  try {
    const response = await invokeLLM({
      messages: [
        { role: "system", content: "You are a fundamental analysis expert. Analyze stocks based on valuation metrics and financial health." },
        { role: "user", content: prompt }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "fundamental_analysis",
          strict: true,
          schema: {
            type: "object",
            properties: {
              recommendation: { type: "string", enum: ["strong_buy", "buy", "hold", "sell", "strong_sell"] },
              confidence: { type: "number" },
              reasoning: { type: "string" },
              keyFactors: { type: "array", items: { type: "string" } },
              priceTarget: { type: "number" }
            },
            required: ["recommendation", "confidence", "reasoning", "keyFactors", "priceTarget"],
            additionalProperties: false
          }
        }
      }
    });
    const content = response.choices[0].message.content;
    const result = JSON.parse(typeof content === "string" ? content : "{}");
    return {
      agentType: "Fundamental Analysis",
      ...result
    };
  } catch (error) {
    return {
      agentType: "Fundamental Analysis",
      recommendation: "hold",
      confidence: 0.5,
      reasoning: "Unable to complete fundamental analysis",
      keyFactors: ["Analysis unavailable"]
    };
  }
}
async function runSentimentAgent2(symbol, newsHeadlines) {
  const prompt = `Analyze the market sentiment for ${symbol} based on recent news.

Recent Headlines:
${newsHeadlines.map((h, i) => `${i + 1}. ${h}`).join("\n")}

Provide sentiment analysis in JSON format:
{
  "recommendation": "strong_buy" | "buy" | "hold" | "sell" | "strong_sell",
  "confidence": 0.0-1.0,
  "reasoning": "Brief explanation of sentiment",
  "keyFactors": ["sentiment factor 1", "sentiment factor 2"]
}`;
  try {
    const response = await invokeLLM({
      messages: [
        { role: "system", content: "You are a market sentiment analyst. Analyze news and social sentiment to gauge market mood." },
        { role: "user", content: prompt }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "sentiment_analysis",
          strict: true,
          schema: {
            type: "object",
            properties: {
              recommendation: { type: "string", enum: ["strong_buy", "buy", "hold", "sell", "strong_sell"] },
              confidence: { type: "number" },
              reasoning: { type: "string" },
              keyFactors: { type: "array", items: { type: "string" } }
            },
            required: ["recommendation", "confidence", "reasoning", "keyFactors"],
            additionalProperties: false
          }
        }
      }
    });
    const content = response.choices[0].message.content;
    const result = JSON.parse(typeof content === "string" ? content : "{}");
    return {
      agentType: "Sentiment Analysis",
      ...result
    };
  } catch (error) {
    return {
      agentType: "Sentiment Analysis",
      recommendation: "hold",
      confidence: 0.5,
      reasoning: "Unable to complete sentiment analysis",
      keyFactors: ["Analysis unavailable"]
    };
  }
}
async function runRiskAgent2(symbol, currentPrice, indicators, regime, accountBalance) {
  const factors = [];
  let riskScore = 50;
  if (regime.volatilityLevel > 15) {
    riskScore += 20;
    factors.push("High volatility environment");
  } else if (regime.volatilityLevel < 5) {
    riskScore -= 10;
    factors.push("Low volatility - favorable conditions");
  }
  if (regime.type === "sideways") {
    riskScore += 10;
    factors.push("Sideways market - higher whipsaw risk");
  } else if (regime.trendStrength > 40) {
    riskScore -= 10;
    factors.push("Strong trend - favorable for trend-following");
  }
  if (indicators.rsi > 80 || indicators.rsi < 20) {
    riskScore += 15;
    factors.push("Extreme RSI levels - reversal risk");
  }
  if (indicators.volumeRatio < 0.5) {
    riskScore += 10;
    factors.push("Low volume - liquidity risk");
  }
  const positionSizing = calculateKellyPosition(
    0.55,
    // Assumed 55% win rate
    indicators.atr * 2,
    // Average win
    indicators.atr * 1,
    // Average loss
    accountBalance
  );
  let recommendation;
  if (riskScore < 30) recommendation = "strong_buy";
  else if (riskScore < 45) recommendation = "buy";
  else if (riskScore > 70) recommendation = "strong_sell";
  else if (riskScore > 55) recommendation = "sell";
  else recommendation = "hold";
  const confidence = 1 - Math.abs(riskScore - 50) / 100;
  return {
    agentType: "Risk Management",
    recommendation,
    confidence,
    reasoning: `Risk assessment score: ${riskScore}/100. ${riskScore > 50 ? "Elevated" : "Acceptable"} risk levels.`,
    keyFactors: factors,
    stopLoss: currentPrice - indicators.atr * 2,
    takeProfit: currentPrice + indicators.atr * 3
  };
}
async function runQuantAgent2(symbol, prices, indicators) {
  const factors = [];
  let score = 0;
  if (indicators.ema20 > indicators.ema50 && indicators.ema50 > indicators.ema200) {
    score += 2;
    factors.push("Golden alignment (EMA20 > EMA50 > EMA200)");
  } else if (indicators.ema20 < indicators.ema50 && indicators.ema50 < indicators.ema200) {
    score -= 2;
    factors.push("Death alignment (EMA20 < EMA50 < EMA200)");
  }
  const momentum5 = (prices[prices.length - 1] - prices[prices.length - 6]) / prices[prices.length - 6];
  const momentum20 = (prices[prices.length - 1] - prices[prices.length - 21]) / prices[prices.length - 21];
  if (momentum5 > 0.02 && momentum20 > 0.05) {
    score += 1;
    factors.push("Strong positive momentum");
  } else if (momentum5 < -0.02 && momentum20 < -0.05) {
    score -= 1;
    factors.push("Strong negative momentum");
  }
  const currentPrice = prices[prices.length - 1];
  if (currentPrice > indicators.vwap * 1.02) {
    score += 1;
    factors.push("Trading above VWAP");
  } else if (currentPrice < indicators.vwap * 0.98) {
    score -= 1;
    factors.push("Trading below VWAP");
  }
  if (indicators.obv > 0) {
    score += 0.5;
    factors.push("Positive OBV trend");
  } else {
    score -= 0.5;
    factors.push("Negative OBV trend");
  }
  let recommendation;
  if (score >= 3) recommendation = "strong_buy";
  else if (score >= 1.5) recommendation = "buy";
  else if (score <= -3) recommendation = "strong_sell";
  else if (score <= -1.5) recommendation = "sell";
  else recommendation = "hold";
  const confidence = Math.min(Math.abs(score) / 4, 0.9);
  return {
    agentType: "Quantitative Analysis",
    recommendation,
    confidence,
    reasoning: `Quantitative score: ${score.toFixed(2)}. Pattern analysis indicates ${recommendation}.`,
    keyFactors: factors
  };
}
function aggregateConsensus(agents) {
  const weights = {
    "Technical Analysis": 0.25,
    "Fundamental Analysis": 0.2,
    "Sentiment Analysis": 0.15,
    "Risk Management": 0.2,
    "Quantitative Analysis": 0.2
  };
  const scores = {
    "strong_buy": 2,
    "buy": 1,
    "hold": 0,
    "sell": -1,
    "strong_sell": -2
  };
  let weightedScore = 0;
  let totalWeight = 0;
  let totalConfidence = 0;
  for (const agent of agents) {
    const weight = weights[agent.agentType] || 0.2;
    const score = scores[agent.recommendation];
    weightedScore += score * weight * agent.confidence;
    totalWeight += weight;
    totalConfidence += agent.confidence * weight;
  }
  const avgScore = weightedScore / totalWeight;
  const avgConfidence = totalConfidence / totalWeight;
  let recommendation;
  if (avgScore >= 1.2) recommendation = "strong_buy";
  else if (avgScore >= 0.4) recommendation = "buy";
  else if (avgScore <= -1.2) recommendation = "strong_sell";
  else if (avgScore <= -0.4) recommendation = "sell";
  else recommendation = "hold";
  return { recommendation, confidence: avgConfidence };
}
async function runEnhancedAnalysis(symbol, accountBalance = 1e4) {
  let stockData;
  try {
    const response = await callDataApi("YahooFinance/get_stock_chart", {
      query: {
        symbol,
        region: "US",
        interval: "1d",
        range: "6mo"
      }
    });
    if (response?.chart?.result?.[0]) {
      const result = response.chart.result[0];
      stockData = {
        prices: result.indicators.quote[0].close.filter((p) => p !== null),
        volumes: result.indicators.quote[0].volume.filter((v) => v !== null),
        highs: result.indicators.quote[0].high.filter((h) => h !== null),
        lows: result.indicators.quote[0].low.filter((l) => l !== null),
        currentPrice: result.meta.regularMarketPrice,
        fiftyTwoWeekHigh: result.meta.fiftyTwoWeekHigh,
        fiftyTwoWeekLow: result.meta.fiftyTwoWeekLow,
        marketCap: result.meta.marketCap,
        volume: result.meta.regularMarketVolume
      };
    }
  } catch (error) {
    console.error("Error fetching stock data:", error);
    throw new Error(`Failed to fetch data for ${symbol}`);
  }
  if (!stockData || stockData.prices.length < 50) {
    throw new Error(`Insufficient data for ${symbol}`);
  }
  const indicators = calculateTechnicalIndicators(
    stockData.prices,
    stockData.volumes,
    stockData.highs,
    stockData.lows
  );
  const regime = detectMarketRegime(stockData.prices, indicators);
  const [technicalAgent, fundamentalAgent, sentimentAgent, riskAgent, quantAgent] = await Promise.all([
    runTechnicalAgent2(symbol, stockData.currentPrice, indicators, regime),
    runFundamentalAgent2(symbol, stockData),
    runSentimentAgent2(symbol, [
      `${symbol} stock performance analysis`,
      `Market outlook for ${symbol}`,
      `${symbol} trading volume trends`
    ]),
    runRiskAgent2(symbol, stockData.currentPrice, indicators, regime, accountBalance),
    runQuantAgent2(symbol, stockData.prices, indicators)
  ]);
  const agents = [technicalAgent, fundamentalAgent, sentimentAgent, riskAgent, quantAgent];
  const consensus = aggregateConsensus(agents);
  const positionSizing = calculateKellyPosition(
    0.55,
    indicators.atr * 2,
    indicators.atr * 1,
    accountBalance
  );
  let riskLevel;
  if (regime.volatilityLevel > 20) riskLevel = "extreme";
  else if (regime.volatilityLevel > 12) riskLevel = "high";
  else if (regime.volatilityLevel > 6) riskLevel = "medium";
  else riskLevel = "low";
  const recommendationScores = {
    "strong_buy": 90,
    "buy": 70,
    "hold": 50,
    "sell": 30,
    "strong_sell": 10
  };
  const overallScore = recommendationScores[consensus.recommendation] * consensus.confidence;
  const ensemblePrediction = {
    direction: consensus.recommendation.includes("buy") ? "up" : consensus.recommendation.includes("sell") ? "down" : "neutral",
    magnitude: indicators.atr / stockData.currentPrice * 100,
    timeframe: "1-5 days",
    confidence: consensus.confidence
  };
  return {
    symbol,
    timestamp: /* @__PURE__ */ new Date(),
    currentPrice: stockData.currentPrice,
    agents,
    consensusRecommendation: consensus.recommendation,
    consensusConfidence: consensus.confidence,
    technicalIndicators: indicators,
    marketRegime: regime,
    positionSizing,
    suggestedStopLoss: stockData.currentPrice - indicators.atr * 2,
    suggestedTakeProfit: stockData.currentPrice + indicators.atr * 3,
    riskLevel,
    ensemblePrediction,
    overallScore,
    profitProbability: consensus.confidence * (consensus.recommendation.includes("buy") || consensus.recommendation.includes("sell") ? 0.6 : 0.5)
  };
}
var init_enhancedAnalysis = __esm({
  "server/services/enhancedAnalysis.ts"() {
    "use strict";
    init_llm();
    init_dataApi();
  }
});

// server/services/monteCarloSimulation.ts
var monteCarloSimulation_exports = {};
__export(monteCarloSimulation_exports, {
  runMonteCarloSimulation: () => runMonteCarloSimulation,
  runQuickSimulation: () => runQuickSimulation
});
async function fetchHistoricalReturns(symbol, days = 252 * 5) {
  try {
    const response = await callDataApi("YahooFinance/get_stock_chart", {
      query: {
        symbol,
        region: "US",
        interval: "1d",
        range: "5y",
        includeAdjustedClose: true
      }
    });
    if (!response?.chart?.result?.[0]) {
      throw new Error("No data returned from API");
    }
    const result = response.chart.result[0];
    const quotes = result.indicators.quote[0];
    const closes = quotes.close.filter((c) => c !== null);
    const returns = [];
    for (let i = 1; i < closes.length; i++) {
      const dailyReturn = (closes[i] - closes[i - 1]) / closes[i - 1];
      returns.push(dailyReturn);
    }
    return returns;
  } catch (error) {
    console.error(`[MonteCarlo] Error fetching data for ${symbol}:`, error);
    return generateSyntheticReturns(days);
  }
}
function generateSyntheticReturns(days) {
  const returns = [];
  const meanReturn = 4e-4;
  const volatility = 0.015;
  for (let i = 0; i < days; i++) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z3 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    returns.push(meanReturn + volatility * z3);
  }
  return returns;
}
function blockBootstrapSample(returns, sampleSize, blockSize = 20) {
  const sample = [];
  while (sample.length < sampleSize) {
    const startIdx = Math.floor(Math.random() * (returns.length - blockSize));
    for (let i = 0; i < blockSize && sample.length < sampleSize; i++) {
      sample.push(returns[startIdx + i]);
    }
  }
  return sample;
}
function applyStrategy(returns, strategyType, lookback = 20) {
  if (strategyType === "buy_hold") {
    return returns;
  }
  const strategyReturns = [];
  let position = 1;
  for (let i = 0; i < returns.length; i++) {
    if (i < lookback) {
      strategyReturns.push(returns[i] * position);
      continue;
    }
    const recentReturns = returns.slice(i - lookback, i);
    const momentum = recentReturns.reduce((a, b) => a + b, 0);
    if (strategyType === "momentum") {
      position = momentum > 0 ? 1 : 0;
    } else if (strategyType === "mean_reversion") {
      position = momentum < -0.05 ? 1 : momentum > 0.05 ? 0 : position;
    } else if (strategyType === "enhanced") {
      const avgGain = recentReturns.filter((r) => r > 0).reduce((a, b) => a + b, 0) / lookback;
      const avgLoss = Math.abs(recentReturns.filter((r) => r < 0).reduce((a, b) => a + b, 0)) / lookback;
      const rs = avgLoss > 0 ? avgGain / avgLoss : 100;
      const rsi = 100 - 100 / (1 + rs);
      if (rsi < 30) position = 1;
      else if (rsi > 70) position = 0;
    }
    strategyReturns.push(returns[i] * position);
  }
  return strategyReturns;
}
function calculatePortfolioPath(initialCapital, returns) {
  const path3 = [initialCapital];
  let value = initialCapital;
  for (const ret of returns) {
    value *= 1 + ret;
    path3.push(value);
  }
  return path3;
}
function calculateMaxDrawdown(path3) {
  let maxDrawdown = 0;
  let peak = path3[0];
  for (const value of path3) {
    if (value > peak) peak = value;
    const drawdown = (peak - value) / peak;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
  }
  return maxDrawdown;
}
function percentile(arr, p) {
  const sorted = [...arr].sort((a, b) => a - b);
  const idx = Math.floor(p * (sorted.length - 1));
  return sorted[idx];
}
function mean(arr) {
  return arr.reduce((a, b) => a + b, 0) / arr.length;
}
function std(arr) {
  const avg = mean(arr);
  const squareDiffs = arr.map((value) => Math.pow(value - avg, 2));
  return Math.sqrt(mean(squareDiffs));
}
function skewness(arr) {
  const n = arr.length;
  const avg = mean(arr);
  const s = std(arr);
  if (s === 0) return 0;
  const sum2 = arr.reduce((acc, val) => acc + Math.pow((val - avg) / s, 3), 0);
  return n / ((n - 1) * (n - 2)) * sum2;
}
function kurtosis(arr) {
  const n = arr.length;
  const avg = mean(arr);
  const s = std(arr);
  if (s === 0) return 0;
  const sum2 = arr.reduce((acc, val) => acc + Math.pow((val - avg) / s, 4), 0);
  return n * (n + 1) / ((n - 1) * (n - 2) * (n - 3)) * sum2 - 3 * Math.pow(n - 1, 2) / ((n - 2) * (n - 3));
}
function createHistogram(arr, numBins = 50) {
  const min = Math.min(...arr);
  const max = Math.max(...arr);
  const binWidth = (max - min) / numBins;
  const bins = [];
  const frequencies = new Array(numBins).fill(0);
  for (let i = 0; i < numBins; i++) {
    bins.push(min + (i + 0.5) * binWidth);
  }
  for (const val of arr) {
    const binIdx = Math.min(Math.floor((val - min) / binWidth), numBins - 1);
    frequencies[binIdx]++;
  }
  const total = arr.length;
  for (let i = 0; i < frequencies.length; i++) {
    frequencies[i] = frequencies[i] / total * 100;
  }
  return { bins, frequencies };
}
async function runMonteCarloSimulation(config) {
  const {
    symbol,
    initialCapital,
    numSimulations,
    timeHorizonDays,
    confidenceLevels,
    strategyType,
    riskFreeRate = 0.05
  } = config;
  const historicalReturns = await fetchHistoricalReturns(symbol);
  const finalValues = [];
  const finalReturns = [];
  const maxDrawdowns = [];
  const allPaths = [];
  for (let sim = 0; sim < numSimulations; sim++) {
    const sampledReturns = blockBootstrapSample(historicalReturns, timeHorizonDays);
    const strategyReturns = applyStrategy(sampledReturns, strategyType);
    const path3 = calculatePortfolioPath(initialCapital, strategyReturns);
    finalValues.push(path3[path3.length - 1]);
    finalReturns.push((path3[path3.length - 1] - initialCapital) / initialCapital);
    maxDrawdowns.push(calculateMaxDrawdown(path3));
    if (sim % Math.max(1, Math.floor(numSimulations / 100)) === 0) {
      allPaths.push(path3);
    }
  }
  const expectedReturn = mean(finalReturns);
  const medianReturn = percentile(finalReturns, 0.5);
  const standardDeviation2 = std(finalReturns);
  const returnSkewness = skewness(finalReturns);
  const returnKurtosis = kurtosis(finalReturns);
  const valueAtRisk = {};
  const conditionalVaR = {};
  for (const level of confidenceLevels) {
    const varThreshold = percentile(finalReturns, 1 - level);
    valueAtRisk[level] = -varThreshold;
    const tailReturns = finalReturns.filter((r) => r <= varThreshold);
    conditionalVaR[level] = tailReturns.length > 0 ? -mean(tailReturns) : -varThreshold;
  }
  const maxDrawdownDistribution = {
    mean: mean(maxDrawdowns),
    median: percentile(maxDrawdowns, 0.5),
    percentile95: percentile(maxDrawdowns, 0.95),
    percentile99: percentile(maxDrawdowns, 0.99)
  };
  const probabilityOfProfit = finalReturns.filter((r) => r > 0).length / numSimulations;
  const probabilityOfLoss = finalReturns.filter((r) => r < 0).length / numSimulations;
  const probabilityOfRuin = finalReturns.filter((r) => r < -0.5).length / numSimulations;
  const returnDistribution = createHistogram(finalReturns.map((r) => r * 100), 50);
  const confidenceIntervals = {};
  for (const level of confidenceLevels) {
    const alpha = (1 - level) / 2;
    confidenceIntervals[level] = {
      lower: percentile(finalReturns, alpha),
      upper: percentile(finalReturns, 1 - alpha)
    };
  }
  const simulationPaths = [];
  const maxPathLength = Math.max(...allPaths.map((p) => p.length));
  for (let day = 0; day < maxPathLength; day++) {
    const dayValues = allPaths.map((path3) => path3[Math.min(day, path3.length - 1)]);
    simulationPaths.push({
      day,
      values: dayValues.slice(0, 10),
      // Store first 10 paths for visualization
      mean: mean(dayValues),
      median: percentile(dayValues, 0.5),
      percentile5: percentile(dayValues, 0.05),
      percentile25: percentile(dayValues, 0.25),
      percentile75: percentile(dayValues, 0.75),
      percentile95: percentile(dayValues, 0.95)
    });
  }
  const bullThreshold = 0.15;
  const bearThreshold = -0.1;
  const bullReturns = finalReturns.filter((r) => r > bullThreshold);
  const bearReturns = finalReturns.filter((r) => r < bearThreshold);
  const sidewaysReturns = finalReturns.filter((r) => r >= bearThreshold && r <= bullThreshold);
  const scenarioAnalysis = {
    bullMarket: {
      probability: bullReturns.length / numSimulations,
      avgReturn: bullReturns.length > 0 ? mean(bullReturns) : 0
    },
    bearMarket: {
      probability: bearReturns.length / numSimulations,
      avgReturn: bearReturns.length > 0 ? mean(bearReturns) : 0
    },
    sideways: {
      probability: sidewaysReturns.length / numSimulations,
      avgReturn: sidewaysReturns.length > 0 ? mean(sidewaysReturns) : 0
    }
  };
  const finalValuesStats = {
    min: Math.min(...finalValues),
    max: Math.max(...finalValues),
    mean: mean(finalValues),
    median: percentile(finalValues, 0.5),
    std: std(finalValues)
  };
  return {
    config,
    expectedReturn,
    medianReturn,
    standardDeviation: standardDeviation2,
    skewness: returnSkewness,
    kurtosis: returnKurtosis,
    valueAtRisk,
    conditionalVaR,
    maxDrawdownDistribution,
    probabilityOfProfit,
    probabilityOfLoss,
    probabilityOfRuin,
    returnDistribution,
    confidenceIntervals,
    simulationPaths,
    finalValues: finalValuesStats,
    scenarioAnalysis
  };
}
async function runQuickSimulation(symbol, initialCapital, timeHorizonDays) {
  const result = await runMonteCarloSimulation({
    symbol,
    initialCapital,
    numSimulations: 500,
    // Fewer simulations for speed
    timeHorizonDays,
    confidenceLevels: [0.95],
    strategyType: "buy_hold"
  });
  return {
    expectedReturn: result.expectedReturn,
    probabilityOfProfit: result.probabilityOfProfit,
    var95: result.valueAtRisk[0.95] || 0,
    maxDrawdown: result.maxDrawdownDistribution.median
  };
}
var init_monteCarloSimulation = __esm({
  "server/services/monteCarloSimulation.ts"() {
    "use strict";
    init_dataApi();
  }
});

// server/services/brokers/types.ts
var BrokerError;
var init_types = __esm({
  "server/services/brokers/types.ts"() {
    "use strict";
    BrokerError = class extends Error {
      constructor(code, message, brokerType, originalError) {
        super(message);
        this.code = code;
        this.brokerType = brokerType;
        this.originalError = originalError;
        this.name = "BrokerError";
      }
    };
  }
});

// server/services/brokers/IBrokerAdapter.ts
var BaseBrokerAdapter;
var init_IBrokerAdapter = __esm({
  "server/services/brokers/IBrokerAdapter.ts"() {
    "use strict";
    BaseBrokerAdapter = class {
      credentials = null;
      connected = false;
      async initialize(credentials) {
        this.credentials = credentials;
        this.connected = true;
      }
      isConnected() {
        return this.connected;
      }
      async disconnect() {
        this.credentials = null;
        this.connected = false;
      }
      async testConnection() {
        try {
          await this.getAccounts();
          return true;
        } catch {
          return false;
        }
      }
      needsTokenRefresh() {
        if (!this.credentials) return true;
        const oauth = this.credentials;
        if (!oauth.expiresAt) return false;
        return Date.now() > oauth.expiresAt - 5 * 60 * 1e3;
      }
      async getPosition(symbol, accountId) {
        const positions = await this.getPositions(accountId);
        return positions.find((p) => p.symbol === symbol) || null;
      }
      async cancelAllOrders(accountId) {
        const orders = await this.getOrders({ status: "open" }, accountId);
        await Promise.all(orders.map((o) => this.cancelOrder(o.id, accountId)));
      }
      async modifyOrder(orderId, updates, accountId) {
        await this.cancelOrder(orderId, accountId);
        const originalOrder = await this.getOrder(orderId, accountId);
        return this.placeOrder({
          symbol: originalOrder.symbol,
          side: originalOrder.side,
          type: originalOrder.type,
          quantity: updates.quantity || originalOrder.quantity,
          price: updates.price || originalOrder.price,
          stopPrice: updates.stopPrice || originalOrder.stopPrice,
          timeInForce: updates.timeInForce || originalOrder.timeInForce,
          clientOrderId: updates.clientOrderId
        }, accountId);
      }
      async getQuotes(symbols) {
        const quotes = /* @__PURE__ */ new Map();
        const results = await Promise.all(symbols.map((s) => this.getQuote(s).catch(() => null)));
        symbols.forEach((symbol, i) => {
          if (results[i]) quotes.set(symbol, results[i]);
        });
        return quotes;
      }
      async getLatestBar(symbol) {
        const bars = await this.getHistoricalBars({
          symbol,
          start: new Date(Date.now() - 24 * 60 * 60 * 1e3),
          timeframe: "1Day",
          limit: 1
        });
        if (bars.length === 0) throw new Error(`No bars found for ${symbol}`);
        return bars[bars.length - 1];
      }
      async searchAssets(query, _assetClass) {
        const asset = await this.getAsset(query).catch(() => null);
        return asset ? [asset] : [];
      }
      async isTradable(symbol) {
        try {
          const asset = await this.getAsset(symbol);
          return asset.tradable;
        } catch {
          return false;
        }
      }
      normalizeSymbol(brokerSymbol) {
        return brokerSymbol.toUpperCase();
      }
      toBrokerSymbol(normalizedSymbol) {
        return normalizedSymbol.toUpperCase();
      }
    };
  }
});

// server/services/brokers/AlpacaAdapter.ts
var ALPACA_OAUTH_URL, ALPACA_TOKEN_URL, ALPACA_PAPER_API, ALPACA_LIVE_API, ALPACA_DATA_API, AlpacaAdapter;
var init_AlpacaAdapter = __esm({
  "server/services/brokers/AlpacaAdapter.ts"() {
    "use strict";
    init_IBrokerAdapter();
    init_types();
    ALPACA_OAUTH_URL = "https://app.alpaca.markets/oauth/authorize";
    ALPACA_TOKEN_URL = "https://api.alpaca.markets/oauth/token";
    ALPACA_PAPER_API = "https://paper-api.alpaca.markets";
    ALPACA_LIVE_API = "https://api.alpaca.markets";
    ALPACA_DATA_API = "https://data.alpaca.markets";
    AlpacaAdapter = class extends BaseBrokerAdapter {
      config = null;
      baseUrl = ALPACA_PAPER_API;
      dataUrl = ALPACA_DATA_API;
      constructor(config) {
        super();
        if (config) {
          this.config = config;
          this.baseUrl = config.isPaper ? ALPACA_PAPER_API : ALPACA_LIVE_API;
        }
      }
      getBrokerType() {
        return "alpaca" /* ALPACA */;
      }
      getCapabilities() {
        return {
          supportedAssetClasses: ["us_equity" /* US_EQUITY */, "crypto" /* CRYPTO */],
          supportedOrderTypes: [
            "market" /* MARKET */,
            "limit" /* LIMIT */,
            "stop" /* STOP */,
            "stop_limit" /* STOP_LIMIT */,
            "trailing_stop" /* TRAILING_STOP */
          ],
          supportedTimeInForce: [
            "day" /* DAY */,
            "gtc" /* GTC */,
            "ioc" /* IOC */,
            "fok" /* FOK */,
            "opg" /* OPG */,
            "cls" /* CLS */
          ],
          supportsExtendedHours: true,
          supportsFractionalShares: true,
          supportsShortSelling: true,
          supportsMarginTrading: true,
          supportsOptionsTrading: false,
          supportsCryptoTrading: true,
          supportsForexTrading: false,
          supportsPaperTrading: true,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 200
        };
      }
      // ============================================================================
      // OAuth2 Authentication
      // ============================================================================
      getAuthorizationUrl(state, isPaper = true) {
        if (!this.config) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "Alpaca config not initialized",
            "alpaca" /* ALPACA */
          );
        }
        const params = new URLSearchParams({
          response_type: "code",
          client_id: this.config.clientId,
          redirect_uri: this.config.redirectUri,
          state,
          scope: "account:write trading data"
        });
        return `${ALPACA_OAUTH_URL}?${params.toString()}`;
      }
      async handleOAuthCallback(code, _state) {
        if (!this.config) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "Alpaca config not initialized",
            "alpaca" /* ALPACA */
          );
        }
        const response = await fetch(ALPACA_TOKEN_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: new URLSearchParams({
            grant_type: "authorization_code",
            code,
            client_id: this.config.clientId,
            client_secret: this.config.clientSecret,
            redirect_uri: this.config.redirectUri
          })
        });
        if (!response.ok) {
          const error = await response.text();
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            `Failed to exchange code for token: ${error}`,
            "alpaca" /* ALPACA */
          );
        }
        const data = await response.json();
        return {
          accessToken: data.access_token,
          refreshToken: data.refresh_token,
          expiresIn: data.expires_in,
          tokenType: data.token_type,
          scope: data.scope
        };
      }
      async refreshAccessToken() {
        if (!this.config || !this.credentials) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "Not authenticated",
            "alpaca" /* ALPACA */
          );
        }
        const oauth = this.credentials;
        if (!oauth.refreshToken) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "No refresh token available",
            "alpaca" /* ALPACA */
          );
        }
        const response = await fetch(ALPACA_TOKEN_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: new URLSearchParams({
            grant_type: "refresh_token",
            refresh_token: oauth.refreshToken,
            client_id: this.config.clientId,
            client_secret: this.config.clientSecret
          })
        });
        if (!response.ok) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "Failed to refresh token",
            "alpaca" /* ALPACA */
          );
        }
        const data = await response.json();
        this.credentials.accessToken = data.access_token;
        if (data.refresh_token) {
          this.credentials.refreshToken = data.refresh_token;
        }
        this.credentials.expiresAt = Date.now() + data.expires_in * 1e3;
        return {
          accessToken: data.access_token,
          refreshToken: data.refresh_token,
          expiresIn: data.expires_in,
          tokenType: data.token_type
        };
      }
      // ============================================================================
      // HTTP Helper
      // ============================================================================
      async request(endpoint, options = {}, useDataApi = false) {
        if (!this.credentials) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "Not authenticated",
            "alpaca" /* ALPACA */
          );
        }
        if (this.needsTokenRefresh()) {
          await this.refreshAccessToken();
        }
        const oauth = this.credentials;
        const baseUrl = useDataApi ? this.dataUrl : this.baseUrl;
        const url = `${baseUrl}${endpoint}`;
        const response = await fetch(url, {
          ...options,
          headers: {
            "Authorization": `Bearer ${oauth.accessToken}`,
            "Content-Type": "application/json",
            ...options.headers
          }
        });
        if (!response.ok) {
          const errorText = await response.text();
          let errorCode = "unknown_error" /* UNKNOWN_ERROR */;
          if (response.status === 401) errorCode = "authentication_failed" /* AUTHENTICATION_FAILED */;
          else if (response.status === 403) errorCode = "insufficient_funds" /* INSUFFICIENT_FUNDS */;
          else if (response.status === 404) errorCode = "invalid_symbol" /* INVALID_SYMBOL */;
          else if (response.status === 422) errorCode = "invalid_order" /* INVALID_ORDER */;
          else if (response.status === 429) errorCode = "rate_limited" /* RATE_LIMITED */;
          throw new BrokerError(errorCode, errorText, "alpaca" /* ALPACA */);
        }
        if (response.status === 204) {
          return {};
        }
        return response.json();
      }
      // ============================================================================
      // Account Operations
      // ============================================================================
      async getAccounts() {
        const account = await this.request("/v2/account");
        return [{
          id: account.id,
          accountNumber: account.account_number,
          accountType: account.account_type || "trading",
          currency: account.currency,
          status: account.status,
          isPaper: this.config?.isPaper ?? true,
          createdAt: new Date(account.created_at)
        }];
      }
      async getAccountBalance(_accountId) {
        const account = await this.request("/v2/account");
        return {
          currency: account.currency,
          cash: parseFloat(account.cash),
          cashAvailable: parseFloat(account.cash),
          cashWithdrawable: parseFloat(account.cash_withdrawable || "0"),
          buyingPower: parseFloat(account.buying_power),
          portfolioValue: parseFloat(account.portfolio_value),
          equity: parseFloat(account.equity),
          lastEquity: parseFloat(account.last_equity),
          longMarketValue: parseFloat(account.long_market_value),
          shortMarketValue: parseFloat(account.short_market_value),
          initialMargin: parseFloat(account.initial_margin || "0"),
          maintenanceMargin: parseFloat(account.maintenance_margin || "0"),
          dayTradeCount: account.daytrade_count,
          patternDayTrader: account.pattern_day_trader
        };
      }
      async getPositions(_accountId) {
        const positions = await this.request("/v2/positions");
        return positions.map((p) => ({
          symbol: p.symbol,
          quantity: parseFloat(p.qty),
          side: parseFloat(p.qty) > 0 ? "long" : "short",
          avgEntryPrice: parseFloat(p.avg_entry_price),
          marketValue: parseFloat(p.market_value),
          costBasis: parseFloat(p.cost_basis),
          unrealizedPL: parseFloat(p.unrealized_pl),
          unrealizedPLPercent: parseFloat(p.unrealized_plpc) * 100,
          currentPrice: parseFloat(p.current_price),
          lastDayPrice: parseFloat(p.lastday_price || "0"),
          changeToday: parseFloat(p.change_today || "0") * 100,
          assetClass: p.asset_class === "crypto" ? "crypto" /* CRYPTO */ : "us_equity" /* US_EQUITY */,
          exchange: p.exchange
        }));
      }
      // ============================================================================
      // Order Operations
      // ============================================================================
      async placeOrder(order, _accountId) {
        const alpacaOrder = {
          symbol: this.toBrokerSymbol(order.symbol),
          qty: order.quantity.toString(),
          side: order.side,
          type: this.toAlpacaOrderType(order.type),
          time_in_force: this.toAlpacaTimeInForce(order.timeInForce),
          extended_hours: order.extendedHours || false
        };
        if (order.price) alpacaOrder.limit_price = order.price.toString();
        if (order.stopPrice) alpacaOrder.stop_price = order.stopPrice.toString();
        if (order.trailPercent) alpacaOrder.trail_percent = order.trailPercent.toString();
        if (order.trailPrice) alpacaOrder.trail_price = order.trailPrice.toString();
        if (order.clientOrderId) alpacaOrder.client_order_id = order.clientOrderId;
        if (order.orderClass && order.orderClass !== "simple") {
          alpacaOrder.order_class = order.orderClass;
          if (order.takeProfit) {
            alpacaOrder.take_profit = { limit_price: order.takeProfit.limitPrice.toString() };
          }
          if (order.stopLoss) {
            alpacaOrder.stop_loss = {
              stop_price: order.stopLoss.stopPrice.toString(),
              ...order.stopLoss.limitPrice && { limit_price: order.stopLoss.limitPrice.toString() }
            };
          }
        }
        const response = await this.request("/v2/orders", {
          method: "POST",
          body: JSON.stringify(alpacaOrder)
        });
        return this.parseOrderResponse(response);
      }
      async cancelOrder(orderId, _accountId) {
        await this.request(`/v2/orders/${orderId}`, { method: "DELETE" });
      }
      async getOrders(params, _accountId) {
        const queryParams = new URLSearchParams();
        if (params?.status) queryParams.set("status", params.status);
        if (params?.limit) queryParams.set("limit", params.limit.toString());
        if (params?.after) queryParams.set("after", params.after.toISOString());
        if (params?.until) queryParams.set("until", params.until.toISOString());
        if (params?.direction) queryParams.set("direction", params.direction);
        if (params?.symbols) queryParams.set("symbols", params.symbols.join(","));
        const query = queryParams.toString();
        const endpoint = `/v2/orders${query ? `?${query}` : ""}`;
        const orders = await this.request(endpoint);
        return orders.map((o) => this.parseOrderResponse(o));
      }
      async getOrder(orderId, _accountId) {
        const order = await this.request(`/v2/orders/${orderId}`);
        return this.parseOrderResponse(order);
      }
      // ============================================================================
      // Market Data
      // ============================================================================
      async getQuote(symbol) {
        const brokerSymbol = this.toBrokerSymbol(symbol);
        const response = await this.request(
          `/v2/stocks/${brokerSymbol}/quotes/latest`,
          {},
          true
        );
        const quote = response.quote;
        return {
          symbol,
          bidPrice: quote.bp,
          bidSize: quote.bs,
          askPrice: quote.ap,
          askSize: quote.as,
          lastPrice: (quote.bp + quote.ap) / 2,
          lastSize: 0,
          volume: 0,
          timestamp: new Date(quote.t)
        };
      }
      async getHistoricalBars(params) {
        const brokerSymbol = this.toBrokerSymbol(params.symbol);
        const timeframe = this.toAlpacaTimeframe(params.timeframe);
        const queryParams = new URLSearchParams({
          start: params.start.toISOString(),
          timeframe
        });
        if (params.end) queryParams.set("end", params.end.toISOString());
        if (params.limit) queryParams.set("limit", params.limit.toString());
        if (params.adjustment) queryParams.set("adjustment", params.adjustment);
        const response = await this.request(
          `/v2/stocks/${brokerSymbol}/bars?${queryParams.toString()}`,
          {},
          true
        );
        return (response.bars || []).map((bar) => ({
          timestamp: new Date(bar.t),
          open: bar.o,
          high: bar.h,
          low: bar.l,
          close: bar.c,
          volume: bar.v,
          vwap: bar.vw,
          tradeCount: bar.n
        }));
      }
      // ============================================================================
      // Asset Information
      // ============================================================================
      async getAsset(symbol) {
        const brokerSymbol = this.toBrokerSymbol(symbol);
        const asset = await this.request(`/v2/assets/${brokerSymbol}`);
        return {
          id: asset.id,
          symbol: asset.symbol,
          name: asset.name,
          exchange: asset.exchange,
          assetClass: asset.class === "crypto" ? "crypto" /* CRYPTO */ : "us_equity" /* US_EQUITY */,
          status: asset.status,
          tradable: asset.tradable,
          marginable: asset.marginable,
          shortable: asset.shortable,
          easyToBorrow: asset.easy_to_borrow,
          fractionable: asset.fractionable,
          minOrderSize: asset.min_order_size ? parseFloat(asset.min_order_size) : void 0,
          minPriceIncrement: asset.min_trade_increment ? parseFloat(asset.min_trade_increment) : void 0,
          priceScale: asset.price_increment ? Math.round(-Math.log10(parseFloat(asset.price_increment))) : void 0
        };
      }
      async searchAssets(query, assetClass) {
        const params = new URLSearchParams({ status: "active" });
        if (assetClass) params.set("asset_class", assetClass);
        const assets = await this.request(`/v2/assets?${params.toString()}`);
        const filtered = assets.filter(
          (a) => a.symbol.toLowerCase().includes(query.toLowerCase()) || a.name.toLowerCase().includes(query.toLowerCase())
        ).slice(0, 20);
        return filtered.map((asset) => ({
          id: asset.id,
          symbol: asset.symbol,
          name: asset.name,
          exchange: asset.exchange,
          assetClass: asset.class === "crypto" ? "crypto" /* CRYPTO */ : "us_equity" /* US_EQUITY */,
          status: asset.status,
          tradable: asset.tradable,
          marginable: asset.marginable,
          shortable: asset.shortable,
          easyToBorrow: asset.easy_to_borrow,
          fractionable: asset.fractionable
        }));
      }
      // ============================================================================
      // Symbol Mapping
      // ============================================================================
      normalizeSymbol(brokerSymbol) {
        return brokerSymbol.replace("/USD", "").toUpperCase();
      }
      toBrokerSymbol(normalizedSymbol) {
        const cryptoSymbols = ["BTC", "ETH", "DOGE", "SHIB", "LTC", "BCH", "LINK", "UNI", "AVAX", "AAVE"];
        if (cryptoSymbols.includes(normalizedSymbol.toUpperCase())) {
          return `${normalizedSymbol.toUpperCase()}/USD`;
        }
        return normalizedSymbol.toUpperCase();
      }
      // ============================================================================
      // Helper Methods
      // ============================================================================
      toAlpacaOrderType(type) {
        const mapping = {
          ["market" /* MARKET */]: "market",
          ["limit" /* LIMIT */]: "limit",
          ["stop" /* STOP */]: "stop",
          ["stop_limit" /* STOP_LIMIT */]: "stop_limit",
          ["trailing_stop" /* TRAILING_STOP */]: "trailing_stop"
        };
        return mapping[type];
      }
      toAlpacaTimeInForce(tif) {
        const mapping = {
          ["day" /* DAY */]: "day",
          ["gtc" /* GTC */]: "gtc",
          ["ioc" /* IOC */]: "ioc",
          ["fok" /* FOK */]: "fok",
          ["opg" /* OPG */]: "opg",
          ["cls" /* CLS */]: "cls"
        };
        return mapping[tif];
      }
      toAlpacaTimeframe(timeframe) {
        const mapping = {
          "1Min": "1Min",
          "5Min": "5Min",
          "15Min": "15Min",
          "30Min": "30Min",
          "1Hour": "1Hour",
          "4Hour": "4Hour",
          "1Day": "1Day",
          "1Week": "1Week",
          "1Month": "1Month"
        };
        return mapping[timeframe] || "1Day";
      }
      parseOrderResponse(order) {
        return {
          id: order.id,
          clientOrderId: order.client_order_id,
          symbol: this.normalizeSymbol(order.symbol),
          side: order.side,
          type: this.parseOrderType(order.type),
          quantity: parseFloat(order.qty),
          filledQuantity: parseFloat(order.filled_qty || "0"),
          price: order.limit_price ? parseFloat(order.limit_price) : void 0,
          stopPrice: order.stop_price ? parseFloat(order.stop_price) : void 0,
          avgFillPrice: order.filled_avg_price ? parseFloat(order.filled_avg_price) : void 0,
          status: this.parseOrderStatus(order.status),
          timeInForce: this.parseTimeInForce(order.time_in_force),
          extendedHours: order.extended_hours,
          createdAt: new Date(order.created_at),
          updatedAt: new Date(order.updated_at),
          filledAt: order.filled_at ? new Date(order.filled_at) : void 0,
          cancelledAt: order.canceled_at ? new Date(order.canceled_at) : void 0,
          expiredAt: order.expired_at ? new Date(order.expired_at) : void 0,
          failedAt: order.failed_at ? new Date(order.failed_at) : void 0,
          assetClass: order.asset_class === "crypto" ? "crypto" /* CRYPTO */ : "us_equity" /* US_EQUITY */,
          legs: order.legs?.map((leg) => this.parseOrderResponse(leg))
        };
      }
      parseOrderType(type) {
        const mapping = {
          "market": "market" /* MARKET */,
          "limit": "limit" /* LIMIT */,
          "stop": "stop" /* STOP */,
          "stop_limit": "stop_limit" /* STOP_LIMIT */,
          "trailing_stop": "trailing_stop" /* TRAILING_STOP */
        };
        return mapping[type] || "market" /* MARKET */;
      }
      parseOrderStatus(status) {
        const mapping = {
          "new": "new" /* NEW */,
          "pending_new": "pending" /* PENDING */,
          "accepted": "accepted" /* ACCEPTED */,
          "partially_filled": "partially_filled" /* PARTIALLY_FILLED */,
          "filled": "filled" /* FILLED */,
          "canceled": "cancelled" /* CANCELLED */,
          "rejected": "rejected" /* REJECTED */,
          "expired": "expired" /* EXPIRED */,
          "replaced": "replaced" /* REPLACED */,
          "pending_cancel": "pending" /* PENDING */,
          "pending_replace": "pending" /* PENDING */
        };
        return mapping[status] || "new" /* NEW */;
      }
      parseTimeInForce(tif) {
        const mapping = {
          "day": "day" /* DAY */,
          "gtc": "gtc" /* GTC */,
          "ioc": "ioc" /* IOC */,
          "fok": "fok" /* FOK */,
          "opg": "opg" /* OPG */,
          "cls": "cls" /* CLS */
        };
        return mapping[tif] || "day" /* DAY */;
      }
    };
  }
});

// server/services/brokers/IBKRAdapter.ts
import * as crypto2 from "crypto";
var IBKR_OAUTH_BASE, IBKR_PORTAL_BASE, IBKR_OAUTH2_AUTHORIZE, IBKR_OAUTH2_TOKEN, IBKRAdapter;
var init_IBKRAdapter = __esm({
  "server/services/brokers/IBKRAdapter.ts"() {
    "use strict";
    init_IBrokerAdapter();
    init_types();
    IBKR_OAUTH_BASE = "https://api.ibkr.com/v1/api";
    IBKR_PORTAL_BASE = "https://api.ibkr.com/v1/portal";
    IBKR_OAUTH2_AUTHORIZE = "https://www.interactivebrokers.com/authorize";
    IBKR_OAUTH2_TOKEN = "https://api.ibkr.com/v1/api/oauth2/api/v1/token";
    IBKRAdapter = class extends BaseBrokerAdapter {
      config = null;
      authMethod = "oauth2";
      // OAuth 2.0 tokens
      accessToken = null;
      refreshToken = null;
      tokenExpiry = 0;
      // OAuth 1.0a tokens (legacy)
      liveSessionToken = null;
      liveSessionTokenExpiry = 0;
      accountId = null;
      constructor(config) {
        super();
        if (config) {
          this.config = config;
          this.authMethod = config.authMethod || "oauth2";
        }
      }
      getBrokerType() {
        return "interactive_brokers" /* INTERACTIVE_BROKERS */;
      }
      getCapabilities() {
        return {
          supportedAssetClasses: [
            "us_equity" /* US_EQUITY */,
            "options" /* OPTIONS */,
            "futures" /* FUTURES */,
            "forex" /* FOREX */,
            "crypto" /* CRYPTO */
          ],
          supportedOrderTypes: [
            "market" /* MARKET */,
            "limit" /* LIMIT */,
            "stop" /* STOP */,
            "stop_limit" /* STOP_LIMIT */,
            "trailing_stop" /* TRAILING_STOP */
          ],
          supportedTimeInForce: [
            "day" /* DAY */,
            "gtc" /* GTC */,
            "ioc" /* IOC */,
            "fok" /* FOK */,
            "opg" /* OPG */
          ],
          supportsExtendedHours: true,
          supportsFractionalShares: false,
          supportsShortSelling: true,
          supportsMarginTrading: true,
          supportsOptionsTrading: true,
          supportsCryptoTrading: true,
          supportsForexTrading: true,
          supportsPaperTrading: true,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 50
        };
      }
      // ============================================================================
      // OAuth 2.0 Authentication (Recommended)
      // ============================================================================
      /**
       * Get OAuth 2.0 authorization URL
       * Users will be redirected here to authorize the application
       */
      getOAuth2AuthorizationUrl(state, isPaper = true) {
        if (!this.config?.clientId) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "IBKR OAuth 2.0 client ID not configured",
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const params = new URLSearchParams({
          response_type: "code",
          client_id: this.config.clientId,
          redirect_uri: this.config.redirectUri,
          scope: "trading",
          state
        });
        if (isPaper) {
          params.append("paper", "true");
        }
        return `${IBKR_OAUTH2_AUTHORIZE}?${params.toString()}`;
      }
      /**
       * Exchange OAuth 2.0 authorization code for tokens
       */
      async handleOAuth2Callback(code, _state) {
        if (!this.config?.clientId) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "IBKR OAuth 2.0 not configured",
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const clientAssertion = await this.createJWTClientAssertion();
        const response = await fetch(IBKR_OAUTH2_TOKEN, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: new URLSearchParams({
            grant_type: "authorization_code",
            code,
            client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
            client_assertion: clientAssertion,
            redirect_uri: this.config.redirectUri
          }).toString()
        });
        if (!response.ok) {
          const error = await response.text();
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            `IBKR OAuth 2.0 error: ${error}`,
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const data = await response.json();
        this.accessToken = data.access_token;
        this.refreshToken = data.refresh_token || null;
        this.tokenExpiry = Date.now() + (data.expires_in || 3600) * 1e3;
        this.connected = true;
        return {
          accessToken: data.access_token,
          refreshToken: data.refresh_token,
          expiresIn: data.expires_in,
          tokenType: data.token_type,
          scope: data.scope
        };
      }
      /**
       * Refresh OAuth 2.0 access token
       */
      async refreshOAuth2Token() {
        if (!this.refreshToken || !this.config?.clientId) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "No refresh token available",
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const clientAssertion = await this.createJWTClientAssertion();
        const response = await fetch(IBKR_OAUTH2_TOKEN, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: new URLSearchParams({
            grant_type: "refresh_token",
            refresh_token: this.refreshToken,
            client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
            client_assertion: clientAssertion
          }).toString()
        });
        if (!response.ok) {
          const error = await response.text();
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            `IBKR token refresh error: ${error}`,
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const data = await response.json();
        this.accessToken = data.access_token;
        this.refreshToken = data.refresh_token || this.refreshToken;
        this.tokenExpiry = Date.now() + (data.expires_in || 3600) * 1e3;
        return {
          accessToken: data.access_token,
          refreshToken: data.refresh_token,
          expiresIn: data.expires_in,
          tokenType: data.token_type
        };
      }
      /**
       * Create JWT client assertion for OAuth 2.0
       * IBKR requires private_key_jwt authentication method
       */
      async createJWTClientAssertion() {
        if (!this.config?.clientId) {
          throw new Error("Client ID not configured");
        }
        const header = {
          alg: "RS256",
          typ: "JWT"
        };
        const now = Math.floor(Date.now() / 1e3);
        const payload = {
          iss: this.config.clientId,
          sub: this.config.clientId,
          aud: IBKR_OAUTH2_TOKEN,
          exp: now + 300,
          // 5 minutes
          iat: now,
          jti: crypto2.randomUUID()
        };
        const base64Header = Buffer.from(JSON.stringify(header)).toString("base64url");
        const base64Payload = Buffer.from(JSON.stringify(payload)).toString("base64url");
        const unsignedToken = `${base64Header}.${base64Payload}`;
        if (this.config.privateKey) {
          const sign = crypto2.createSign("RSA-SHA256");
          sign.update(unsignedToken);
          const signature = sign.sign(this.config.privateKey, "base64url");
          return `${unsignedToken}.${signature}`;
        }
        return `${unsignedToken}.development_signature`;
      }
      // ============================================================================
      // OAuth 1.0A Authentication (Legacy)
      // ============================================================================
      /**
       * Generate OAuth 1.0A signature using RSA-SHA256
       */
      generateSignature(method, url, params, tokenSecret = "") {
        if (!this.config) throw new Error("Config not initialized");
        const sortedParams = Object.entries(params).filter(([key]) => key !== "oauth_signature").sort(([a], [b]) => a.localeCompare(b)).map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`).join("&");
        const signatureBase = [
          method.toUpperCase(),
          encodeURIComponent(url),
          encodeURIComponent(sortedParams)
        ].join("&");
        if (!this.config?.privateKey) {
          throw new Error("Private key not configured for OAuth 1.0a");
        }
        const sign = crypto2.createSign("RSA-SHA256");
        sign.update(signatureBase);
        const signature = sign.sign(this.config.privateKey, "base64");
        return signature;
      }
      /**
       * Generate OAuth authorization header
       */
      generateAuthHeader(params) {
        const headerParams = Object.entries(params).map(([key, value]) => `${key}="${encodeURIComponent(value)}"`).join(", ");
        return `OAuth realm="${this.config?.realm}", ${headerParams}`;
      }
      /**
       * Generate nonce for OAuth
       */
      generateNonce() {
        return crypto2.randomBytes(16).toString("hex");
      }
      /**
       * Step 1: Get Request Token
       */
      async getRequestToken() {
        if (!this.config) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "IBKR config not initialized",
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const url = `${IBKR_OAUTH_BASE}/oauth/request_token`;
        const timestamp2 = Math.floor(Date.now() / 1e3).toString();
        const nonce = this.generateNonce();
        const params = {
          oauth_consumer_key: this.config.consumerKey || "",
          oauth_signature_method: "RSA-SHA256",
          oauth_timestamp: timestamp2,
          oauth_nonce: nonce,
          oauth_version: "1.0",
          oauth_callback: this.config.redirectUri
        };
        params.oauth_signature = this.generateSignature("POST", url, params);
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "Authorization": this.generateAuthHeader(params),
            "Content-Type": "application/x-www-form-urlencoded"
          }
        });
        if (!response.ok) {
          const error = await response.text();
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            `Failed to get request token: ${error}`,
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const body = await response.text();
        const data = new URLSearchParams(body);
        return {
          token: data.get("oauth_token") || "",
          tokenSecret: data.get("oauth_token_secret") || ""
        };
      }
      /**
       * Get authorization URL for user to approve
       * Supports both OAuth 2.0 and OAuth 1.0a based on configuration
       */
      getAuthorizationUrl(state, isPaper = true) {
        if (this.authMethod === "oauth2") {
          return this.getOAuth2AuthorizationUrl(state, isPaper);
        }
        return `${IBKR_OAUTH_BASE}/oauth/authorize?oauth_token=${state}`;
      }
      /**
       * Handle OAuth callback - supports both OAuth 2.0 and OAuth 1.0a
       */
      async handleOAuthCallback(code, state, verifier) {
        if (this.authMethod === "oauth2") {
          return this.handleOAuth2Callback(code, state);
        }
        return this.handleOAuth1Callback(code, state, verifier || "");
      }
      /**
       * OAuth 1.0a callback handler (legacy)
       */
      async handleOAuth1Callback(_code, requestToken, verifier) {
        if (!this.config) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "IBKR config not initialized",
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const url = `${IBKR_OAUTH_BASE}/oauth/access_token`;
        const timestamp2 = Math.floor(Date.now() / 1e3).toString();
        const nonce = this.generateNonce();
        const params = {
          oauth_consumer_key: this.config.consumerKey || "",
          oauth_signature_method: "RSA-SHA256",
          oauth_timestamp: timestamp2,
          oauth_nonce: nonce,
          oauth_version: "1.0",
          oauth_token: requestToken,
          oauth_verifier: verifier
        };
        params.oauth_signature = this.generateSignature("POST", url, params);
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "Authorization": this.generateAuthHeader(params),
            "Content-Type": "application/x-www-form-urlencoded"
          }
        });
        if (!response.ok) {
          const error = await response.text();
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            `Failed to get access token: ${error}`,
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const body = await response.text();
        const data = new URLSearchParams(body);
        return {
          accessToken: data.get("oauth_token") || "",
          refreshToken: data.get("oauth_token_secret") || ""
        };
      }
      /**
       * Step 4: Compute Live Session Token using Diffie-Hellman
       */
      async computeLiveSessionToken() {
        if (!this.config || !this.credentials) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "Not authenticated",
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const oauth = this.credentials;
        const dh = crypto2.createDiffieHellman(256);
        const dhPublicKey = dh.generateKeys("hex");
        const url = `${IBKR_OAUTH_BASE}/oauth/live_session_token`;
        const timestamp2 = Math.floor(Date.now() / 1e3).toString();
        const nonce = this.generateNonce();
        const params = {
          oauth_consumer_key: this.config.consumerKey || "",
          oauth_signature_method: "RSA-SHA256",
          oauth_timestamp: timestamp2,
          oauth_nonce: nonce,
          oauth_version: "1.0",
          oauth_token: oauth.accessToken
        };
        params.oauth_signature = this.generateSignature("POST", url, params, oauth.accessTokenSecret);
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "Authorization": this.generateAuthHeader(params),
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: `diffie_hellman_challenge=${encodeURIComponent(dhPublicKey)}`
        });
        if (!response.ok) {
          const error = await response.text();
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            `Failed to compute LST: ${error}`,
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const body = await response.text();
        const data = new URLSearchParams(body);
        const dhResponse = data.get("diffie_hellman_response") || "";
        const lstSignature = data.get("live_session_token_signature") || "";
        const lstExpiration = data.get("live_session_token_expiration") || "";
        const sharedSecret = dh.computeSecret(Buffer.from(dhResponse, "hex"));
        const lst = crypto2.createHmac("sha256", sharedSecret).update(oauth.accessToken).digest("hex");
        const verify = crypto2.createVerify("RSA-SHA256");
        verify.update(lst);
        this.liveSessionToken = lst;
        this.liveSessionTokenExpiry = parseInt(lstExpiration) * 1e3;
        return lst;
      }
      async refreshAccessToken() {
        if (this.authMethod === "oauth2" && this.refreshToken) {
          return this.refreshOAuth2Token();
        }
        const lst = await this.computeLiveSessionToken();
        return {
          accessToken: lst,
          expiresIn: Math.floor((this.liveSessionTokenExpiry - Date.now()) / 1e3)
        };
      }
      needsTokenRefresh() {
        if (this.authMethod === "oauth2") {
          if (!this.accessToken) return true;
          return Date.now() > this.tokenExpiry - 5 * 60 * 1e3;
        }
        if (!this.liveSessionToken) return true;
        return Date.now() > this.liveSessionTokenExpiry - 5 * 60 * 1e3;
      }
      // ============================================================================
      // HTTP Helper with OAuth 1.0A
      // ============================================================================
      async request(endpoint, options = {}) {
        const isOAuth2 = this.authMethod === "oauth2";
        if (isOAuth2 && !this.accessToken) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "Not authenticated (OAuth 2.0)",
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        if (!isOAuth2 && (!this.config || !this.credentials)) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "Not authenticated (OAuth 1.0a)",
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        if (this.needsTokenRefresh()) {
          if (isOAuth2) {
            await this.refreshOAuth2Token();
          } else {
            await this.computeLiveSessionToken();
          }
        }
        const url = `${IBKR_PORTAL_BASE}${endpoint}`;
        const method = options.method || "GET";
        let headers;
        if (isOAuth2) {
          headers = {
            "Authorization": `Bearer ${this.accessToken}`,
            "Content-Type": "application/json",
            ...options.headers
          };
        } else {
          const oauth = this.credentials;
          const timestamp2 = Math.floor(Date.now() / 1e3).toString();
          const nonce = this.generateNonce();
          const params = {
            oauth_consumer_key: this.config.consumerKey,
            oauth_signature_method: "RSA-SHA256",
            oauth_timestamp: timestamp2,
            oauth_nonce: nonce,
            oauth_version: "1.0",
            oauth_token: oauth.accessToken
          };
          params.oauth_signature = this.generateSignature(method, url, params, oauth.accessTokenSecret);
          headers = {
            "Authorization": this.generateAuthHeader(params),
            "Content-Type": "application/json",
            ...options.headers
          };
        }
        const response = await fetch(url, {
          ...options,
          headers
        });
        if (!response.ok) {
          const errorText = await response.text();
          let errorCode = "unknown_error" /* UNKNOWN_ERROR */;
          if (response.status === 401) errorCode = "authentication_failed" /* AUTHENTICATION_FAILED */;
          else if (response.status === 403) errorCode = "insufficient_funds" /* INSUFFICIENT_FUNDS */;
          else if (response.status === 404) errorCode = "invalid_symbol" /* INVALID_SYMBOL */;
          else if (response.status === 429) errorCode = "rate_limited" /* RATE_LIMITED */;
          throw new BrokerError(errorCode, errorText, "interactive_brokers" /* INTERACTIVE_BROKERS */);
        }
        if (response.status === 204) {
          return {};
        }
        return response.json();
      }
      // ============================================================================
      // Account Operations
      // ============================================================================
      async getAccounts() {
        const response = await this.request("/portfolio/accounts");
        return response.map((acc) => ({
          id: acc.accountId,
          accountNumber: acc.accountId,
          accountType: acc.type || "trading",
          currency: acc.currency,
          status: "active",
          isPaper: this.config?.isPaper ?? false,
          createdAt: /* @__PURE__ */ new Date()
        }));
      }
      async getAccountBalance(accountId) {
        const accId = accountId || this.accountId;
        if (!accId) {
          const accounts = await this.getAccounts();
          this.accountId = accounts[0]?.id;
        }
        const response = await this.request(`/portfolio/${accId || this.accountId}/summary`);
        return {
          currency: response.currency || "USD",
          cash: response.availablefunds?.amount || 0,
          cashAvailable: response.availablefunds?.amount || 0,
          cashWithdrawable: response.availablefunds?.amount || 0,
          buyingPower: response.buyingpower?.amount || 0,
          portfolioValue: response.netliquidation?.amount || 0,
          equity: response.netliquidation?.amount || 0,
          lastEquity: response.netliquidation?.amount || 0,
          longMarketValue: response.grosspositionvalue?.amount || 0,
          shortMarketValue: 0,
          initialMargin: response.initmarginreq?.amount || 0,
          maintenanceMargin: response.maintmarginreq?.amount || 0
        };
      }
      async getPositions(accountId) {
        const accId = accountId || this.accountId;
        if (!accId) {
          const accounts = await this.getAccounts();
          this.accountId = accounts[0]?.id;
        }
        const response = await this.request(`/portfolio/${accId || this.accountId}/positions/0`);
        return response.map((p) => ({
          symbol: p.ticker || p.contractDesc,
          quantity: Math.abs(p.position),
          side: p.position > 0 ? "long" : "short",
          avgEntryPrice: p.avgCost,
          marketValue: p.mktValue,
          costBasis: p.avgCost * Math.abs(p.position),
          unrealizedPL: p.unrealizedPnl,
          unrealizedPLPercent: p.unrealizedPnl / (p.avgCost * Math.abs(p.position)) * 100,
          currentPrice: p.mktPrice,
          assetClass: this.parseAssetClass(p.assetClass),
          exchange: p.listingExchange
        }));
      }
      // ============================================================================
      // Order Operations
      // ============================================================================
      async placeOrder(order, accountId) {
        const accId = accountId || this.accountId;
        if (!accId) {
          const accounts = await this.getAccounts();
          this.accountId = accounts[0]?.id;
        }
        const conid = await this.getContractId(order.symbol);
        const ibkrOrder = {
          acctId: accId || this.accountId,
          conid,
          orderType: this.toIBKROrderType(order.type),
          side: order.side.toUpperCase(),
          quantity: order.quantity,
          tif: this.toIBKRTimeInForce(order.timeInForce),
          outsideRTH: order.extendedHours || false
        };
        if (order.price) ibkrOrder.price = order.price;
        if (order.stopPrice) ibkrOrder.auxPrice = order.stopPrice;
        if (order.clientOrderId) ibkrOrder.cOID = order.clientOrderId;
        const response = await this.request(`/iserver/account/${accId || this.accountId}/orders`, {
          method: "POST",
          body: JSON.stringify({ orders: [ibkrOrder] })
        });
        if (response[0]?.id === "confirm") {
          const confirmResponse = await this.request(`/iserver/reply/${response[0].id}`, {
            method: "POST",
            body: JSON.stringify({ confirmed: true })
          });
          return this.parseOrderResponse(confirmResponse[0]);
        }
        return this.parseOrderResponse(response[0]);
      }
      async cancelOrder(orderId, accountId) {
        const accId = accountId || this.accountId;
        await this.request(`/iserver/account/${accId}/order/${orderId}`, {
          method: "DELETE"
        });
      }
      async getOrders(params, _accountId) {
        const filters = params?.status === "open" ? "Submitted,PreSubmitted" : params?.status === "closed" ? "Filled,Cancelled" : "";
        const endpoint = filters ? `/iserver/account/orders?filters=${filters}` : "/iserver/account/orders";
        const response = await this.request(endpoint);
        return (response.orders || []).map((o) => this.parseOrderResponse(o));
      }
      async getOrder(orderId, _accountId) {
        const response = await this.request(`/iserver/account/order/status/${orderId}`);
        return this.parseOrderResponse(response);
      }
      // ============================================================================
      // Market Data
      // ============================================================================
      async getQuote(symbol) {
        const conid = await this.getContractId(symbol);
        const response = await this.request(`/iserver/marketdata/snapshot?conids=${conid}&fields=31,84,85,86,87,88`);
        const data = response[0] || {};
        return {
          symbol,
          bidPrice: data["84"] || 0,
          bidSize: data["88"] || 0,
          askPrice: data["86"] || 0,
          askSize: data["85"] || 0,
          lastPrice: data["31"] || 0,
          lastSize: data["87"] || 0,
          volume: data["87"] || 0,
          timestamp: /* @__PURE__ */ new Date()
        };
      }
      async getHistoricalBars(params) {
        const conid = await this.getContractId(params.symbol);
        const period = this.toIBKRPeriod(params.start, params.end);
        const bar = this.toIBKRBarSize(params.timeframe);
        const response = await this.request(
          `/iserver/marketdata/history?conid=${conid}&period=${period}&bar=${bar}`
        );
        return (response.data || []).map((bar2) => ({
          timestamp: new Date(bar2.t * 1e3),
          open: bar2.o,
          high: bar2.h,
          low: bar2.l,
          close: bar2.c,
          volume: bar2.v
        }));
      }
      // ============================================================================
      // Asset Information
      // ============================================================================
      async getAsset(symbol) {
        const response = await this.request(`/iserver/secdef/search?symbol=${symbol}`);
        if (!response || response.length === 0) {
          throw new BrokerError(
            "invalid_symbol" /* INVALID_SYMBOL */,
            `Symbol not found: ${symbol}`,
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        const asset = response[0];
        return {
          id: asset.conid.toString(),
          symbol: asset.symbol,
          name: asset.companyName || asset.description,
          exchange: asset.exchange,
          assetClass: this.parseAssetClass(asset.assetClass),
          status: "active",
          tradable: true,
          marginable: true,
          shortable: true,
          easyToBorrow: true,
          fractionable: false
        };
      }
      async searchAssets(query, _assetClass) {
        const response = await this.request(`/iserver/secdef/search?symbol=${query}`);
        return (response || []).slice(0, 20).map((asset) => ({
          id: asset.conid.toString(),
          symbol: asset.symbol,
          name: asset.companyName || asset.description,
          exchange: asset.exchange,
          assetClass: this.parseAssetClass(asset.assetClass),
          status: "active",
          tradable: true,
          marginable: true,
          shortable: true,
          easyToBorrow: true,
          fractionable: false
        }));
      }
      // ============================================================================
      // Helper Methods
      // ============================================================================
      async getContractId(symbol) {
        const response = await this.request(`/iserver/secdef/search?symbol=${symbol}`);
        if (!response || response.length === 0) {
          throw new BrokerError(
            "invalid_symbol" /* INVALID_SYMBOL */,
            `Symbol not found: ${symbol}`,
            "interactive_brokers" /* INTERACTIVE_BROKERS */
          );
        }
        return response[0].conid;
      }
      toIBKROrderType(type) {
        const mapping = {
          ["market" /* MARKET */]: "MKT",
          ["limit" /* LIMIT */]: "LMT",
          ["stop" /* STOP */]: "STP",
          ["stop_limit" /* STOP_LIMIT */]: "STP LMT",
          ["trailing_stop" /* TRAILING_STOP */]: "TRAIL"
        };
        return mapping[type];
      }
      toIBKRTimeInForce(tif) {
        const mapping = {
          ["day" /* DAY */]: "DAY",
          ["gtc" /* GTC */]: "GTC",
          ["ioc" /* IOC */]: "IOC",
          ["fok" /* FOK */]: "FOK",
          ["opg" /* OPG */]: "OPG",
          ["cls" /* CLS */]: "DAY"
        };
        return mapping[tif];
      }
      toIBKRPeriod(start, end) {
        const endDate = end || /* @__PURE__ */ new Date();
        const diffDays = Math.ceil((endDate.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24));
        if (diffDays <= 1) return "1d";
        if (diffDays <= 7) return "1w";
        if (diffDays <= 30) return "1m";
        if (diffDays <= 90) return "3m";
        if (diffDays <= 180) return "6m";
        if (diffDays <= 365) return "1y";
        return "5y";
      }
      toIBKRBarSize(timeframe) {
        const mapping = {
          "1Min": "1min",
          "5Min": "5min",
          "15Min": "15min",
          "30Min": "30min",
          "1Hour": "1h",
          "4Hour": "4h",
          "1Day": "1d",
          "1Week": "1w",
          "1Month": "1m"
        };
        return mapping[timeframe] || "1d";
      }
      parseAssetClass(assetClass) {
        const mapping = {
          "STK": "us_equity" /* US_EQUITY */,
          "OPT": "options" /* OPTIONS */,
          "FUT": "futures" /* FUTURES */,
          "CASH": "forex" /* FOREX */,
          "CRYPTO": "crypto" /* CRYPTO */
        };
        return mapping[assetClass] || "us_equity" /* US_EQUITY */;
      }
      parseOrderResponse(order) {
        return {
          id: order.orderId?.toString() || order.order_id?.toString(),
          clientOrderId: order.cOID,
          symbol: order.ticker || order.symbol,
          side: order.side?.toLowerCase() || "buy",
          type: this.parseOrderType(order.orderType),
          quantity: order.totalSize || order.quantity || 0,
          filledQuantity: order.filledQuantity || 0,
          price: order.price,
          stopPrice: order.auxPrice,
          avgFillPrice: order.avgPrice,
          status: this.parseOrderStatus(order.status),
          timeInForce: this.parseTimeInForce(order.tif),
          extendedHours: order.outsideRTH || false,
          createdAt: new Date(order.lastExecutionTime_r || Date.now()),
          updatedAt: new Date(order.lastExecutionTime_r || Date.now()),
          assetClass: "us_equity" /* US_EQUITY */
        };
      }
      parseOrderType(type) {
        const mapping = {
          "MKT": "market" /* MARKET */,
          "LMT": "limit" /* LIMIT */,
          "STP": "stop" /* STOP */,
          "STP LMT": "stop_limit" /* STOP_LIMIT */,
          "TRAIL": "trailing_stop" /* TRAILING_STOP */
        };
        return mapping[type] || "market" /* MARKET */;
      }
      parseOrderStatus(status) {
        const mapping = {
          "Submitted": "accepted" /* ACCEPTED */,
          "PreSubmitted": "pending" /* PENDING */,
          "Filled": "filled" /* FILLED */,
          "Cancelled": "cancelled" /* CANCELLED */,
          "Inactive": "rejected" /* REJECTED */,
          "PendingSubmit": "pending" /* PENDING */,
          "PendingCancel": "pending" /* PENDING */
        };
        return mapping[status] || "new" /* NEW */;
      }
      parseTimeInForce(tif) {
        const mapping = {
          "DAY": "day" /* DAY */,
          "GTC": "gtc" /* GTC */,
          "IOC": "ioc" /* IOC */,
          "FOK": "fok" /* FOK */,
          "OPG": "opg" /* OPG */
        };
        return mapping[tif] || "day" /* DAY */;
      }
      // ============================================================================
      // Symbol Mapping
      // ============================================================================
      normalizeSymbol(brokerSymbol) {
        return brokerSymbol.toUpperCase();
      }
      toBrokerSymbol(normalizedSymbol) {
        return normalizedSymbol.toUpperCase();
      }
    };
  }
});

// server/services/brokers/BinanceBrokerAdapter.ts
import crypto3 from "crypto";
var BINANCE_API_URL, BINANCE_TESTNET_URL, BinanceBrokerAdapter;
var init_BinanceBrokerAdapter = __esm({
  "server/services/brokers/BinanceBrokerAdapter.ts"() {
    "use strict";
    init_types();
    init_IBrokerAdapter();
    BINANCE_API_URL = "https://api.binance.com";
    BINANCE_TESTNET_URL = "https://testnet.binance.vision";
    BinanceBrokerAdapter = class extends BaseBrokerAdapter {
      apiKey = "";
      secretKey = "";
      baseUrl = BINANCE_API_URL;
      accountInfo = null;
      getBrokerType() {
        return "binance" /* BINANCE */;
      }
      getCapabilities() {
        return {
          supportedAssetClasses: ["crypto" /* CRYPTO */],
          supportedOrderTypes: ["market" /* MARKET */, "limit" /* LIMIT */, "stop" /* STOP */, "stop_limit" /* STOP_LIMIT */],
          supportedTimeInForce: ["day" /* DAY */, "gtc" /* GTC */, "ioc" /* IOC */, "fok" /* FOK */],
          supportsExtendedHours: true,
          // 24/7 crypto trading
          supportsFractionalShares: true,
          supportsShortSelling: true,
          // Via margin trading
          supportsMarginTrading: true,
          supportsOptionsTrading: false,
          supportsCryptoTrading: true,
          supportsForexTrading: false,
          supportsPaperTrading: true,
          // Testnet
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 600
        };
      }
      async initialize(credentials) {
        const binanceCredentials = credentials;
        this.apiKey = binanceCredentials.apiKey;
        this.secretKey = binanceCredentials.secretKey;
        this.baseUrl = binanceCredentials.testnet ? BINANCE_TESTNET_URL : BINANCE_API_URL;
        this.credentials = credentials;
        this.connected = true;
      }
      // ============================================================================
      // Signature Generation
      // ============================================================================
      generateSignature(queryString) {
        return crypto3.createHmac("sha256", this.secretKey).update(queryString).digest("hex");
      }
      buildSignedUrl(endpoint, params = {}) {
        const timestamp2 = Date.now();
        const queryParams = new URLSearchParams({
          ...params,
          timestamp: timestamp2.toString()
        });
        const queryString = queryParams.toString();
        const signature = this.generateSignature(queryString);
        return `${this.baseUrl}${endpoint}?${queryString}&signature=${signature}`;
      }
      async makeRequest(endpoint, method = "GET", params = {}, signed = true) {
        let url;
        const headers = {
          "X-MBX-APIKEY": this.apiKey,
          "Content-Type": "application/json"
        };
        if (signed) {
          url = this.buildSignedUrl(endpoint, params);
        } else {
          const queryString = new URLSearchParams(params).toString();
          url = `${this.baseUrl}${endpoint}${queryString ? "?" + queryString : ""}`;
        }
        const response = await fetch(url, {
          method,
          headers
        });
        if (!response.ok) {
          const error = await response.json().catch(() => ({ msg: response.statusText }));
          throw new Error(`Binance API error: ${error.msg || response.statusText}`);
        }
        return response.json();
      }
      // ============================================================================
      // OAuth (Not applicable for Binance - uses API keys)
      // ============================================================================
      getAuthorizationUrl(_state, _isPaper) {
        return "https://www.binance.com/en/my/settings/api-management";
      }
      async handleOAuthCallback(_code, _state, _verifier) {
        throw new Error("Binance uses API key authentication, not OAuth");
      }
      async refreshAccessToken() {
        return {
          accessToken: this.apiKey,
          refreshToken: "",
          expiresIn: 0,
          tokenType: "apikey"
        };
      }
      // ============================================================================
      // Account Operations
      // ============================================================================
      async getAccounts() {
        const accountInfo = await this.makeRequest("/api/v3/account");
        this.accountInfo = accountInfo;
        let totalBalance = 0;
        for (const balance of accountInfo.balances) {
          const free = parseFloat(balance.free);
          const locked = parseFloat(balance.locked);
          if (free > 0 || locked > 0) {
            if (balance.asset === "USDT" || balance.asset === "BUSD" || balance.asset === "USD") {
              totalBalance += free + locked;
            }
          }
        }
        return [{
          id: "binance-spot",
          accountNumber: "binance-spot",
          accountType: "spot",
          currency: "USD",
          status: accountInfo.canTrade ? "active" : "restricted",
          isPaper: this.baseUrl === BINANCE_TESTNET_URL,
          createdAt: new Date(accountInfo.updateTime)
        }];
      }
      async getAccountBalance(_accountId) {
        const accountInfo = await this.makeRequest("/api/v3/account");
        this.accountInfo = accountInfo;
        let totalEquity = 0;
        let availableCash = 0;
        for (const balance of accountInfo.balances) {
          const free = parseFloat(balance.free);
          const locked = parseFloat(balance.locked);
          if (balance.asset === "USDT" || balance.asset === "BUSD" || balance.asset === "USD") {
            availableCash += free;
            totalEquity += free + locked;
          }
        }
        return {
          currency: "USD",
          cash: availableCash,
          cashAvailable: availableCash,
          cashWithdrawable: availableCash,
          buyingPower: availableCash,
          portfolioValue: totalEquity,
          equity: totalEquity,
          lastEquity: totalEquity,
          longMarketValue: totalEquity,
          shortMarketValue: 0,
          initialMargin: 0,
          maintenanceMargin: 0,
          dayTradeCount: 0,
          patternDayTrader: false
        };
      }
      async getPositions(_accountId) {
        const accountInfo = await this.makeRequest("/api/v3/account");
        const positions = [];
        for (const balance of accountInfo.balances) {
          const free = parseFloat(balance.free);
          const locked = parseFloat(balance.locked);
          const total = free + locked;
          if (total > 0 && balance.asset !== "USDT" && balance.asset !== "BUSD" && balance.asset !== "USD") {
            let currentPrice = 0;
            let marketValue = 0;
            try {
              const ticker = await this.makeRequest(
                "/api/v3/ticker/price",
                "GET",
                { symbol: `${balance.asset}USDT` },
                false
              );
              currentPrice = parseFloat(ticker.price);
              marketValue = total * currentPrice;
            } catch {
              continue;
            }
            positions.push({
              symbol: balance.asset,
              quantity: total,
              side: "long",
              avgEntryPrice: 0,
              // Binance doesn't provide average entry price
              currentPrice,
              marketValue,
              costBasis: 0,
              unrealizedPL: 0,
              // Would need historical data to calculate
              unrealizedPLPercent: 0,
              assetClass: "crypto" /* CRYPTO */,
              exchange: "BINANCE"
            });
          }
        }
        return positions;
      }
      // ============================================================================
      // Order Operations
      // ============================================================================
      async placeOrder(order, _accountId) {
        const binanceSymbol = this.toBrokerSymbol(order.symbol);
        const params = {
          symbol: binanceSymbol,
          side: order.side.toUpperCase(),
          type: this.mapOrderType(order.type),
          quantity: order.quantity.toString()
        };
        if (order.type === "limit" || order.type === "stop_limit") {
          params.price = order.price.toString();
          params.timeInForce = this.mapTimeInForce(order.timeInForce || "gtc");
        }
        if (order.type === "stop" || order.type === "stop_limit") {
          params.stopPrice = order.stopPrice.toString();
        }
        if (order.clientOrderId) {
          params.newClientOrderId = order.clientOrderId;
        }
        const response = await this.makeRequest("/api/v3/order", "POST", params);
        return this.mapBinanceOrder(response);
      }
      async cancelOrder(orderId, _accountId) {
        const [symbol, binanceOrderId] = orderId.split(":");
        await this.makeRequest("/api/v3/order", "DELETE", {
          symbol,
          orderId: binanceOrderId
        });
      }
      async getOrders(params, _accountId) {
        const orders = [];
        if (params?.status === "open" || params?.status === "all") {
          const openOrders = await this.makeRequest("/api/v3/openOrders");
          orders.push(...openOrders.map((o) => this.mapBinanceOrder(o)));
        }
        if (params?.status === "closed" || params?.status === "all") {
          const symbols = params?.symbols || ["BTCUSDT", "ETHUSDT"];
          for (const symbol of symbols) {
            try {
              const allOrders = await this.makeRequest("/api/v3/allOrders", "GET", {
                symbol,
                limit: params?.limit || 100
              });
              const closedOrders = allOrders.filter(
                (o) => o.status === "FILLED" || o.status === "CANCELED" || o.status === "EXPIRED"
              );
              orders.push(...closedOrders.map((o) => this.mapBinanceOrder(o)));
            } catch {
            }
          }
        }
        return orders;
      }
      async getOrder(orderId, _accountId) {
        const [symbol, binanceOrderId] = orderId.split(":");
        const order = await this.makeRequest("/api/v3/order", "GET", {
          symbol,
          orderId: binanceOrderId
        });
        return this.mapBinanceOrder(order);
      }
      // ============================================================================
      // Market Data
      // ============================================================================
      async getQuote(symbol) {
        const binanceSymbol = this.toBrokerSymbol(symbol);
        const ticker = await this.makeRequest(
          "/api/v3/ticker/24hr",
          "GET",
          { symbol: binanceSymbol },
          false
        );
        return {
          symbol: this.normalizeSymbol(ticker.symbol),
          bidPrice: parseFloat(ticker.bidPrice),
          bidSize: parseFloat(ticker.bidQty),
          askPrice: parseFloat(ticker.askPrice),
          askSize: parseFloat(ticker.askQty),
          lastPrice: parseFloat(ticker.lastPrice),
          lastSize: parseFloat(ticker.lastQty),
          volume: parseFloat(ticker.volume),
          timestamp: new Date(ticker.closeTime)
        };
      }
      async getHistoricalBars(params) {
        const binanceSymbol = this.toBrokerSymbol(params.symbol);
        const interval = this.mapTimeframe(params.timeframe);
        const requestParams = {
          symbol: binanceSymbol,
          interval,
          limit: params.limit || 500
        };
        if (params.start) {
          requestParams.startTime = params.start.getTime();
        }
        if (params.end) {
          requestParams.endTime = params.end.getTime();
        }
        const klines = await this.makeRequest(
          "/api/v3/klines",
          "GET",
          requestParams,
          false
        );
        return klines.map((k) => ({
          symbol: params.symbol,
          timestamp: new Date(k[0]),
          open: parseFloat(k[1]),
          high: parseFloat(k[2]),
          low: parseFloat(k[3]),
          close: parseFloat(k[4]),
          volume: parseFloat(k[5]),
          vwap: 0,
          tradeCount: k[8]
        }));
      }
      // ============================================================================
      // Asset Information
      // ============================================================================
      async getAsset(symbol) {
        const binanceSymbol = this.toBrokerSymbol(symbol);
        const exchangeInfo = await this.makeRequest("/api/v3/exchangeInfo", "GET", { symbol: binanceSymbol }, false);
        const symbolInfo = exchangeInfo.symbols.find((s) => s.symbol === binanceSymbol);
        if (!symbolInfo) {
          throw new Error(`Asset not found: ${symbol}`);
        }
        const lotSizeFilter = symbolInfo.filters.find((f) => f.filterType === "LOT_SIZE");
        const minQty = lotSizeFilter ? parseFloat(lotSizeFilter.minQty) : 0;
        return {
          id: symbolInfo.symbol,
          symbol: this.normalizeSymbol(symbolInfo.symbol),
          name: `${symbolInfo.baseAsset}/${symbolInfo.quoteAsset}`,
          exchange: "BINANCE",
          assetClass: "crypto" /* CRYPTO */,
          status: symbolInfo.status === "TRADING" ? "active" : "inactive",
          tradable: symbolInfo.status === "TRADING",
          shortable: true,
          marginable: true,
          easyToBorrow: false,
          fractionable: true,
          minOrderSize: minQty,
          minPriceIncrement: Math.pow(10, -symbolInfo.quoteAssetPrecision)
        };
      }
      // ============================================================================
      // Symbol Mapping
      // ============================================================================
      normalizeSymbol(brokerSymbol) {
        if (brokerSymbol.endsWith("USDT")) {
          return brokerSymbol.replace("USDT", "/USDT");
        }
        if (brokerSymbol.endsWith("BTC")) {
          return brokerSymbol.replace("BTC", "/BTC");
        }
        if (brokerSymbol.endsWith("ETH")) {
          return brokerSymbol.replace("ETH", "/ETH");
        }
        return brokerSymbol;
      }
      toBrokerSymbol(normalizedSymbol) {
        return normalizedSymbol.replace("/", "").toUpperCase();
      }
      // ============================================================================
      // Helper Methods
      // ============================================================================
      mapOrderType(type) {
        const mapping = {
          ["market" /* MARKET */]: "MARKET",
          ["limit" /* LIMIT */]: "LIMIT",
          ["stop" /* STOP */]: "STOP_LOSS",
          ["stop_limit" /* STOP_LIMIT */]: "STOP_LOSS_LIMIT",
          ["trailing_stop" /* TRAILING_STOP */]: "TRAILING_STOP_MARKET"
        };
        return mapping[type] || "MARKET";
      }
      mapTimeInForce(tif) {
        const mapping = {
          ["day" /* DAY */]: "GTC",
          // Binance doesn't have DAY, use GTC
          ["gtc" /* GTC */]: "GTC",
          ["ioc" /* IOC */]: "IOC",
          ["fok" /* FOK */]: "FOK",
          ["opg" /* OPG */]: "GTC",
          ["cls" /* CLS */]: "GTC"
        };
        return mapping[tif] || "GTC";
      }
      mapTimeframe(timeframe) {
        const mapping = {
          "1Min": "1m",
          "5Min": "5m",
          "15Min": "15m",
          "30Min": "30m",
          "1Hour": "1h",
          "4Hour": "4h",
          "1Day": "1d",
          "1Week": "1w",
          "1Month": "1M"
        };
        return mapping[timeframe] || "1d";
      }
      mapBinanceOrderStatus(status) {
        const mapping = {
          NEW: "pending" /* PENDING */,
          PARTIALLY_FILLED: "partially_filled" /* PARTIALLY_FILLED */,
          FILLED: "filled" /* FILLED */,
          CANCELED: "cancelled" /* CANCELLED */,
          PENDING_CANCEL: "pending" /* PENDING */,
          REJECTED: "rejected" /* REJECTED */,
          EXPIRED: "expired" /* EXPIRED */
        };
        return mapping[status] || "pending" /* PENDING */;
      }
      mapBinanceOrder(order) {
        return {
          id: `${order.symbol}:${order.orderId}`,
          clientOrderId: order.clientOrderId,
          symbol: this.normalizeSymbol(order.symbol),
          side: order.side.toLowerCase(),
          type: this.mapBinanceOrderType(order.type),
          status: this.mapBinanceOrderStatus(order.status),
          quantity: parseFloat(order.origQty),
          filledQuantity: parseFloat(order.executedQty),
          price: parseFloat(order.price),
          avgFillPrice: parseFloat(order.cummulativeQuoteQty) / parseFloat(order.executedQty) || 0,
          extendedHours: false,
          assetClass: "crypto" /* CRYPTO */,
          stopPrice: order.stopPrice ? parseFloat(order.stopPrice) : void 0,
          timeInForce: order.timeInForce.toLowerCase(),
          createdAt: new Date(order.time),
          updatedAt: new Date(order.updateTime),
          filledAt: order.status === "FILLED" ? new Date(order.updateTime) : void 0
        };
      }
      mapBinanceOrderType(type) {
        const mapping = {
          MARKET: "market" /* MARKET */,
          LIMIT: "limit" /* LIMIT */,
          STOP_LOSS: "stop" /* STOP */,
          STOP_LOSS_LIMIT: "stop_limit" /* STOP_LIMIT */,
          TAKE_PROFIT: "stop" /* STOP */,
          TAKE_PROFIT_LIMIT: "stop_limit" /* STOP_LIMIT */,
          TRAILING_STOP_MARKET: "trailing_stop" /* TRAILING_STOP */
        };
        return mapping[type] || "market" /* MARKET */;
      }
    };
  }
});

// server/services/brokers/CoinbaseBrokerAdapter.ts
import crypto4 from "crypto";
var COINBASE_API_URL, COINBASE_SANDBOX_URL, CoinbaseBrokerAdapter;
var init_CoinbaseBrokerAdapter = __esm({
  "server/services/brokers/CoinbaseBrokerAdapter.ts"() {
    "use strict";
    init_types();
    init_IBrokerAdapter();
    COINBASE_API_URL = "https://api.coinbase.com";
    COINBASE_SANDBOX_URL = "https://api-sandbox.coinbase.com";
    CoinbaseBrokerAdapter = class extends BaseBrokerAdapter {
      apiKeyId = "";
      apiKeySecret = "";
      baseUrl = COINBASE_API_URL;
      getBrokerType() {
        return "coinbase" /* COINBASE */;
      }
      getCapabilities() {
        return {
          supportedAssetClasses: ["crypto" /* CRYPTO */],
          supportedOrderTypes: ["market" /* MARKET */, "limit" /* LIMIT */, "stop" /* STOP */, "stop_limit" /* STOP_LIMIT */],
          supportedTimeInForce: ["gtc" /* GTC */, "ioc" /* IOC */, "fok" /* FOK */],
          supportsExtendedHours: true,
          // 24/7 crypto trading
          supportsFractionalShares: true,
          supportsShortSelling: false,
          supportsMarginTrading: false,
          supportsOptionsTrading: false,
          supportsCryptoTrading: true,
          supportsForexTrading: false,
          supportsPaperTrading: true,
          // Sandbox
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 100
        };
      }
      async initialize(credentials) {
        const coinbaseCredentials = credentials;
        this.apiKeyId = coinbaseCredentials.apiKeyId;
        this.apiKeySecret = coinbaseCredentials.apiKeySecret;
        this.baseUrl = coinbaseCredentials.sandbox ? COINBASE_SANDBOX_URL : COINBASE_API_URL;
        this.credentials = credentials;
        this.connected = true;
      }
      // ============================================================================
      // JWT Generation
      // ============================================================================
      generateJWT(method, path3) {
        const timestamp2 = Math.floor(Date.now() / 1e3);
        const uri = `${method} ${new URL(path3, this.baseUrl).host}${path3}`;
        const header = {
          alg: "ES256",
          typ: "JWT",
          kid: this.apiKeyId,
          nonce: crypto4.randomBytes(16).toString("hex")
        };
        const payload = {
          sub: this.apiKeyId,
          iss: "cdp",
          nbf: timestamp2,
          exp: timestamp2 + 120,
          // 2 minutes expiry
          uri
        };
        const encodedHeader = Buffer.from(JSON.stringify(header)).toString("base64url");
        const encodedPayload = Buffer.from(JSON.stringify(payload)).toString("base64url");
        const message = `${encodedHeader}.${encodedPayload}`;
        const sign = crypto4.createSign("SHA256");
        sign.update(message);
        const signature = sign.sign(this.apiKeySecret, "base64url");
        return `${message}.${signature}`;
      }
      async makeRequest(endpoint, method = "GET", body) {
        const jwt2 = this.generateJWT(method, endpoint);
        const headers = {
          "Authorization": `Bearer ${jwt2}`,
          "Content-Type": "application/json"
        };
        const options = {
          method,
          headers
        };
        if (body) {
          options.body = JSON.stringify(body);
        }
        const response = await fetch(`${this.baseUrl}${endpoint}`, options);
        if (!response.ok) {
          const error = await response.json().catch(() => ({ message: response.statusText }));
          throw new Error(`Coinbase API error: ${error.message || response.statusText}`);
        }
        return response.json();
      }
      // ============================================================================
      // OAuth (Coinbase supports OAuth 2.0)
      // ============================================================================
      getAuthorizationUrl(state, _isPaper) {
        const params = new URLSearchParams({
          response_type: "code",
          client_id: this.apiKeyId,
          redirect_uri: process.env.COINBASE_REDIRECT_URI || "",
          state,
          scope: "wallet:accounts:read wallet:orders:create wallet:orders:read wallet:trades:read"
        });
        return `https://www.coinbase.com/oauth/authorize?${params.toString()}`;
      }
      async handleOAuthCallback(code, _state, _verifier) {
        const response = await fetch("https://api.coinbase.com/oauth/token", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            grant_type: "authorization_code",
            code,
            client_id: this.apiKeyId,
            client_secret: this.apiKeySecret,
            redirect_uri: process.env.COINBASE_REDIRECT_URI || ""
          })
        });
        if (!response.ok) {
          throw new Error("Failed to exchange authorization code");
        }
        const data = await response.json();
        return {
          accessToken: data.access_token,
          refreshToken: data.refresh_token,
          expiresIn: data.expires_in,
          tokenType: data.token_type,
          scope: data.scope
        };
      }
      async refreshAccessToken() {
        const oauth = this.credentials;
        if (!oauth?.refreshToken) {
          throw new Error("No refresh token available");
        }
        const response = await fetch("https://api.coinbase.com/oauth/token", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            grant_type: "refresh_token",
            refresh_token: oauth.refreshToken,
            client_id: this.apiKeyId,
            client_secret: this.apiKeySecret
          })
        });
        if (!response.ok) {
          throw new Error("Failed to refresh access token");
        }
        const data = await response.json();
        return {
          accessToken: data.access_token,
          refreshToken: data.refresh_token,
          expiresIn: data.expires_in,
          tokenType: data.token_type
        };
      }
      // ============================================================================
      // Account Operations
      // ============================================================================
      async getAccounts() {
        const response = await this.makeRequest(
          "/api/v3/brokerage/accounts"
        );
        return response.accounts.map((account) => ({
          id: account.uuid,
          accountNumber: account.uuid,
          accountType: account.type,
          currency: account.currency,
          status: account.active ? "active" : "inactive",
          isPaper: this.baseUrl === COINBASE_SANDBOX_URL,
          createdAt: new Date(account.created_at)
        }));
      }
      async getAccountBalance(_accountId) {
        const response = await this.makeRequest(
          "/api/v3/brokerage/accounts"
        );
        let totalEquity = 0;
        let availableCash = 0;
        for (const account of response.accounts) {
          const available = parseFloat(account.available_balance.value);
          const held = parseFloat(account.hold.value);
          if (account.currency === "USD" || account.currency === "USDC") {
            availableCash += available;
            totalEquity += available + held;
          }
        }
        return {
          currency: "USD",
          cash: availableCash,
          cashAvailable: availableCash,
          cashWithdrawable: availableCash,
          buyingPower: availableCash,
          portfolioValue: totalEquity,
          equity: totalEquity,
          lastEquity: totalEquity,
          longMarketValue: totalEquity,
          shortMarketValue: 0,
          initialMargin: 0,
          maintenanceMargin: 0,
          dayTradeCount: 0,
          patternDayTrader: false
        };
      }
      async getPositions(_accountId) {
        const response = await this.makeRequest(
          "/api/v3/brokerage/accounts"
        );
        const positions = [];
        for (const account of response.accounts) {
          const available = parseFloat(account.available_balance.value);
          const held = parseFloat(account.hold.value);
          const total = available + held;
          if (total > 0 && account.currency !== "USD" && account.currency !== "USDC") {
            let currentPrice = 0;
            let marketValue = 0;
            try {
              const product = await this.makeRequest(
                `/api/v3/brokerage/products/${account.currency}-USD`
              );
              if (product.products && product.products[0]) {
                currentPrice = parseFloat(product.products[0].price);
                marketValue = total * currentPrice;
              }
            } catch {
              try {
                const product = await this.makeRequest(
                  `/api/v3/brokerage/products/${account.currency}-USDC`
                );
                if (product.products && product.products[0]) {
                  currentPrice = parseFloat(product.products[0].price);
                  marketValue = total * currentPrice;
                }
              } catch {
                continue;
              }
            }
            positions.push({
              symbol: account.currency,
              quantity: total,
              side: "long",
              avgEntryPrice: 0,
              // Coinbase doesn't provide average entry price
              currentPrice,
              marketValue,
              costBasis: 0,
              unrealizedPL: 0,
              unrealizedPLPercent: 0,
              assetClass: "crypto" /* CRYPTO */,
              exchange: "COINBASE"
            });
          }
        }
        return positions;
      }
      // ============================================================================
      // Order Operations
      // ============================================================================
      async placeOrder(order, _accountId) {
        const productId = this.toBrokerSymbol(order.symbol);
        const orderConfig = {};
        if (order.type === "market" /* MARKET */) {
          orderConfig.market_market_ioc = {
            base_size: order.quantity.toString()
          };
        } else if (order.type === "limit" /* LIMIT */) {
          if (order.timeInForce === "gtc" /* GTC */) {
            orderConfig.limit_limit_gtc = {
              base_size: order.quantity.toString(),
              limit_price: order.price.toString(),
              post_only: false
            };
          } else {
            orderConfig.limit_limit_gtd = {
              base_size: order.quantity.toString(),
              limit_price: order.price.toString(),
              end_time: new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString(),
              post_only: false
            };
          }
        } else if (order.type === "stop_limit" /* STOP_LIMIT */) {
          orderConfig.stop_limit_stop_limit_gtc = {
            base_size: order.quantity.toString(),
            limit_price: order.price.toString(),
            stop_price: order.stopPrice.toString(),
            stop_direction: order.side === "buy" /* BUY */ ? "STOP_DIRECTION_STOP_UP" : "STOP_DIRECTION_STOP_DOWN"
          };
        }
        const body = {
          client_order_id: order.clientOrderId || crypto4.randomUUID(),
          product_id: productId,
          side: order.side === "buy" /* BUY */ ? "BUY" : "SELL",
          order_configuration: orderConfig
        };
        const response = await this.makeRequest(
          "/api/v3/brokerage/orders",
          "POST",
          body
        );
        return this.mapCoinbaseOrder(response.order);
      }
      async cancelOrder(orderId, _accountId) {
        await this.makeRequest(
          "/api/v3/brokerage/orders/batch_cancel",
          "POST",
          { order_ids: [orderId] }
        );
      }
      async getOrders(params, _accountId) {
        const queryParams = {};
        if (params?.status === "open") {
          queryParams.order_status = "OPEN";
        } else if (params?.status === "closed") {
          queryParams.order_status = "FILLED,CANCELLED,EXPIRED,FAILED";
        }
        if (params?.limit) {
          queryParams.limit = params.limit.toString();
        }
        if (params?.symbols && params.symbols.length > 0) {
          queryParams.product_ids = params.symbols.map((s) => this.toBrokerSymbol(s)).join(",");
        }
        const queryString = new URLSearchParams(queryParams).toString();
        const endpoint = `/api/v3/brokerage/orders/historical/batch${queryString ? "?" + queryString : ""}`;
        const response = await this.makeRequest(endpoint);
        return response.orders.map((o) => this.mapCoinbaseOrder(o));
      }
      async getOrder(orderId, _accountId) {
        const response = await this.makeRequest(
          `/api/v3/brokerage/orders/historical/${orderId}`
        );
        return this.mapCoinbaseOrder(response.order);
      }
      // ============================================================================
      // Market Data
      // ============================================================================
      async getQuote(symbol) {
        const productId = this.toBrokerSymbol(symbol);
        const response = await this.makeRequest(
          `/api/v3/brokerage/products/${productId}/ticker`
        );
        const latestTrade = response.trades[0];
        return {
          symbol: this.normalizeSymbol(productId),
          bidPrice: parseFloat(response.best_bid),
          bidSize: 0,
          askPrice: parseFloat(response.best_ask),
          askSize: 0,
          lastPrice: latestTrade ? parseFloat(latestTrade.price) : 0,
          lastSize: latestTrade ? parseFloat(latestTrade.size) : 0,
          volume: 0,
          timestamp: latestTrade ? new Date(latestTrade.time) : /* @__PURE__ */ new Date()
        };
      }
      async getHistoricalBars(params) {
        const productId = this.toBrokerSymbol(params.symbol);
        const granularity = this.mapTimeframe(params.timeframe);
        const queryParams = {
          granularity
        };
        if (params.start) {
          queryParams.start = Math.floor(params.start.getTime() / 1e3).toString();
        }
        if (params.end) {
          queryParams.end = Math.floor(params.end.getTime() / 1e3).toString();
        }
        const queryString = new URLSearchParams(queryParams).toString();
        const response = await this.makeRequest(
          `/api/v3/brokerage/products/${productId}/candles?${queryString}`
        );
        return response.candles.map((candle) => ({
          timestamp: new Date(parseInt(candle.start) * 1e3),
          open: parseFloat(candle.open),
          high: parseFloat(candle.high),
          low: parseFloat(candle.low),
          close: parseFloat(candle.close),
          volume: parseFloat(candle.volume)
        }));
      }
      // ============================================================================
      // Asset Information
      // ============================================================================
      async getAsset(symbol) {
        const productId = this.toBrokerSymbol(symbol);
        const response = await this.makeRequest(
          `/api/v3/brokerage/products/${productId}`
        );
        return {
          id: response.product_id,
          symbol: this.normalizeSymbol(response.product_id),
          name: `${response.base_name}/${response.quote_name}`,
          exchange: "COINBASE",
          assetClass: "crypto" /* CRYPTO */,
          status: response.status === "online" ? "active" : "inactive",
          tradable: !response.trading_disabled && !response.is_disabled,
          shortable: false,
          marginable: false,
          easyToBorrow: false,
          fractionable: true,
          minOrderSize: parseFloat(response.base_min_size),
          minPriceIncrement: parseFloat(response.quote_increment)
        };
      }
      // ============================================================================
      // Symbol Mapping
      // ============================================================================
      normalizeSymbol(brokerSymbol) {
        return brokerSymbol.replace("-", "/");
      }
      toBrokerSymbol(normalizedSymbol) {
        return normalizedSymbol.replace("/", "-").toUpperCase();
      }
      // ============================================================================
      // Helper Methods
      // ============================================================================
      mapTimeframe(timeframe) {
        const mapping = {
          "1Min": "ONE_MINUTE",
          "5Min": "FIVE_MINUTE",
          "15Min": "FIFTEEN_MINUTE",
          "30Min": "THIRTY_MINUTE",
          "1Hour": "ONE_HOUR",
          "2Hour": "TWO_HOUR",
          "6Hour": "SIX_HOUR",
          "1Day": "ONE_DAY"
        };
        return mapping[timeframe] || "ONE_DAY";
      }
      mapCoinbaseOrderStatus(status) {
        const mapping = {
          PENDING: "pending" /* PENDING */,
          OPEN: "accepted" /* ACCEPTED */,
          FILLED: "filled" /* FILLED */,
          CANCELLED: "cancelled" /* CANCELLED */,
          EXPIRED: "expired" /* EXPIRED */,
          FAILED: "rejected" /* REJECTED */
        };
        return mapping[status] || "pending" /* PENDING */;
      }
      mapCoinbaseOrder(order) {
        let orderType = "market" /* MARKET */;
        let price;
        let stopPrice;
        let quantity = 0;
        let timeInForce = "gtc" /* GTC */;
        if (order.order_configuration.market_market_ioc) {
          orderType = "market" /* MARKET */;
          quantity = parseFloat(order.order_configuration.market_market_ioc.base_size || "0");
          timeInForce = "ioc" /* IOC */;
        } else if (order.order_configuration.limit_limit_gtc) {
          orderType = "limit" /* LIMIT */;
          quantity = parseFloat(order.order_configuration.limit_limit_gtc.base_size);
          price = parseFloat(order.order_configuration.limit_limit_gtc.limit_price);
          timeInForce = "gtc" /* GTC */;
        } else if (order.order_configuration.limit_limit_gtd) {
          orderType = "limit" /* LIMIT */;
          quantity = parseFloat(order.order_configuration.limit_limit_gtd.base_size);
          price = parseFloat(order.order_configuration.limit_limit_gtd.limit_price);
          timeInForce = "day" /* DAY */;
        } else if (order.order_configuration.stop_limit_stop_limit_gtc) {
          orderType = "stop_limit" /* STOP_LIMIT */;
          quantity = parseFloat(order.order_configuration.stop_limit_stop_limit_gtc.base_size);
          price = parseFloat(order.order_configuration.stop_limit_stop_limit_gtc.limit_price);
          stopPrice = parseFloat(order.order_configuration.stop_limit_stop_limit_gtc.stop_price);
          timeInForce = "gtc" /* GTC */;
        } else if (order.order_configuration.stop_limit_stop_limit_gtd) {
          orderType = "stop_limit" /* STOP_LIMIT */;
          quantity = parseFloat(order.order_configuration.stop_limit_stop_limit_gtd.base_size);
          price = parseFloat(order.order_configuration.stop_limit_stop_limit_gtd.limit_price);
          stopPrice = parseFloat(order.order_configuration.stop_limit_stop_limit_gtd.stop_price);
          timeInForce = "day" /* DAY */;
        }
        return {
          id: order.order_id,
          clientOrderId: order.client_order_id,
          symbol: this.normalizeSymbol(order.product_id),
          side: order.side.toLowerCase() === "buy" ? "buy" /* BUY */ : "sell" /* SELL */,
          type: orderType,
          status: this.mapCoinbaseOrderStatus(order.status),
          quantity,
          filledQuantity: parseFloat(order.filled_size),
          price,
          stopPrice,
          avgFillPrice: parseFloat(order.average_filled_price) || void 0,
          timeInForce,
          extendedHours: false,
          assetClass: "crypto" /* CRYPTO */,
          createdAt: new Date(order.created_time),
          updatedAt: new Date(order.created_time),
          filledAt: order.status === "FILLED" ? new Date(order.created_time) : void 0
        };
      }
    };
  }
});

// server/services/brokers/SchwabAdapter.ts
var SchwabAdapter;
var init_SchwabAdapter = __esm({
  "server/services/brokers/SchwabAdapter.ts"() {
    "use strict";
    init_IBrokerAdapter();
    init_types();
    SchwabAdapter = class extends BaseBrokerAdapter {
      config;
      accessToken = null;
      refreshToken = null;
      tokenExpiresAt = 0;
      accountHash = null;
      // API endpoints
      AUTH_URL = "https://api.schwabapi.com/v1/oauth/authorize";
      TOKEN_URL = "https://api.schwabapi.com/v1/oauth/token";
      API_BASE = "https://api.schwabapi.com";
      constructor(config) {
        super();
        this.config = config;
      }
      // ============================================================================
      // Broker Info
      // ============================================================================
      getBrokerType() {
        return "schwab" /* SCHWAB */;
      }
      getCapabilities() {
        return {
          supportedAssetClasses: ["us_equity" /* US_EQUITY */, "options" /* OPTIONS */],
          supportedOrderTypes: [
            "market" /* MARKET */,
            "limit" /* LIMIT */,
            "stop" /* STOP */,
            "stop_limit" /* STOP_LIMIT */,
            "trailing_stop" /* TRAILING_STOP */
          ],
          supportedTimeInForce: [
            "day" /* DAY */,
            "gtc" /* GTC */,
            "ioc" /* IOC */,
            "fok" /* FOK */
          ],
          supportsExtendedHours: true,
          supportsFractionalShares: true,
          supportsShortSelling: true,
          supportsMarginTrading: true,
          supportsOptionsTrading: true,
          supportsCryptoTrading: false,
          supportsForexTrading: false,
          supportsPaperTrading: false,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 120,
          maxPositions: 1e4
        };
      }
      // ============================================================================
      // OAuth Authentication
      // ============================================================================
      getAuthorizationUrl(state, _isPaper) {
        const params = new URLSearchParams({
          response_type: "code",
          client_id: this.config.clientId,
          redirect_uri: this.config.redirectUri,
          scope: "api",
          state
        });
        return `${this.AUTH_URL}?${params.toString()}`;
      }
      async handleOAuthCallback(code, _state) {
        const credentials = Buffer.from(
          `${this.config.clientId}:${this.config.clientSecret}`
        ).toString("base64");
        const response = await fetch(this.TOKEN_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": `Basic ${credentials}`
          },
          body: new URLSearchParams({
            grant_type: "authorization_code",
            code,
            redirect_uri: this.config.redirectUri
          })
        });
        if (!response.ok) {
          const error = await response.text();
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            `Failed to exchange code for tokens: ${error}`,
            "schwab" /* SCHWAB */
          );
        }
        const data = await response.json();
        this.accessToken = data.access_token;
        this.refreshToken = data.refresh_token;
        this.tokenExpiresAt = Date.now() + data.expires_in * 1e3;
        return {
          accessToken: data.access_token,
          refreshToken: data.refresh_token,
          expiresIn: data.expires_in,
          tokenType: data.token_type,
          scope: data.scope
        };
      }
      async refreshAccessToken() {
        if (!this.refreshToken) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "No refresh token available",
            "schwab" /* SCHWAB */
          );
        }
        const credentials = Buffer.from(
          `${this.config.clientId}:${this.config.clientSecret}`
        ).toString("base64");
        const response = await fetch(this.TOKEN_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": `Basic ${credentials}`
          },
          body: new URLSearchParams({
            grant_type: "refresh_token",
            refresh_token: this.refreshToken
          })
        });
        if (!response.ok) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "Failed to refresh access token",
            "schwab" /* SCHWAB */
          );
        }
        const data = await response.json();
        this.accessToken = data.access_token;
        if (data.refresh_token) {
          this.refreshToken = data.refresh_token;
        }
        this.tokenExpiresAt = Date.now() + data.expires_in * 1e3;
        return {
          accessToken: data.access_token,
          refreshToken: data.refresh_token || this.refreshToken,
          expiresIn: data.expires_in,
          tokenType: data.token_type
        };
      }
      needsTokenRefresh() {
        return Date.now() > this.tokenExpiresAt - 5 * 60 * 1e3;
      }
      // ============================================================================
      // Connection Management
      // ============================================================================
      async initialize(credentials) {
        const oauth = credentials;
        this.accessToken = oauth.accessToken;
        this.refreshToken = oauth.refreshToken || null;
        this.tokenExpiresAt = oauth.expiresAt || 0;
        this.connected = true;
        const accounts = await this.getAccounts();
        if (accounts.length > 0) {
          this.accountHash = accounts[0].id;
        }
      }
      // ============================================================================
      // API Helper
      // ============================================================================
      async apiRequest(endpoint, options = {}) {
        if (this.needsTokenRefresh() && this.refreshToken) {
          await this.refreshAccessToken();
        }
        const url = `${this.API_BASE}${endpoint}`;
        const response = await fetch(url, {
          ...options,
          headers: {
            "Authorization": `Bearer ${this.accessToken}`,
            "Content-Type": "application/json",
            ...options.headers
          }
        });
        if (!response.ok) {
          const errorText = await response.text();
          if (response.status === 401) {
            throw new BrokerError(
              "authentication_failed" /* AUTHENTICATION_FAILED */,
              "Authentication failed",
              "schwab" /* SCHWAB */
            );
          }
          if (response.status === 429) {
            throw new BrokerError(
              "rate_limited" /* RATE_LIMITED */,
              "Rate limit exceeded",
              "schwab" /* SCHWAB */
            );
          }
          throw new BrokerError(
            "unknown_error" /* UNKNOWN_ERROR */,
            `API request failed: ${errorText}`,
            "schwab" /* SCHWAB */
          );
        }
        return response.json();
      }
      // ============================================================================
      // Account Operations
      // ============================================================================
      async getAccounts() {
        const data = await this.apiRequest(
          "/trader/v1/accounts"
        );
        return data.map((account) => ({
          id: account.hashValue,
          accountNumber: account.accountNumber,
          accountType: account.type,
          currency: "USD",
          status: "active",
          isPaper: false,
          createdAt: /* @__PURE__ */ new Date()
        }));
      }
      async getAccountBalance(accountId) {
        const hash = accountId || this.accountHash;
        const data = await this.apiRequest(
          `/trader/v1/accounts/${hash}`
        );
        const balances = data.currentBalances;
        const securities = data.securitiesAccount;
        return {
          currency: "USD",
          cash: balances.cashBalance,
          cashAvailable: balances.cashAvailableForTrading,
          cashWithdrawable: balances.availableFunds,
          buyingPower: balances.buyingPower,
          portfolioValue: balances.liquidationValue,
          equity: balances.liquidationValue,
          lastEquity: balances.liquidationValue,
          longMarketValue: balances.longMarketValue,
          shortMarketValue: balances.shortMarketValue,
          initialMargin: 0,
          maintenanceMargin: balances.maintenanceRequirement,
          dayTradeCount: securities?.roundTrips || 0,
          patternDayTrader: securities?.isDayTrader || false
        };
      }
      async getPositions(accountId) {
        const hash = accountId || this.accountHash;
        const data = await this.apiRequest(
          `/trader/v1/accounts/${hash}?fields=positions`
        );
        const positions = data.securitiesAccount?.positions || [];
        return positions.map((pos) => ({
          symbol: pos.instrument.symbol,
          quantity: pos.longQuantity - pos.shortQuantity,
          side: pos.longQuantity > pos.shortQuantity ? "long" : "short",
          avgEntryPrice: pos.averagePrice,
          currentPrice: pos.marketValue / (pos.longQuantity || pos.shortQuantity || 1),
          marketValue: pos.marketValue,
          unrealizedPL: pos.currentDayProfitLoss,
          unrealizedPLPercent: pos.currentDayProfitLossPercentage,
          costBasis: pos.averagePrice * (pos.longQuantity || pos.shortQuantity),
          assetClass: this.mapAssetClass(pos.instrument.assetType)
        }));
      }
      // ============================================================================
      // Order Operations
      // ============================================================================
      async placeOrder(order, accountId) {
        const hash = accountId || this.accountHash;
        const schwabOrder = {
          orderType: this.mapOrderType(order.type),
          session: "NORMAL",
          duration: this.mapTimeInForce(order.timeInForce || "day" /* DAY */),
          orderStrategyType: "SINGLE",
          orderLegCollection: [{
            instruction: order.side === "buy" /* BUY */ ? "BUY" : "SELL",
            quantity: order.quantity,
            instrument: {
              symbol: order.symbol,
              assetType: "EQUITY"
            }
          }],
          ...order.price && { price: order.price },
          ...order.stopPrice && { stopPrice: order.stopPrice }
        };
        const response = await fetch(
          `${this.API_BASE}/trader/v1/accounts/${hash}/orders`,
          {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.accessToken}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(schwabOrder)
          }
        );
        if (!response.ok) {
          const error = await response.text();
          throw new BrokerError(
            "order_rejected" /* ORDER_REJECTED */,
            `Order rejected: ${error}`,
            "schwab" /* SCHWAB */
          );
        }
        const location = response.headers.get("Location");
        const orderId = location?.split("/").pop() || "";
        return {
          id: orderId,
          clientOrderId: order.clientOrderId || orderId,
          symbol: order.symbol,
          side: order.side,
          type: order.type,
          quantity: order.quantity,
          price: order.price,
          stopPrice: order.stopPrice,
          timeInForce: order.timeInForce || "day" /* DAY */,
          status: "new" /* NEW */,
          filledQuantity: 0,
          avgFillPrice: 0,
          extendedHours: false,
          assetClass: "us_equity" /* US_EQUITY */,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
      }
      async cancelOrder(orderId, accountId) {
        const hash = accountId || this.accountHash;
        const response = await fetch(
          `${this.API_BASE}/trader/v1/accounts/${hash}/orders/${orderId}`,
          {
            method: "DELETE",
            headers: {
              "Authorization": `Bearer ${this.accessToken}`
            }
          }
        );
        if (!response.ok) {
          throw new BrokerError(
            "unknown_error" /* UNKNOWN_ERROR */,
            "Failed to cancel order",
            "schwab" /* SCHWAB */
          );
        }
      }
      async getOrders(params, accountId) {
        const hash = accountId || this.accountHash;
        const queryParams = new URLSearchParams();
        if (params?.after) {
          queryParams.set("fromEnteredTime", params.after.toISOString());
        }
        if (params?.until) {
          queryParams.set("toEnteredTime", params.until.toISOString());
        }
        if (params?.status) {
          queryParams.set("status", this.mapOrderStatusFilter(params.status));
        }
        const data = await this.apiRequest(
          `/trader/v1/accounts/${hash}/orders?${queryParams.toString()}`
        );
        return data.map((order) => this.mapOrder(order));
      }
      async getOrder(orderId, accountId) {
        const hash = accountId || this.accountHash;
        const data = await this.apiRequest(
          `/trader/v1/accounts/${hash}/orders/${orderId}`
        );
        return this.mapOrder(data);
      }
      // ============================================================================
      // Market Data
      // ============================================================================
      async getQuote(symbol) {
        const data = await this.apiRequest(
          `/marketdata/v1/quotes?symbols=${encodeURIComponent(symbol)}`
        );
        const quote = data[symbol];
        if (!quote) {
          throw new BrokerError(
            "invalid_symbol" /* INVALID_SYMBOL */,
            `Quote not found for ${symbol}`,
            "schwab" /* SCHWAB */
          );
        }
        return {
          symbol: quote.symbol,
          bidPrice: quote.quote.bidPrice,
          askPrice: quote.quote.askPrice,
          bidSize: quote.quote.bidSize,
          askSize: quote.quote.askSize,
          lastPrice: quote.quote.lastPrice,
          lastSize: quote.quote.lastSize,
          volume: quote.quote.totalVolume,
          timestamp: new Date(quote.quote.quoteTime)
        };
      }
      async getHistoricalBars(params) {
        const periodType = this.mapPeriodType(params.timeframe);
        const frequencyType = this.mapFrequencyType(params.timeframe);
        const queryParams = new URLSearchParams({
          symbol: params.symbol,
          periodType,
          frequencyType,
          ...params.start && { startDate: params.start.getTime().toString() },
          ...params.end && { endDate: params.end.getTime().toString() }
        });
        const data = await this.apiRequest(`/marketdata/v1/pricehistory?${queryParams.toString()}`);
        return data.candles.map((candle) => ({
          symbol: params.symbol,
          timestamp: new Date(candle.datetime),
          open: candle.open,
          high: candle.high,
          low: candle.low,
          close: candle.close,
          volume: candle.volume,
          vwap: (candle.high + candle.low + candle.close) / 3
        }));
      }
      // ============================================================================
      // Asset Information
      // ============================================================================
      async getAsset(symbol) {
        const data = await this.apiRequest(
          `/marketdata/v1/quotes?symbols=${encodeURIComponent(symbol)}`
        );
        const quote = data[symbol];
        if (!quote) {
          throw new BrokerError(
            "invalid_symbol" /* INVALID_SYMBOL */,
            `Asset not found: ${symbol}`,
            "schwab" /* SCHWAB */
          );
        }
        return {
          id: quote.reference.cusip || quote.symbol,
          symbol: quote.symbol,
          name: quote.reference.description,
          exchange: quote.reference.exchange,
          assetClass: this.mapAssetClass(quote.assetMainType),
          status: "active",
          tradable: quote.quote.securityStatus === "Normal",
          marginable: true,
          shortable: true,
          easyToBorrow: true,
          fractionable: true
        };
      }
      // ============================================================================
      // Helper Methods
      // ============================================================================
      mapOrderType(type) {
        const mapping = {
          ["market" /* MARKET */]: "MARKET",
          ["limit" /* LIMIT */]: "LIMIT",
          ["stop" /* STOP */]: "STOP",
          ["stop_limit" /* STOP_LIMIT */]: "STOP_LIMIT",
          ["trailing_stop" /* TRAILING_STOP */]: "TRAILING_STOP"
        };
        return mapping[type] || "MARKET";
      }
      mapTimeInForce(tif) {
        const mapping = {
          ["day" /* DAY */]: "DAY",
          ["gtc" /* GTC */]: "GOOD_TILL_CANCEL",
          ["ioc" /* IOC */]: "IMMEDIATE_OR_CANCEL",
          ["fok" /* FOK */]: "FILL_OR_KILL",
          ["opg" /* OPG */]: "DAY",
          ["cls" /* CLS */]: "DAY"
        };
        return mapping[tif] || "DAY";
      }
      mapOrderStatus(status) {
        const mapping = {
          "AWAITING_PARENT_ORDER": "pending" /* PENDING */,
          "AWAITING_CONDITION": "pending" /* PENDING */,
          "AWAITING_STOP_CONDITION": "pending" /* PENDING */,
          "AWAITING_MANUAL_REVIEW": "pending" /* PENDING */,
          "ACCEPTED": "accepted" /* ACCEPTED */,
          "PENDING_ACTIVATION": "pending" /* PENDING */,
          "QUEUED": "new" /* NEW */,
          "WORKING": "accepted" /* ACCEPTED */,
          "REJECTED": "rejected" /* REJECTED */,
          "PENDING_CANCEL": "pending" /* PENDING */,
          "CANCELED": "cancelled" /* CANCELLED */,
          "PENDING_REPLACE": "pending" /* PENDING */,
          "REPLACED": "replaced" /* REPLACED */,
          "FILLED": "filled" /* FILLED */,
          "EXPIRED": "expired" /* EXPIRED */
        };
        return mapping[status] || "new" /* NEW */;
      }
      mapOrderStatusFilter(status) {
        if (status === "open") return "WORKING";
        if (status === "closed") return "FILLED";
        return "";
      }
      mapAssetClass(assetType) {
        const mapping = {
          "EQUITY": "us_equity" /* US_EQUITY */,
          "OPTION": "options" /* OPTIONS */,
          "FUTURE": "futures" /* FUTURES */,
          "FOREX": "forex" /* FOREX */
        };
        return mapping[assetType] || "us_equity" /* US_EQUITY */;
      }
      mapPeriodType(timeframe) {
        if (timeframe.includes("Min") || timeframe.includes("Hour")) return "day";
        if (timeframe.includes("Day")) return "month";
        if (timeframe.includes("Week")) return "year";
        return "day";
      }
      mapFrequencyType(timeframe) {
        if (timeframe.includes("Min")) return "minute";
        if (timeframe.includes("Hour")) return "minute";
        if (timeframe.includes("Day")) return "daily";
        if (timeframe.includes("Week")) return "weekly";
        return "daily";
      }
      mapOrder(order) {
        const leg = order.orderLegCollection[0];
        return {
          id: order.orderId.toString(),
          clientOrderId: order.tag || order.orderId.toString(),
          symbol: leg.instrument.symbol,
          side: leg.instruction === "BUY" ? "buy" /* BUY */ : "sell" /* SELL */,
          type: this.reverseMapOrderType(order.orderType),
          quantity: order.quantity,
          price: order.price,
          stopPrice: order.stopPrice,
          timeInForce: this.reverseMapTimeInForce(order.duration),
          status: this.mapOrderStatus(order.status),
          filledQuantity: order.filledQuantity,
          avgFillPrice: 0,
          extendedHours: false,
          assetClass: "us_equity" /* US_EQUITY */,
          createdAt: new Date(order.enteredTime),
          updatedAt: order.closeTime ? new Date(order.closeTime) : new Date(order.enteredTime)
        };
      }
      reverseMapOrderType(type) {
        const mapping = {
          "MARKET": "market" /* MARKET */,
          "LIMIT": "limit" /* LIMIT */,
          "STOP": "stop" /* STOP */,
          "STOP_LIMIT": "stop_limit" /* STOP_LIMIT */,
          "TRAILING_STOP": "trailing_stop" /* TRAILING_STOP */
        };
        return mapping[type] || "market" /* MARKET */;
      }
      reverseMapTimeInForce(duration) {
        const mapping = {
          "DAY": "day" /* DAY */,
          "GOOD_TILL_CANCEL": "gtc" /* GTC */,
          "IMMEDIATE_OR_CANCEL": "ioc" /* IOC */,
          "FILL_OR_KILL": "fok" /* FOK */
        };
        return mapping[duration] || "day" /* DAY */;
      }
      // ============================================================================
      // Symbol Mapping
      // ============================================================================
      normalizeSymbol(brokerSymbol) {
        return brokerSymbol.toUpperCase();
      }
      toBrokerSymbol(normalizedSymbol) {
        return normalizedSymbol.toUpperCase();
      }
    };
  }
});

// server/services/brokers/BrokerFactory.ts
var BROKER_INFO, BrokerFactory;
var init_BrokerFactory = __esm({
  "server/services/brokers/BrokerFactory.ts"() {
    "use strict";
    init_AlpacaAdapter();
    init_IBKRAdapter();
    init_BinanceBrokerAdapter();
    init_CoinbaseBrokerAdapter();
    init_SchwabAdapter();
    init_types();
    BROKER_INFO = {
      ["alpaca" /* ALPACA */]: {
        type: "alpaca" /* ALPACA */,
        name: "Alpaca",
        description: "Commission-free stock and crypto trading API with paper trading support",
        logoUrl: "/brokers/alpaca.svg",
        websiteUrl: "https://alpaca.markets",
        documentationUrl: "https://docs.alpaca.markets",
        capabilities: {
          supportedAssetClasses: ["us_equity" /* US_EQUITY */, "crypto" /* CRYPTO */],
          supportedOrderTypes: [
            "market" /* MARKET */,
            "limit" /* LIMIT */,
            "stop" /* STOP */,
            "stop_limit" /* STOP_LIMIT */,
            "trailing_stop" /* TRAILING_STOP */
          ],
          supportedTimeInForce: [
            "day" /* DAY */,
            "gtc" /* GTC */,
            "ioc" /* IOC */,
            "fok" /* FOK */
          ],
          supportsExtendedHours: true,
          supportsFractionalShares: true,
          supportsShortSelling: true,
          supportsMarginTrading: true,
          supportsOptionsTrading: false,
          supportsCryptoTrading: true,
          supportsForexTrading: false,
          supportsPaperTrading: true,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 200
        },
        authType: "oauth2",
        requiresApproval: false,
        supportedRegions: ["US"]
      },
      ["interactive_brokers" /* INTERACTIVE_BROKERS */]: {
        type: "interactive_brokers" /* INTERACTIVE_BROKERS */,
        name: "Interactive Brokers",
        description: "Professional-grade trading platform with global market access",
        logoUrl: "/brokers/ibkr.svg",
        websiteUrl: "https://www.interactivebrokers.com",
        documentationUrl: "https://www.interactivebrokers.com/campus/ibkr-api-page/",
        capabilities: {
          supportedAssetClasses: [
            "us_equity" /* US_EQUITY */,
            "options" /* OPTIONS */,
            "futures" /* FUTURES */,
            "forex" /* FOREX */,
            "crypto" /* CRYPTO */
          ],
          supportedOrderTypes: [
            "market" /* MARKET */,
            "limit" /* LIMIT */,
            "stop" /* STOP */,
            "stop_limit" /* STOP_LIMIT */,
            "trailing_stop" /* TRAILING_STOP */
          ],
          supportedTimeInForce: [
            "day" /* DAY */,
            "gtc" /* GTC */,
            "ioc" /* IOC */,
            "fok" /* FOK */
          ],
          supportsExtendedHours: true,
          supportsFractionalShares: false,
          supportsShortSelling: true,
          supportsMarginTrading: true,
          supportsOptionsTrading: true,
          supportsCryptoTrading: true,
          supportsForexTrading: true,
          supportsPaperTrading: true,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 50
        },
        authType: "oauth2",
        // OAuth 2.0 (recommended) or OAuth 1.0a (legacy)
        requiresApproval: true,
        approvalUrl: "https://www.interactivebrokers.com/en/trading/ib-api.php",
        supportedRegions: ["US", "EU", "APAC"]
      },
      ["binance" /* BINANCE */]: {
        type: "binance" /* BINANCE */,
        name: "Binance",
        description: "World's largest cryptocurrency exchange by trading volume",
        logoUrl: "/brokers/binance.svg",
        websiteUrl: "https://www.binance.com",
        documentationUrl: "https://binance-docs.github.io/apidocs/",
        capabilities: {
          supportedAssetClasses: ["crypto" /* CRYPTO */],
          supportedOrderTypes: [
            "market" /* MARKET */,
            "limit" /* LIMIT */,
            "stop" /* STOP */,
            "stop_limit" /* STOP_LIMIT */
          ],
          supportedTimeInForce: [
            "gtc" /* GTC */,
            "ioc" /* IOC */,
            "fok" /* FOK */
          ],
          supportsExtendedHours: true,
          supportsFractionalShares: true,
          supportsShortSelling: true,
          supportsMarginTrading: true,
          supportsOptionsTrading: false,
          supportsCryptoTrading: true,
          supportsForexTrading: false,
          supportsPaperTrading: true,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 1200
        },
        authType: "api_key",
        requiresApproval: false,
        supportedRegions: ["GLOBAL"]
      },
      ["coinbase" /* COINBASE */]: {
        type: "coinbase" /* COINBASE */,
        name: "Coinbase",
        description: "US-regulated cryptocurrency exchange with advanced trading features",
        logoUrl: "/brokers/coinbase.svg",
        websiteUrl: "https://www.coinbase.com",
        documentationUrl: "https://docs.cloud.coinbase.com/",
        capabilities: {
          supportedAssetClasses: ["crypto" /* CRYPTO */],
          supportedOrderTypes: [
            "market" /* MARKET */,
            "limit" /* LIMIT */,
            "stop" /* STOP */
          ],
          supportedTimeInForce: [
            "gtc" /* GTC */,
            "ioc" /* IOC */,
            "fok" /* FOK */
          ],
          supportsExtendedHours: true,
          supportsFractionalShares: true,
          supportsShortSelling: false,
          supportsMarginTrading: false,
          supportsOptionsTrading: false,
          supportsCryptoTrading: true,
          supportsForexTrading: false,
          supportsPaperTrading: true,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 30
        },
        authType: "oauth2",
        requiresApproval: false,
        supportedRegions: ["US"]
      },
      ["schwab" /* SCHWAB */]: {
        type: "schwab" /* SCHWAB */,
        name: "Charles Schwab",
        description: "Full-service brokerage with stocks, ETFs, and options trading (formerly TD Ameritrade)",
        logoUrl: "/brokers/schwab.svg",
        websiteUrl: "https://www.schwab.com",
        documentationUrl: "https://developer.schwab.com/",
        capabilities: {
          supportedAssetClasses: ["us_equity" /* US_EQUITY */, "options" /* OPTIONS */],
          supportedOrderTypes: [
            "market" /* MARKET */,
            "limit" /* LIMIT */,
            "stop" /* STOP */,
            "stop_limit" /* STOP_LIMIT */,
            "trailing_stop" /* TRAILING_STOP */
          ],
          supportedTimeInForce: [
            "day" /* DAY */,
            "gtc" /* GTC */,
            "ioc" /* IOC */,
            "fok" /* FOK */
          ],
          supportsExtendedHours: true,
          supportsFractionalShares: true,
          supportsShortSelling: true,
          supportsMarginTrading: true,
          supportsOptionsTrading: true,
          supportsCryptoTrading: false,
          supportsForexTrading: false,
          supportsPaperTrading: false,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 120
        },
        authType: "oauth2",
        requiresApproval: true,
        approvalUrl: "https://developer.schwab.com/",
        supportedRegions: ["US"]
      }
    };
    BrokerFactory = class {
      config;
      constructor(config = {}) {
        this.config = config;
      }
      /**
       * Create a broker adapter instance
       */
      createAdapter(brokerType, isPaper = true) {
        switch (brokerType) {
          case "alpaca" /* ALPACA */:
            if (!this.config.alpaca) {
              throw new Error("Alpaca configuration not provided");
            }
            return new AlpacaAdapter({
              ...this.config.alpaca,
              isPaper
            });
          case "interactive_brokers" /* INTERACTIVE_BROKERS */:
            if (!this.config.ibkr) {
              throw new Error("Interactive Brokers configuration not provided");
            }
            return new IBKRAdapter({
              ...this.config.ibkr,
              isPaper
            });
          case "binance" /* BINANCE */:
            return new BinanceBrokerAdapter();
          case "coinbase" /* COINBASE */:
            return new CoinbaseBrokerAdapter();
          case "schwab" /* SCHWAB */:
            if (!this.config.schwab) {
              throw new Error("Schwab configuration not provided");
            }
            return new SchwabAdapter({
              ...this.config.schwab,
              isPaper: false
              // Schwab doesn't support paper trading
            });
          default:
            throw new Error(`Unknown broker type: ${brokerType}`);
        }
      }
      /**
       * Get broker information
       */
      getBrokerInfo(brokerType) {
        return BROKER_INFO[brokerType];
      }
      /**
       * Get all available brokers
       */
      getAvailableBrokers() {
        return Object.values(BROKER_INFO);
      }
      /**
       * Get brokers that support a specific asset class
       */
      getBrokersByAssetClass(assetClass) {
        return Object.values(BROKER_INFO).filter(
          (broker) => broker.capabilities.supportedAssetClasses.includes(assetClass)
        );
      }
      /**
       * Get brokers that support paper trading
       */
      getPaperTradingBrokers() {
        return Object.values(BROKER_INFO).filter(
          (broker) => broker.capabilities.supportsPaperTrading
        );
      }
      /**
       * Check if a broker is configured
       */
      isBrokerConfigured(brokerType) {
        switch (brokerType) {
          case "alpaca" /* ALPACA */:
            return !!this.config.alpaca;
          case "interactive_brokers" /* INTERACTIVE_BROKERS */:
            return !!this.config.ibkr;
          default:
            return false;
        }
      }
    };
  }
});

// server/services/brokers/BrokerService.ts
import { eq as eq6, and as and6, desc as desc6, lt as lt3 } from "drizzle-orm";
import crypto5 from "crypto";
function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function getEncryptionKey() {
  return crypto5.scryptSync(ENCRYPTION_KEY2, "salt", 32);
}
function encrypt(text2) {
  const iv = crypto5.randomBytes(16);
  const key = getEncryptionKey();
  const cipher = crypto5.createCipheriv(ALGORITHM, key, iv);
  let encrypted = cipher.update(text2, "utf8", "hex");
  encrypted += cipher.final("hex");
  const authTag = cipher.getAuthTag();
  return `${iv.toString("hex")}:${authTag.toString("hex")}:${encrypted}`;
}
function decrypt(encryptedText) {
  const [ivHex, authTagHex, encrypted] = encryptedText.split(":");
  const iv = Buffer.from(ivHex, "hex");
  const authTag = Buffer.from(authTagHex, "hex");
  const key = getEncryptionKey();
  const decipher = crypto5.createDecipheriv(ALGORITHM, key, iv);
  decipher.setAuthTag(authTag);
  let decrypted = decipher.update(encrypted, "hex", "utf8");
  decrypted += decipher.final("utf8");
  return decrypted;
}
async function createOAuthState(userId, brokerType, isPaper, codeVerifier, requestToken, requestTokenSecret) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const state = crypto5.randomBytes(32).toString("hex");
  const expiresAt = new Date(Date.now() + 10 * 60 * 1e3);
  const record = {
    id: uuidv4(),
    state,
    userId,
    brokerType,
    isPaper,
    codeVerifier,
    requestToken,
    requestTokenSecret,
    expiresAt
  };
  await db.insert(oauthStates).values(record);
  const [created] = await db.select().from(oauthStates).where(eq6(oauthStates.id, record.id));
  return created;
}
async function getOAuthState(state) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const [record] = await db.select().from(oauthStates).where(eq6(oauthStates.state, state));
  if (!record) return null;
  if (new Date(record.expiresAt) < /* @__PURE__ */ new Date()) {
    await db.delete(oauthStates).where(eq6(oauthStates.id, record.id));
    return null;
  }
  return record;
}
async function deleteOAuthState(state) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  await db.delete(oauthStates).where(eq6(oauthStates.state, state));
}
async function createBrokerConnection(userId, brokerType, isPaper, tokens, accountInfo) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const record = {
    id: uuidv4(),
    userId,
    brokerType,
    isPaper,
    isActive: true,
    accessTokenEncrypted: encrypt(tokens.accessToken),
    refreshTokenEncrypted: tokens.refreshToken ? encrypt(tokens.refreshToken) : null,
    accessTokenSecretEncrypted: tokens.accessTokenSecret ? encrypt(tokens.accessTokenSecret) : null,
    tokenExpiresAt: tokens.expiresAt,
    liveSessionTokenEncrypted: tokens.liveSessionToken ? encrypt(tokens.liveSessionToken) : null,
    liveSessionTokenExpiresAt: tokens.liveSessionTokenExpiresAt,
    accountId: accountInfo?.accountId,
    accountNumber: accountInfo?.accountNumber,
    accountType: accountInfo?.accountType,
    lastConnectedAt: /* @__PURE__ */ new Date()
  };
  await db.insert(brokerConnections).values(record);
  const [created] = await db.select().from(brokerConnections).where(eq6(brokerConnections.id, record.id));
  return created;
}
async function getBrokerConnection(connectionId) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const [record] = await db.select().from(brokerConnections).where(eq6(brokerConnections.id, connectionId));
  return record || null;
}
async function getUserBrokerConnections(userId) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  return db.select().from(brokerConnections).where(eq6(brokerConnections.userId, userId)).orderBy(desc6(brokerConnections.createdAt));
}
async function updateBrokerConnection(connectionId, updates) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const updateData = {};
  if (updates.accessToken) updateData.accessTokenEncrypted = encrypt(updates.accessToken);
  if (updates.refreshToken) updateData.refreshTokenEncrypted = encrypt(updates.refreshToken);
  if (updates.accessTokenSecret) updateData.accessTokenSecretEncrypted = encrypt(updates.accessTokenSecret);
  if (updates.liveSessionToken) updateData.liveSessionTokenEncrypted = encrypt(updates.liveSessionToken);
  if (updates.tokenExpiresAt) updateData.tokenExpiresAt = updates.tokenExpiresAt;
  if (updates.liveSessionTokenExpiresAt) updateData.liveSessionTokenExpiresAt = updates.liveSessionTokenExpiresAt;
  if (updates.accountId) updateData.accountId = updates.accountId;
  if (updates.accountNumber) updateData.accountNumber = updates.accountNumber;
  if (updates.accountType) updateData.accountType = updates.accountType;
  if (updates.isActive !== void 0) updateData.isActive = updates.isActive;
  if (updates.connectionError !== void 0) updateData.connectionError = updates.connectionError;
  if (updates.lastSyncAt) updateData.lastSyncAt = updates.lastSyncAt;
  await db.update(brokerConnections).set(updateData).where(eq6(brokerConnections.id, connectionId));
  return getBrokerConnection(connectionId);
}
async function deleteBrokerConnection(connectionId) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  await db.delete(brokerOrders).where(eq6(brokerOrders.connectionId, connectionId));
  await db.delete(brokerPositions).where(eq6(brokerPositions.connectionId, connectionId));
  await db.delete(brokerConnections).where(eq6(brokerConnections.id, connectionId));
}
function getDecryptedTokens(connection) {
  return {
    accessToken: connection.accessTokenEncrypted ? decrypt(connection.accessTokenEncrypted) : null,
    refreshToken: connection.refreshTokenEncrypted ? decrypt(connection.refreshTokenEncrypted) : null,
    accessTokenSecret: connection.accessTokenSecretEncrypted ? decrypt(connection.accessTokenSecretEncrypted) : null,
    liveSessionToken: connection.liveSessionTokenEncrypted ? decrypt(connection.liveSessionTokenEncrypted) : null
  };
}
async function createBrokerOrder(connectionId, userId, order) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const record = {
    id: uuidv4(),
    connectionId,
    userId,
    brokerOrderId: order.brokerOrderId,
    clientOrderId: order.clientOrderId || uuidv4(),
    symbol: order.symbol,
    side: order.side.toLowerCase(),
    orderType: order.orderType.toLowerCase(),
    timeInForce: order.timeInForce?.toLowerCase() || "day",
    quantity: order.quantity.toString(),
    price: order.price?.toString(),
    stopPrice: order.stopPrice?.toString(),
    trailPercent: order.trailPercent?.toString(),
    extendedHours: order.extendedHours || false,
    status: "new"
  };
  await db.insert(brokerOrders).values(record);
  const [created] = await db.select().from(brokerOrders).where(eq6(brokerOrders.id, record.id));
  return created;
}
async function updateBrokerOrder(orderId, updates) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const updateData = {};
  if (updates.brokerOrderId) updateData.brokerOrderId = updates.brokerOrderId;
  if (updates.status) updateData.status = updates.status.toLowerCase();
  if (updates.filledQuantity !== void 0) updateData.filledQuantity = updates.filledQuantity.toString();
  if (updates.avgFillPrice !== void 0) updateData.avgFillPrice = updates.avgFillPrice.toString();
  if (updates.filledAt) updateData.filledAt = updates.filledAt;
  if (updates.cancelledAt) updateData.cancelledAt = updates.cancelledAt;
  if (updates.expiredAt) updateData.expiredAt = updates.expiredAt;
  await db.update(brokerOrders).set(updateData).where(eq6(brokerOrders.id, orderId));
  const [updated] = await db.select().from(brokerOrders).where(eq6(brokerOrders.id, orderId));
  return updated || null;
}
async function getBrokerOrder(orderId) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const [record] = await db.select().from(brokerOrders).where(eq6(brokerOrders.id, orderId));
  return record || null;
}
async function getUserBrokerOrders(userId, connectionId, limit = 50) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (connectionId) {
    return db.select().from(brokerOrders).where(and6(
      eq6(brokerOrders.userId, userId),
      eq6(brokerOrders.connectionId, connectionId)
    )).orderBy(desc6(brokerOrders.createdAt)).limit(limit);
  }
  return db.select().from(brokerOrders).where(eq6(brokerOrders.userId, userId)).orderBy(desc6(brokerOrders.createdAt)).limit(limit);
}
async function syncBrokerPositions(connectionId, userId, positions) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  await db.delete(brokerPositions).where(eq6(brokerPositions.connectionId, connectionId));
  const records = positions.map((pos) => ({
    id: uuidv4(),
    connectionId,
    userId,
    symbol: pos.symbol,
    quantity: pos.quantity.toString(),
    side: pos.side,
    avgEntryPrice: pos.avgEntryPrice.toString(),
    marketValue: pos.marketValue?.toString(),
    costBasis: pos.costBasis?.toString(),
    unrealizedPL: pos.unrealizedPL?.toString(),
    unrealizedPLPercent: pos.unrealizedPLPercent?.toString(),
    currentPrice: pos.currentPrice?.toString(),
    lastSyncAt: /* @__PURE__ */ new Date()
  }));
  if (records.length > 0) {
    await db.insert(brokerPositions).values(records);
  }
  return db.select().from(brokerPositions).where(eq6(brokerPositions.connectionId, connectionId));
}
async function getUserBrokerPositions(userId, connectionId) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  if (connectionId) {
    return db.select().from(brokerPositions).where(and6(
      eq6(brokerPositions.userId, userId),
      eq6(brokerPositions.connectionId, connectionId)
    ));
  }
  return db.select().from(brokerPositions).where(eq6(brokerPositions.userId, userId));
}
async function initializeBrokerAdapter(connection, config) {
  const factory = new BrokerFactory(config);
  const adapter = factory.createAdapter(connection.brokerType, connection.isPaper);
  const tokens = getDecryptedTokens(connection);
  if (!tokens.accessToken) {
    throw new Error("No access token found for broker connection");
  }
  await adapter.initialize({
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken ?? void 0,
    accessTokenSecret: tokens.accessTokenSecret ?? void 0,
    liveSessionToken: tokens.liveSessionToken ?? void 0
  });
  return adapter;
}
function getAvailableBrokers() {
  return Object.values(BROKER_INFO).filter((info) => info.type === "alpaca" /* ALPACA */ || info.type === "interactive_brokers" /* INTERACTIVE_BROKERS */).map((info) => ({
    type: info.type,
    name: info.name,
    description: info.description,
    logoUrl: info.logoUrl,
    authType: info.authType,
    requiresApproval: info.requiresApproval,
    approvalUrl: info.approvalUrl,
    capabilities: {
      supportsStocks: info.capabilities.supportedAssetClasses.includes("us_equity"),
      supportsCrypto: info.capabilities.supportsCryptoTrading,
      supportsOptions: info.capabilities.supportsOptionsTrading,
      supportsFractional: info.capabilities.supportsFractionalShares,
      supportsPaperTrading: info.capabilities.supportsPaperTrading
    }
  }));
}
var ENCRYPTION_KEY2, ALGORITHM;
var init_BrokerService = __esm({
  "server/services/brokers/BrokerService.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_types();
    init_BrokerFactory();
    ENCRYPTION_KEY2 = process.env.JWT_SECRET || "default-encryption-key-change-me";
    ALGORITHM = "aes-256-gcm";
  }
});

// server/services/positionSync.ts
var positionSync_exports = {};
__export(positionSync_exports, {
  default: () => positionSync_default,
  getAggregatedPositions: () => getAggregatedPositions,
  getSyncHistory: () => getSyncHistory,
  getSyncStatus: () => getSyncStatus,
  getUserSyncStatus: () => getUserSyncStatus,
  initializeAllSyncs: () => initializeAllSyncs,
  startAutoSync: () => startAutoSync,
  stopAutoSync: () => stopAutoSync,
  syncConnectionPositions: () => syncConnectionPositions,
  syncUserPositions: () => syncUserPositions
});
import { eq as eq8 } from "drizzle-orm";
function getBrokerConfig() {
  return {
    alpaca: process.env.ALPACA_CLIENT_ID ? {
      clientId: process.env.ALPACA_CLIENT_ID,
      clientSecret: process.env.ALPACA_CLIENT_SECRET,
      redirectUri: process.env.ALPACA_REDIRECT_URI || ""
    } : void 0,
    ibkr: process.env.IBKR_CONSUMER_KEY ? {
      consumerKey: process.env.IBKR_CONSUMER_KEY,
      privateKey: process.env.IBKR_PRIVATE_KEY,
      realm: process.env.IBKR_REALM || "limited_poa",
      redirectUri: process.env.IBKR_REDIRECT_URI || ""
    } : void 0
  };
}
async function syncConnectionPositions(connectionId) {
  const connection = await getBrokerConnection(connectionId);
  if (!connection) {
    return { success: false, positionsCount: 0, error: "Connection not found" };
  }
  syncStatusCache.set(connectionId, {
    connectionId,
    lastSyncAt: syncStatusCache.get(connectionId)?.lastSyncAt || null,
    nextSyncAt: null,
    status: "syncing",
    positionsCount: syncStatusCache.get(connectionId)?.positionsCount || 0
  });
  try {
    const config = getBrokerConfig();
    const adapter = await initializeBrokerAdapter(connection, config);
    const positions = await adapter.getPositions();
    await syncBrokerPositions(
      connectionId,
      connection.userId,
      positions.map((pos) => ({
        symbol: pos.symbol,
        quantity: pos.quantity,
        side: pos.side,
        avgEntryPrice: pos.avgEntryPrice,
        marketValue: pos.marketValue,
        costBasis: pos.costBasis,
        unrealizedPL: pos.unrealizedPL,
        unrealizedPLPercent: pos.unrealizedPLPercent,
        currentPrice: pos.currentPrice
      }))
    );
    const now = /* @__PURE__ */ new Date();
    syncStatusCache.set(connectionId, {
      connectionId,
      lastSyncAt: now,
      nextSyncAt: null,
      // Will be set by scheduler
      status: "idle",
      positionsCount: positions.length
    });
    const db = await getDb();
    if (db) {
      await db.update(brokerConnections).set({ lastSyncAt: now }).where(eq8(brokerConnections.id, connectionId));
    }
    return { success: true, positionsCount: positions.length };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    syncStatusCache.set(connectionId, {
      connectionId,
      lastSyncAt: syncStatusCache.get(connectionId)?.lastSyncAt || null,
      nextSyncAt: null,
      status: "error",
      error: errorMessage,
      positionsCount: syncStatusCache.get(connectionId)?.positionsCount || 0
    });
    return { success: false, positionsCount: 0, error: errorMessage };
  }
}
async function syncUserPositions(userId) {
  const connections = await getUserBrokerConnections(userId);
  const results = [];
  let synced = 0;
  let failed = 0;
  for (const connection of connections) {
    if (!connection.isActive) continue;
    const result = await syncConnectionPositions(connection.id);
    results.push({ connectionId: connection.id, ...result });
    if (result.success) {
      synced++;
    } else {
      failed++;
    }
  }
  return { synced, failed, results };
}
function getSyncStatus(connectionId) {
  return syncStatusCache.get(connectionId) || null;
}
async function getUserSyncStatus(userId) {
  const connections = await getUserBrokerConnections(userId);
  return connections.map(
    (conn) => syncStatusCache.get(conn.id) || {
      connectionId: conn.id,
      lastSyncAt: conn.lastSyncAt,
      nextSyncAt: null,
      status: "idle",
      positionsCount: 0
    }
  );
}
function startAutoSync(connectionId, intervalMinutes = 5) {
  stopAutoSync(connectionId);
  const intervalMs = intervalMinutes * 60 * 1e3;
  const interval = setInterval(async () => {
    await syncConnectionPositions(connectionId);
    const status2 = syncStatusCache.get(connectionId);
    if (status2) {
      status2.nextSyncAt = new Date(Date.now() + intervalMs);
      syncStatusCache.set(connectionId, status2);
    }
  }, intervalMs);
  syncIntervals.set(connectionId, interval);
  const status = syncStatusCache.get(connectionId) || {
    connectionId,
    lastSyncAt: null,
    nextSyncAt: new Date(Date.now() + intervalMs),
    status: "idle",
    positionsCount: 0
  };
  status.nextSyncAt = new Date(Date.now() + intervalMs);
  syncStatusCache.set(connectionId, status);
  syncConnectionPositions(connectionId);
}
function stopAutoSync(connectionId) {
  const interval = syncIntervals.get(connectionId);
  if (interval) {
    clearInterval(interval);
    syncIntervals.delete(connectionId);
  }
  const status = syncStatusCache.get(connectionId);
  if (status) {
    status.nextSyncAt = null;
    syncStatusCache.set(connectionId, status);
  }
}
async function getAggregatedPositions(userId) {
  const db = await getDb();
  if (!db) {
    return { positions: [], totalValue: 0, totalPL: 0, lastSyncAt: null };
  }
  const connections = await getUserBrokerConnections(userId);
  const connectionIds = connections.map((c) => c.id);
  if (connectionIds.length === 0) {
    return { positions: [], totalValue: 0, totalPL: 0, lastSyncAt: null };
  }
  const allPositions = [];
  let totalValue = 0;
  let totalPL = 0;
  let lastSyncAt = null;
  for (const connection of connections) {
    const positions = await db.select().from(brokerPositions).where(eq8(brokerPositions.connectionId, connection.id));
    for (const pos of positions) {
      const marketValue = Number(pos.marketValue) || 0;
      const unrealizedPL = Number(pos.unrealizedPL) || 0;
      allPositions.push({
        symbol: pos.symbol,
        quantity: Number(pos.quantity) || 0,
        side: pos.side,
        avgEntryPrice: Number(pos.avgEntryPrice) || 0,
        marketValue,
        unrealizedPL,
        unrealizedPLPercent: Number(pos.unrealizedPLPercent) || 0,
        currentPrice: Number(pos.currentPrice) || 0,
        connectionId: connection.id,
        brokerType: connection.brokerType
      });
      totalValue += marketValue;
      totalPL += unrealizedPL;
    }
    if (connection.lastSyncAt && (!lastSyncAt || connection.lastSyncAt > lastSyncAt)) {
      lastSyncAt = connection.lastSyncAt;
    }
  }
  return { positions: allPositions, totalValue, totalPL, lastSyncAt };
}
async function getSyncHistory(connectionId, limit = 10) {
  const status = syncStatusCache.get(connectionId);
  if (!status || !status.lastSyncAt) {
    return [];
  }
  return [{
    syncedAt: status.lastSyncAt,
    positionsCount: status.positionsCount,
    status: status.status
  }];
}
async function initializeAllSyncs() {
  const db = await getDb();
  if (!db) return;
  const activeConnections = await db.select().from(brokerConnections).where(eq8(brokerConnections.isActive, true));
  for (const connection of activeConnections) {
    startAutoSync(connection.id, 5);
  }
  console.log(`[PositionSync] Initialized sync for ${activeConnections.length} connections`);
}
var syncStatusCache, syncIntervals, positionSync_default;
var init_positionSync = __esm({
  "server/services/positionSync.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_BrokerService();
    syncStatusCache = /* @__PURE__ */ new Map();
    syncIntervals = /* @__PURE__ */ new Map();
    positionSync_default = {
      syncConnectionPositions,
      syncUserPositions,
      getSyncStatus,
      getUserSyncStatus,
      startAutoSync,
      stopAutoSync,
      getAggregatedPositions,
      getSyncHistory,
      initializeAllSyncs
    };
  }
});

// server/services/orderHistory.ts
var orderHistory_exports = {};
__export(orderHistory_exports, {
  getDailyPnL: () => getDailyPnL,
  getExecutionById: () => getExecutionById,
  getExecutionsByOrderId: () => getExecutionsByOrderId,
  getOrderHistory: () => getOrderHistory2,
  getPnLSummary: () => getPnLSummary,
  getSymbolPnLBreakdown: () => getSymbolPnLBreakdown,
  recordOrderExecution: () => recordOrderExecution
});
import { eq as eq9, and as and9, desc as desc8, gte as gte3, lte as lte4, sql as sql2 } from "drizzle-orm";
import { randomUUID as randomUUID2 } from "crypto";
async function recordOrderExecution(input) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const executionValue = input.executedQuantity * input.executedPrice;
  const commission = input.commission || 0;
  const fees = input.fees || 0;
  const totalCost = executionValue + commission + fees;
  let slippage = null;
  if (input.marketPrice && input.marketPrice > 0) {
    slippage = (input.executedPrice - input.marketPrice) / input.marketPrice * 100;
    if (input.side === "sell") {
      slippage = -slippage;
    }
  }
  const closingTradeInfo = await findOpeningTrade(input.userId, input.symbol, input.side);
  let realizedPL = null;
  let realizedPLPercent = null;
  let holdingPeriodDays = null;
  if (closingTradeInfo) {
    if (input.side === "sell") {
      realizedPL = (input.executedPrice - closingTradeInfo.avgEntryPrice) * input.executedQuantity - commission - fees;
    } else {
      realizedPL = (closingTradeInfo.avgEntryPrice - input.executedPrice) * input.executedQuantity - commission - fees;
    }
    realizedPLPercent = realizedPL / (closingTradeInfo.avgEntryPrice * input.executedQuantity) * 100;
    const openDate = new Date(closingTradeInfo.openedAt);
    const closeDate = input.executedAt;
    holdingPeriodDays = Math.floor((closeDate.getTime() - openDate.getTime()) / (1e3 * 60 * 60 * 24));
  }
  const execution = {
    id: randomUUID2(),
    orderId: input.orderId,
    connectionId: input.connectionId,
    userId: input.userId,
    symbol: input.symbol,
    side: input.side,
    orderType: input.orderType,
    executionId: input.executionId || null,
    executedQuantity: input.executedQuantity.toString(),
    executedPrice: input.executedPrice.toString(),
    executionValue: executionValue.toString(),
    commission: commission.toString(),
    fees: fees.toString(),
    totalCost: totalCost.toString(),
    isClosingTrade: !!closingTradeInfo,
    openingExecutionId: closingTradeInfo?.executionId || null,
    realizedPL: realizedPL?.toString() || null,
    realizedPLPercent: realizedPLPercent?.toString() || null,
    holdingPeriodDays,
    marketPrice: input.marketPrice?.toString() || null,
    slippage: slippage?.toString() || null,
    executedAt: input.executedAt
  };
  await db.insert(orderExecutions).values(execution);
  return execution;
}
async function findOpeningTrade(userId, symbol, closingSide) {
  const db = await getDb();
  if (!db) return null;
  const openingSide = closingSide === "sell" ? "buy" : "sell";
  const openingTrades = await db.select().from(orderExecutions).where(
    and9(
      eq9(orderExecutions.userId, userId),
      eq9(orderExecutions.symbol, symbol),
      eq9(orderExecutions.side, openingSide),
      eq9(orderExecutions.isClosingTrade, false)
    )
  ).orderBy(desc8(orderExecutions.executedAt)).limit(1);
  if (openingTrades.length === 0) {
    return null;
  }
  const trade = openingTrades[0];
  return {
    executionId: trade.id,
    avgEntryPrice: parseFloat(trade.executedPrice),
    openedAt: trade.executedAt
  };
}
async function getOrderHistory2(filters) {
  const db = await getDb();
  if (!db) return { executions: [], total: 0, limit: 50, offset: 0 };
  const conditions = [eq9(orderExecutions.userId, filters.userId)];
  if (filters.connectionId) {
    conditions.push(eq9(orderExecutions.connectionId, filters.connectionId));
  }
  if (filters.symbol) {
    conditions.push(eq9(orderExecutions.symbol, filters.symbol));
  }
  if (filters.side) {
    conditions.push(eq9(orderExecutions.side, filters.side));
  }
  if (filters.startDate) {
    conditions.push(gte3(orderExecutions.executedAt, filters.startDate));
  }
  if (filters.endDate) {
    conditions.push(lte4(orderExecutions.executedAt, filters.endDate));
  }
  if (filters.isClosingTrade !== void 0) {
    conditions.push(eq9(orderExecutions.isClosingTrade, filters.isClosingTrade));
  }
  const limit = filters.limit || 50;
  const offset = filters.offset || 0;
  const executions = await db.select().from(orderExecutions).where(and9(...conditions)).orderBy(desc8(orderExecutions.executedAt)).limit(limit).offset(offset);
  const countResult = await db.select({ count: sql2`count(*)` }).from(orderExecutions).where(and9(...conditions));
  const total = countResult[0]?.count || 0;
  return {
    executions: executions.map(formatExecution),
    total,
    limit,
    offset
  };
}
async function getPnLSummary(userId, connectionId, startDate, endDate) {
  const db = await getDb();
  if (!db) {
    return {
      totalRealizedPL: 0,
      totalTrades: 0,
      winningTrades: 0,
      losingTrades: 0,
      winRate: 0,
      avgWin: 0,
      avgLoss: 0,
      profitFactor: 0,
      largestWin: 0,
      largestLoss: 0,
      avgHoldingPeriod: 0
    };
  }
  const conditions = [
    eq9(orderExecutions.userId, userId),
    eq9(orderExecutions.isClosingTrade, true)
  ];
  if (connectionId) conditions.push(eq9(orderExecutions.connectionId, connectionId));
  if (startDate) conditions.push(gte3(orderExecutions.executedAt, startDate));
  if (endDate) conditions.push(lte4(orderExecutions.executedAt, endDate));
  const closingTrades = await db.select().from(orderExecutions).where(and9(...conditions));
  if (closingTrades.length === 0) {
    return {
      totalRealizedPL: 0,
      totalTrades: 0,
      winningTrades: 0,
      losingTrades: 0,
      winRate: 0,
      avgWin: 0,
      avgLoss: 0,
      profitFactor: 0,
      largestWin: 0,
      largestLoss: 0,
      avgHoldingPeriod: 0
    };
  }
  let totalRealizedPL = 0, winningTrades = 0, losingTrades = 0;
  let totalWins = 0, totalLosses = 0, largestWin = 0, largestLoss = 0, totalHoldingPeriod = 0;
  for (const trade of closingTrades) {
    const pl = parseFloat(trade.realizedPL || "0");
    totalRealizedPL += pl;
    if (pl > 0) {
      winningTrades++;
      totalWins += pl;
      if (pl > largestWin) largestWin = pl;
    } else if (pl < 0) {
      losingTrades++;
      totalLosses += Math.abs(pl);
      if (Math.abs(pl) > largestLoss) largestLoss = Math.abs(pl);
    }
    if (trade.holdingPeriodDays) totalHoldingPeriod += trade.holdingPeriodDays;
  }
  const totalTrades = closingTrades.length;
  const winRate = totalTrades > 0 ? winningTrades / totalTrades * 100 : 0;
  const avgWin = winningTrades > 0 ? totalWins / winningTrades : 0;
  const avgLoss = losingTrades > 0 ? totalLosses / losingTrades : 0;
  const profitFactor = totalLosses > 0 ? totalWins / totalLosses : totalWins > 0 ? Infinity : 0;
  const avgHoldingPeriod = totalTrades > 0 ? totalHoldingPeriod / totalTrades : 0;
  return {
    totalRealizedPL,
    totalTrades,
    winningTrades,
    losingTrades,
    winRate,
    avgWin,
    avgLoss,
    profitFactor,
    largestWin,
    largestLoss,
    avgHoldingPeriod
  };
}
async function getExecutionById(executionId, userId) {
  const db = await getDb();
  if (!db) return null;
  const executions = await db.select().from(orderExecutions).where(and9(eq9(orderExecutions.id, executionId), eq9(orderExecutions.userId, userId))).limit(1);
  if (executions.length === 0) return null;
  return formatExecution(executions[0]);
}
async function getExecutionsByOrderId(orderId, userId) {
  const db = await getDb();
  if (!db) return [];
  const executions = await db.select().from(orderExecutions).where(and9(eq9(orderExecutions.orderId, orderId), eq9(orderExecutions.userId, userId))).orderBy(desc8(orderExecutions.executedAt));
  return executions.map(formatExecution);
}
async function getSymbolPnLBreakdown(userId, connectionId, startDate, endDate) {
  const db = await getDb();
  if (!db) return [];
  const conditions = [
    eq9(orderExecutions.userId, userId),
    eq9(orderExecutions.isClosingTrade, true)
  ];
  if (connectionId) conditions.push(eq9(orderExecutions.connectionId, connectionId));
  if (startDate) conditions.push(gte3(orderExecutions.executedAt, startDate));
  if (endDate) conditions.push(lte4(orderExecutions.executedAt, endDate));
  const closingTrades = await db.select().from(orderExecutions).where(and9(...conditions));
  const symbolMap = /* @__PURE__ */ new Map();
  for (const trade of closingTrades) {
    const symbol = trade.symbol;
    const pl = parseFloat(trade.realizedPL || "0");
    const volume = parseFloat(trade.executionValue);
    if (!symbolMap.has(symbol)) {
      symbolMap.set(symbol, { symbol, totalPL: 0, trades: 0, wins: 0, losses: 0, totalVolume: 0 });
    }
    const data = symbolMap.get(symbol);
    data.totalPL += pl;
    data.trades++;
    data.totalVolume += volume;
    if (pl > 0) data.wins++;
    else if (pl < 0) data.losses++;
  }
  return Array.from(symbolMap.values()).map((d) => ({ ...d, winRate: d.trades > 0 ? d.wins / d.trades * 100 : 0 })).sort((a, b) => b.totalPL - a.totalPL);
}
async function getDailyPnL(userId, connectionId, days = 30) {
  const db = await getDb();
  if (!db) return [];
  const startDate = /* @__PURE__ */ new Date();
  startDate.setDate(startDate.getDate() - days);
  const conditions = [
    eq9(orderExecutions.userId, userId),
    eq9(orderExecutions.isClosingTrade, true),
    gte3(orderExecutions.executedAt, startDate)
  ];
  if (connectionId) conditions.push(eq9(orderExecutions.connectionId, connectionId));
  const closingTrades = await db.select().from(orderExecutions).where(and9(...conditions)).orderBy(orderExecutions.executedAt);
  const dailyMap = /* @__PURE__ */ new Map();
  for (const trade of closingTrades) {
    const date2 = trade.executedAt.toISOString().split("T")[0];
    const pl = parseFloat(trade.realizedPL || "0");
    dailyMap.set(date2, (dailyMap.get(date2) || 0) + pl);
  }
  const result = [];
  let cumulativePnl = 0;
  for (let i = 0; i < days; i++) {
    const date2 = new Date(startDate);
    date2.setDate(date2.getDate() + i);
    const dateStr = date2.toISOString().split("T")[0];
    const dayPnl = dailyMap.get(dateStr) || 0;
    cumulativePnl += dayPnl;
    result.push({ date: dateStr, pnl: dayPnl, cumulativePnl });
  }
  return result;
}
function formatExecution(execution) {
  return {
    id: execution.id,
    orderId: execution.orderId,
    connectionId: execution.connectionId,
    symbol: execution.symbol,
    side: execution.side,
    orderType: execution.orderType,
    executionId: execution.executionId,
    executedQuantity: parseFloat(execution.executedQuantity),
    executedPrice: parseFloat(execution.executedPrice),
    executionValue: parseFloat(execution.executionValue),
    commission: parseFloat(execution.commission),
    fees: parseFloat(execution.fees),
    totalCost: parseFloat(execution.totalCost),
    isClosingTrade: execution.isClosingTrade,
    openingExecutionId: execution.openingExecutionId,
    realizedPL: execution.realizedPL ? parseFloat(execution.realizedPL) : null,
    realizedPLPercent: execution.realizedPLPercent ? parseFloat(execution.realizedPLPercent) : null,
    holdingPeriodDays: execution.holdingPeriodDays,
    marketPrice: execution.marketPrice ? parseFloat(execution.marketPrice) : null,
    slippage: execution.slippage ? parseFloat(execution.slippage) : null,
    executedAt: execution.executedAt.toISOString(),
    createdAt: execution.createdAt.toISOString()
  };
}
var init_orderHistory = __esm({
  "server/services/orderHistory.ts"() {
    "use strict";
    init_db();
    init_schema();
  }
});

// server/services/brokerAnalytics.ts
var brokerAnalytics_exports = {};
__export(brokerAnalytics_exports, {
  calculatePerformanceMetrics: () => calculatePerformanceMetrics2,
  getAccountSnapshots: () => getAccountSnapshots,
  getAggregatedAnalytics: () => getAggregatedAnalytics,
  getBuyingPowerHistory: () => getBuyingPowerHistory,
  getLatestSnapshot: () => getLatestSnapshot,
  getPerformanceMetrics: () => getPerformanceMetrics,
  getTradeFrequency: () => getTradeFrequency,
  recordAccountSnapshot: () => recordAccountSnapshot
});
import { eq as eq10, and as and10, desc as desc9, gte as gte4, lte as lte5 } from "drizzle-orm";
import { randomUUID as randomUUID3 } from "crypto";
async function recordAccountSnapshot(snapshot) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const marginUtilization = snapshot.buyingPower > 0 ? (snapshot.marginUsed || 0) / snapshot.buyingPower * 100 : 0;
  const dayPLPercent = snapshot.equity > 0 && snapshot.dayPL ? snapshot.dayPL / snapshot.equity * 100 : 0;
  const totalPLPercent = snapshot.portfolioValue > 0 && snapshot.totalPL ? snapshot.totalPL / snapshot.portfolioValue * 100 : 0;
  const record = {
    id: randomUUID3(),
    connectionId: snapshot.connectionId,
    userId: snapshot.userId,
    equity: snapshot.equity.toString(),
    cash: snapshot.cash.toString(),
    buyingPower: snapshot.buyingPower.toString(),
    portfolioValue: snapshot.portfolioValue.toString(),
    marginUsed: (snapshot.marginUsed || 0).toString(),
    marginAvailable: snapshot.marginAvailable?.toString() || null,
    marginUtilization: marginUtilization.toString(),
    dayPL: (snapshot.dayPL || 0).toString(),
    dayPLPercent: dayPLPercent.toString(),
    totalPL: (snapshot.totalPL || 0).toString(),
    totalPLPercent: totalPLPercent.toString(),
    tradesCount: 0,
    winningTrades: 0,
    losingTrades: 0,
    tradingVolume: "0",
    positionsCount: snapshot.positionsCount || 0,
    longPositions: 0,
    shortPositions: 0,
    snapshotDate: /* @__PURE__ */ new Date()
  };
  await db.insert(brokerAccountSnapshots).values(record);
  return record;
}
async function getAccountSnapshots(connectionId, userId, days = 30) {
  const db = await getDb();
  if (!db) return [];
  const startDate = /* @__PURE__ */ new Date();
  startDate.setDate(startDate.getDate() - days);
  const snapshots = await db.select().from(brokerAccountSnapshots).where(
    and10(
      eq10(brokerAccountSnapshots.connectionId, connectionId),
      eq10(brokerAccountSnapshots.userId, userId),
      gte4(brokerAccountSnapshots.snapshotDate, startDate)
    )
  ).orderBy(desc9(brokerAccountSnapshots.snapshotDate));
  return snapshots.map(formatSnapshot);
}
async function getLatestSnapshot(connectionId, userId) {
  const db = await getDb();
  if (!db) return null;
  const snapshots = await db.select().from(brokerAccountSnapshots).where(
    and10(
      eq10(brokerAccountSnapshots.connectionId, connectionId),
      eq10(brokerAccountSnapshots.userId, userId)
    )
  ).orderBy(desc9(brokerAccountSnapshots.snapshotDate)).limit(1);
  if (snapshots.length === 0) return null;
  return formatSnapshot(snapshots[0]);
}
async function calculatePerformanceMetrics2(connectionId, userId, periodType) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const now = /* @__PURE__ */ new Date();
  let periodStart = /* @__PURE__ */ new Date();
  switch (periodType) {
    case "daily":
      periodStart.setDate(now.getDate() - 1);
      break;
    case "weekly":
      periodStart.setDate(now.getDate() - 7);
      break;
    case "monthly":
      periodStart.setMonth(now.getMonth() - 1);
      break;
    case "yearly":
      periodStart.setFullYear(now.getFullYear() - 1);
      break;
    case "all_time":
      periodStart = /* @__PURE__ */ new Date("2020-01-01");
      break;
  }
  const executions = await db.select().from(orderExecutions).where(
    and10(
      eq10(orderExecutions.connectionId, connectionId),
      eq10(orderExecutions.userId, userId),
      eq10(orderExecutions.isClosingTrade, true),
      gte4(orderExecutions.executedAt, periodStart),
      lte5(orderExecutions.executedAt, now)
    )
  );
  let totalReturn = 0;
  let winningTrades = 0;
  let losingTrades = 0;
  let totalVolume = 0;
  const returns = [];
  let largestWin = 0;
  let largestLoss = 0;
  let totalWins = 0;
  let totalLosses = 0;
  for (const exec of executions) {
    const pl = parseFloat(exec.realizedPL || "0");
    const volume = parseFloat(exec.executionValue);
    totalReturn += pl;
    totalVolume += volume;
    returns.push(pl);
    if (pl > 0) {
      winningTrades++;
      totalWins += pl;
      if (pl > largestWin) largestWin = pl;
    } else if (pl < 0) {
      losingTrades++;
      totalLosses += Math.abs(pl);
      if (Math.abs(pl) > largestLoss) largestLoss = Math.abs(pl);
    }
  }
  const totalTrades = executions.length;
  const winRate = totalTrades > 0 ? winningTrades / totalTrades * 100 : 0;
  const avgWin = winningTrades > 0 ? totalWins / winningTrades : 0;
  const avgLoss = losingTrades > 0 ? totalLosses / losingTrades : 0;
  const profitFactor = totalLosses > 0 ? totalWins / totalLosses : 0;
  const avgTradeSize = totalTrades > 0 ? totalVolume / totalTrades : 0;
  let volatility = 0;
  let sharpeRatio = 0;
  if (returns.length > 1) {
    const avgReturn = totalReturn / returns.length;
    const variance = returns.reduce((sum2, r) => sum2 + Math.pow(r - avgReturn, 2), 0) / returns.length;
    volatility = Math.sqrt(variance);
    const riskFreeRate = 0.02;
    if (volatility > 0) {
      sharpeRatio = (avgReturn - riskFreeRate) / volatility;
    }
  }
  let maxDrawdown = 0;
  let peak = 0;
  let cumulative = 0;
  for (const ret of returns) {
    cumulative += ret;
    if (cumulative > peak) peak = cumulative;
    const drawdown = peak > 0 ? (peak - cumulative) / peak * 100 : 0;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
  }
  const snapshots = await db.select().from(brokerAccountSnapshots).where(
    and10(
      eq10(brokerAccountSnapshots.connectionId, connectionId),
      eq10(brokerAccountSnapshots.userId, userId),
      gte4(brokerAccountSnapshots.snapshotDate, periodStart)
    )
  ).orderBy(brokerAccountSnapshots.snapshotDate).limit(1);
  const initialEquity = snapshots.length > 0 ? parseFloat(snapshots[0].equity) : 0;
  const totalReturnPercent = initialEquity > 0 ? totalReturn / initialEquity * 100 : 0;
  const metrics = {
    id: randomUUID3(),
    connectionId,
    userId,
    periodType,
    periodStart,
    periodEnd: now,
    totalReturn: totalReturn.toString(),
    totalReturnPercent: totalReturnPercent.toString(),
    sharpeRatio: sharpeRatio.toString(),
    sortinoRatio: null,
    // Would need downside deviation calculation
    maxDrawdown: maxDrawdown.toString(),
    maxDrawdownDuration: null,
    volatility: volatility.toString(),
    totalTrades,
    winningTrades,
    losingTrades,
    winRate: winRate.toString(),
    profitFactor: profitFactor.toString(),
    avgWin: avgWin.toString(),
    avgLoss: avgLoss.toString(),
    largestWin: largestWin.toString(),
    largestLoss: largestLoss.toString(),
    totalVolume: totalVolume.toString(),
    avgTradeSize: avgTradeSize.toString(),
    avgHoldingPeriod: null,
    calculatedAt: now,
    createdAt: now
  };
  await db.insert(brokerPerformanceMetrics).values(metrics);
  return formatMetrics(metrics);
}
async function getPerformanceMetrics(connectionId, userId, periodType) {
  const db = await getDb();
  if (!db) return [];
  const conditions = [
    eq10(brokerPerformanceMetrics.connectionId, connectionId),
    eq10(brokerPerformanceMetrics.userId, userId)
  ];
  if (periodType) {
    conditions.push(eq10(brokerPerformanceMetrics.periodType, periodType));
  }
  const metrics = await db.select().from(brokerPerformanceMetrics).where(and10(...conditions)).orderBy(desc9(brokerPerformanceMetrics.calculatedAt));
  return metrics.map(formatMetrics);
}
async function getAggregatedAnalytics(userId) {
  const db = await getDb();
  if (!db) return null;
  const connections = await db.select().from(brokerConnections).where(eq10(brokerConnections.userId, userId));
  if (connections.length === 0) {
    return {
      totalEquity: 0,
      totalCash: 0,
      totalBuyingPower: 0,
      totalPortfolioValue: 0,
      totalMarginUsed: 0,
      totalDayPL: 0,
      totalPL: 0,
      connectionCount: 0,
      brokerBreakdown: []
    };
  }
  let totalEquity = 0;
  let totalCash = 0;
  let totalBuyingPower = 0;
  let totalPortfolioValue = 0;
  let totalMarginUsed = 0;
  let totalDayPL = 0;
  let totalPL = 0;
  const brokerBreakdown = [];
  for (const conn of connections) {
    const snapshot = await getLatestSnapshot(conn.id, userId);
    if (snapshot) {
      totalEquity += snapshot.equity;
      totalCash += snapshot.cash;
      totalBuyingPower += snapshot.buyingPower;
      totalPortfolioValue += snapshot.portfolioValue;
      totalMarginUsed += snapshot.marginUsed;
      totalDayPL += snapshot.dayPL;
      totalPL += snapshot.totalPL;
      brokerBreakdown.push({
        connectionId: conn.id,
        brokerType: conn.brokerType,
        equity: snapshot.equity,
        portfolioValue: snapshot.portfolioValue,
        dayPL: snapshot.dayPL,
        totalPL: snapshot.totalPL
      });
    }
  }
  return {
    totalEquity,
    totalCash,
    totalBuyingPower,
    totalPortfolioValue,
    totalMarginUsed,
    totalDayPL,
    totalPL,
    connectionCount: connections.length,
    brokerBreakdown
  };
}
async function getBuyingPowerHistory(connectionId, userId, days = 30) {
  const db = await getDb();
  if (!db) return [];
  const startDate = /* @__PURE__ */ new Date();
  startDate.setDate(startDate.getDate() - days);
  const snapshots = await db.select().from(brokerAccountSnapshots).where(
    and10(
      eq10(brokerAccountSnapshots.connectionId, connectionId),
      eq10(brokerAccountSnapshots.userId, userId),
      gte4(brokerAccountSnapshots.snapshotDate, startDate)
    )
  ).orderBy(brokerAccountSnapshots.snapshotDate);
  return snapshots.map((s) => ({
    date: s.snapshotDate.toISOString().split("T")[0],
    buyingPower: parseFloat(s.buyingPower),
    marginUsed: parseFloat(s.marginUsed),
    marginUtilization: s.marginUtilization ? parseFloat(s.marginUtilization) : 0
  }));
}
async function getTradeFrequency(connectionId, userId, days = 30) {
  const db = await getDb();
  if (!db) return { daily: [], hourly: [], bySymbol: [] };
  const startDate = /* @__PURE__ */ new Date();
  startDate.setDate(startDate.getDate() - days);
  const executions = await db.select().from(orderExecutions).where(
    and10(
      eq10(orderExecutions.connectionId, connectionId),
      eq10(orderExecutions.userId, userId),
      gte4(orderExecutions.executedAt, startDate)
    )
  );
  const dailyMap = /* @__PURE__ */ new Map();
  const hourlyMap = /* @__PURE__ */ new Map();
  const symbolMap = /* @__PURE__ */ new Map();
  for (const exec of executions) {
    const date2 = exec.executedAt.toISOString().split("T")[0];
    const hour = exec.executedAt.getHours();
    const symbol = exec.symbol;
    dailyMap.set(date2, (dailyMap.get(date2) || 0) + 1);
    hourlyMap.set(hour, (hourlyMap.get(hour) || 0) + 1);
    symbolMap.set(symbol, (symbolMap.get(symbol) || 0) + 1);
  }
  const daily = Array.from(dailyMap.entries()).map(([date2, count2]) => ({ date: date2, count: count2 })).sort((a, b) => a.date.localeCompare(b.date));
  const hourly = Array.from(hourlyMap.entries()).map(([hour, count2]) => ({ hour, count: count2 })).sort((a, b) => a.hour - b.hour);
  const bySymbol = Array.from(symbolMap.entries()).map(([symbol, count2]) => ({ symbol, count: count2 })).sort((a, b) => b.count - a.count);
  return { daily, hourly, bySymbol };
}
function formatSnapshot(snapshot) {
  return {
    id: snapshot.id,
    connectionId: snapshot.connectionId,
    equity: parseFloat(snapshot.equity),
    cash: parseFloat(snapshot.cash),
    buyingPower: parseFloat(snapshot.buyingPower),
    portfolioValue: parseFloat(snapshot.portfolioValue),
    marginUsed: parseFloat(snapshot.marginUsed),
    marginAvailable: snapshot.marginAvailable ? parseFloat(snapshot.marginAvailable) : null,
    marginUtilization: snapshot.marginUtilization ? parseFloat(snapshot.marginUtilization) : 0,
    dayPL: parseFloat(snapshot.dayPL),
    dayPLPercent: snapshot.dayPLPercent ? parseFloat(snapshot.dayPLPercent) : 0,
    totalPL: parseFloat(snapshot.totalPL),
    totalPLPercent: snapshot.totalPLPercent ? parseFloat(snapshot.totalPLPercent) : 0,
    tradesCount: snapshot.tradesCount,
    winningTrades: snapshot.winningTrades,
    losingTrades: snapshot.losingTrades,
    tradingVolume: parseFloat(snapshot.tradingVolume),
    positionsCount: snapshot.positionsCount,
    longPositions: snapshot.longPositions,
    shortPositions: snapshot.shortPositions,
    snapshotDate: snapshot.snapshotDate.toISOString()
  };
}
function formatMetrics(metrics) {
  return {
    id: metrics.id,
    connectionId: metrics.connectionId,
    periodType: metrics.periodType,
    periodStart: metrics.periodStart.toISOString(),
    periodEnd: metrics.periodEnd.toISOString(),
    totalReturn: parseFloat(metrics.totalReturn),
    totalReturnPercent: metrics.totalReturnPercent ? parseFloat(metrics.totalReturnPercent) : null,
    sharpeRatio: metrics.sharpeRatio ? parseFloat(metrics.sharpeRatio) : null,
    sortinoRatio: metrics.sortinoRatio ? parseFloat(metrics.sortinoRatio) : null,
    maxDrawdown: metrics.maxDrawdown ? parseFloat(metrics.maxDrawdown) : null,
    maxDrawdownDuration: metrics.maxDrawdownDuration,
    volatility: metrics.volatility ? parseFloat(metrics.volatility) : null,
    totalTrades: metrics.totalTrades,
    winningTrades: metrics.winningTrades,
    losingTrades: metrics.losingTrades,
    winRate: metrics.winRate ? parseFloat(metrics.winRate) : null,
    profitFactor: metrics.profitFactor ? parseFloat(metrics.profitFactor) : null,
    avgWin: metrics.avgWin ? parseFloat(metrics.avgWin) : null,
    avgLoss: metrics.avgLoss ? parseFloat(metrics.avgLoss) : null,
    largestWin: metrics.largestWin ? parseFloat(metrics.largestWin) : null,
    largestLoss: metrics.largestLoss ? parseFloat(metrics.largestLoss) : null,
    totalVolume: parseFloat(metrics.totalVolume),
    avgTradeSize: metrics.avgTradeSize ? parseFloat(metrics.avgTradeSize) : null,
    avgHoldingPeriod: metrics.avgHoldingPeriod ? parseFloat(metrics.avgHoldingPeriod) : null,
    calculatedAt: metrics.calculatedAt.toISOString()
  };
}
var init_brokerAnalytics = __esm({
  "server/services/brokerAnalytics.ts"() {
    "use strict";
    init_db();
    init_schema();
  }
});

// server/services/portfolioRebalancing.ts
var portfolioRebalancing_exports = {};
__export(portfolioRebalancing_exports, {
  calculateRebalanceSuggestions: () => calculateRebalanceSuggestions,
  createAllocation: () => createAllocation,
  deleteAllocation: () => deleteAllocation,
  executeRebalancing: () => executeRebalancing,
  getAllocation: () => getAllocation,
  getRebalancingHistory: () => getRebalancingHistory,
  getUserAllocations: () => getUserAllocations,
  updateAllocation: () => updateAllocation
});
import { eq as eq11, and as and11, desc as desc10 } from "drizzle-orm";
import { randomUUID as randomUUID4 } from "crypto";
async function createAllocation(input) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const totalPercent = input.targetAllocations.reduce((sum2, a) => sum2 + a.targetPercent, 0);
  if (Math.abs(totalPercent - 100) > 0.01) {
    throw new Error(`Target allocations must sum to 100%. Current sum: ${totalPercent.toFixed(2)}%`);
  }
  const allocation = {
    id: randomUUID4(),
    userId: input.userId,
    name: input.name,
    description: input.description || null,
    targetAllocations: JSON.stringify(input.targetAllocations),
    rebalanceThreshold: (input.rebalanceThreshold || 5).toString(),
    rebalanceFrequency: input.rebalanceFrequency || "manual",
    lastRebalancedAt: null,
    nextRebalanceAt: calculateNextRebalance(input.rebalanceFrequency || "manual"),
    preferredBrokers: input.preferredBrokers ? JSON.stringify(input.preferredBrokers) : null,
    isActive: true
  };
  await db.insert(portfolioAllocations).values(allocation);
  return formatAllocation(allocation);
}
async function updateAllocation(allocationId, userId, updates) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const existing = await db.select().from(portfolioAllocations).where(
    and11(
      eq11(portfolioAllocations.id, allocationId),
      eq11(portfolioAllocations.userId, userId)
    )
  ).limit(1);
  if (existing.length === 0) {
    throw new Error("Allocation not found");
  }
  const updateData = {};
  if (updates.name) updateData.name = updates.name;
  if (updates.description !== void 0) updateData.description = updates.description;
  if (updates.targetAllocations) {
    const totalPercent = updates.targetAllocations.reduce((sum2, a) => sum2 + a.targetPercent, 0);
    if (Math.abs(totalPercent - 100) > 0.01) {
      throw new Error(`Target allocations must sum to 100%. Current sum: ${totalPercent.toFixed(2)}%`);
    }
    updateData.targetAllocations = JSON.stringify(updates.targetAllocations);
  }
  if (updates.rebalanceThreshold !== void 0) {
    updateData.rebalanceThreshold = updates.rebalanceThreshold.toString();
  }
  if (updates.rebalanceFrequency) {
    updateData.rebalanceFrequency = updates.rebalanceFrequency;
    updateData.nextRebalanceAt = calculateNextRebalance(updates.rebalanceFrequency);
  }
  if (updates.preferredBrokers) {
    updateData.preferredBrokers = JSON.stringify(updates.preferredBrokers);
  }
  await db.update(portfolioAllocations).set(updateData).where(eq11(portfolioAllocations.id, allocationId));
  return getAllocation(allocationId, userId);
}
async function getAllocation(allocationId, userId) {
  const db = await getDb();
  if (!db) return null;
  const allocations = await db.select().from(portfolioAllocations).where(
    and11(
      eq11(portfolioAllocations.id, allocationId),
      eq11(portfolioAllocations.userId, userId)
    )
  ).limit(1);
  if (allocations.length === 0) return null;
  return formatAllocation(allocations[0]);
}
async function getUserAllocations(userId) {
  const db = await getDb();
  if (!db) return [];
  const allocations = await db.select().from(portfolioAllocations).where(eq11(portfolioAllocations.userId, userId)).orderBy(desc10(portfolioAllocations.createdAt));
  return allocations.map(formatAllocation);
}
async function deleteAllocation(allocationId, userId) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  await db.delete(portfolioAllocations).where(
    and11(
      eq11(portfolioAllocations.id, allocationId),
      eq11(portfolioAllocations.userId, userId)
    )
  );
}
async function calculateRebalanceSuggestions(allocationId, userId) {
  const db = await getDb();
  if (!db) return null;
  const allocation = await getAllocation(allocationId, userId);
  if (!allocation) return null;
  const positions = await db.select().from(brokerPositions).where(eq11(brokerPositions.userId, userId));
  const connections = await db.select().from(brokerConnections).where(eq11(brokerConnections.userId, userId));
  const connectionMap = new Map(connections.map((c) => [c.id, c]));
  let totalPortfolioValue = 0;
  const currentHoldings = /* @__PURE__ */ new Map();
  for (const pos of positions) {
    const value = parseFloat(pos.marketValue || "0");
    totalPortfolioValue += value;
    const existing = currentHoldings.get(pos.symbol);
    if (existing) {
      existing.value += value;
      existing.quantity += parseFloat(pos.quantity);
    } else {
      currentHoldings.set(pos.symbol, {
        value,
        quantity: parseFloat(pos.quantity),
        connectionId: pos.connectionId
      });
    }
  }
  if (totalPortfolioValue === 0) {
    return {
      allocationId,
      totalPortfolioValue: 0,
      currentAllocations: [],
      suggestedTrades: [],
      estimatedFees: 0,
      estimatedTaxImpact: 0
    };
  }
  const currentAllocations = [];
  const suggestedTrades = [];
  for (const target of allocation.targetAllocations) {
    const current = currentHoldings.get(target.symbol);
    const currentValue = current?.value || 0;
    const currentPercent = currentValue / totalPortfolioValue * 100;
    const targetValue = target.targetPercent / 100 * totalPortfolioValue;
    const drift = currentPercent - target.targetPercent;
    currentAllocations.push({
      symbol: target.symbol,
      currentPercent,
      targetPercent: target.targetPercent,
      drift,
      currentValue,
      targetValue
    });
    if (Math.abs(drift) > allocation.rebalanceThreshold) {
      const valueDiff = targetValue - currentValue;
      const currentPrice = current?.value && current?.quantity ? current.value / current.quantity : 0;
      const estimatedPrice = currentPrice || 100;
      const quantity = Math.abs(valueDiff / estimatedPrice);
      let connectionId = current?.connectionId || "";
      let brokerType = "unknown";
      if (allocation.preferredBrokers && allocation.preferredBrokers.length > 0) {
        connectionId = allocation.preferredBrokers[0];
      }
      const conn = connectionMap.get(connectionId);
      if (conn) {
        brokerType = conn.brokerType;
      }
      if (valueDiff !== 0 && connectionId) {
        suggestedTrades.push({
          symbol: target.symbol,
          side: valueDiff > 0 ? "buy" : "sell",
          quantity: Math.round(quantity * 100) / 100,
          estimatedValue: Math.abs(valueDiff),
          connectionId,
          brokerType,
          reason: `${drift > 0 ? "Overweight" : "Underweight"} by ${Math.abs(drift).toFixed(2)}%`
        });
      }
    }
  }
  for (const [symbol, holding] of Array.from(currentHoldings.entries())) {
    const inTarget = allocation.targetAllocations.some((t2) => t2.symbol === symbol);
    if (!inTarget && holding.value > 0) {
      const conn = connectionMap.get(holding.connectionId);
      currentAllocations.push({
        symbol,
        currentPercent: holding.value / totalPortfolioValue * 100,
        targetPercent: 0,
        drift: holding.value / totalPortfolioValue * 100,
        currentValue: holding.value,
        targetValue: 0
      });
      suggestedTrades.push({
        symbol,
        side: "sell",
        quantity: holding.quantity,
        estimatedValue: holding.value,
        connectionId: holding.connectionId,
        brokerType: conn?.brokerType || "unknown",
        reason: "Not in target allocation - should be sold"
      });
    }
  }
  const estimatedFees = suggestedTrades.reduce((sum2, t2) => sum2 + t2.quantity * 0.01, 0);
  const estimatedTaxImpact = suggestedTrades.filter((t2) => t2.side === "sell").reduce((sum2, t2) => sum2 + t2.estimatedValue * 0.15, 0);
  return {
    allocationId,
    totalPortfolioValue,
    currentAllocations: currentAllocations.sort((a, b) => b.currentValue - a.currentValue),
    suggestedTrades: suggestedTrades.sort((a, b) => b.estimatedValue - a.estimatedValue),
    estimatedFees,
    estimatedTaxImpact
  };
}
async function executeRebalancing(allocationId, userId, tradesToExecute) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const suggestions = await calculateRebalanceSuggestions(allocationId, userId);
  if (!suggestions) {
    throw new Error("Could not calculate rebalancing suggestions");
  }
  let trades2 = suggestions.suggestedTrades;
  if (tradesToExecute && tradesToExecute.length > 0) {
    trades2 = trades2.filter((t2) => tradesToExecute.includes(t2.symbol));
  }
  if (trades2.length === 0) {
    throw new Error("No trades to execute");
  }
  const historyId = randomUUID4();
  const now = /* @__PURE__ */ new Date();
  const historyRecord = {
    id: historyId,
    allocationId,
    userId,
    preAllocations: JSON.stringify(
      suggestions.currentAllocations.map((a) => ({
        symbol: a.symbol,
        actual: a.currentPercent,
        target: a.targetPercent,
        value: a.currentValue
      }))
    ),
    totalPortfolioValue: suggestions.totalPortfolioValue.toString(),
    tradesExecuted: JSON.stringify(trades2),
    tradesCount: trades2.length,
    totalTradingVolume: trades2.reduce((sum2, t2) => sum2 + t2.estimatedValue, 0).toString(),
    totalFees: suggestions.estimatedFees.toString(),
    postAllocations: JSON.stringify([]),
    // Will be updated after execution
    status: "pending",
    errorMessage: null,
    triggeredBy: "manual",
    startedAt: now,
    completedAt: null
  };
  await db.insert(rebalancingHistory).values(historyRecord);
  await db.update(rebalancingHistory).set({
    status: "completed",
    completedAt: /* @__PURE__ */ new Date(),
    postAllocations: JSON.stringify(
      suggestions.currentAllocations.map((a) => ({
        symbol: a.symbol,
        actual: a.targetPercent,
        // Assuming perfect execution
        target: a.targetPercent,
        value: a.targetValue
      }))
    )
  }).where(eq11(rebalancingHistory.id, historyId));
  await db.update(portfolioAllocations).set({
    lastRebalancedAt: now,
    nextRebalanceAt: calculateNextRebalance(
      (await getAllocation(allocationId, userId))?.rebalanceFrequency || "manual"
    )
  }).where(eq11(portfolioAllocations.id, allocationId));
  return { historyId, status: "completed" };
}
async function getRebalancingHistory(userId, allocationId, limit = 20) {
  const db = await getDb();
  if (!db) return [];
  const conditions = [eq11(rebalancingHistory.userId, userId)];
  if (allocationId) {
    conditions.push(eq11(rebalancingHistory.allocationId, allocationId));
  }
  const history = await db.select().from(rebalancingHistory).where(and11(...conditions)).orderBy(desc10(rebalancingHistory.createdAt)).limit(limit);
  return history.map(formatHistory);
}
function calculateNextRebalance(frequency) {
  const now = /* @__PURE__ */ new Date();
  switch (frequency) {
    case "daily":
      now.setDate(now.getDate() + 1);
      break;
    case "weekly":
      now.setDate(now.getDate() + 7);
      break;
    case "monthly":
      now.setMonth(now.getMonth() + 1);
      break;
    case "quarterly":
      now.setMonth(now.getMonth() + 3);
      break;
    case "manual":
    default:
      return null;
  }
  return now;
}
function formatAllocation(allocation) {
  const targetAllocations = typeof allocation.targetAllocations === "string" ? JSON.parse(allocation.targetAllocations) : allocation.targetAllocations;
  const preferredBrokers = allocation.preferredBrokers ? typeof allocation.preferredBrokers === "string" ? JSON.parse(allocation.preferredBrokers) : allocation.preferredBrokers : [];
  return {
    id: allocation.id,
    userId: allocation.userId,
    name: allocation.name,
    description: allocation.description,
    targetAllocations,
    rebalanceThreshold: parseFloat(allocation.rebalanceThreshold),
    rebalanceFrequency: allocation.rebalanceFrequency,
    lastRebalancedAt: allocation.lastRebalancedAt ? allocation.lastRebalancedAt.toISOString() : null,
    nextRebalanceAt: allocation.nextRebalanceAt ? allocation.nextRebalanceAt.toISOString() : null,
    preferredBrokers,
    isActive: allocation.isActive,
    createdAt: allocation.createdAt ? allocation.createdAt.toISOString() : (/* @__PURE__ */ new Date()).toISOString(),
    updatedAt: allocation.updatedAt ? allocation.updatedAt.toISOString() : (/* @__PURE__ */ new Date()).toISOString()
  };
}
function formatHistory(history) {
  return {
    id: history.id,
    allocationId: history.allocationId,
    preAllocations: JSON.parse(history.preAllocations),
    totalPortfolioValue: parseFloat(history.totalPortfolioValue),
    tradesExecuted: JSON.parse(history.tradesExecuted),
    tradesCount: history.tradesCount,
    totalTradingVolume: parseFloat(history.totalTradingVolume),
    totalFees: parseFloat(history.totalFees),
    postAllocations: JSON.parse(history.postAllocations),
    status: history.status,
    errorMessage: history.errorMessage,
    triggeredBy: history.triggeredBy,
    startedAt: history.startedAt?.toISOString() || null,
    completedAt: history.completedAt?.toISOString() || null,
    createdAt: history.createdAt.toISOString()
  };
}
var init_portfolioRebalancing = __esm({
  "server/services/portfolioRebalancing.ts"() {
    "use strict";
    init_db();
    init_schema();
  }
});

// server/services/tradeSimulator.ts
var tradeSimulator_exports = {};
__export(tradeSimulator_exports, {
  compareScenarios: () => compareScenarios,
  generateOptimizedTrades: () => generateOptimizedTrades,
  getSamplePositions: () => getSamplePositions,
  simulateTrades: () => simulateTrades
});
function calculatePortfolioMetrics2(positions, cash) {
  const totalEquity = positions.reduce((sum2, p) => sum2 + p.marketValue, 0);
  const totalValue = totalEquity + cash;
  const positionsWithWeights = positions.map((p) => ({
    ...p,
    weight: totalValue > 0 ? p.marketValue / totalValue * 100 : 0
  }));
  const numPositions = positions.length;
  const weights = positionsWithWeights.map((p) => p.weight / 100);
  const herfindahlIndex = weights.reduce((sum2, w) => sum2 + w * w, 0);
  const diversificationScore = numPositions > 0 ? Math.min(100, (1 - herfindahlIndex) * 100 * (Math.min(numPositions, 20) / 20)) : 0;
  const maxWeight = Math.max(...weights, 0);
  const concentrationRisk = maxWeight * 100;
  let portfolioBeta = 0;
  for (const pos of positionsWithWeights) {
    const beta = BETA_VALUES[pos.symbol] || BETA_VALUES["default"];
    portfolioBeta += beta * (pos.weight / 100);
  }
  let portfolioVolatility = 0;
  for (const pos of positionsWithWeights) {
    const vol = VOLATILITY_VALUES[pos.symbol] || VOLATILITY_VALUES["default"];
    portfolioVolatility += vol * (pos.weight / 100);
  }
  const riskFreeRate = 0.05;
  const expectedReturn = 0.1;
  const sharpeRatio = portfolioVolatility > 0 ? (expectedReturn - riskFreeRate) / portfolioVolatility : 0;
  const maxDrawdownRisk = portfolioVolatility * 2.5;
  const sectorExposure = {};
  for (const pos of positionsWithWeights) {
    const sector = SECTOR_MAPPING[pos.symbol] || "Other";
    sectorExposure[sector] = (sectorExposure[sector] || 0) + pos.weight;
  }
  return {
    totalValue,
    totalCash: cash,
    totalEquity,
    positions: positionsWithWeights,
    diversificationScore,
    concentrationRisk,
    beta: portfolioBeta,
    volatility: portfolioVolatility * 100,
    // Convert to percentage
    sharpeRatio,
    maxDrawdownRisk: maxDrawdownRisk * 100,
    // Convert to percentage
    sectorExposure
  };
}
function applyTradesToPositions(positions, cash, trades2) {
  const newPositions = [...positions.map((p) => ({ ...p }))];
  let newCash = cash;
  for (const trade of trades2) {
    const tradeValue = trade.quantity * trade.estimatedPrice;
    const existingIndex = newPositions.findIndex((p) => p.symbol === trade.symbol);
    if (trade.side === "buy") {
      newCash -= tradeValue;
      if (existingIndex >= 0) {
        const existing = newPositions[existingIndex];
        const totalCost = existing.avgCost * existing.quantity + tradeValue;
        const totalQty = existing.quantity + trade.quantity;
        existing.quantity = totalQty;
        existing.avgCost = totalCost / totalQty;
        existing.marketValue = totalQty * trade.estimatedPrice;
        existing.currentPrice = trade.estimatedPrice;
        existing.unrealizedPL = existing.marketValue - existing.avgCost * totalQty;
        existing.unrealizedPLPercent = existing.unrealizedPL / (existing.avgCost * totalQty) * 100;
      } else {
        newPositions.push({
          symbol: trade.symbol,
          quantity: trade.quantity,
          avgCost: trade.estimatedPrice,
          currentPrice: trade.estimatedPrice,
          marketValue: tradeValue,
          unrealizedPL: 0,
          unrealizedPLPercent: 0,
          weight: 0
          // Will be recalculated
        });
      }
    } else {
      newCash += tradeValue;
      if (existingIndex >= 0) {
        const existing = newPositions[existingIndex];
        existing.quantity -= trade.quantity;
        if (existing.quantity <= 0) {
          newPositions.splice(existingIndex, 1);
        } else {
          existing.marketValue = existing.quantity * trade.estimatedPrice;
          existing.currentPrice = trade.estimatedPrice;
          existing.unrealizedPL = existing.marketValue - existing.avgCost * existing.quantity;
          existing.unrealizedPLPercent = existing.unrealizedPL / (existing.avgCost * existing.quantity) * 100;
        }
      }
    }
  }
  return { positions: newPositions, cash: newCash };
}
function generateWarnings(beforeMetrics, afterMetrics, trades2) {
  const warnings = [];
  if (afterMetrics.concentrationRisk > 25) {
    const topPosition = afterMetrics.positions.reduce((max, p) => p.weight > max.weight ? p : max, afterMetrics.positions[0]);
    warnings.push({
      type: "concentration",
      severity: afterMetrics.concentrationRisk > 40 ? "high" : "medium",
      message: `High concentration risk: ${topPosition?.symbol || "Unknown"} will represent ${afterMetrics.concentrationRisk.toFixed(1)}% of portfolio`,
      affectedSymbol: topPosition?.symbol
    });
  }
  if (afterMetrics.diversificationScore < 40) {
    warnings.push({
      type: "diversification",
      severity: afterMetrics.diversificationScore < 20 ? "high" : "medium",
      message: `Low diversification score (${afterMetrics.diversificationScore.toFixed(0)}). Consider spreading investments across more assets.`
    });
  }
  if (afterMetrics.volatility > beforeMetrics.volatility * 1.2) {
    warnings.push({
      type: "volatility",
      severity: afterMetrics.volatility > 40 ? "high" : "medium",
      message: `Portfolio volatility will increase by ${((afterMetrics.volatility - beforeMetrics.volatility) / beforeMetrics.volatility * 100).toFixed(1)}%`
    });
  }
  if (afterMetrics.totalCash < 0) {
    warnings.push({
      type: "margin",
      severity: "high",
      message: `Insufficient cash: These trades would require $${Math.abs(afterMetrics.totalCash).toFixed(2)} in margin`
    });
  } else if (afterMetrics.totalCash < afterMetrics.totalValue * 0.05) {
    warnings.push({
      type: "margin",
      severity: "low",
      message: `Low cash reserve: Only ${(afterMetrics.totalCash / afterMetrics.totalValue * 100).toFixed(1)}% cash remaining`
    });
  }
  const sellTrades = trades2.filter((t2) => t2.side === "sell");
  if (sellTrades.length > 0) {
    warnings.push({
      type: "tax",
      severity: "low",
      message: `${sellTrades.length} sell trade(s) may trigger capital gains tax. Review tax implications.`
    });
  }
  return warnings;
}
function estimateCosts(trades2, beforePositions) {
  let estimatedCommission = 0;
  let estimatedSlippage = 0;
  let estimatedTaxImpact = 0;
  for (const trade of trades2) {
    const tradeValue = trade.quantity * trade.estimatedPrice;
    estimatedCommission += Math.max(1, trade.quantity * 5e-3);
    estimatedSlippage += tradeValue * 1e-3;
    if (trade.side === "sell") {
      const existingPosition = beforePositions.find((p) => p.symbol === trade.symbol);
      if (existingPosition && existingPosition.unrealizedPL > 0) {
        const profitPerShare = existingPosition.unrealizedPL / existingPosition.quantity;
        const realizedProfit = Math.min(trade.quantity, existingPosition.quantity) * profitPerShare;
        if (realizedProfit > 0) {
          estimatedTaxImpact += realizedProfit * 0.15;
        }
      }
    }
  }
  return {
    estimatedCommission,
    estimatedSlippage,
    estimatedTaxImpact,
    totalCosts: estimatedCommission + estimatedSlippage + estimatedTaxImpact
  };
}
async function simulateTrades(userId, trades2, scenarioName = "Default Scenario", currentPositions, currentCash) {
  const positions = currentPositions || [];
  const cash = currentCash ?? 1e4;
  const beforeMetrics = calculatePortfolioMetrics2(positions, cash);
  const { positions: newPositions, cash: newCash } = applyTradesToPositions(positions, cash, trades2);
  const afterMetrics = calculatePortfolioMetrics2(newPositions, newCash);
  const warnings = generateWarnings(beforeMetrics, afterMetrics, trades2);
  const costs = estimateCosts(trades2, positions);
  const beforeSymbols = new Set(positions.map((p) => p.symbol));
  const afterSymbols = new Set(newPositions.map((p) => p.symbol));
  const newPositionSymbols = Array.from(afterSymbols).filter((s) => !beforeSymbols.has(s));
  const closedPositionSymbols = Array.from(beforeSymbols).filter((s) => !afterSymbols.has(s));
  const increasedPositions = [];
  const decreasedPositions = [];
  for (const trade of trades2) {
    if (beforeSymbols.has(trade.symbol) && afterSymbols.has(trade.symbol)) {
      if (trade.side === "buy") {
        increasedPositions.push(trade.symbol);
      } else {
        decreasedPositions.push(trade.symbol);
      }
    }
  }
  const impact = {
    totalValueChange: afterMetrics.totalValue - beforeMetrics.totalValue - costs.totalCosts,
    totalValueChangePercent: beforeMetrics.totalValue > 0 ? (afterMetrics.totalValue - beforeMetrics.totalValue - costs.totalCosts) / beforeMetrics.totalValue * 100 : 0,
    cashChange: afterMetrics.totalCash - beforeMetrics.totalCash,
    diversificationChange: afterMetrics.diversificationScore - beforeMetrics.diversificationScore,
    concentrationRiskChange: afterMetrics.concentrationRisk - beforeMetrics.concentrationRisk,
    betaChange: afterMetrics.beta - beforeMetrics.beta,
    volatilityChange: afterMetrics.volatility - beforeMetrics.volatility,
    sharpeRatioChange: afterMetrics.sharpeRatio - beforeMetrics.sharpeRatio,
    maxDrawdownRiskChange: afterMetrics.maxDrawdownRisk - beforeMetrics.maxDrawdownRisk,
    newPositions: newPositionSymbols,
    closedPositions: closedPositionSymbols,
    increasedPositions: Array.from(new Set(increasedPositions)),
    decreasedPositions: Array.from(new Set(decreasedPositions))
  };
  return {
    scenarioId: `sim-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    scenarioName,
    trades: trades2,
    beforeMetrics,
    afterMetrics,
    impact,
    costs,
    warnings,
    simulatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
}
async function compareScenarios(userId, scenarios, currentPositions, currentCash) {
  const results = [];
  for (const scenario of scenarios) {
    const result = await simulateTrades(
      userId,
      scenario.trades,
      scenario.name,
      currentPositions,
      currentCash
    );
    results.push(result);
  }
  let bestScenario = results[0]?.scenarioName || "";
  let worstScenario = results[0]?.scenarioName || "";
  let bestSharpeChange = results[0]?.impact.sharpeRatioChange || -Infinity;
  let worstSharpeChange = results[0]?.impact.sharpeRatioChange || Infinity;
  for (const result of results) {
    if (result.impact.sharpeRatioChange > bestSharpeChange) {
      bestSharpeChange = result.impact.sharpeRatioChange;
      bestScenario = result.scenarioName;
    }
    if (result.impact.sharpeRatioChange < worstSharpeChange) {
      worstSharpeChange = result.impact.sharpeRatioChange;
      worstScenario = result.scenarioName;
    }
  }
  let recommendation = "";
  const bestResult = results.find((r) => r.scenarioName === bestScenario);
  if (bestResult) {
    if (bestResult.warnings.some((w) => w.severity === "high")) {
      recommendation = `"${bestScenario}" has the best risk-adjusted return improvement, but has high-severity warnings. Review carefully before execution.`;
    } else if (bestResult.impact.sharpeRatioChange > 0) {
      recommendation = `"${bestScenario}" is recommended as it improves the portfolio's risk-adjusted return by ${(bestResult.impact.sharpeRatioChange * 100).toFixed(2)}%.`;
    } else {
      recommendation = `None of the scenarios significantly improve risk-adjusted returns. Consider alternative strategies.`;
    }
  }
  return {
    scenarios: results,
    bestScenario,
    worstScenario,
    recommendation
  };
}
async function generateOptimizedTrades(userId, targetAllocations, currentPositions, currentCash, constraints) {
  const trades2 = [];
  const totalValue = currentPositions.reduce((sum2, p) => sum2 + p.marketValue, 0) + currentCash;
  const maxConcentration = constraints?.maxConcentration || 25;
  const minTradeValue = constraints?.minTradeValue || 100;
  const preserveCash = constraints?.preserveCash || totalValue * 0.05;
  const targetValues = {};
  for (const target of targetAllocations) {
    const cappedPercent = Math.min(target.targetPercent, maxConcentration);
    targetValues[target.symbol] = cappedPercent / 100 * totalValue;
  }
  const currentValues = {};
  for (const pos of currentPositions) {
    currentValues[pos.symbol] = pos.marketValue;
  }
  const allSymbols = Array.from(/* @__PURE__ */ new Set([...Object.keys(targetValues), ...Object.keys(currentValues)]));
  for (const symbol of allSymbols) {
    const currentValue = currentValues[symbol] || 0;
    const targetValue = targetValues[symbol] || 0;
    const difference = targetValue - currentValue;
    if (Math.abs(difference) < minTradeValue) continue;
    const position = currentPositions.find((p) => p.symbol === symbol);
    const estimatedPrice = position?.currentPrice || 100;
    const quantity = Math.abs(Math.floor(difference / estimatedPrice));
    if (quantity === 0) continue;
    trades2.push({
      symbol,
      side: difference > 0 ? "buy" : "sell",
      quantity,
      estimatedPrice
    });
  }
  const totalBuys = trades2.filter((t2) => t2.side === "buy").reduce((sum2, t2) => sum2 + t2.quantity * t2.estimatedPrice, 0);
  const availableCash = currentCash - preserveCash;
  if (totalBuys > availableCash) {
    const scaleFactor = availableCash / totalBuys;
    for (const trade of trades2) {
      if (trade.side === "buy") {
        trade.quantity = Math.floor(trade.quantity * scaleFactor);
      }
    }
  }
  return trades2.filter((t2) => t2.quantity > 0);
}
function getSamplePositions() {
  return [
    { symbol: "AAPL", quantity: 50, avgCost: 145, currentPrice: 175, marketValue: 8750, unrealizedPL: 1500, unrealizedPLPercent: 20.69, weight: 0 },
    { symbol: "MSFT", quantity: 30, avgCost: 280, currentPrice: 375, marketValue: 11250, unrealizedPL: 2850, unrealizedPLPercent: 33.93, weight: 0 },
    { symbol: "GOOGL", quantity: 20, avgCost: 120, currentPrice: 140, marketValue: 2800, unrealizedPL: 400, unrealizedPLPercent: 16.67, weight: 0 },
    { symbol: "NVDA", quantity: 15, avgCost: 400, currentPrice: 480, marketValue: 7200, unrealizedPL: 1200, unrealizedPLPercent: 20, weight: 0 },
    { symbol: "TSLA", quantity: 25, avgCost: 200, currentPrice: 250, marketValue: 6250, unrealizedPL: 1250, unrealizedPLPercent: 25, weight: 0 }
  ];
}
var SECTOR_MAPPING, BETA_VALUES, VOLATILITY_VALUES;
var init_tradeSimulator = __esm({
  "server/services/tradeSimulator.ts"() {
    "use strict";
    SECTOR_MAPPING = {
      "AAPL": "Technology",
      "MSFT": "Technology",
      "GOOGL": "Technology",
      "GOOG": "Technology",
      "META": "Technology",
      "NVDA": "Technology",
      "AMD": "Technology",
      "INTC": "Technology",
      "TSLA": "Consumer Discretionary",
      "AMZN": "Consumer Discretionary",
      "JPM": "Financials",
      "BAC": "Financials",
      "GS": "Financials",
      "V": "Financials",
      "MA": "Financials",
      "JNJ": "Healthcare",
      "UNH": "Healthcare",
      "PFE": "Healthcare",
      "MRNA": "Healthcare",
      "XOM": "Energy",
      "CVX": "Energy",
      "COP": "Energy",
      "PG": "Consumer Staples",
      "KO": "Consumer Staples",
      "PEP": "Consumer Staples",
      "WMT": "Consumer Staples",
      "HD": "Consumer Discretionary",
      "NKE": "Consumer Discretionary",
      "DIS": "Communication Services",
      "NFLX": "Communication Services",
      "T": "Communication Services",
      "VZ": "Communication Services",
      "CAT": "Industrials",
      "BA": "Industrials",
      "UPS": "Industrials",
      "NEE": "Utilities",
      "DUK": "Utilities",
      "AMT": "Real Estate",
      "PLD": "Real Estate",
      "LIN": "Materials",
      "APD": "Materials"
    };
    BETA_VALUES = {
      "AAPL": 1.25,
      "MSFT": 0.95,
      "GOOGL": 1.1,
      "META": 1.35,
      "NVDA": 1.7,
      "TSLA": 2.05,
      "AMZN": 1.2,
      "JPM": 1.15,
      "JNJ": 0.7,
      "PG": 0.45,
      "KO": 0.6,
      "XOM": 0.9,
      "default": 1
    };
    VOLATILITY_VALUES = {
      "AAPL": 0.28,
      "MSFT": 0.25,
      "GOOGL": 0.3,
      "META": 0.4,
      "NVDA": 0.55,
      "TSLA": 0.65,
      "AMZN": 0.35,
      "JPM": 0.3,
      "JNJ": 0.18,
      "PG": 0.15,
      "KO": 0.16,
      "XOM": 0.32,
      "default": 0.3
    };
  }
});

// server/services/simulationTemplates.ts
var simulationTemplates_exports = {};
__export(simulationTemplates_exports, {
  createCustomTemplate: () => createCustomTemplate,
  generateTradesFromTemplate: () => generateTradesFromTemplate,
  getAllTemplates: () => getAllTemplates,
  getTemplateById: () => getTemplateById,
  getTemplatesByCategory: () => getTemplatesByCategory,
  getTemplatesByRiskLevel: () => getTemplatesByRiskLevel,
  searchTemplates: () => searchTemplates
});
function generateId() {
  return "template-" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}
function getAllTemplates() {
  return BUILT_IN_TEMPLATES;
}
function getTemplateById(id) {
  return BUILT_IN_TEMPLATES.find((t2) => t2.id === id);
}
function getTemplatesByCategory(category) {
  return BUILT_IN_TEMPLATES.filter((t2) => t2.category === category);
}
function getTemplatesByRiskLevel(riskLevel) {
  return BUILT_IN_TEMPLATES.filter((t2) => t2.riskLevel === riskLevel);
}
function searchTemplates(query) {
  const lowerQuery = query.toLowerCase();
  return BUILT_IN_TEMPLATES.filter(
    (t2) => t2.name.toLowerCase().includes(lowerQuery) || t2.description.toLowerCase().includes(lowerQuery) || t2.tags.some((tag) => tag.toLowerCase().includes(lowerQuery))
  );
}
function generateTradesFromTemplate(template, portfolioValue, currentPositions, currentCash) {
  const trades2 = [];
  const totalValue = portfolioValue;
  const positionMap = /* @__PURE__ */ new Map();
  for (const pos of currentPositions) {
    positionMap.set(pos.symbol, { quantity: pos.quantity, currentPrice: pos.currentPrice });
  }
  for (const allocation of template.targetAllocation) {
    const targetValue = totalValue * (allocation.targetPercent / 100);
    const currentPosition = positionMap.get(allocation.symbol);
    const currentValue = currentPosition ? currentPosition.quantity * currentPosition.currentPrice : 0;
    const difference = targetValue - currentValue;
    const estimatedPrice = currentPosition?.currentPrice || getEstimatedPrice(allocation.symbol);
    if (Math.abs(difference) < 100) continue;
    const quantity = Math.abs(Math.floor(difference / estimatedPrice));
    if (quantity === 0) continue;
    trades2.push({
      symbol: allocation.symbol,
      side: difference > 0 ? "buy" : "sell",
      quantity,
      estimatedPrice,
      targetPercent: allocation.targetPercent
    });
  }
  for (const [symbol, position] of Array.from(positionMap.entries())) {
    const inTemplate = template.targetAllocation.some((a) => a.symbol === symbol);
    if (!inTemplate && position.quantity > 0) {
      trades2.push({
        symbol,
        side: "sell",
        quantity: position.quantity,
        estimatedPrice: position.currentPrice,
        targetPercent: 0
      });
    }
  }
  return trades2;
}
function getEstimatedPrice(symbol) {
  const prices = {
    "AAPL": 175,
    "MSFT": 375,
    "NVDA": 480,
    "GOOGL": 140,
    "META": 350,
    "AMZN": 155,
    "TSLA": 250,
    "JPM": 170,
    "JNJ": 160,
    "PG": 155,
    "KO": 60,
    "PEP": 175,
    "VZ": 40,
    "T": 18,
    "XOM": 105,
    "CVX": 150,
    "BRK.B": 360,
    "UNH": 530,
    "PFE": 28,
    "ABBV": 165,
    "MRK": 115,
    "BAC": 35,
    "WFC": 50,
    "GS": 380,
    "MS": 90,
    "AMD": 145,
    "AVGO": 130,
    "CRM": 270,
    "NOW": 700,
    "NFLX": 480,
    "SHOP": 75,
    "SQ": 70,
    "INTC": 45,
    "WMT": 165,
    "COST": 580,
    "NEE": 75,
    "O": 55,
    "MMM": 100,
    "ABT": 110,
    "CL": 85,
    "MO": 45,
    "VFC": 18,
    // ETFs
    "QQQ": 400,
    "SPY": 475,
    "VTI": 240,
    "VXUS": 55,
    "VUG": 320,
    "VTV": 150,
    "BND": 75,
    "BNDX": 50,
    "TLT": 95,
    "IEI": 115,
    "GLD": 185,
    "DBC": 22,
    "XLV": 140,
    "XLF": 40,
    "XLU": 70,
    "XLP": 75,
    "VNQ": 85,
    "SCHD": 78,
    "DVY": 120,
    "NOBL": 95,
    "MTUM": 175,
    "QUAL": 150,
    "VLUE": 100,
    "ARKK": 50
  };
  return prices[symbol] || 100;
}
function createCustomTemplate(name, description, allocations, riskLevel, rebalanceFrequency) {
  const volatilities = {
    "stock": 0.25,
    "etf": 0.18,
    "bond": 0.08,
    "reit": 0.22,
    "commodity": 0.2,
    "crypto": 0.6
  };
  const returns = {
    "stock": 0.1,
    "etf": 0.08,
    "bond": 0.04,
    "reit": 0.07,
    "commodity": 0.05,
    "crypto": 0.15
  };
  let estimatedVolatility = 0;
  let estimatedReturn = 0;
  for (const alloc of allocations) {
    const weight = alloc.targetPercent / 100;
    estimatedVolatility += weight * (volatilities[alloc.assetClass] || 0.2);
    estimatedReturn += weight * (returns[alloc.assetClass] || 0.08);
  }
  return {
    id: generateId(),
    name,
    description,
    category: "custom",
    riskLevel,
    targetAllocation: allocations,
    rebalanceFrequency,
    estimatedVolatility,
    estimatedReturn,
    minInvestment: 1e3,
    tags: ["custom", riskLevel],
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    isBuiltIn: false
  };
}
var BUILT_IN_TEMPLATES;
var init_simulationTemplates = __esm({
  "server/services/simulationTemplates.ts"() {
    "use strict";
    BUILT_IN_TEMPLATES = [
      // Sector Rotation Templates
      {
        id: "sector-tech-heavy",
        name: "Tech-Heavy Growth",
        description: "Concentrated technology sector exposure with high growth potential. Suitable for investors with high risk tolerance seeking maximum growth.",
        category: "sector_rotation",
        riskLevel: "aggressive",
        targetAllocation: [
          { symbol: "AAPL", name: "Apple Inc.", targetPercent: 20, sector: "Technology", assetClass: "stock" },
          { symbol: "MSFT", name: "Microsoft Corp.", targetPercent: 20, sector: "Technology", assetClass: "stock" },
          { symbol: "NVDA", name: "NVIDIA Corp.", targetPercent: 15, sector: "Technology", assetClass: "stock" },
          { symbol: "GOOGL", name: "Alphabet Inc.", targetPercent: 15, sector: "Technology", assetClass: "stock" },
          { symbol: "META", name: "Meta Platforms", targetPercent: 10, sector: "Technology", assetClass: "stock" },
          { symbol: "AMZN", name: "Amazon.com", targetPercent: 10, sector: "Consumer Discretionary", assetClass: "stock" },
          { symbol: "QQQ", name: "Nasdaq 100 ETF", targetPercent: 10, sector: "Technology", assetClass: "etf" }
        ],
        rebalanceFrequency: "quarterly",
        estimatedVolatility: 0.35,
        estimatedReturn: 0.15,
        minInvestment: 5e3,
        tags: ["technology", "growth", "high-risk", "sector-rotation"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      },
      {
        id: "sector-healthcare",
        name: "Healthcare Sector Focus",
        description: "Defensive healthcare sector allocation with pharmaceutical and biotech exposure. Lower volatility with steady growth potential.",
        category: "sector_rotation",
        riskLevel: "moderate",
        targetAllocation: [
          { symbol: "JNJ", name: "Johnson & Johnson", targetPercent: 20, sector: "Healthcare", assetClass: "stock" },
          { symbol: "UNH", name: "UnitedHealth Group", targetPercent: 18, sector: "Healthcare", assetClass: "stock" },
          { symbol: "PFE", name: "Pfizer Inc.", targetPercent: 15, sector: "Healthcare", assetClass: "stock" },
          { symbol: "ABBV", name: "AbbVie Inc.", targetPercent: 15, sector: "Healthcare", assetClass: "stock" },
          { symbol: "MRK", name: "Merck & Co.", targetPercent: 12, sector: "Healthcare", assetClass: "stock" },
          { symbol: "XLV", name: "Health Care Select ETF", targetPercent: 20, sector: "Healthcare", assetClass: "etf" }
        ],
        rebalanceFrequency: "quarterly",
        estimatedVolatility: 0.18,
        estimatedReturn: 0.09,
        minInvestment: 3e3,
        tags: ["healthcare", "defensive", "moderate-risk", "sector-rotation"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      },
      {
        id: "sector-financials",
        name: "Financial Sector Play",
        description: "Banking and financial services exposure. Benefits from rising interest rates and economic growth.",
        category: "sector_rotation",
        riskLevel: "moderate",
        targetAllocation: [
          { symbol: "JPM", name: "JPMorgan Chase", targetPercent: 20, sector: "Financials", assetClass: "stock" },
          { symbol: "BAC", name: "Bank of America", targetPercent: 15, sector: "Financials", assetClass: "stock" },
          { symbol: "WFC", name: "Wells Fargo", targetPercent: 12, sector: "Financials", assetClass: "stock" },
          { symbol: "GS", name: "Goldman Sachs", targetPercent: 13, sector: "Financials", assetClass: "stock" },
          { symbol: "MS", name: "Morgan Stanley", targetPercent: 10, sector: "Financials", assetClass: "stock" },
          { symbol: "BRK.B", name: "Berkshire Hathaway", targetPercent: 15, sector: "Financials", assetClass: "stock" },
          { symbol: "XLF", name: "Financial Select ETF", targetPercent: 15, sector: "Financials", assetClass: "etf" }
        ],
        rebalanceFrequency: "quarterly",
        estimatedVolatility: 0.25,
        estimatedReturn: 0.1,
        minInvestment: 4e3,
        tags: ["financials", "banks", "moderate-risk", "sector-rotation"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      },
      // Dividend Growth Templates
      {
        id: "dividend-aristocrats",
        name: "Dividend Aristocrats",
        description: "Companies with 25+ years of consecutive dividend increases. Focus on income and capital preservation with steady growth.",
        category: "dividend_growth",
        riskLevel: "conservative",
        targetAllocation: [
          { symbol: "JNJ", name: "Johnson & Johnson", targetPercent: 15, sector: "Healthcare", assetClass: "stock" },
          { symbol: "PG", name: "Procter & Gamble", targetPercent: 15, sector: "Consumer Staples", assetClass: "stock" },
          { symbol: "KO", name: "Coca-Cola Co.", targetPercent: 12, sector: "Consumer Staples", assetClass: "stock" },
          { symbol: "PEP", name: "PepsiCo Inc.", targetPercent: 12, sector: "Consumer Staples", assetClass: "stock" },
          { symbol: "MMM", name: "3M Company", targetPercent: 10, sector: "Industrials", assetClass: "stock" },
          { symbol: "ABT", name: "Abbott Laboratories", targetPercent: 12, sector: "Healthcare", assetClass: "stock" },
          { symbol: "CL", name: "Colgate-Palmolive", targetPercent: 10, sector: "Consumer Staples", assetClass: "stock" },
          { symbol: "NOBL", name: "Dividend Aristocrats ETF", targetPercent: 14, sector: "Diversified", assetClass: "etf" }
        ],
        rebalanceFrequency: "annually",
        estimatedVolatility: 0.14,
        estimatedReturn: 0.08,
        minInvestment: 5e3,
        tags: ["dividend", "income", "conservative", "blue-chip"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      },
      {
        id: "high-yield-dividend",
        name: "High Yield Income",
        description: "Focus on high dividend yield stocks and REITs for maximum current income. Higher risk due to yield concentration.",
        category: "dividend_growth",
        riskLevel: "moderate",
        targetAllocation: [
          { symbol: "VZ", name: "Verizon Communications", targetPercent: 15, sector: "Communication Services", assetClass: "stock" },
          { symbol: "T", name: "AT&T Inc.", targetPercent: 12, sector: "Communication Services", assetClass: "stock" },
          { symbol: "MO", name: "Altria Group", targetPercent: 10, sector: "Consumer Staples", assetClass: "stock" },
          { symbol: "O", name: "Realty Income Corp.", targetPercent: 15, sector: "Real Estate", assetClass: "reit" },
          { symbol: "VNQ", name: "Vanguard Real Estate ETF", targetPercent: 15, sector: "Real Estate", assetClass: "etf" },
          { symbol: "SCHD", name: "Schwab US Dividend ETF", targetPercent: 18, sector: "Diversified", assetClass: "etf" },
          { symbol: "DVY", name: "iShares Select Dividend", targetPercent: 15, sector: "Diversified", assetClass: "etf" }
        ],
        rebalanceFrequency: "quarterly",
        estimatedVolatility: 0.18,
        estimatedReturn: 0.07,
        minInvestment: 3e3,
        tags: ["dividend", "high-yield", "income", "reits"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      },
      // Momentum Templates
      {
        id: "momentum-leaders",
        name: "Momentum Leaders",
        description: "Stocks with strong price momentum and relative strength. Higher turnover strategy following market trends.",
        category: "momentum",
        riskLevel: "aggressive",
        targetAllocation: [
          { symbol: "NVDA", name: "NVIDIA Corp.", targetPercent: 18, sector: "Technology", assetClass: "stock" },
          { symbol: "TSLA", name: "Tesla Inc.", targetPercent: 15, sector: "Consumer Discretionary", assetClass: "stock" },
          { symbol: "AMD", name: "Advanced Micro Devices", targetPercent: 12, sector: "Technology", assetClass: "stock" },
          { symbol: "AVGO", name: "Broadcom Inc.", targetPercent: 12, sector: "Technology", assetClass: "stock" },
          { symbol: "CRM", name: "Salesforce Inc.", targetPercent: 10, sector: "Technology", assetClass: "stock" },
          { symbol: "NOW", name: "ServiceNow Inc.", targetPercent: 8, sector: "Technology", assetClass: "stock" },
          { symbol: "MTUM", name: "iShares Momentum ETF", targetPercent: 25, sector: "Diversified", assetClass: "etf" }
        ],
        rebalanceFrequency: "monthly",
        estimatedVolatility: 0.4,
        estimatedReturn: 0.18,
        minInvestment: 5e3,
        tags: ["momentum", "growth", "high-risk", "trend-following"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      },
      {
        id: "momentum-factor",
        name: "Factor Momentum",
        description: "ETF-based momentum strategy with diversified factor exposure. Lower single-stock risk while capturing momentum premium.",
        category: "momentum",
        riskLevel: "moderate",
        targetAllocation: [
          { symbol: "MTUM", name: "iShares Momentum ETF", targetPercent: 35, sector: "Diversified", assetClass: "etf" },
          { symbol: "QUAL", name: "iShares Quality ETF", targetPercent: 25, sector: "Diversified", assetClass: "etf" },
          { symbol: "VUG", name: "Vanguard Growth ETF", targetPercent: 25, sector: "Diversified", assetClass: "etf" },
          { symbol: "QQQ", name: "Nasdaq 100 ETF", targetPercent: 15, sector: "Technology", assetClass: "etf" }
        ],
        rebalanceFrequency: "monthly",
        estimatedVolatility: 0.25,
        estimatedReturn: 0.12,
        minInvestment: 2e3,
        tags: ["momentum", "factor", "etf", "diversified"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      },
      // Value Templates
      {
        id: "deep-value",
        name: "Deep Value",
        description: "Undervalued stocks trading below intrinsic value. Contrarian approach with long-term horizon.",
        category: "value",
        riskLevel: "moderate",
        targetAllocation: [
          { symbol: "BRK.B", name: "Berkshire Hathaway", targetPercent: 20, sector: "Financials", assetClass: "stock" },
          { symbol: "CVX", name: "Chevron Corp.", targetPercent: 12, sector: "Energy", assetClass: "stock" },
          { symbol: "XOM", name: "Exxon Mobil", targetPercent: 12, sector: "Energy", assetClass: "stock" },
          { symbol: "INTC", name: "Intel Corp.", targetPercent: 10, sector: "Technology", assetClass: "stock" },
          { symbol: "VFC", name: "VF Corporation", targetPercent: 8, sector: "Consumer Discretionary", assetClass: "stock" },
          { symbol: "VTV", name: "Vanguard Value ETF", targetPercent: 20, sector: "Diversified", assetClass: "etf" },
          { symbol: "VLUE", name: "iShares Value Factor", targetPercent: 18, sector: "Diversified", assetClass: "etf" }
        ],
        rebalanceFrequency: "quarterly",
        estimatedVolatility: 0.2,
        estimatedReturn: 0.09,
        minInvestment: 4e3,
        tags: ["value", "contrarian", "long-term", "undervalued"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      },
      // Defensive Templates
      {
        id: "defensive-staples",
        name: "Defensive Staples",
        description: "Consumer staples and utilities for capital preservation. Low volatility with steady dividends.",
        category: "defensive",
        riskLevel: "conservative",
        targetAllocation: [
          { symbol: "PG", name: "Procter & Gamble", targetPercent: 18, sector: "Consumer Staples", assetClass: "stock" },
          { symbol: "KO", name: "Coca-Cola Co.", targetPercent: 15, sector: "Consumer Staples", assetClass: "stock" },
          { symbol: "WMT", name: "Walmart Inc.", targetPercent: 15, sector: "Consumer Staples", assetClass: "stock" },
          { symbol: "COST", name: "Costco Wholesale", targetPercent: 12, sector: "Consumer Staples", assetClass: "stock" },
          { symbol: "NEE", name: "NextEra Energy", targetPercent: 10, sector: "Utilities", assetClass: "stock" },
          { symbol: "XLU", name: "Utilities Select ETF", targetPercent: 15, sector: "Utilities", assetClass: "etf" },
          { symbol: "XLP", name: "Consumer Staples ETF", targetPercent: 15, sector: "Consumer Staples", assetClass: "etf" }
        ],
        rebalanceFrequency: "annually",
        estimatedVolatility: 0.12,
        estimatedReturn: 0.06,
        minInvestment: 3e3,
        tags: ["defensive", "low-volatility", "staples", "utilities"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      },
      // Growth Templates
      {
        id: "aggressive-growth",
        name: "Aggressive Growth",
        description: "High-growth companies with strong revenue growth. Maximum capital appreciation potential with higher risk.",
        category: "growth",
        riskLevel: "aggressive",
        targetAllocation: [
          { symbol: "NVDA", name: "NVIDIA Corp.", targetPercent: 15, sector: "Technology", assetClass: "stock" },
          { symbol: "TSLA", name: "Tesla Inc.", targetPercent: 12, sector: "Consumer Discretionary", assetClass: "stock" },
          { symbol: "AMZN", name: "Amazon.com", targetPercent: 12, sector: "Consumer Discretionary", assetClass: "stock" },
          { symbol: "NFLX", name: "Netflix Inc.", targetPercent: 10, sector: "Communication Services", assetClass: "stock" },
          { symbol: "SHOP", name: "Shopify Inc.", targetPercent: 8, sector: "Technology", assetClass: "stock" },
          { symbol: "SQ", name: "Block Inc.", targetPercent: 8, sector: "Financials", assetClass: "stock" },
          { symbol: "ARKK", name: "ARK Innovation ETF", targetPercent: 20, sector: "Diversified", assetClass: "etf" },
          { symbol: "VUG", name: "Vanguard Growth ETF", targetPercent: 15, sector: "Diversified", assetClass: "etf" }
        ],
        rebalanceFrequency: "quarterly",
        estimatedVolatility: 0.45,
        estimatedReturn: 0.2,
        minInvestment: 5e3,
        tags: ["growth", "aggressive", "high-risk", "innovation"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      },
      // Balanced Templates
      {
        id: "classic-60-40",
        name: "Classic 60/40",
        description: "Traditional balanced portfolio with 60% stocks and 40% bonds. Time-tested allocation for moderate risk tolerance.",
        category: "balanced",
        riskLevel: "moderate",
        targetAllocation: [
          { symbol: "VTI", name: "Vanguard Total Stock", targetPercent: 40, sector: "Diversified", assetClass: "etf" },
          { symbol: "VXUS", name: "Vanguard Intl Stock", targetPercent: 20, sector: "International", assetClass: "etf" },
          { symbol: "BND", name: "Vanguard Total Bond", targetPercent: 30, sector: "Fixed Income", assetClass: "bond" },
          { symbol: "BNDX", name: "Vanguard Intl Bond", targetPercent: 10, sector: "Fixed Income", assetClass: "bond" }
        ],
        rebalanceFrequency: "annually",
        estimatedVolatility: 0.12,
        estimatedReturn: 0.07,
        minInvestment: 1e3,
        tags: ["balanced", "60-40", "diversified", "classic"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      },
      {
        id: "all-weather",
        name: "All-Weather Portfolio",
        description: "Ray Dalio-inspired portfolio designed to perform in any economic environment. Balanced across asset classes.",
        category: "balanced",
        riskLevel: "conservative",
        targetAllocation: [
          { symbol: "VTI", name: "Vanguard Total Stock", targetPercent: 30, sector: "Diversified", assetClass: "etf" },
          { symbol: "TLT", name: "iShares 20+ Year Treasury", targetPercent: 40, sector: "Fixed Income", assetClass: "bond" },
          { symbol: "IEI", name: "iShares 3-7 Year Treasury", targetPercent: 15, sector: "Fixed Income", assetClass: "bond" },
          { symbol: "GLD", name: "SPDR Gold Shares", targetPercent: 7.5, sector: "Commodities", assetClass: "commodity" },
          { symbol: "DBC", name: "Invesco DB Commodity", targetPercent: 7.5, sector: "Commodities", assetClass: "commodity" }
        ],
        rebalanceFrequency: "annually",
        estimatedVolatility: 0.1,
        estimatedReturn: 0.06,
        minInvestment: 2e3,
        tags: ["all-weather", "balanced", "risk-parity", "diversified"],
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        isBuiltIn: true
      }
    ];
  }
});

// server/services/tradeExecution.ts
var tradeExecution_exports = {};
__export(tradeExecution_exports, {
  cancelOrder: () => cancelOrder2,
  executeTrades: () => executeTrades,
  getExecutionHistory: () => getExecutionHistory,
  validateTrades: () => validateTrades
});
import { eq as eq12, and as and12 } from "drizzle-orm";
function generateExecutionId() {
  return "exec-" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}
function validateTrades(trades2) {
  const errors = [];
  for (const trade of trades2) {
    if (!trade.symbol || trade.symbol.trim() === "") {
      errors.push(`Invalid symbol for trade`);
    }
    if (!trade.side || !["buy", "sell"].includes(trade.side)) {
      errors.push(`Invalid side for ${trade.symbol}: ${trade.side}`);
    }
    if (!trade.quantity || trade.quantity <= 0) {
      errors.push(`Invalid quantity for ${trade.symbol}: ${trade.quantity}`);
    }
    if (trade.orderType === "limit" && !trade.limitPrice) {
      errors.push(`Limit price required for limit order on ${trade.symbol}`);
    }
    if (trade.orderType === "stop" && !trade.stopPrice) {
      errors.push(`Stop price required for stop order on ${trade.symbol}`);
    }
    if (trade.orderType === "stop_limit" && (!trade.limitPrice || !trade.stopPrice)) {
      errors.push(`Both limit and stop prices required for stop-limit order on ${trade.symbol}`);
    }
  }
  return { valid: errors.length === 0, errors };
}
async function executeTrades(request) {
  const db = await getDb();
  const executionId = generateExecutionId();
  const errors = [];
  if (!db) {
    return {
      executionId,
      connectionId: request.connectionId,
      brokerType: "unknown",
      status: "rejected",
      trades: [],
      totalValue: 0,
      totalCommission: 0,
      executedAt: (/* @__PURE__ */ new Date()).toISOString(),
      errors: ["Database not available"]
    };
  }
  const tradeResults = [];
  const validation = validateTrades(request.trades);
  if (!validation.valid) {
    return {
      executionId,
      connectionId: request.connectionId,
      brokerType: "unknown",
      status: "rejected",
      trades: [],
      totalValue: 0,
      totalCommission: 0,
      executedAt: (/* @__PURE__ */ new Date()).toISOString(),
      errors: validation.errors
    };
  }
  const connections = await db.select().from(brokerConnections).where(and12(
    eq12(brokerConnections.id, request.connectionId),
    eq12(brokerConnections.userId, request.userId)
  ));
  if (connections.length === 0) {
    return {
      executionId,
      connectionId: request.connectionId,
      brokerType: "unknown",
      status: "rejected",
      trades: [],
      totalValue: 0,
      totalCommission: 0,
      executedAt: (/* @__PURE__ */ new Date()).toISOString(),
      errors: ["Broker connection not found"]
    };
  }
  const connection = connections[0];
  const brokerType = connection.brokerType;
  if (!connection.isActive) {
    return {
      executionId,
      connectionId: request.connectionId,
      brokerType,
      status: "rejected",
      trades: [],
      totalValue: 0,
      totalCommission: 0,
      executedAt: (/* @__PURE__ */ new Date()).toISOString(),
      errors: ["Broker connection is not active"]
    };
  }
  if (request.dryRun) {
    for (const trade of request.trades) {
      const commission = calculateCommission(brokerType, trade);
      tradeResults.push({
        symbol: trade.symbol,
        side: trade.side,
        requestedQuantity: trade.quantity,
        filledQuantity: trade.quantity,
        avgFillPrice: trade.estimatedPrice,
        commission,
        status: "filled",
        orderId: "dry-run-" + generateExecutionId()
      });
    }
    const totalValue2 = tradeResults.reduce((sum2, t2) => sum2 + t2.filledQuantity * t2.avgFillPrice, 0);
    const totalCommission2 = tradeResults.reduce((sum2, t2) => sum2 + t2.commission, 0);
    return {
      executionId,
      connectionId: request.connectionId,
      brokerType,
      status: "filled",
      trades: tradeResults,
      totalValue: totalValue2,
      totalCommission: totalCommission2,
      executedAt: (/* @__PURE__ */ new Date()).toISOString(),
      errors: []
    };
  }
  for (const trade of request.trades) {
    try {
      const result = await executeTradeWithBroker(connection, trade, brokerType);
      tradeResults.push(result);
      const executionValue = result.filledQuantity * result.avgFillPrice;
      await db.insert(orderExecutions).values({
        id: generateExecutionId(),
        orderId: result.orderId,
        userId: request.userId,
        connectionId: request.connectionId,
        symbol: trade.symbol,
        side: trade.side,
        orderType: trade.orderType || "market",
        executedQuantity: result.filledQuantity.toString(),
        executedPrice: result.avgFillPrice.toString(),
        executionValue: executionValue.toString(),
        commission: result.commission.toString(),
        fees: "0",
        totalCost: (executionValue + result.commission).toString(),
        executedAt: /* @__PURE__ */ new Date(),
        createdAt: /* @__PURE__ */ new Date()
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      errors.push(`Failed to execute ${trade.side} ${trade.quantity} ${trade.symbol}: ${errorMessage}`);
      tradeResults.push({
        symbol: trade.symbol,
        side: trade.side,
        requestedQuantity: trade.quantity,
        filledQuantity: 0,
        avgFillPrice: 0,
        commission: 0,
        status: "rejected",
        orderId: "",
        errorMessage
      });
    }
  }
  const totalValue = tradeResults.reduce((sum2, t2) => sum2 + t2.filledQuantity * t2.avgFillPrice, 0);
  const totalCommission = tradeResults.reduce((sum2, t2) => sum2 + t2.commission, 0);
  const filledCount = tradeResults.filter((t2) => t2.status === "filled").length;
  const partialCount = tradeResults.filter((t2) => t2.status === "partial").length;
  const rejectedCount = tradeResults.filter((t2) => t2.status === "rejected").length;
  let status = "pending";
  if (filledCount === tradeResults.length) {
    status = "filled";
  } else if (rejectedCount === tradeResults.length) {
    status = "rejected";
  } else if (filledCount > 0 || partialCount > 0) {
    status = "partial";
  }
  return {
    executionId,
    connectionId: request.connectionId,
    brokerType,
    status,
    trades: tradeResults,
    totalValue,
    totalCommission,
    executedAt: (/* @__PURE__ */ new Date()).toISOString(),
    errors
  };
}
async function executeTradeWithBroker(connection, trade, brokerType) {
  const commission = calculateCommission(brokerType, trade);
  const slippage = trade.side === "buy" ? 1.001 : 0.999;
  const fillPrice = trade.orderType === "market" ? trade.estimatedPrice * slippage : trade.limitPrice || trade.estimatedPrice;
  await new Promise((resolve) => setTimeout(resolve, 100));
  return {
    symbol: trade.symbol,
    side: trade.side,
    requestedQuantity: trade.quantity,
    filledQuantity: trade.quantity,
    avgFillPrice: fillPrice,
    commission,
    status: "filled",
    orderId: `${brokerType}-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`
  };
}
function calculateCommission(brokerType, trade) {
  const tradeValue = trade.quantity * trade.estimatedPrice;
  const commissionRates = {
    alpaca: { perShare: 0, min: 0, max: 0, percent: 0 },
    // Commission-free
    interactive_brokers: { perShare: 5e-3, min: 1, max: 0.5, percent: 5e-3 },
    binance: { perShare: 0, min: 0, max: 0, percent: 1e-3 },
    // 0.1%
    coinbase: { perShare: 0, min: 0, max: 0, percent: 6e-3 }
    // 0.6%
  };
  const rate = commissionRates[brokerType] || { perShare: 0.01, min: 1, max: 0, percent: 0 };
  if (rate.percent > 0) {
    return tradeValue * rate.percent;
  }
  const perShareCommission = trade.quantity * rate.perShare;
  return Math.max(rate.min, Math.min(perShareCommission, rate.max > 0 ? tradeValue * rate.max : Infinity));
}
async function getExecutionHistory(userId, options = {}) {
  const db = await getDb();
  if (!db) {
    return { executions: [], total: 0 };
  }
  const executions = await db.select().from(orderExecutions).where(eq12(orderExecutions.userId, userId)).orderBy(orderExecutions.executedAt).limit(options.limit || 50).offset(options.offset || 0);
  const countResult = await db.select().from(orderExecutions).where(eq12(orderExecutions.userId, userId));
  return {
    executions,
    total: countResult.length
  };
}
async function cancelOrder2(userId, executionId) {
  const db = await getDb();
  if (!db) {
    return { success: false, message: "Database not available" };
  }
  const executions = await db.select().from(orderExecutions).where(and12(
    eq12(orderExecutions.id, executionId),
    eq12(orderExecutions.userId, userId)
  ));
  if (executions.length === 0) {
    return { success: false, message: "Execution not found" };
  }
  return { success: true, message: "Order cancelled successfully" };
}
var init_tradeExecution = __esm({
  "server/services/tradeExecution.ts"() {
    "use strict";
    init_db();
    init_schema();
  }
});

// server/services/scenarioSharing.ts
var scenarioSharing_exports = {};
__export(scenarioSharing_exports, {
  deleteScenario: () => deleteScenario,
  getCommunityScenarios: () => getCommunityScenarios,
  getScenarioById: () => getScenarioById,
  getScenarioCategories: () => getScenarioCategories,
  getUserScenarios: () => getUserScenarios,
  hasUserLiked: () => hasUserLiked,
  importScenario: () => importScenario,
  likeScenario: () => likeScenario,
  shareScenario: () => shareScenario
});
import { eq as eq13, desc as desc11, and as and13, sql as sql4 } from "drizzle-orm";
async function shareScenario(userId, data) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const scenarioData = {
    trades: data.trades,
    positions: data.positions || [],
    cash: data.cash || 0,
    createdAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  const result = await db.insert(sharedScenarios).values({
    userId,
    name: data.name,
    description: data.description || "",
    scenarioData: JSON.stringify(scenarioData),
    trades: JSON.stringify(data.trades),
    positions: data.positions ? JSON.stringify(data.positions) : null,
    cash: String(data.cash || 0),
    category: data.category || "general",
    tags: data.tags ? JSON.stringify(data.tags) : null,
    isPublic: data.isPublic !== false
  });
  return { id: Number(result[0]?.insertId || 0), success: true };
}
async function getCommunityScenarios(filters = {}) {
  const db = await getDb();
  if (!db) return [];
  const limit = filters.limit || 20;
  const offset = filters.offset || 0;
  let query = db.select({
    id: sharedScenarios.id,
    name: sharedScenarios.name,
    description: sharedScenarios.description,
    category: sharedScenarios.category,
    tags: sharedScenarios.tags,
    likesCount: sharedScenarios.likesCount,
    importsCount: sharedScenarios.importsCount,
    viewsCount: sharedScenarios.viewsCount,
    trades: sharedScenarios.trades,
    createdAt: sharedScenarios.createdAt,
    userId: sharedScenarios.userId,
    authorName: users.name
  }).from(sharedScenarios).leftJoin(users, eq13(sharedScenarios.userId, users.id)).where(eq13(sharedScenarios.isPublic, true)).limit(limit).offset(offset);
  if (filters.sortBy === "likes") {
    query = query.orderBy(desc11(sharedScenarios.likesCount));
  } else if (filters.sortBy === "imports") {
    query = query.orderBy(desc11(sharedScenarios.importsCount));
  } else {
    query = query.orderBy(desc11(sharedScenarios.createdAt));
  }
  const results = await query;
  return results.map((r) => ({
    id: r.id,
    name: r.name,
    description: r.description || "",
    category: r.category || "general",
    tags: r.tags ? typeof r.tags === "string" ? JSON.parse(r.tags) : r.tags : [],
    likesCount: r.likesCount || 0,
    importsCount: r.importsCount || 0,
    viewsCount: r.viewsCount || 0,
    authorName: r.authorName || "Anonymous",
    authorId: r.userId,
    createdAt: r.createdAt,
    trades: r.trades ? typeof r.trades === "string" ? JSON.parse(r.trades) : r.trades : []
  }));
}
async function getScenarioById(scenarioId, incrementView = true) {
  const db = await getDb();
  if (!db) return null;
  if (incrementView) {
    await db.update(sharedScenarios).set({ viewsCount: sql4`${sharedScenarios.viewsCount} + 1` }).where(eq13(sharedScenarios.id, scenarioId));
  }
  const results = await db.select({
    id: sharedScenarios.id,
    name: sharedScenarios.name,
    description: sharedScenarios.description,
    category: sharedScenarios.category,
    tags: sharedScenarios.tags,
    trades: sharedScenarios.trades,
    positions: sharedScenarios.positions,
    cash: sharedScenarios.cash,
    likesCount: sharedScenarios.likesCount,
    importsCount: sharedScenarios.importsCount,
    viewsCount: sharedScenarios.viewsCount,
    createdAt: sharedScenarios.createdAt,
    userId: sharedScenarios.userId,
    authorName: users.name
  }).from(sharedScenarios).leftJoin(users, eq13(sharedScenarios.userId, users.id)).where(eq13(sharedScenarios.id, scenarioId)).limit(1);
  if (results.length === 0) return null;
  const r = results[0];
  return {
    id: r.id,
    name: r.name,
    description: r.description || "",
    category: r.category || "general",
    tags: r.tags ? typeof r.tags === "string" ? JSON.parse(r.tags) : r.tags : [],
    trades: r.trades ? typeof r.trades === "string" ? JSON.parse(r.trades) : r.trades : [],
    positions: r.positions ? typeof r.positions === "string" ? JSON.parse(r.positions) : r.positions : [],
    cash: Number(r.cash) || 0,
    likesCount: r.likesCount || 0,
    importsCount: r.importsCount || 0,
    viewsCount: r.viewsCount || 0,
    authorName: r.authorName || "Anonymous",
    authorId: r.userId,
    createdAt: r.createdAt
  };
}
async function likeScenario(scenarioId, userId) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const existing = await db.select().from(scenarioLikes).where(and13(
    eq13(scenarioLikes.scenarioId, scenarioId),
    eq13(scenarioLikes.userId, userId)
  )).limit(1);
  if (existing.length > 0) {
    await db.delete(scenarioLikes).where(and13(
      eq13(scenarioLikes.scenarioId, scenarioId),
      eq13(scenarioLikes.userId, userId)
    ));
    await db.update(sharedScenarios).set({ likesCount: sql4`${sharedScenarios.likesCount} - 1` }).where(eq13(sharedScenarios.id, scenarioId));
    return { success: true, liked: false };
  } else {
    await db.insert(scenarioLikes).values({
      scenarioId,
      userId
    });
    await db.update(sharedScenarios).set({ likesCount: sql4`${sharedScenarios.likesCount} + 1` }).where(eq13(sharedScenarios.id, scenarioId));
    return { success: true, liked: true };
  }
}
async function importScenario(scenarioId, userId) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const scenario = await getScenarioById(scenarioId, false);
  if (!scenario) throw new Error("Scenario not found");
  await db.insert(scenarioImports).values({
    scenarioId,
    userId
  });
  await db.update(sharedScenarios).set({ importsCount: sql4`${sharedScenarios.importsCount} + 1` }).where(eq13(sharedScenarios.id, scenarioId));
  return {
    success: true,
    trades: scenario.trades,
    positions: scenario.positions,
    cash: scenario.cash
  };
}
async function getUserScenarios(userId) {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select().from(sharedScenarios).where(eq13(sharedScenarios.userId, userId)).orderBy(desc11(sharedScenarios.createdAt));
  return results.map((r) => ({
    id: r.id,
    name: r.name,
    description: r.description || "",
    category: r.category || "general",
    isPublic: r.isPublic || false,
    likesCount: r.likesCount || 0,
    importsCount: r.importsCount || 0,
    viewsCount: r.viewsCount || 0,
    createdAt: r.createdAt
  }));
}
async function deleteScenario(scenarioId, userId) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const scenario = await db.select().from(sharedScenarios).where(and13(
    eq13(sharedScenarios.id, scenarioId),
    eq13(sharedScenarios.userId, userId)
  )).limit(1);
  if (scenario.length === 0) {
    throw new Error("Scenario not found or not owned by user");
  }
  await db.delete(scenarioLikes).where(eq13(scenarioLikes.scenarioId, scenarioId));
  await db.delete(scenarioImports).where(eq13(scenarioImports.scenarioId, scenarioId));
  await db.delete(sharedScenarios).where(eq13(sharedScenarios.id, scenarioId));
  return { success: true };
}
async function hasUserLiked(scenarioId, userId) {
  const db = await getDb();
  if (!db) return false;
  const existing = await db.select().from(scenarioLikes).where(and13(
    eq13(scenarioLikes.scenarioId, scenarioId),
    eq13(scenarioLikes.userId, userId)
  )).limit(1);
  return existing.length > 0;
}
async function getScenarioCategories() {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select({
    category: sharedScenarios.category,
    count: sql4`COUNT(*)`
  }).from(sharedScenarios).where(eq13(sharedScenarios.isPublic, true)).groupBy(sharedScenarios.category);
  return results.map((r) => ({
    category: r.category || "general",
    count: Number(r.count)
  }));
}
var init_scenarioSharing = __esm({
  "server/services/scenarioSharing.ts"() {
    "use strict";
    init_db();
    init_schema();
  }
});

// server/services/monteCarloVisualization.ts
var monteCarloVisualization_exports = {};
__export(monteCarloVisualization_exports, {
  formatForChartJS: () => formatForChartJS,
  generateRiskSummary: () => generateRiskSummary,
  generateVisualizationData: () => generateVisualizationData
});
function generateVisualizationData(simulationResults, initialValue, numBins = 50, numSamplePaths = 10, pathData) {
  const sorted = [...simulationResults].sort((a, b) => a - b);
  const n = sorted.length;
  const min = sorted[0];
  const max = sorted[n - 1];
  const binWidth = (max - min) / numBins;
  const bins = [];
  const frequencies = new Array(numBins).fill(0);
  const binLabels = [];
  for (let i = 0; i < numBins; i++) {
    const binStart = min + i * binWidth;
    const binEnd = binStart + binWidth;
    bins.push(binStart + binWidth / 2);
    binLabels.push(`$${(binStart / 1e3).toFixed(1)}k - $${(binEnd / 1e3).toFixed(1)}k`);
  }
  for (const value of simulationResults) {
    const binIndex = Math.min(Math.floor((value - min) / binWidth), numBins - 1);
    frequencies[binIndex]++;
  }
  const normalizedFrequencies = frequencies.map((f) => f / n * 100);
  const mean5 = simulationResults.reduce((a, b) => a + b, 0) / n;
  const median = n % 2 === 0 ? (sorted[n / 2 - 1] + sorted[n / 2]) / 2 : sorted[Math.floor(n / 2)];
  const variance = simulationResults.reduce((sum2, val) => sum2 + Math.pow(val - mean5, 2), 0) / n;
  const standardDeviation2 = Math.sqrt(variance);
  const skewness2 = simulationResults.reduce((sum2, val) => sum2 + Math.pow((val - mean5) / standardDeviation2, 3), 0) / n;
  const kurtosis2 = simulationResults.reduce((sum2, val) => sum2 + Math.pow((val - mean5) / standardDeviation2, 4), 0) / n - 3;
  const returns = simulationResults.map((v) => (v - initialValue) / initialValue);
  const sortedReturns = [...returns].sort((a, b) => a - b);
  const var95Index = Math.floor(n * 0.05);
  const var99Index = Math.floor(n * 0.01);
  const var95 = -sortedReturns[var95Index] * initialValue;
  const var99 = -sortedReturns[var99Index] * initialValue;
  const cvar95 = -sortedReturns.slice(0, var95Index).reduce((a, b) => a + b, 0) / var95Index * initialValue;
  const cvar99 = -sortedReturns.slice(0, var99Index).reduce((a, b) => a + b, 0) / var99Index * initialValue;
  const getPercentile = (p) => sorted[Math.floor(n * p)];
  const confidenceIntervals = {
    ci50: { lower: getPercentile(0.25), upper: getPercentile(0.75) },
    ci75: { lower: getPercentile(0.125), upper: getPercentile(0.875) },
    ci90: { lower: getPercentile(0.05), upper: getPercentile(0.95) },
    ci95: { lower: getPercentile(0.025), upper: getPercentile(0.975) },
    ci99: { lower: getPercentile(5e-3), upper: getPercentile(0.995) }
  };
  const profitCount = simulationResults.filter((v) => v > initialValue).length;
  const lossCount = simulationResults.filter((v) => v < initialValue).length;
  const breakEvenCount = n - profitCount - lossCount;
  const targets = [
    initialValue * 1.05,
    // 5% gain
    initialValue * 1.1,
    // 10% gain
    initialValue * 1.2,
    // 20% gain
    initialValue * 0.95,
    // 5% loss
    initialValue * 0.9,
    // 10% loss
    initialValue * 0.8
    // 20% loss
  ];
  const targetProbabilities = targets.map((target) => ({
    target,
    probability: target > initialValue ? simulationResults.filter((v) => v >= target).length / n * 100 : simulationResults.filter((v) => v <= target).length / n * 100
  }));
  const cdfValues = [];
  const cdfProbabilities = [];
  const step = Math.max(1, Math.floor(n / 100));
  for (let i = 0; i < n; i += step) {
    cdfValues.push(sorted[i]);
    cdfProbabilities.push(i / n * 100);
  }
  const samplePaths = [];
  if (pathData && pathData.length > 0) {
    const pathsWithFinal = pathData.map((path3, i) => ({
      path: path3,
      finalValue: path3[path3.length - 1],
      index: i
    }));
    pathsWithFinal.sort((a, b) => a.finalValue - b.finalValue);
    const selectedIndices = /* @__PURE__ */ new Set();
    selectedIndices.add(0);
    selectedIndices.add(pathsWithFinal.length - 1);
    selectedIndices.add(Math.floor(pathsWithFinal.length / 2));
    while (selectedIndices.size < Math.min(numSamplePaths, pathsWithFinal.length)) {
      selectedIndices.add(Math.floor(Math.random() * pathsWithFinal.length));
    }
    Array.from(selectedIndices).forEach((idx, i) => {
      const pathInfo = pathsWithFinal[idx];
      const path3 = pathInfo.path;
      let peak = path3[0];
      let maxDrawdown = 0;
      for (const value of path3) {
        if (value > peak) peak = value;
        const drawdown = (peak - value) / peak;
        if (drawdown > maxDrawdown) maxDrawdown = drawdown;
      }
      samplePaths.push({
        pathId: i,
        values: path3,
        finalValue: pathInfo.finalValue,
        maxDrawdown: maxDrawdown * 100,
        isProfit: pathInfo.finalValue > initialValue
      });
    });
  }
  return {
    histogram: {
      bins,
      frequencies: normalizedFrequencies,
      binLabels
    },
    statistics: {
      mean: mean5,
      median,
      standardDeviation: standardDeviation2,
      skewness: skewness2,
      kurtosis: kurtosis2,
      min,
      max
    },
    var: {
      var95,
      var99,
      cvar95,
      cvar99
    },
    confidenceIntervals,
    probabilities: {
      profitProbability: profitCount / n * 100,
      lossProbability: lossCount / n * 100,
      breakEvenProbability: breakEvenCount / n * 100,
      targetProbabilities
    },
    cumulativeDistribution: {
      values: cdfValues,
      probabilities: cdfProbabilities
    },
    samplePaths
  };
}
function generateRiskSummary(visualizationData, initialValue) {
  const { var: varData, probabilities, statistics } = visualizationData;
  let riskScore = 0;
  const var95Percent = varData.var95 / initialValue * 100;
  riskScore += Math.min(30, var95Percent * 3);
  riskScore += probabilities.lossProbability / 100 * 30;
  const cv = statistics.standardDeviation / statistics.mean * 100;
  riskScore += Math.min(20, cv);
  if (statistics.skewness < 0) {
    riskScore += Math.min(10, Math.abs(statistics.skewness) * 5);
  }
  if (statistics.kurtosis > 0) {
    riskScore += Math.min(10, statistics.kurtosis * 2);
  }
  riskScore = Math.min(100, Math.max(0, riskScore));
  let riskLevel;
  if (riskScore < 25) riskLevel = "low";
  else if (riskScore < 50) riskLevel = "moderate";
  else if (riskScore < 75) riskLevel = "high";
  else riskLevel = "extreme";
  const summary = `This strategy has a ${riskLevel} risk profile with a ${probabilities.profitProbability.toFixed(1)}% probability of profit. The 95% VaR is $${varData.var95.toFixed(0)}, meaning there's a 5% chance of losing more than this amount. Expected outcome ranges from $${statistics.min.toFixed(0)} to $${statistics.max.toFixed(0)}.`;
  const recommendations = [];
  if (probabilities.lossProbability > 40) {
    recommendations.push("Consider reducing position sizes to limit potential losses");
  }
  if (var95Percent > 10) {
    recommendations.push("High VaR suggests adding stop-loss orders for protection");
  }
  if (statistics.skewness < -0.5) {
    recommendations.push("Negative skew indicates tail risk - consider hedging strategies");
  }
  if (cv > 30) {
    recommendations.push("High volatility - consider diversifying across more assets");
  }
  if (recommendations.length === 0) {
    recommendations.push("Risk metrics are within acceptable ranges");
    recommendations.push("Continue monitoring market conditions");
  }
  return {
    riskLevel,
    riskScore,
    summary,
    recommendations
  };
}
function formatForChartJS(visualizationData, initialValue) {
  const { histogram, cumulativeDistribution, confidenceIntervals } = visualizationData;
  return {
    histogramChart: {
      labels: histogram.binLabels,
      datasets: [{
        label: "Probability (%)",
        data: histogram.frequencies,
        backgroundColor: "rgba(34, 197, 94, 0.6)",
        borderColor: "rgb(34, 197, 94)"
      }]
    },
    cdfChart: {
      labels: cumulativeDistribution.values.map((v) => `$${(v / 1e3).toFixed(1)}k`),
      datasets: [{
        label: "Cumulative Probability (%)",
        data: cumulativeDistribution.probabilities,
        borderColor: "rgb(59, 130, 246)",
        fill: false
      }]
    },
    confidenceChart: {
      labels: ["50%", "75%", "90%", "95%", "99%"],
      datasets: [
        {
          label: "Lower Bound",
          data: [
            confidenceIntervals.ci50.lower,
            confidenceIntervals.ci75.lower,
            confidenceIntervals.ci90.lower,
            confidenceIntervals.ci95.lower,
            confidenceIntervals.ci99.lower
          ],
          backgroundColor: "rgba(239, 68, 68, 0.6)"
        },
        {
          label: "Upper Bound",
          data: [
            confidenceIntervals.ci50.upper,
            confidenceIntervals.ci75.upper,
            confidenceIntervals.ci90.upper,
            confidenceIntervals.ci95.upper,
            confidenceIntervals.ci99.upper
          ],
          backgroundColor: "rgba(34, 197, 94, 0.6)"
        }
      ]
    }
  };
}
var init_monteCarloVisualization = __esm({
  "server/services/monteCarloVisualization.ts"() {
    "use strict";
  }
});

// server/services/templatePerformanceTracking.ts
var templatePerformanceTracking_exports = {};
__export(templatePerformanceTracking_exports, {
  calculateTemplatePerformance: () => calculateTemplatePerformance,
  compareTemplatePerformance: () => compareTemplatePerformance,
  getHistoricalPerformance: () => getHistoricalPerformance,
  getTemplatePerformanceSummary: () => getTemplatePerformanceSummary,
  getTemplateRankings: () => getTemplateRankings,
  savePerformanceSnapshot: () => savePerformanceSnapshot
});
import { eq as eq14, and as and14, sql as sql5 } from "drizzle-orm";
async function calculateTemplatePerformance(templateId, startDate, endDate, initialInvestment = 1e5) {
  const template = getTemplateById(templateId);
  if (!template) return null;
  const days = Math.floor((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
  const dailyReturns = [];
  const dailyValues = [initialInvestment];
  const baseVolatility = template.estimatedVolatility / Math.sqrt(252);
  const baseDrift = template.estimatedReturn / 252;
  for (let i = 0; i < days; i++) {
    const riskMultiplier = template.riskLevel === "aggressive" ? 1.5 : template.riskLevel === "conservative" ? 0.7 : 1;
    const randomReturn = (Math.random() - 0.5) * 2 * baseVolatility * riskMultiplier;
    const dailyReturn = baseDrift + randomReturn;
    dailyReturns.push(dailyReturn);
    const newValue = dailyValues[dailyValues.length - 1] * (1 + dailyReturn);
    dailyValues.push(newValue);
  }
  const endValue = dailyValues[dailyValues.length - 1];
  const totalReturn = (endValue - initialInvestment) / initialInvestment;
  const yearsElapsed = days / 365;
  const annualizedReturn = Math.pow(1 + totalReturn, 1 / yearsElapsed) - 1;
  const meanReturn = dailyReturns.reduce((a, b) => a + b, 0) / dailyReturns.length;
  const variance = dailyReturns.reduce((sum2, r) => sum2 + Math.pow(r - meanReturn, 2), 0) / dailyReturns.length;
  const dailyVolatility = Math.sqrt(variance);
  const annualizedVolatility = dailyVolatility * Math.sqrt(252);
  const riskFreeRate = 0.03;
  const sharpeRatio = (annualizedReturn - riskFreeRate) / annualizedVolatility;
  let peak = dailyValues[0];
  let maxDrawdown = 0;
  for (const value of dailyValues) {
    if (value > peak) peak = value;
    const drawdown = (peak - value) / peak;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
  }
  const winningDays = dailyReturns.filter((r) => r > 0).length;
  const winRate = winningDays / dailyReturns.length;
  let bestDayIdx = 0;
  let worstDayIdx = 0;
  for (let i = 0; i < dailyReturns.length; i++) {
    if (dailyReturns[i] > dailyReturns[bestDayIdx]) bestDayIdx = i;
    if (dailyReturns[i] < dailyReturns[worstDayIdx]) worstDayIdx = i;
  }
  const bestDate = new Date(startDate.getTime() + bestDayIdx * 24 * 60 * 60 * 1e3);
  const worstDate = new Date(startDate.getTime() + worstDayIdx * 24 * 60 * 60 * 1e3);
  const monthlyReturns = [];
  let monthStart = 0;
  let currentMonth = startDate.getMonth();
  let currentYear = startDate.getFullYear();
  for (let i = 0; i < days; i++) {
    const currentDate = new Date(startDate.getTime() + i * 24 * 60 * 60 * 1e3);
    if (currentDate.getMonth() !== currentMonth || i === days - 1) {
      const monthEnd = i === days - 1 ? i : i - 1;
      const monthReturn = dailyReturns.slice(monthStart, monthEnd + 1).reduce((a, b) => a + b, 0);
      monthlyReturns.push({
        month: `${currentYear}-${String(currentMonth + 1).padStart(2, "0")}`,
        return: monthReturn * 100
      });
      monthStart = i;
      currentMonth = currentDate.getMonth();
      currentYear = currentDate.getFullYear();
    }
  }
  return {
    templateId,
    templateName: template.name,
    period: `${days} days`,
    startDate,
    endDate,
    startValue: initialInvestment,
    endValue,
    totalReturn: totalReturn * 100,
    annualizedReturn: annualizedReturn * 100,
    volatility: annualizedVolatility * 100,
    sharpeRatio,
    maxDrawdown: maxDrawdown * 100,
    winRate: winRate * 100,
    totalTrades: Math.floor(days / (template.rebalanceFrequency === "monthly" ? 30 : template.rebalanceFrequency === "quarterly" ? 90 : template.rebalanceFrequency === "annually" ? 365 : 30)),
    bestDay: { date: bestDate.toISOString().split("T")[0], return: dailyReturns[bestDayIdx] * 100 },
    worstDay: { date: worstDate.toISOString().split("T")[0], return: dailyReturns[worstDayIdx] * 100 },
    monthlyReturns,
    dailyReturns: dailyReturns.map((r) => r * 100)
  };
}
async function getTemplateRankings(period = "1y", sortBy = "return") {
  const templates = getAllTemplates();
  const endDate = /* @__PURE__ */ new Date();
  let startDate;
  switch (period) {
    case "1m":
      startDate = new Date(endDate.getTime() - 30 * 24 * 60 * 60 * 1e3);
      break;
    case "3m":
      startDate = new Date(endDate.getTime() - 90 * 24 * 60 * 60 * 1e3);
      break;
    case "6m":
      startDate = new Date(endDate.getTime() - 180 * 24 * 60 * 60 * 1e3);
      break;
    case "ytd":
      startDate = new Date(endDate.getFullYear(), 0, 1);
      break;
    case "1y":
    default:
      startDate = new Date(endDate.getTime() - 365 * 24 * 60 * 60 * 1e3);
  }
  const rankings = [];
  for (const template of templates) {
    const performance = await calculateTemplatePerformance(template.id, startDate, endDate);
    if (performance) {
      rankings.push({
        templateId: template.id,
        templateName: template.name,
        category: template.category,
        riskLevel: template.riskLevel,
        totalReturn: performance.totalReturn,
        sharpeRatio: performance.sharpeRatio,
        maxDrawdown: performance.maxDrawdown,
        rank: 0
      });
    }
  }
  if (sortBy === "return") {
    rankings.sort((a, b) => b.totalReturn - a.totalReturn);
  } else if (sortBy === "sharpe") {
    rankings.sort((a, b) => b.sharpeRatio - a.sharpeRatio);
  } else {
    rankings.sort((a, b) => a.maxDrawdown - b.maxDrawdown);
  }
  rankings.forEach((r, i) => r.rank = i + 1);
  return rankings;
}
async function savePerformanceSnapshot(templateId, metrics) {
  const db = await getDb();
  if (!db) return;
  const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
  await db.insert(templatePerformance).values({
    templateId,
    snapshotDate: /* @__PURE__ */ new Date(),
    portfolioValue: String(metrics.endValue),
    dailyReturn: String(metrics.dailyReturns[metrics.dailyReturns.length - 1] / 100),
    cumulativeReturn: String(metrics.totalReturn / 100),
    volatility: String(metrics.volatility / 100),
    sharpeRatio: String(metrics.sharpeRatio),
    maxDrawdown: String(metrics.maxDrawdown / 100),
    winRate: String(metrics.winRate / 100),
    totalTrades: metrics.totalTrades,
    positions: JSON.stringify([])
  }).onDuplicateKeyUpdate({
    set: {
      portfolioValue: String(metrics.endValue),
      dailyReturn: String(metrics.dailyReturns[metrics.dailyReturns.length - 1] / 100),
      cumulativeReturn: String(metrics.totalReturn / 100)
    }
  });
}
async function getHistoricalPerformance(templateId, days = 30) {
  const db = await getDb();
  if (!db) return [];
  const startDate = /* @__PURE__ */ new Date();
  startDate.setDate(startDate.getDate() - days);
  const results = await db.select().from(templatePerformance).where(and14(
    eq14(templatePerformance.templateId, templateId),
    sql5`${templatePerformance.snapshotDate} >= ${startDate.toISOString().split("T")[0]}`
  )).orderBy(templatePerformance.snapshotDate);
  return results.map((r) => ({
    date: r.snapshotDate,
    portfolioValue: Number(r.portfolioValue),
    dailyReturn: Number(r.dailyReturn) * 100,
    cumulativeReturn: Number(r.cumulativeReturn) * 100
  }));
}
async function compareTemplatePerformance(templateIds, period = "1y") {
  const endDate = /* @__PURE__ */ new Date();
  let startDate;
  switch (period) {
    case "1m":
      startDate = new Date(endDate.getTime() - 30 * 24 * 60 * 60 * 1e3);
      break;
    case "3m":
      startDate = new Date(endDate.getTime() - 90 * 24 * 60 * 60 * 1e3);
      break;
    case "6m":
      startDate = new Date(endDate.getTime() - 180 * 24 * 60 * 60 * 1e3);
      break;
    case "1y":
    default:
      startDate = new Date(endDate.getTime() - 365 * 24 * 60 * 60 * 1e3);
  }
  const templates = [];
  for (const templateId of templateIds) {
    const template = getTemplateById(templateId);
    const metrics = await calculateTemplatePerformance(templateId, startDate, endDate);
    if (template && metrics) {
      templates.push({
        templateId,
        templateName: template.name,
        metrics
      });
    }
  }
  let bestReturn = { templateId: "", value: -Infinity };
  let bestSharpe = { templateId: "", value: -Infinity };
  let lowestDrawdown = { templateId: "", value: Infinity };
  let lowestVolatility = { templateId: "", value: Infinity };
  for (const t2 of templates) {
    if (t2.metrics.totalReturn > bestReturn.value) {
      bestReturn = { templateId: t2.templateId, value: t2.metrics.totalReturn };
    }
    if (t2.metrics.sharpeRatio > bestSharpe.value) {
      bestSharpe = { templateId: t2.templateId, value: t2.metrics.sharpeRatio };
    }
    if (t2.metrics.maxDrawdown < lowestDrawdown.value) {
      lowestDrawdown = { templateId: t2.templateId, value: t2.metrics.maxDrawdown };
    }
    if (t2.metrics.volatility < lowestVolatility.value) {
      lowestVolatility = { templateId: t2.templateId, value: t2.metrics.volatility };
    }
  }
  return {
    templates,
    comparison: {
      bestReturn,
      bestSharpe,
      lowestDrawdown,
      lowestVolatility
    }
  };
}
function getTemplatePerformanceSummary(templateId) {
  const template = getTemplateById(templateId);
  if (!template) return null;
  return {
    templateId: template.id,
    templateName: template.name,
    category: template.category,
    riskLevel: template.riskLevel,
    estimatedReturn: template.estimatedReturn * 100,
    estimatedVolatility: template.estimatedVolatility * 100,
    rebalanceFrequency: template.rebalanceFrequency,
    minInvestment: template.minInvestment,
    holdings: template.targetAllocation.length
  };
}
var init_templatePerformanceTracking = __esm({
  "server/services/templatePerformanceTracking.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_simulationTemplates();
  }
});

// server/services/ai-agents/AgentOrchestrator.ts
var AgentOrchestrator_exports = {};
__export(AgentOrchestrator_exports, {
  ExecutionAgent: () => ExecutionAgent,
  FundamentalAnalysisAgent: () => FundamentalAnalysisAgent,
  MarketRegimeAgent: () => MarketRegimeAgent,
  MetaCoordinatorAgent: () => MetaCoordinatorAgent,
  RiskManagementAgent: () => RiskManagementAgent,
  SentimentAnalysisAgent: () => SentimentAnalysisAgent,
  TechnicalAnalysisAgent: () => TechnicalAnalysisAgent,
  agentOrchestrator: () => agentOrchestrator
});
var TechnicalAnalysisAgent, FundamentalAnalysisAgent, SentimentAnalysisAgent, RiskManagementAgent, MarketRegimeAgent, ExecutionAgent, MetaCoordinatorAgent, agentOrchestrator;
var init_AgentOrchestrator = __esm({
  "server/services/ai-agents/AgentOrchestrator.ts"() {
    "use strict";
    init_llm();
    TechnicalAnalysisAgent = class {
      agentType = "technical";
      historicalAccuracy = 0.65;
      // Updated based on performance
      async analyze(data) {
        const indicators = data.indicators || {};
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        if (indicators.rsi !== void 0) {
          if (indicators.rsi < 30) {
            signal = "buy";
            confidence += 15;
            reasons.push(`RSI oversold at ${indicators.rsi.toFixed(1)}`);
          } else if (indicators.rsi > 70) {
            signal = "sell";
            confidence += 15;
            reasons.push(`RSI overbought at ${indicators.rsi.toFixed(1)}`);
          } else if (indicators.rsi > 50 && indicators.rsi < 60) {
            reasons.push(`RSI neutral-bullish at ${indicators.rsi.toFixed(1)}`);
            confidence += 5;
          }
        }
        if (indicators.macd) {
          if (indicators.macd.histogram > 0 && indicators.macd.value > indicators.macd.signal) {
            if (signal === "buy") {
              signal = "strong_buy";
              confidence += 10;
            } else if (signal === "hold") {
              signal = "buy";
              confidence += 10;
            }
            reasons.push("MACD bullish crossover");
          } else if (indicators.macd.histogram < 0 && indicators.macd.value < indicators.macd.signal) {
            if (signal === "sell") {
              signal = "strong_sell";
              confidence += 10;
            } else if (signal === "hold") {
              signal = "sell";
              confidence += 10;
            }
            reasons.push("MACD bearish crossover");
          }
        }
        if (indicators.ema) {
          const { ema8, ema21, ema50, ema200 } = indicators.ema;
          if (ema8 > ema21 && ema21 > ema50 && ema50 > ema200) {
            reasons.push("Strong uptrend: EMA alignment bullish");
            confidence += 10;
            if (signal === "hold") signal = "buy";
          } else if (ema8 < ema21 && ema21 < ema50 && ema50 < ema200) {
            reasons.push("Strong downtrend: EMA alignment bearish");
            confidence += 10;
            if (signal === "hold") signal = "sell";
          }
        }
        if (indicators.bollinger && data.currentPrice) {
          const { upper, lower, middle } = indicators.bollinger;
          if (data.currentPrice <= lower) {
            reasons.push("Price at lower Bollinger Band - potential bounce");
            confidence += 8;
            if (signal === "hold") signal = "buy";
          } else if (data.currentPrice >= upper) {
            reasons.push("Price at upper Bollinger Band - potential pullback");
            confidence += 8;
            if (signal === "hold") signal = "sell";
          }
        }
        if (data.priceHistory.length >= 5) {
          const recent = data.priceHistory.slice(-5);
          const higherHighs = recent.every(
            (candle, i) => i === 0 || candle.high >= recent[i - 1].high
          );
          const lowerLows = recent.every(
            (candle, i) => i === 0 || candle.low <= recent[i - 1].low
          );
          if (higherHighs) {
            reasons.push("Higher highs pattern detected");
            confidence += 5;
          }
          if (lowerLows) {
            reasons.push("Lower lows pattern detected");
            confidence += 5;
          }
        }
        confidence = Math.min(95, Math.max(10, confidence));
        return {
          agentType: this.agentType,
          signal,
          confidence,
          reasoning: reasons.join(". ") || "Insufficient technical data for analysis",
          indicators: {
            rsi: indicators.rsi || "N/A",
            macdHistogram: indicators.macd?.histogram || "N/A",
            atr: indicators.atr || "N/A"
          },
          timestamp: Date.now()
        };
      }
      updateAccuracy(wasCorrect) {
        this.historicalAccuracy = this.historicalAccuracy * 0.95 + (wasCorrect ? 0.05 : 0);
      }
      getWeight() {
        return this.historicalAccuracy;
      }
    };
    FundamentalAnalysisAgent = class {
      agentType = "fundamental";
      historicalAccuracy = 0.6;
      async analyze(data) {
        const fundamentals = data.fundamentals || {};
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        if (fundamentals.peRatio !== void 0) {
          if (fundamentals.peRatio < 15 && fundamentals.peRatio > 0) {
            signal = "buy";
            confidence += 15;
            reasons.push(`Undervalued with P/E of ${fundamentals.peRatio.toFixed(1)}`);
          } else if (fundamentals.peRatio > 40) {
            signal = "sell";
            confidence += 10;
            reasons.push(`Potentially overvalued with P/E of ${fundamentals.peRatio.toFixed(1)}`);
          } else if (fundamentals.peRatio >= 15 && fundamentals.peRatio <= 25) {
            reasons.push(`Fair valuation with P/E of ${fundamentals.peRatio.toFixed(1)}`);
          }
        }
        if (fundamentals.earningsGrowth !== void 0) {
          if (fundamentals.earningsGrowth > 20) {
            confidence += 15;
            reasons.push(`Strong earnings growth at ${fundamentals.earningsGrowth.toFixed(1)}%`);
            if (signal === "hold") signal = "buy";
          } else if (fundamentals.earningsGrowth < -10) {
            confidence += 10;
            reasons.push(`Declining earnings at ${fundamentals.earningsGrowth.toFixed(1)}%`);
            if (signal === "hold") signal = "sell";
          }
        }
        if (fundamentals.debtToEquity !== void 0) {
          if (fundamentals.debtToEquity > 2) {
            confidence -= 10;
            reasons.push(`High debt-to-equity ratio of ${fundamentals.debtToEquity.toFixed(2)}`);
          } else if (fundamentals.debtToEquity < 0.5) {
            confidence += 5;
            reasons.push(`Low debt-to-equity ratio of ${fundamentals.debtToEquity.toFixed(2)}`);
          }
        }
        if (data.assetType === "crypto" && fundamentals.marketCap) {
          if (fundamentals.marketCap > 1e10) {
            confidence += 5;
            reasons.push("Large-cap crypto with established market presence");
          } else if (fundamentals.marketCap < 1e8) {
            confidence -= 10;
            reasons.push("Small-cap crypto with higher risk");
          }
        }
        confidence = Math.min(95, Math.max(10, confidence));
        return {
          agentType: this.agentType,
          signal,
          confidence,
          reasoning: reasons.join(". ") || "Limited fundamental data available",
          indicators: {
            peRatio: fundamentals.peRatio || "N/A",
            earningsGrowth: fundamentals.earningsGrowth || "N/A",
            debtToEquity: fundamentals.debtToEquity || "N/A"
          },
          timestamp: Date.now()
        };
      }
      getWeight() {
        return this.historicalAccuracy;
      }
    };
    SentimentAnalysisAgent = class {
      agentType = "sentiment";
      historicalAccuracy = 0.55;
      async analyze(data) {
        const sentiment = data.sentiment || {};
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        if (sentiment.newsScore !== void 0) {
          if (sentiment.newsScore > 70) {
            signal = "buy";
            confidence += 15;
            reasons.push(`Positive news sentiment at ${sentiment.newsScore}`);
          } else if (sentiment.newsScore < 30) {
            signal = "sell";
            confidence += 15;
            reasons.push(`Negative news sentiment at ${sentiment.newsScore}`);
          } else {
            reasons.push(`Neutral news sentiment at ${sentiment.newsScore}`);
          }
        }
        if (sentiment.socialScore !== void 0) {
          if (sentiment.socialScore > 70) {
            confidence += 10;
            reasons.push(`Bullish social media sentiment at ${sentiment.socialScore}`);
            if (signal === "hold") signal = "buy";
          } else if (sentiment.socialScore < 30) {
            confidence += 10;
            reasons.push(`Bearish social media sentiment at ${sentiment.socialScore}`);
            if (signal === "hold") signal = "sell";
          }
        }
        if (sentiment.fearGreedIndex !== void 0) {
          if (sentiment.fearGreedIndex < 25) {
            reasons.push(`Extreme fear (${sentiment.fearGreedIndex}) - contrarian buy signal`);
            confidence += 10;
            if (signal === "hold" || signal === "sell") signal = "buy";
          } else if (sentiment.fearGreedIndex > 75) {
            reasons.push(`Extreme greed (${sentiment.fearGreedIndex}) - contrarian sell signal`);
            confidence += 10;
            if (signal === "hold" || signal === "buy") signal = "sell";
          }
        }
        if (data.assetType === "crypto" && data.onChainMetrics) {
          const { exchangeInflow, exchangeOutflow, whaleTransactions } = data.onChainMetrics;
          if (exchangeOutflow && exchangeInflow && exchangeOutflow > exchangeInflow * 1.5) {
            reasons.push("High exchange outflow - accumulation signal");
            confidence += 8;
            if (signal === "hold") signal = "buy";
          }
          if (whaleTransactions && whaleTransactions > 100) {
            reasons.push(`High whale activity: ${whaleTransactions} large transactions`);
            confidence += 5;
          }
        }
        confidence = Math.min(95, Math.max(10, confidence));
        return {
          agentType: this.agentType,
          signal,
          confidence,
          reasoning: reasons.join(". ") || "Limited sentiment data available",
          indicators: {
            newsScore: sentiment.newsScore || "N/A",
            socialScore: sentiment.socialScore || "N/A",
            fearGreedIndex: sentiment.fearGreedIndex || "N/A"
          },
          timestamp: Date.now()
        };
      }
      getWeight() {
        return this.historicalAccuracy;
      }
    };
    RiskManagementAgent = class {
      agentType = "risk";
      maxDrawdownLimit = 0.2;
      // 20% max drawdown
      maxPositionSize = 0.1;
      // 10% max per position
      async analyze(data, portfolio, proposedAction) {
        let approved = true;
        let adjustedQuantity = proposedAction.quantity;
        const reasons = [];
        let confidence = 70;
        if (portfolio.currentDrawdown >= this.maxDrawdownLimit * 0.8) {
          approved = false;
          reasons.push(`Current drawdown (${(portfolio.currentDrawdown * 100).toFixed(1)}%) approaching limit`);
          confidence += 20;
        }
        const positionValue = proposedAction.quantity * data.currentPrice;
        const positionPercent = positionValue / portfolio.portfolioValue;
        if (positionPercent > this.maxPositionSize) {
          adjustedQuantity = Math.floor(portfolio.portfolioValue * this.maxPositionSize / data.currentPrice);
          reasons.push(`Position size reduced from ${(positionPercent * 100).toFixed(1)}% to ${(this.maxPositionSize * 100).toFixed(1)}%`);
        }
        if (proposedAction.action === "buy" && positionValue > portfolio.availableCash) {
          adjustedQuantity = Math.floor(portfolio.availableCash / data.currentPrice);
          reasons.push("Quantity adjusted to available cash");
        }
        if (data.indicators?.atr && data.currentPrice) {
          const atrPercent = data.indicators.atr / data.currentPrice * 100;
          if (atrPercent > 5) {
            reasons.push(`High volatility warning: ATR at ${atrPercent.toFixed(1)}% of price`);
            confidence += 10;
            adjustedQuantity = Math.floor(adjustedQuantity * 0.7);
          }
        }
        if (portfolio.riskTolerance === "conservative") {
          adjustedQuantity = Math.floor(adjustedQuantity * 0.5);
          reasons.push("Conservative risk profile - position reduced by 50%");
        } else if (portfolio.riskTolerance === "aggressive") {
          reasons.push("Aggressive risk profile - full position allowed");
        }
        const stopLossPercent = portfolio.riskTolerance === "conservative" ? 0.03 : portfolio.riskTolerance === "aggressive" ? 0.08 : 0.05;
        const takeProfitPercent = stopLossPercent * 2;
        confidence = Math.min(95, Math.max(10, confidence));
        return {
          agentType: this.agentType,
          signal: approved ? "hold" : "strong_sell",
          // Risk agent doesn't give buy/sell signals
          confidence,
          reasoning: reasons.join(". ") || "Trade within risk parameters",
          indicators: {
            currentDrawdown: `${(portfolio.currentDrawdown * 100).toFixed(1)}%`,
            positionSize: `${(positionPercent * 100).toFixed(1)}%`,
            suggestedStopLoss: `${(stopLossPercent * 100).toFixed(1)}%`
          },
          timestamp: Date.now(),
          approved,
          adjustedQuantity
        };
      }
    };
    MarketRegimeAgent = class {
      agentType = "regime";
      historicalAccuracy = 0.58;
      async analyze(data) {
        let regime = "unknown";
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        if (data.priceHistory.length < 20) {
          return {
            agentType: this.agentType,
            signal: "hold",
            confidence: 30,
            reasoning: "Insufficient price history for regime detection",
            indicators: { regime: "unknown" },
            timestamp: Date.now(),
            regime: "unknown"
          };
        }
        const returns = data.priceHistory.slice(1).map(
          (candle, i) => (candle.close - data.priceHistory[i].close) / data.priceHistory[i].close
        );
        const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
        const volatility = Math.sqrt(
          returns.reduce((sum2, r) => sum2 + Math.pow(r - avgReturn, 2), 0) / returns.length
        );
        if (volatility > 0.03) {
          regime = "volatile";
          signal = "hold";
          reasons.push(`High volatility regime: ${(volatility * 100).toFixed(2)}% daily volatility`);
          confidence += 15;
        } else if (avgReturn > 5e-3) {
          regime = "bullish";
          signal = "buy";
          reasons.push(`Bullish regime: ${(avgReturn * 100).toFixed(2)}% average daily return`);
          confidence += 20;
        } else if (avgReturn < -5e-3) {
          regime = "bearish";
          signal = "sell";
          reasons.push(`Bearish regime: ${(avgReturn * 100).toFixed(2)}% average daily return`);
          confidence += 20;
        } else {
          regime = "sideways";
          signal = "hold";
          reasons.push("Sideways/consolidation regime detected");
          confidence += 10;
        }
        if (data.indicators?.ema) {
          const { ema8, ema21, ema50 } = data.indicators.ema;
          if (ema8 > ema21 && ema21 > ema50) {
            reasons.push("EMAs confirm uptrend");
            confidence += 10;
          } else if (ema8 < ema21 && ema21 < ema50) {
            reasons.push("EMAs confirm downtrend");
            confidence += 10;
          }
        }
        confidence = Math.min(95, Math.max(10, confidence));
        return {
          agentType: this.agentType,
          signal,
          confidence,
          reasoning: reasons.join(". "),
          indicators: {
            regime,
            avgReturn: `${(avgReturn * 100).toFixed(2)}%`,
            volatility: `${(volatility * 100).toFixed(2)}%`
          },
          timestamp: Date.now(),
          regime
        };
      }
      getWeight() {
        return this.historicalAccuracy;
      }
    };
    ExecutionAgent = class {
      agentType = "execution";
      async analyze(data) {
        let optimalExecutionTime = "immediate";
        let suggestedSplits;
        const reasons = [];
        let confidence = 60;
        if (data.priceHistory.length > 0) {
          const recentVolume = data.priceHistory.slice(-5).reduce((sum2, c) => sum2 + c.volume, 0) / 5;
          const avgVolume = data.priceHistory.reduce((sum2, c) => sum2 + c.volume, 0) / data.priceHistory.length;
          if (recentVolume < avgVolume * 0.5) {
            optimalExecutionTime = "wait";
            reasons.push("Low volume - wait for better liquidity");
            confidence += 15;
          } else if (recentVolume > avgVolume * 2) {
            reasons.push("High volume - good liquidity for execution");
            confidence += 10;
          }
        }
        if (data.priceHistory.length > 0) {
          const lastCandle = data.priceHistory[data.priceHistory.length - 1];
          const spread = (lastCandle.high - lastCandle.low) / lastCandle.close;
          if (spread > 0.02) {
            optimalExecutionTime = "split";
            suggestedSplits = 3;
            reasons.push("Wide spread - split order recommended");
            confidence += 10;
          }
        }
        if (data.indicators?.atr && data.currentPrice) {
          const atrPercent = data.indicators.atr / data.currentPrice;
          if (atrPercent > 0.03) {
            reasons.push("High ATR - consider limit orders");
          }
        }
        return {
          agentType: this.agentType,
          signal: "hold",
          // Execution agent doesn't give directional signals
          confidence,
          reasoning: reasons.join(". ") || "Standard execution recommended",
          indicators: {
            executionStrategy: optimalExecutionTime,
            suggestedSplits: suggestedSplits || 1
          },
          timestamp: Date.now(),
          optimalExecutionTime,
          suggestedSplits
        };
      }
    };
    MetaCoordinatorAgent = class {
      technicalAgent;
      fundamentalAgent;
      sentimentAgent;
      riskAgent;
      regimeAgent;
      executionAgent;
      constructor() {
        this.technicalAgent = new TechnicalAnalysisAgent();
        this.fundamentalAgent = new FundamentalAnalysisAgent();
        this.sentimentAgent = new SentimentAnalysisAgent();
        this.riskAgent = new RiskManagementAgent();
        this.regimeAgent = new MarketRegimeAgent();
        this.executionAgent = new ExecutionAgent();
      }
      async orchestrate(data, portfolio) {
        const [
          technicalAnalysis,
          fundamentalAnalysis,
          sentimentAnalysis,
          regimeAnalysis,
          executionAnalysis
        ] = await Promise.all([
          this.technicalAgent.analyze(data),
          this.fundamentalAgent.analyze(data),
          this.sentimentAgent.analyze(data),
          this.regimeAgent.analyze(data),
          this.executionAgent.analyze(data)
        ]);
        const signalToScore = {
          "strong_buy": 2,
          "buy": 1,
          "hold": 0,
          "sell": -1,
          "strong_sell": -2
        };
        const agents = [
          { analysis: technicalAnalysis, weight: this.technicalAgent.getWeight() },
          { analysis: fundamentalAnalysis, weight: this.fundamentalAgent.getWeight() },
          { analysis: sentimentAnalysis, weight: this.sentimentAgent.getWeight() },
          { analysis: regimeAnalysis, weight: this.regimeAgent.getWeight() }
        ];
        let totalWeight = 0;
        let weightedScore = 0;
        let totalConfidence = 0;
        for (const { analysis, weight } of agents) {
          const adjustedWeight = weight * (analysis.confidence / 100);
          totalWeight += adjustedWeight;
          weightedScore += signalToScore[analysis.signal] * adjustedWeight;
          totalConfidence += analysis.confidence * weight;
        }
        const avgScore = totalWeight > 0 ? weightedScore / totalWeight : 0;
        const avgConfidence = totalWeight > 0 ? totalConfidence / totalWeight : 50;
        let finalSignal;
        if (avgScore >= 1.5) finalSignal = "strong_buy";
        else if (avgScore >= 0.5) finalSignal = "buy";
        else if (avgScore <= -1.5) finalSignal = "strong_sell";
        else if (avgScore <= -0.5) finalSignal = "sell";
        else finalSignal = "hold";
        let action = "hold";
        let quantity = 0;
        if (finalSignal === "strong_buy" || finalSignal === "buy") {
          action = "buy";
          const basePercent = portfolio.riskTolerance === "aggressive" ? 0.1 : portfolio.riskTolerance === "conservative" ? 0.03 : 0.05;
          const confidenceMultiplier = avgConfidence / 100;
          quantity = Math.floor(portfolio.availableCash * basePercent * confidenceMultiplier / data.currentPrice);
        } else if (finalSignal === "strong_sell" || finalSignal === "sell") {
          action = "sell";
          if (portfolio.currentPosition) {
            const sellPercent = finalSignal === "strong_sell" ? 1 : 0.5;
            quantity = Math.floor(portfolio.currentPosition.quantity * sellPercent);
          }
        }
        const riskAnalysis = await this.riskAgent.analyze(data, portfolio, { action: action === "hold" ? "buy" : action, quantity });
        const riskApproved = riskAnalysis.approved;
        const adjustedQuantity = riskAnalysis.adjustedQuantity || quantity;
        const reasoningParts = [
          `Technical: ${technicalAnalysis.signal} (${technicalAnalysis.confidence}%)`,
          `Fundamental: ${fundamentalAnalysis.signal} (${fundamentalAnalysis.confidence}%)`,
          `Sentiment: ${sentimentAnalysis.signal} (${sentimentAnalysis.confidence}%)`,
          `Regime: ${regimeAnalysis.regime} (${regimeAnalysis.confidence}%)`,
          `Risk: ${riskApproved ? "Approved" : "VETOED"}`
        ];
        const stopLossPercent = portfolio.riskTolerance === "conservative" ? 0.03 : portfolio.riskTolerance === "aggressive" ? 0.08 : 0.05;
        const stopLoss = action === "buy" ? data.currentPrice * (1 - stopLossPercent) : void 0;
        const takeProfit = action === "buy" ? data.currentPrice * (1 + stopLossPercent * 2) : void 0;
        return {
          finalSignal: riskApproved ? finalSignal : "hold",
          overallConfidence: avgConfidence,
          agentVotes: [
            technicalAnalysis,
            fundamentalAnalysis,
            sentimentAnalysis,
            regimeAnalysis,
            executionAnalysis,
            riskAnalysis
          ],
          riskApproved,
          reasoning: reasoningParts.join(" | "),
          suggestedAction: {
            action: riskApproved ? action : "hold",
            quantity: riskApproved ? adjustedQuantity : 0,
            stopLoss,
            takeProfit,
            urgency: executionAnalysis.optimalExecutionTime === "immediate" ? "immediate" : executionAnalysis.optimalExecutionTime === "wait" ? "low" : "normal"
          }
        };
      }
      /**
       * Get AI-enhanced analysis using LLM for deeper insights
       */
      async getEnhancedAnalysis(data, consensusDecision) {
        const prompt = `You are an expert financial analyst. Analyze this trading decision and provide additional insights.

Symbol: ${data.symbol}
Asset Type: ${data.assetType}
Current Price: $${data.currentPrice}

Agent Consensus:
- Final Signal: ${consensusDecision.finalSignal}
- Overall Confidence: ${consensusDecision.overallConfidence.toFixed(1)}%
- Risk Approved: ${consensusDecision.riskApproved}

Individual Agent Analyses:
${consensusDecision.agentVotes.map(
          (v) => `- ${v.agentType}: ${v.signal} (${v.confidence}%) - ${v.reasoning}`
        ).join("\n")}

Suggested Action: ${consensusDecision.suggestedAction.action} ${consensusDecision.suggestedAction.quantity} units

Please provide:
1. A brief summary of the overall market outlook
2. Key risks to watch
3. Alternative scenarios to consider
4. Confidence assessment of the recommendation

Keep your response concise and actionable.`;
        try {
          const response = await invokeLLM({
            messages: [
              { role: "system", content: "You are an expert financial analyst providing trading insights. Be concise and actionable." },
              { role: "user", content: prompt }
            ]
          });
          const content = response.choices?.[0]?.message?.content;
          return typeof content === "string" ? content : "Unable to generate enhanced analysis";
        } catch (error) {
          console.error("Error generating enhanced analysis:", error);
          return "Enhanced analysis unavailable";
        }
      }
    };
    agentOrchestrator = new MetaCoordinatorAgent();
  }
});

// server/services/ai-agents/CryptoAgent.ts
var CryptoAgent_exports = {};
__export(CryptoAgent_exports, {
  CryptoMarketCoordinator: () => CryptoMarketCoordinator,
  DeFiAnalysisAgent: () => DeFiAnalysisAgent,
  DerivativesAnalysisAgent: () => DerivativesAnalysisAgent,
  OnChainAnalysisAgent: () => OnChainAnalysisAgent,
  TokenomicsAnalysisAgent: () => TokenomicsAnalysisAgent,
  cryptoCoordinator: () => cryptoCoordinator
});
var OnChainAnalysisAgent, DeFiAnalysisAgent, DerivativesAnalysisAgent, TokenomicsAnalysisAgent, CryptoMarketCoordinator, cryptoCoordinator;
var init_CryptoAgent = __esm({
  "server/services/ai-agents/CryptoAgent.ts"() {
    "use strict";
    OnChainAnalysisAgent = class {
      async analyze(symbol, metrics) {
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const netFlow = metrics.exchangeInflow - metrics.exchangeOutflow;
        const flowRatio = metrics.exchangeOutflow / (metrics.exchangeInflow || 1);
        if (flowRatio > 1.5) {
          signal = "buy";
          confidence += 20;
          reasons.push(`Strong accumulation: ${flowRatio.toFixed(2)}x more outflow than inflow`);
        } else if (flowRatio < 0.7) {
          signal = "sell";
          confidence += 20;
          reasons.push(`Distribution detected: ${(1 / flowRatio).toFixed(2)}x more inflow than outflow`);
        }
        if (metrics.activeAddresses > 1e5) {
          confidence += 10;
          reasons.push(`High network activity: ${(metrics.activeAddresses / 1e3).toFixed(0)}k active addresses`);
          if (signal === "hold") signal = "buy";
        } else if (metrics.activeAddresses < 1e4) {
          confidence += 5;
          reasons.push(`Low network activity: ${metrics.activeAddresses} active addresses`);
        }
        if (metrics.whaleTransactions > 50) {
          reasons.push(`High whale activity: ${metrics.whaleTransactions} large transactions`);
          confidence += 8;
        }
        if (metrics.topHolderConcentration > 50) {
          confidence -= 10;
          reasons.push(`High concentration risk: Top 100 wallets hold ${metrics.topHolderConcentration.toFixed(1)}%`);
        } else if (metrics.topHolderConcentration < 20) {
          confidence += 5;
          reasons.push(`Well distributed: Top 100 wallets hold only ${metrics.topHolderConcentration.toFixed(1)}%`);
        }
        if (metrics.stakingRatio !== void 0) {
          if (metrics.stakingRatio > 60) {
            confidence += 10;
            reasons.push(`High staking ratio: ${metrics.stakingRatio.toFixed(1)}% staked (reduced sell pressure)`);
            if (signal === "hold") signal = "buy";
          } else if (metrics.stakingRatio < 30) {
            reasons.push(`Low staking ratio: ${metrics.stakingRatio.toFixed(1)}% staked`);
          }
        }
        confidence = Math.min(95, Math.max(10, confidence));
        return {
          agentType: "technical",
          // Using 'technical' as closest match
          signal,
          confidence,
          reasoning: reasons.join(". ") || "Insufficient on-chain data",
          indicators: {
            exchangeFlowRatio: flowRatio.toFixed(2),
            activeAddresses: metrics.activeAddresses,
            whaleTransactions: metrics.whaleTransactions,
            stakingRatio: metrics.stakingRatio || "N/A"
          },
          timestamp: Date.now()
        };
      }
    };
    DeFiAnalysisAgent = class {
      async analyze(symbol, metrics) {
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        if (metrics.totalValueLocked !== void 0) {
          if (metrics.totalValueLocked > 1e9) {
            confidence += 15;
            reasons.push(`Strong TVL: $${(metrics.totalValueLocked / 1e9).toFixed(2)}B locked`);
            if (signal === "hold") signal = "buy";
          } else if (metrics.totalValueLocked < 1e7) {
            confidence -= 10;
            reasons.push(`Low TVL: $${(metrics.totalValueLocked / 1e6).toFixed(2)}M locked`);
          }
        }
        if (metrics.liquidityDepth !== void 0) {
          if (metrics.liquidityDepth > 1e7) {
            confidence += 10;
            reasons.push(`Deep liquidity: $${(metrics.liquidityDepth / 1e6).toFixed(2)}M available`);
          } else if (metrics.liquidityDepth < 1e5) {
            confidence -= 15;
            reasons.push(`Shallow liquidity warning: $${(metrics.liquidityDepth / 1e3).toFixed(0)}K available`);
          }
        }
        if (metrics.yieldRate !== void 0) {
          if (metrics.yieldRate > 20) {
            reasons.push(`High yield: ${metrics.yieldRate.toFixed(1)}% APY (sustainability concern)`);
            confidence -= 5;
          } else if (metrics.yieldRate > 5 && metrics.yieldRate <= 20) {
            confidence += 5;
            reasons.push(`Healthy yield: ${metrics.yieldRate.toFixed(1)}% APY`);
          }
        }
        confidence = Math.min(95, Math.max(10, confidence));
        return {
          agentType: "fundamental",
          signal,
          confidence,
          reasoning: reasons.join(". ") || "Insufficient DeFi data",
          indicators: {
            tvl: metrics.totalValueLocked ? `$${(metrics.totalValueLocked / 1e9).toFixed(2)}B` : "N/A",
            liquidityDepth: metrics.liquidityDepth ? `$${(metrics.liquidityDepth / 1e6).toFixed(2)}M` : "N/A",
            yieldRate: metrics.yieldRate ? `${metrics.yieldRate.toFixed(1)}%` : "N/A"
          },
          timestamp: Date.now()
        };
      }
    };
    DerivativesAnalysisAgent = class {
      async analyze(symbol, metrics) {
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        if (metrics.fundingRate !== void 0) {
          if (metrics.fundingRate > 0.1) {
            signal = "sell";
            confidence += 20;
            reasons.push(`Extreme positive funding (${(metrics.fundingRate * 100).toFixed(3)}%) - overleveraged longs`);
          } else if (metrics.fundingRate < -0.1) {
            signal = "buy";
            confidence += 20;
            reasons.push(`Extreme negative funding (${(metrics.fundingRate * 100).toFixed(3)}%) - overleveraged shorts`);
          } else if (metrics.fundingRate > 0.03) {
            reasons.push(`Positive funding (${(metrics.fundingRate * 100).toFixed(3)}%) - bullish bias`);
            confidence += 5;
          } else if (metrics.fundingRate < -0.03) {
            reasons.push(`Negative funding (${(metrics.fundingRate * 100).toFixed(3)}%) - bearish bias`);
            confidence += 5;
          }
        }
        if (metrics.openInterest !== void 0) {
          reasons.push(`Open Interest: $${(metrics.openInterest / 1e9).toFixed(2)}B`);
        }
        if (metrics.longShortRatio !== void 0) {
          if (metrics.longShortRatio > 2) {
            signal = "sell";
            confidence += 15;
            reasons.push(`Crowded long: ${metrics.longShortRatio.toFixed(2)} L/S ratio (contrarian sell)`);
          } else if (metrics.longShortRatio < 0.5) {
            signal = "buy";
            confidence += 15;
            reasons.push(`Crowded short: ${metrics.longShortRatio.toFixed(2)} L/S ratio (contrarian buy)`);
          } else {
            reasons.push(`Balanced positioning: ${metrics.longShortRatio.toFixed(2)} L/S ratio`);
          }
        }
        confidence = Math.min(95, Math.max(10, confidence));
        return {
          agentType: "sentiment",
          signal,
          confidence,
          reasoning: reasons.join(". ") || "Insufficient derivatives data",
          indicators: {
            fundingRate: metrics.fundingRate ? `${(metrics.fundingRate * 100).toFixed(3)}%` : "N/A",
            openInterest: metrics.openInterest ? `$${(metrics.openInterest / 1e9).toFixed(2)}B` : "N/A",
            longShortRatio: metrics.longShortRatio?.toFixed(2) || "N/A"
          },
          timestamp: Date.now()
        };
      }
    };
    TokenomicsAnalysisAgent = class {
      async analyze(symbol, tokenomics) {
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const circulatingRatio = tokenomics.circulatingSupply / tokenomics.totalSupply;
        if (circulatingRatio > 0.9) {
          confidence += 10;
          reasons.push(`${(circulatingRatio * 100).toFixed(1)}% of supply circulating - minimal dilution risk`);
        } else if (circulatingRatio < 0.3) {
          confidence -= 15;
          signal = "sell";
          reasons.push(`Only ${(circulatingRatio * 100).toFixed(1)}% circulating - high dilution risk`);
        }
        if (tokenomics.inflationRate > 10) {
          confidence -= 10;
          reasons.push(`High inflation: ${tokenomics.inflationRate.toFixed(1)}% annual`);
          if (signal === "hold") signal = "sell";
        } else if (tokenomics.inflationRate < 2) {
          confidence += 5;
          reasons.push(`Low inflation: ${tokenomics.inflationRate.toFixed(1)}% annual`);
        }
        if (tokenomics.burnRate && tokenomics.burnRate > 0) {
          confidence += 8;
          reasons.push(`Deflationary: ${tokenomics.burnRate.toFixed(2)}% burn rate`);
          if (signal === "hold") signal = "buy";
        }
        if (tokenomics.vestingSchedule) {
          const daysUntilUnlock = Math.ceil(
            (tokenomics.vestingSchedule.nextUnlock.getTime() - Date.now()) / (1e3 * 60 * 60 * 24)
          );
          if (daysUntilUnlock < 30 && tokenomics.vestingSchedule.unlockPercentage > 5) {
            confidence -= 15;
            signal = "sell";
            reasons.push(`Warning: ${tokenomics.vestingSchedule.unlockPercentage.toFixed(1)}% unlock in ${daysUntilUnlock} days`);
          } else if (daysUntilUnlock > 180) {
            confidence += 5;
            reasons.push("No significant unlocks in next 6 months");
          }
        }
        if (tokenomics.maxSupply) {
          const percentOfMax = tokenomics.circulatingSupply / tokenomics.maxSupply * 100;
          if (percentOfMax > 80) {
            confidence += 5;
            reasons.push(`${percentOfMax.toFixed(1)}% of max supply reached - scarcity factor`);
          }
        }
        confidence = Math.min(95, Math.max(10, confidence));
        return {
          agentType: "fundamental",
          signal,
          confidence,
          reasoning: reasons.join(". ") || "Insufficient tokenomics data",
          indicators: {
            circulatingRatio: `${(circulatingRatio * 100).toFixed(1)}%`,
            inflationRate: `${tokenomics.inflationRate.toFixed(1)}%`,
            burnRate: tokenomics.burnRate ? `${tokenomics.burnRate.toFixed(2)}%` : "N/A"
          },
          timestamp: Date.now()
        };
      }
    };
    CryptoMarketCoordinator = class {
      onChainAgent;
      defiAgent;
      derivativesAgent;
      tokenomicsAgent;
      constructor() {
        this.onChainAgent = new OnChainAnalysisAgent();
        this.defiAgent = new DeFiAnalysisAgent();
        this.derivativesAgent = new DerivativesAnalysisAgent();
        this.tokenomicsAgent = new TokenomicsAnalysisAgent();
      }
      async analyzeComprehensive(symbol, metrics, tokenomics) {
        const analyses = [];
        const onChainAnalysis = await this.onChainAgent.analyze(symbol, metrics);
        analyses.push(onChainAnalysis);
        const defiAnalysis = await this.defiAgent.analyze(symbol, metrics);
        analyses.push(defiAnalysis);
        const derivativesAnalysis = await this.derivativesAgent.analyze(symbol, metrics);
        analyses.push(derivativesAnalysis);
        if (tokenomics) {
          const tokenomicsAnalysis = await this.tokenomicsAgent.analyze(symbol, tokenomics);
          analyses.push(tokenomicsAnalysis);
        }
        const signalToScore = {
          "strong_buy": 2,
          "buy": 1,
          "hold": 0,
          "sell": -1,
          "strong_sell": -2
        };
        const weights = [0.35, 0.2, 0.3, 0.15];
        let totalWeight = 0;
        let weightedScore = 0;
        let totalConfidence = 0;
        analyses.forEach((analysis, index) => {
          const weight = weights[index] || 0.1;
          const adjustedWeight = weight * (analysis.confidence / 100);
          totalWeight += adjustedWeight;
          weightedScore += signalToScore[analysis.signal] * adjustedWeight;
          totalConfidence += analysis.confidence * weight;
        });
        const avgScore = totalWeight > 0 ? weightedScore / totalWeight : 0;
        const avgConfidence = totalWeight > 0 ? totalConfidence / totalWeight : 50;
        let overallSignal;
        if (avgScore >= 1.5) overallSignal = "strong_buy";
        else if (avgScore >= 0.5) overallSignal = "buy";
        else if (avgScore <= -1.5) overallSignal = "strong_sell";
        else if (avgScore <= -0.5) overallSignal = "sell";
        else overallSignal = "hold";
        const summary = analyses.map((a) => `${a.agentType}: ${a.signal} (${a.confidence}%)`).join(" | ");
        return {
          overallSignal,
          confidence: avgConfidence,
          analyses,
          summary
        };
      }
    };
    cryptoCoordinator = new CryptoMarketCoordinator();
  }
});

// server/services/ai-agents/TechnicalIndicators.ts
var TechnicalIndicators_exports = {};
__export(TechnicalIndicators_exports, {
  calculateADX: () => calculateADX4,
  calculateATR: () => calculateATR2,
  calculateAllIndicators: () => calculateAllIndicators,
  calculateBollingerBands: () => calculateBollingerBands2,
  calculateCCI: () => calculateCCI,
  calculateEMA: () => calculateEMA6,
  calculateKeltnerChannels: () => calculateKeltnerChannels,
  calculateMACD: () => calculateMACD3,
  calculateOBV: () => calculateOBV,
  calculateParabolicSAR: () => calculateParabolicSAR,
  calculateRSI: () => calculateRSI4,
  calculateSMA: () => calculateSMA3,
  calculateStochastic: () => calculateStochastic,
  calculateVWAP: () => calculateVWAP,
  calculateWilliamsR: () => calculateWilliamsR,
  detectCandlestickPatterns: () => detectCandlestickPatterns
});
function calculateEMA6(data, period) {
  if (data.length < period) return [];
  const multiplier = 2 / (period + 1);
  const ema = [];
  let sum2 = 0;
  for (let i = 0; i < period; i++) {
    sum2 += data[i];
  }
  ema.push(sum2 / period);
  for (let i = period; i < data.length; i++) {
    ema.push((data[i] - ema[ema.length - 1]) * multiplier + ema[ema.length - 1]);
  }
  return ema;
}
function calculateSMA3(data, period) {
  if (data.length < period) return [];
  const sma = [];
  for (let i = period - 1; i < data.length; i++) {
    let sum2 = 0;
    for (let j = 0; j < period; j++) {
      sum2 += data[i - j];
    }
    sma.push(sum2 / period);
  }
  return sma;
}
function calculateRSI4(closes, period = 14) {
  if (closes.length < period + 1) return [];
  const rsi = [];
  const gains = [];
  const losses = [];
  for (let i = 1; i < closes.length; i++) {
    const change = closes[i] - closes[i - 1];
    gains.push(change > 0 ? change : 0);
    losses.push(change < 0 ? Math.abs(change) : 0);
  }
  let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
  let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
  for (let i = period; i < gains.length; i++) {
    avgGain = (avgGain * (period - 1) + gains[i]) / period;
    avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
    rsi.push(100 - 100 / (1 + rs));
  }
  return rsi;
}
function calculateMACD3(closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
  const fastEMA = calculateEMA6(closes, fastPeriod);
  const slowEMA = calculateEMA6(closes, slowPeriod);
  const offset = slowPeriod - fastPeriod;
  const macd = [];
  for (let i = 0; i < slowEMA.length; i++) {
    macd.push(fastEMA[i + offset] - slowEMA[i]);
  }
  const signal = calculateEMA6(macd, signalPeriod);
  const histogram = [];
  const signalOffset = signalPeriod - 1;
  for (let i = 0; i < signal.length; i++) {
    histogram.push(macd[i + signalOffset] - signal[i]);
  }
  return { macd, signal, histogram };
}
function calculateBollingerBands2(closes, period = 20, stdDev = 2) {
  const sma = calculateSMA3(closes, period);
  const upper = [];
  const lower = [];
  for (let i = period - 1; i < closes.length; i++) {
    const slice = closes.slice(i - period + 1, i + 1);
    const mean5 = sma[i - period + 1];
    const variance = slice.reduce((sum2, val) => sum2 + Math.pow(val - mean5, 2), 0) / period;
    const std4 = Math.sqrt(variance);
    upper.push(mean5 + stdDev * std4);
    lower.push(mean5 - stdDev * std4);
  }
  return { upper, middle: sma, lower };
}
function calculateATR2(candles, period = 14) {
  if (candles.length < period + 1) return [];
  const trueRanges = [];
  for (let i = 1; i < candles.length; i++) {
    const high = candles[i].high;
    const low = candles[i].low;
    const prevClose = candles[i - 1].close;
    const tr = Math.max(
      high - low,
      Math.abs(high - prevClose),
      Math.abs(low - prevClose)
    );
    trueRanges.push(tr);
  }
  let atr = trueRanges.slice(0, period).reduce((a, b) => a + b, 0) / period;
  const atrValues = [atr];
  for (let i = period; i < trueRanges.length; i++) {
    atr = (atr * (period - 1) + trueRanges[i]) / period;
    atrValues.push(atr);
  }
  return atrValues;
}
function calculateStochastic(candles, kPeriod = 14, dPeriod = 3) {
  if (candles.length < kPeriod) return { k: [], d: [] };
  const kValues = [];
  for (let i = kPeriod - 1; i < candles.length; i++) {
    const slice = candles.slice(i - kPeriod + 1, i + 1);
    const highest = Math.max(...slice.map((c) => c.high));
    const lowest = Math.min(...slice.map((c) => c.low));
    const current = candles[i].close;
    const k = highest === lowest ? 50 : (current - lowest) / (highest - lowest) * 100;
    kValues.push(k);
  }
  const dValues = calculateSMA3(kValues, dPeriod);
  return { k: kValues, d: dValues };
}
function calculateWilliamsR(candles, period = 14) {
  if (candles.length < period) return [];
  const values = [];
  for (let i = period - 1; i < candles.length; i++) {
    const slice = candles.slice(i - period + 1, i + 1);
    const highest = Math.max(...slice.map((c) => c.high));
    const lowest = Math.min(...slice.map((c) => c.low));
    const current = candles[i].close;
    const wr = highest === lowest ? -50 : (highest - current) / (highest - lowest) * -100;
    values.push(wr);
  }
  return values;
}
function calculateCCI(candles, period = 20) {
  if (candles.length < period) return [];
  const typicalPrices = candles.map((c) => (c.high + c.low + c.close) / 3);
  const sma = calculateSMA3(typicalPrices, period);
  const cci = [];
  for (let i = period - 1; i < candles.length; i++) {
    const slice = typicalPrices.slice(i - period + 1, i + 1);
    const mean5 = sma[i - period + 1];
    const meanDeviation = slice.reduce((sum2, val) => sum2 + Math.abs(val - mean5), 0) / period;
    const tp = typicalPrices[i];
    cci.push(meanDeviation === 0 ? 0 : (tp - mean5) / (0.015 * meanDeviation));
  }
  return cci;
}
function calculateADX4(candles, period = 14) {
  if (candles.length < period * 2) return { adx: [], plusDI: [], minusDI: [] };
  const plusDM = [];
  const minusDM = [];
  const tr = [];
  for (let i = 1; i < candles.length; i++) {
    const high = candles[i].high;
    const low = candles[i].low;
    const prevHigh = candles[i - 1].high;
    const prevLow = candles[i - 1].low;
    const prevClose = candles[i - 1].close;
    const upMove = high - prevHigh;
    const downMove = prevLow - low;
    plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);
    minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);
    tr.push(Math.max(
      high - low,
      Math.abs(high - prevClose),
      Math.abs(low - prevClose)
    ));
  }
  const smoothedPlusDM = calculateEMA6(plusDM, period);
  const smoothedMinusDM = calculateEMA6(minusDM, period);
  const smoothedTR = calculateEMA6(tr, period);
  const plusDI = [];
  const minusDI = [];
  const dx = [];
  for (let i = 0; i < smoothedTR.length; i++) {
    const pdi = smoothedTR[i] === 0 ? 0 : smoothedPlusDM[i] / smoothedTR[i] * 100;
    const mdi = smoothedTR[i] === 0 ? 0 : smoothedMinusDM[i] / smoothedTR[i] * 100;
    plusDI.push(pdi);
    minusDI.push(mdi);
    const sum2 = pdi + mdi;
    dx.push(sum2 === 0 ? 0 : Math.abs(pdi - mdi) / sum2 * 100);
  }
  const adx = calculateEMA6(dx, period);
  return { adx, plusDI, minusDI };
}
function calculateOBV(candles) {
  if (candles.length < 2) return [];
  const obv = [0];
  for (let i = 1; i < candles.length; i++) {
    const prevOBV = obv[obv.length - 1];
    const volume = candles[i].volume;
    if (candles[i].close > candles[i - 1].close) {
      obv.push(prevOBV + volume);
    } else if (candles[i].close < candles[i - 1].close) {
      obv.push(prevOBV - volume);
    } else {
      obv.push(prevOBV);
    }
  }
  return obv;
}
function calculateVWAP(candles) {
  const vwap = [];
  let cumulativeTPV = 0;
  let cumulativeVolume = 0;
  for (const candle of candles) {
    const typicalPrice = (candle.high + candle.low + candle.close) / 3;
    cumulativeTPV += typicalPrice * candle.volume;
    cumulativeVolume += candle.volume;
    vwap.push(cumulativeVolume === 0 ? typicalPrice : cumulativeTPV / cumulativeVolume);
  }
  return vwap;
}
function calculateParabolicSAR(candles, step = 0.02, maxStep = 0.2) {
  if (candles.length < 2) return [];
  const sar = [];
  let isUptrend = candles[1].close > candles[0].close;
  let af = step;
  let ep = isUptrend ? candles[0].high : candles[0].low;
  let sarValue = isUptrend ? candles[0].low : candles[0].high;
  sar.push(sarValue);
  for (let i = 1; i < candles.length; i++) {
    const high = candles[i].high;
    const low = candles[i].low;
    sarValue = sarValue + af * (ep - sarValue);
    if (isUptrend) {
      if (low < sarValue) {
        isUptrend = false;
        sarValue = ep;
        ep = low;
        af = step;
      } else {
        if (high > ep) {
          ep = high;
          af = Math.min(af + step, maxStep);
        }
        if (i >= 2) {
          sarValue = Math.min(sarValue, candles[i - 1].low, candles[i - 2].low);
        }
      }
    } else {
      if (high > sarValue) {
        isUptrend = true;
        sarValue = ep;
        ep = high;
        af = step;
      } else {
        if (low < ep) {
          ep = low;
          af = Math.min(af + step, maxStep);
        }
        if (i >= 2) {
          sarValue = Math.max(sarValue, candles[i - 1].high, candles[i - 2].high);
        }
      }
    }
    sar.push(sarValue);
  }
  return sar;
}
function calculateKeltnerChannels(candles, emaPeriod = 20, atrPeriod = 10, multiplier = 2) {
  const closes = candles.map((c) => c.close);
  const ema = calculateEMA6(closes, emaPeriod);
  const atr = calculateATR2(candles, atrPeriod);
  const upper = [];
  const lower = [];
  const offset = Math.max(emaPeriod, atrPeriod) - 1;
  const minLength = Math.min(ema.length, atr.length);
  for (let i = 0; i < minLength; i++) {
    upper.push(ema[i] + multiplier * atr[i]);
    lower.push(ema[i] - multiplier * atr[i]);
  }
  return { upper, middle: ema.slice(0, minLength), lower };
}
function detectCandlestickPatterns(candles) {
  const patterns = [];
  for (let i = 2; i < candles.length; i++) {
    const current = candles[i];
    const prev = candles[i - 1];
    const prev2 = candles[i - 2];
    const bodySize = Math.abs(current.close - current.open);
    const upperWick = current.high - Math.max(current.open, current.close);
    const lowerWick = Math.min(current.open, current.close) - current.low;
    const range = current.high - current.low;
    if (bodySize < range * 0.1) {
      patterns.push({
        name: "Doji",
        type: "neutral",
        reliability: "medium",
        index: i
      });
    }
    if (lowerWick > bodySize * 2 && upperWick < bodySize * 0.5 && prev.close < prev.open) {
      patterns.push({
        name: "Hammer",
        type: "bullish",
        reliability: "high",
        index: i
      });
    }
    if (upperWick > bodySize * 2 && lowerWick < bodySize * 0.5 && prev.close > prev.open) {
      patterns.push({
        name: "Shooting Star",
        type: "bearish",
        reliability: "high",
        index: i
      });
    }
    const prevBodySize = Math.abs(prev.close - prev.open);
    if (prev.close < prev.open && // Previous was bearish
    current.close > current.open && // Current is bullish
    current.open < prev.close && current.close > prev.open) {
      patterns.push({
        name: "Bullish Engulfing",
        type: "bullish",
        reliability: "high",
        index: i
      });
    }
    if (prev.close > prev.open && // Previous was bullish
    current.close < current.open && // Current is bearish
    current.open > prev.close && current.close < prev.open) {
      patterns.push({
        name: "Bearish Engulfing",
        type: "bearish",
        reliability: "high",
        index: i
      });
    }
    if (i >= 2) {
      const first = prev2;
      const second = prev;
      const third = current;
      const firstBody = Math.abs(first.close - first.open);
      const secondBody = Math.abs(second.close - second.open);
      const thirdBody = Math.abs(third.close - third.open);
      if (first.close < first.open && // First is bearish
      secondBody < firstBody * 0.3 && // Second is small
      third.close > third.open && // Third is bullish
      third.close > (first.open + first.close) / 2) {
        patterns.push({
          name: "Morning Star",
          type: "bullish",
          reliability: "high",
          index: i
        });
      }
      if (first.close > first.open && // First is bullish
      secondBody < firstBody * 0.3 && // Second is small
      third.close < third.open && // Third is bearish
      third.close < (first.open + first.close) / 2) {
        patterns.push({
          name: "Evening Star",
          type: "bearish",
          reliability: "high",
          index: i
        });
      }
    }
    if (i >= 2) {
      if (prev2.close > prev2.open && prev.close > prev.open && current.close > current.open && prev.open > prev2.open && current.open > prev.open && prev.close > prev2.close && current.close > prev.close) {
        patterns.push({
          name: "Three White Soldiers",
          type: "bullish",
          reliability: "high",
          index: i
        });
      }
      if (prev2.close < prev2.open && prev.close < prev.open && current.close < current.open && prev.open < prev2.open && current.open < prev.open && prev.close < prev2.close && current.close < prev.close) {
        patterns.push({
          name: "Three Black Crows",
          type: "bearish",
          reliability: "high",
          index: i
        });
      }
    }
  }
  return patterns;
}
function calculateAllIndicators(candles) {
  const closes = candles.map((c) => c.close);
  return {
    ema: {
      ema8: calculateEMA6(closes, 8),
      ema21: calculateEMA6(closes, 21),
      ema50: calculateEMA6(closes, 50),
      ema200: calculateEMA6(closes, 200)
    },
    rsi: calculateRSI4(closes),
    macd: calculateMACD3(closes),
    bollinger: calculateBollingerBands2(closes),
    atr: calculateATR2(candles),
    stochastic: calculateStochastic(candles),
    williamsR: calculateWilliamsR(candles),
    cci: calculateCCI(candles),
    adx: calculateADX4(candles),
    obv: calculateOBV(candles),
    vwap: calculateVWAP(candles),
    parabolicSar: calculateParabolicSAR(candles),
    patterns: detectCandlestickPatterns(candles)
  };
}
var init_TechnicalIndicators = __esm({
  "server/services/ai-agents/TechnicalIndicators.ts"() {
    "use strict";
  }
});

// server/services/ai-agents/AgenticTradingBot.ts
var AgenticTradingBot_exports = {};
__export(AgenticTradingBot_exports, {
  AgenticTradingBot: () => AgenticTradingBot,
  BotPresets: () => BotPresets,
  createTradingBot: () => createTradingBot2
});
function createTradingBot2(config) {
  return new AgenticTradingBot(config);
}
var AgenticTradingBot, BotPresets;
var init_AgenticTradingBot = __esm({
  "server/services/ai-agents/AgenticTradingBot.ts"() {
    "use strict";
    init_llm();
    init_AgentOrchestrator();
    init_CryptoAgent();
    init_TechnicalIndicators();
    AgenticTradingBot = class {
      config;
      state;
      signalHistory = [];
      constructor(config) {
        this.config = config;
        this.state = {
          isRunning: false,
          lastAnalysis: 0,
          totalSignals: 0,
          successfulTrades: 0,
          failedTrades: 0,
          currentDrawdown: 0,
          peakValue: 0,
          performance: {
            daily: 0,
            weekly: 0,
            monthly: 0,
            allTime: 0
          },
          agentAccuracies: {
            technical: 0.65,
            fundamental: 0.6,
            sentiment: 0.55,
            risk: 0.7,
            regime: 0.58,
            execution: 0.62,
            coordinator: 0.68
          }
        };
      }
      /**
       * Analyze a single asset and generate a trade signal
       */
      async analyzeAsset(marketData, portfolio, cryptoMetrics, tokenomics) {
        const signalId = `sig_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const candles = marketData.priceHistory.map((p) => ({
          timestamp: p.timestamp,
          open: p.open,
          high: p.high,
          low: p.low,
          close: p.close,
          volume: p.volume
        }));
        const indicators = calculateAllIndicators(candles);
        const enrichedData = {
          ...marketData,
          indicators: {
            rsi: indicators.rsi[indicators.rsi.length - 1],
            macd: {
              value: indicators.macd.macd[indicators.macd.macd.length - 1] || 0,
              signal: indicators.macd.signal[indicators.macd.signal.length - 1] || 0,
              histogram: indicators.macd.histogram[indicators.macd.histogram.length - 1] || 0
            },
            ema: {
              ema8: indicators.ema.ema8[indicators.ema.ema8.length - 1] || 0,
              ema21: indicators.ema.ema21[indicators.ema.ema21.length - 1] || 0,
              ema50: indicators.ema.ema50[indicators.ema.ema50.length - 1] || 0,
              ema200: indicators.ema.ema200[indicators.ema.ema200.length - 1] || 0
            },
            bollinger: {
              upper: indicators.bollinger.upper[indicators.bollinger.upper.length - 1] || 0,
              middle: indicators.bollinger.middle[indicators.bollinger.middle.length - 1] || 0,
              lower: indicators.bollinger.lower[indicators.bollinger.lower.length - 1] || 0
            },
            atr: indicators.atr[indicators.atr.length - 1],
            obv: indicators.obv[indicators.obv.length - 1],
            vwap: indicators.vwap[indicators.vwap.length - 1]
          }
        };
        const consensus = await agentOrchestrator.orchestrate(enrichedData, portfolio);
        let cryptoAnalysis = null;
        if (marketData.assetType === "crypto" && cryptoMetrics) {
          cryptoAnalysis = await cryptoCoordinator.analyzeComprehensive(
            marketData.symbol,
            cryptoMetrics,
            tokenomics
          );
        }
        const agentVotes = consensus.agentVotes.map((vote) => ({
          agentName: vote.agentType,
          signal: vote.signal,
          confidence: vote.confidence,
          weight: this.state.agentAccuracies[vote.agentType] || 0.5,
          reasoning: vote.reasoning
        }));
        if (cryptoAnalysis) {
          cryptoAnalysis.analyses.forEach((analysis) => {
            agentVotes.push({
              agentName: `crypto_${analysis.agentType}`,
              signal: analysis.signal,
              confidence: analysis.confidence,
              weight: 0.55,
              // Crypto-specific agents get moderate weight
              reasoning: analysis.reasoning
            });
          });
        }
        const consensusDetails = this.calculateConsensus(agentVotes, consensus.riskApproved);
        let finalAction = "hold";
        let finalConfidence = consensus.overallConfidence;
        if (cryptoAnalysis) {
          finalConfidence = consensus.overallConfidence * 0.6 + cryptoAnalysis.confidence * 0.4;
        }
        if (finalConfidence >= this.config.minConfidenceThreshold) {
          if (consensusDetails.buyVotes > consensusDetails.sellVotes && consensusDetails.riskApproved) {
            finalAction = "buy";
          } else if (consensusDetails.sellVotes > consensusDetails.buyVotes) {
            finalAction = "sell";
          }
        }
        let quantity = 0;
        if (finalAction === "buy") {
          const maxPosition = portfolio.portfolioValue * this.config.maxPositionSize;
          const confidenceMultiplier = finalConfidence / 100;
          quantity = Math.floor(maxPosition * confidenceMultiplier / marketData.currentPrice);
        } else if (finalAction === "sell" && portfolio.currentPosition) {
          const sellPercent = consensusDetails.sellVotes > consensusDetails.buyVotes * 1.5 ? 1 : 0.5;
          quantity = Math.floor(portfolio.currentPosition.quantity * sellPercent);
        }
        const atr = enrichedData.indicators?.atr || marketData.currentPrice * 0.02;
        const stopLossDistance = atr * (this.config.riskTolerance === "conservative" ? 1.5 : this.config.riskTolerance === "aggressive" ? 3 : 2);
        const stopLoss = finalAction === "buy" ? marketData.currentPrice - stopLossDistance : void 0;
        const takeProfit = finalAction === "buy" ? marketData.currentPrice + stopLossDistance * 2 : void 0;
        const reasoning = this.buildReasoning(agentVotes, consensusDetails, indicators.patterns);
        const signal = {
          id: signalId,
          symbol: marketData.symbol,
          assetType: marketData.assetType,
          action: finalAction,
          quantity,
          price: marketData.currentPrice,
          stopLoss,
          takeProfit,
          confidence: finalConfidence,
          urgency: consensus.suggestedAction.urgency,
          reasoning,
          agentVotes,
          consensusDetails,
          timestamp: Date.now(),
          status: "pending"
        };
        this.signalHistory.push(signal);
        this.state.totalSignals++;
        this.state.lastAnalysis = Date.now();
        return signal;
      }
      /**
       * Calculate consensus from agent votes
       */
      calculateConsensus(votes, riskApproved) {
        let buyVotes = 0;
        let sellVotes = 0;
        let holdVotes = 0;
        for (const vote of votes) {
          const weightedVote = vote.weight * (vote.confidence / 100);
          switch (vote.signal) {
            case "strong_buy":
              buyVotes += weightedVote * 2;
              break;
            case "buy":
              buyVotes += weightedVote;
              break;
            case "strong_sell":
              sellVotes += weightedVote * 2;
              break;
            case "sell":
              sellVotes += weightedVote;
              break;
            default:
              holdVotes += weightedVote;
          }
        }
        const totalVotes = buyVotes + sellVotes + holdVotes;
        let meetsConsensus = false;
        switch (this.config.consensusRequirement) {
          case "majority":
            meetsConsensus = Math.max(buyVotes, sellVotes, holdVotes) > totalVotes * 0.5;
            break;
          case "supermajority":
            meetsConsensus = Math.max(buyVotes, sellVotes, holdVotes) > totalVotes * 0.67;
            break;
          case "unanimous":
            meetsConsensus = holdVotes === 0 && (buyVotes === 0 || sellVotes === 0);
            break;
        }
        return {
          method: "weighted_voting",
          totalVotes: votes.length,
          buyVotes,
          sellVotes,
          holdVotes,
          riskApproved: riskApproved && meetsConsensus,
          vetoReason: !riskApproved ? "Risk agent vetoed due to high risk" : !meetsConsensus ? `Consensus requirement (${this.config.consensusRequirement}) not met` : void 0
        };
      }
      /**
       * Build human-readable reasoning from agent analyses
       */
      buildReasoning(votes, consensus, patterns) {
        const parts = [];
        const bullishAgents = votes.filter((v) => v.signal === "buy" || v.signal === "strong_buy");
        const bearishAgents = votes.filter((v) => v.signal === "sell" || v.signal === "strong_sell");
        if (bullishAgents.length > 0) {
          parts.push(`Bullish signals from: ${bullishAgents.map((a) => a.agentName).join(", ")}`);
        }
        if (bearishAgents.length > 0) {
          parts.push(`Bearish signals from: ${bearishAgents.map((a) => a.agentName).join(", ")}`);
        }
        const recentPatterns = patterns.slice(-3);
        if (recentPatterns.length > 0) {
          parts.push(`Detected patterns: ${recentPatterns.map((p) => p.name).join(", ")}`);
        }
        parts.push(`Consensus: ${consensus.buyVotes.toFixed(1)} buy vs ${consensus.sellVotes.toFixed(1)} sell`);
        if (consensus.vetoReason) {
          parts.push(`Note: ${consensus.vetoReason}`);
        }
        return parts.join(". ");
      }
      /**
       * Get enhanced AI analysis with LLM reasoning
       */
      async getEnhancedAnalysis(signal) {
        const prompt = `You are an expert trading analyst. Analyze this trading signal and provide insights.

Symbol: ${signal.symbol} (${signal.assetType})
Action: ${signal.action.toUpperCase()}
Confidence: ${signal.confidence.toFixed(1)}%
Price: $${signal.price.toFixed(2)}
${signal.stopLoss ? `Stop Loss: $${signal.stopLoss.toFixed(2)}` : ""}
${signal.takeProfit ? `Take Profit: $${signal.takeProfit.toFixed(2)}` : ""}

Agent Analysis Summary:
${signal.agentVotes.map((v) => `- ${v.agentName}: ${v.signal} (${v.confidence}%) - ${v.reasoning}`).join("\n")}

Consensus: ${signal.consensusDetails.buyVotes.toFixed(1)} buy vs ${signal.consensusDetails.sellVotes.toFixed(1)} sell
Risk Approved: ${signal.consensusDetails.riskApproved ? "Yes" : "No"}

Please provide:
1. A brief market outlook summary
2. Key factors supporting this signal
3. Potential risks to monitor
4. Suggested position management

Keep response concise and actionable.`;
        try {
          const response = await invokeLLM({
            messages: [
              { role: "system", content: "You are an expert trading analyst. Provide concise, actionable insights." },
              { role: "user", content: prompt }
            ]
          });
          const content = response.choices?.[0]?.message?.content;
          return typeof content === "string" ? content : "Unable to generate enhanced analysis";
        } catch (error) {
          console.error("Error generating enhanced analysis:", error);
          return "Enhanced analysis unavailable";
        }
      }
      /**
       * Update agent accuracy based on trade outcome
       */
      updateAgentAccuracy(signal, wasSuccessful) {
        for (const vote of signal.agentVotes) {
          const agentName = vote.agentName;
          const currentAccuracy = this.state.agentAccuracies[agentName] || 0.5;
          const agentWasCorrect = wasSuccessful && (vote.signal === "buy" || vote.signal === "strong_buy") || !wasSuccessful && (vote.signal === "sell" || vote.signal === "strong_sell");
          this.state.agentAccuracies[agentName] = currentAccuracy * 0.95 + (agentWasCorrect ? 0.05 : 0);
        }
        if (wasSuccessful) {
          this.state.successfulTrades++;
        } else {
          this.state.failedTrades++;
        }
      }
      /**
       * Get bot statistics
       */
      getStatistics() {
        const totalTrades = this.state.successfulTrades + this.state.failedTrades;
        const winRate = totalTrades > 0 ? this.state.successfulTrades / totalTrades * 100 : 0;
        const agentEntries = Object.entries(this.state.agentAccuracies);
        const sortedAgents = agentEntries.sort((a, b) => b[1] - a[1]);
        return {
          winRate,
          totalTrades,
          agentPerformance: this.state.agentAccuracies,
          bestAgent: sortedAgents[0]?.[0] || "none",
          worstAgent: sortedAgents[sortedAgents.length - 1]?.[0] || "none"
        };
      }
      /**
       * Get recent signals
       */
      getRecentSignals(limit = 10) {
        return this.signalHistory.slice(-limit);
      }
      /**
       * Get configuration
       */
      getConfig() {
        return { ...this.config };
      }
      /**
       * Update configuration
       */
      updateConfig(updates) {
        this.config = { ...this.config, ...updates };
      }
      /**
       * Get current state
       */
      getState() {
        return { ...this.state };
      }
      /**
       * Start the bot
       */
      start() {
        this.state.isRunning = true;
      }
      /**
       * Stop the bot
       */
      stop() {
        this.state.isRunning = false;
      }
    };
    BotPresets = {
      conservative: {
        riskTolerance: "conservative",
        maxDrawdown: 0.1,
        maxPositionSize: 0.05,
        minConfidenceThreshold: 80,
        consensusRequirement: "supermajority"
      },
      moderate: {
        riskTolerance: "moderate",
        maxDrawdown: 0.15,
        maxPositionSize: 0.08,
        minConfidenceThreshold: 70,
        consensusRequirement: "majority"
      },
      aggressive: {
        riskTolerance: "aggressive",
        maxDrawdown: 0.25,
        maxPositionSize: 0.15,
        minConfidenceThreshold: 60,
        consensusRequirement: "majority"
      }
    };
  }
});

// server/services/ai-agents/StrategyBacktester.ts
var StrategyBacktester_exports = {};
__export(StrategyBacktester_exports, {
  default: () => StrategyBacktester_default,
  runAgentBacktest: () => runAgentBacktest,
  runQuickBacktest: () => runQuickBacktest
});
function generateMockPriceData(symbol, startDate, endDate) {
  const start = new Date(startDate);
  const end = new Date(endDate);
  const data = [];
  let price = symbol.includes("BTC") ? 4e4 : 150;
  const volatility = symbol.includes("BTC") ? 0.03 : 0.015;
  const drift = 2e-4;
  const current = new Date(start);
  while (current <= end) {
    if (!symbol.includes("BTC") && (current.getDay() === 0 || current.getDay() === 6)) {
      current.setDate(current.getDate() + 1);
      continue;
    }
    const dailyReturn = drift + volatility * (Math.random() - 0.5) * 2;
    const open = price;
    price = price * (1 + dailyReturn);
    const close = price;
    const high = Math.max(open, close) * (1 + Math.random() * volatility * 0.5);
    const low = Math.min(open, close) * (1 - Math.random() * volatility * 0.5);
    const volume = Math.floor(1e6 + Math.random() * 5e6);
    data.push({
      date: current.toISOString().split("T")[0],
      open,
      high,
      low,
      close,
      volume
    });
    current.setDate(current.getDate() + 1);
  }
  return data;
}
function simulateAgentSignals(priceData, index) {
  if (index < 20) {
    return {
      technical: { signal: "hold", confidence: 0.5 },
      fundamental: { signal: "hold", confidence: 0.5 },
      sentiment: { signal: "hold", confidence: 0.5 },
      risk: { signal: "hold", confidence: 0.5 },
      regime: { signal: "hold", confidence: 0.5 },
      execution: { signal: "hold", confidence: 0.5 },
      coordinator: { signal: "hold", confidence: 0.5 }
    };
  }
  const prices = priceData.slice(Math.max(0, index - 20), index + 1).map((p) => p.close);
  const sma20 = prices.reduce((a, b) => a + b, 0) / prices.length;
  const currentPrice = prices[prices.length - 1];
  const priceChange = (currentPrice - prices[0]) / prices[0];
  const momentum = priceChange > 0.02 ? "bullish" : priceChange < -0.02 ? "bearish" : "neutral";
  const signals = {};
  signals.technical = {
    signal: currentPrice > sma20 * 1.02 ? "buy" : currentPrice < sma20 * 0.98 ? "sell" : "hold",
    confidence: 0.6 + Math.random() * 0.3
  };
  signals.fundamental = {
    signal: currentPrice < sma20 * 0.95 ? "buy" : currentPrice > sma20 * 1.05 ? "sell" : "hold",
    confidence: 0.5 + Math.random() * 0.3
  };
  signals.sentiment = {
    signal: momentum === "bullish" ? "buy" : momentum === "bearish" ? "sell" : "hold",
    confidence: 0.5 + Math.random() * 0.3
  };
  const recentPrices = prices.slice(-5);
  const volatility = Math.sqrt(
    recentPrices.reduce((sum2, p, i) => {
      if (i === 0) return 0;
      const ret = (p - recentPrices[i - 1]) / recentPrices[i - 1];
      return sum2 + ret * ret;
    }, 0) / (recentPrices.length - 1)
  );
  signals.risk = {
    signal: volatility > 0.03 ? "sell" : volatility < 0.01 ? "buy" : "hold",
    confidence: 0.6 + Math.random() * 0.2
  };
  signals.regime = {
    signal: priceChange > 0.05 ? "buy" : priceChange < -0.05 ? "sell" : "hold",
    confidence: 0.5 + Math.random() * 0.3
  };
  signals.execution = {
    signal: "hold",
    confidence: 0.5
  };
  const buyCount = Object.values(signals).filter((s) => s.signal === "buy").length;
  const sellCount = Object.values(signals).filter((s) => s.signal === "sell").length;
  signals.coordinator = {
    signal: buyCount > sellCount ? "buy" : sellCount > buyCount ? "sell" : "hold",
    confidence: 0.7
  };
  return signals;
}
function calculateConsensus(signals, weights) {
  let buyScore = 0;
  let sellScore = 0;
  let holdScore = 0;
  let totalWeight = 0;
  for (const [agent, data] of Object.entries(signals)) {
    const weight = weights[agent] || 0.1;
    totalWeight += weight;
    if (data.signal === "buy") {
      buyScore += weight * data.confidence;
    } else if (data.signal === "sell") {
      sellScore += weight * data.confidence;
    } else {
      holdScore += weight * data.confidence;
    }
  }
  buyScore /= totalWeight;
  sellScore /= totalWeight;
  holdScore /= totalWeight;
  const maxScore = Math.max(buyScore, sellScore, holdScore);
  let signal;
  if (maxScore === buyScore && buyScore > 0.4) {
    signal = "buy";
  } else if (maxScore === sellScore && sellScore > 0.4) {
    signal = "sell";
  } else {
    signal = "hold";
  }
  return { signal, confidence: maxScore };
}
async function runAgentBacktest(config) {
  const weights = config.useAgentWeights && config.agentWeights ? config.agentWeights : DEFAULT_WEIGHTS;
  const priceData = generateMockPriceData(config.symbol, config.startDate, config.endDate);
  const benchmarkData = generateMockPriceData(config.benchmark, config.startDate, config.endDate);
  let cash = config.initialCapital;
  let position = null;
  const trades2 = [];
  const dailySnapshots = [];
  const agentStats = {};
  for (const agent of Object.keys(weights)) {
    agentStats[agent] = { correct: 0, total: 0, profitable: 0 };
  }
  let peakValue = config.initialCapital;
  let maxDrawdown = 0;
  let drawdownStart = null;
  const drawdownPeriods = [];
  const monthlyReturns = /* @__PURE__ */ new Map();
  let lastMonthValue = config.initialCapital;
  let lastMonth = "";
  for (let i = 0; i < priceData.length; i++) {
    const day = priceData[i];
    const currentMonth = day.date.substring(0, 7);
    const agentSignals = simulateAgentSignals(
      priceData.slice(0, i + 1).map((p) => ({ close: p.close, volume: p.volume })),
      i
    );
    const consensus = calculateConsensus(agentSignals, weights);
    const portfolioValue = cash + (position ? position.quantity * day.close : 0);
    if (portfolioValue > peakValue) {
      peakValue = portfolioValue;
      if (drawdownStart) {
        drawdownPeriods.push({
          startDate: drawdownStart,
          endDate: day.date,
          maxDrawdown,
          duration: Math.floor((new Date(day.date).getTime() - new Date(drawdownStart).getTime()) / (1e3 * 60 * 60 * 24)),
          recovery: Math.floor((new Date(day.date).getTime() - new Date(drawdownStart).getTime()) / (1e3 * 60 * 60 * 24))
        });
        drawdownStart = null;
      }
    } else {
      const currentDrawdown = (peakValue - portfolioValue) / peakValue;
      if (currentDrawdown > maxDrawdown) {
        maxDrawdown = currentDrawdown;
      }
      if (!drawdownStart && currentDrawdown > 0.01) {
        drawdownStart = day.date;
      }
    }
    if (currentMonth !== lastMonth && lastMonth !== "") {
      const monthReturn = (portfolioValue - lastMonthValue) / lastMonthValue;
      const benchmarkMonthReturn = i > 0 ? (benchmarkData[i].close - benchmarkData[Math.max(0, i - 20)].close) / benchmarkData[Math.max(0, i - 20)].close : 0;
      monthlyReturns.set(lastMonth, { return: monthReturn, benchmarkReturn: benchmarkMonthReturn });
      lastMonthValue = portfolioValue;
    }
    lastMonth = currentMonth;
    const dayTrades = [];
    if (consensus.signal === "buy" && !position && consensus.confidence > 0.5) {
      let positionValue;
      if (config.positionSizing === "fixed") {
        positionValue = Math.min(config.positionSize, cash * 0.95);
      } else if (config.positionSizing === "percent") {
        positionValue = Math.min(cash * (config.positionSize / 100), cash * 0.95);
      } else {
        positionValue = cash * 0.5;
      }
      const quantity = Math.floor(positionValue / day.close);
      if (quantity > 0) {
        const transactionCost = positionValue * (config.transactionCost / 100);
        const slippageCost = positionValue * (config.slippage / 100);
        const totalCost = positionValue + transactionCost + slippageCost;
        if (totalCost <= cash) {
          const trade = {
            id: `trade-${trades2.length + 1}`,
            timestamp: new Date(day.date).getTime(),
            symbol: config.symbol,
            side: "buy",
            quantity,
            price: day.close * (1 + config.slippage / 100),
            totalValue: positionValue,
            transactionCost,
            slippage: slippageCost,
            agentSignals: Object.fromEntries(
              Object.entries(agentSignals).map(([k, v]) => [k, v.signal])
            ),
            consensusSignal: consensus.signal,
            confidence: consensus.confidence,
            reason: "Consensus buy signal"
          };
          trades2.push(trade);
          dayTrades.push(trade);
          cash -= totalCost;
          position = {
            symbol: config.symbol,
            quantity,
            avgCost: trade.price,
            currentPrice: day.close,
            unrealizedPnL: 0,
            unrealizedPnLPercent: 0
          };
        }
      }
    } else if (consensus.signal === "sell" && position && consensus.confidence > 0.5) {
      const saleValue = position.quantity * day.close * (1 - config.slippage / 100);
      const transactionCost = saleValue * (config.transactionCost / 100);
      const slippageCost = position.quantity * day.close * (config.slippage / 100);
      const trade = {
        id: `trade-${trades2.length + 1}`,
        timestamp: new Date(day.date).getTime(),
        symbol: config.symbol,
        side: "sell",
        quantity: position.quantity,
        price: day.close * (1 - config.slippage / 100),
        totalValue: saleValue,
        transactionCost,
        slippage: slippageCost,
        agentSignals: Object.fromEntries(
          Object.entries(agentSignals).map(([k, v]) => [k, v.signal])
        ),
        consensusSignal: consensus.signal,
        confidence: consensus.confidence,
        reason: "Consensus sell signal"
      };
      trades2.push(trade);
      dayTrades.push(trade);
      cash += saleValue - transactionCost;
      const tradeReturn = (trade.price - position.avgCost) / position.avgCost;
      for (const [agent, data] of Object.entries(agentSignals)) {
        agentStats[agent].total++;
        if (data.signal === "buy" && tradeReturn > 0 || data.signal === "sell" && tradeReturn < 0) {
          agentStats[agent].correct++;
        }
        if (tradeReturn > 0) {
          agentStats[agent].profitable++;
        }
      }
      position = null;
    }
    if (position) {
      position.currentPrice = day.close;
      position.unrealizedPnL = (day.close - position.avgCost) * position.quantity;
      position.unrealizedPnLPercent = (day.close - position.avgCost) / position.avgCost;
    }
    const prevValue = i > 0 ? dailySnapshots[i - 1].portfolioValue : config.initialCapital;
    const dailyReturn = (portfolioValue - prevValue) / prevValue;
    const cumulativeReturn = (portfolioValue - config.initialCapital) / config.initialCapital;
    dailySnapshots.push({
      date: day.date,
      portfolioValue,
      cash,
      positions: position ? [position] : [],
      dailyReturn,
      cumulativeReturn,
      drawdown: peakValue > 0 ? (peakValue - portfolioValue) / peakValue : 0,
      trades: dayTrades,
      agentSignals: Object.fromEntries(
        Object.entries(agentSignals).map(([k, v]) => [k, v.signal])
      ),
      consensusSignal: consensus.signal,
      confidence: consensus.confidence
    });
  }
  const finalValue = dailySnapshots[dailySnapshots.length - 1].portfolioValue;
  const totalReturn = (finalValue - config.initialCapital) / config.initialCapital;
  const dailyReturns = dailySnapshots.map((s) => s.dailyReturn);
  const avgDailyReturn = dailyReturns.reduce((a, b) => a + b, 0) / dailyReturns.length;
  const volatility = Math.sqrt(
    dailyReturns.reduce((sum2, r) => sum2 + Math.pow(r - avgDailyReturn, 2), 0) / dailyReturns.length
  ) * Math.sqrt(252);
  const annualizedReturn = Math.pow(1 + totalReturn, 252 / dailySnapshots.length) - 1;
  const sharpeRatio = volatility > 0 ? annualizedReturn / volatility : 0;
  const negativeReturns = dailyReturns.filter((r) => r < 0);
  const downsideDeviation = Math.sqrt(
    negativeReturns.reduce((sum2, r) => sum2 + r * r, 0) / negativeReturns.length
  ) * Math.sqrt(252);
  const sortinoRatio = downsideDeviation > 0 ? annualizedReturn / downsideDeviation : 0;
  const tradePairs = [];
  for (let i = 0; i < trades2.length - 1; i += 2) {
    if (trades2[i].side === "buy" && trades2[i + 1]?.side === "sell") {
      tradePairs.push({ buy: trades2[i], sell: trades2[i + 1] });
    }
  }
  const tradeReturns = tradePairs.map((p) => (p.sell.price - p.buy.price) / p.buy.price);
  const winningTrades = tradeReturns.filter((r) => r > 0);
  const losingTrades = tradeReturns.filter((r) => r < 0);
  const winRate = tradeReturns.length > 0 ? winningTrades.length / tradeReturns.length : 0;
  const avgWin = winningTrades.length > 0 ? winningTrades.reduce((a, b) => a + b, 0) / winningTrades.length : 0;
  const avgLoss = losingTrades.length > 0 ? Math.abs(losingTrades.reduce((a, b) => a + b, 0) / losingTrades.length) : 0;
  const profitFactor = avgLoss > 0 ? avgWin * winningTrades.length / (avgLoss * losingTrades.length) : avgWin > 0 ? Infinity : 0;
  const benchmarkReturn = (benchmarkData[benchmarkData.length - 1].close - benchmarkData[0].close) / benchmarkData[0].close;
  const excessReturn = totalReturn - benchmarkReturn;
  const benchmarkReturns = benchmarkData.slice(1).map(
    (d, i) => (d.close - benchmarkData[i].close) / benchmarkData[i].close
  );
  const returnDiffs = dailyReturns.slice(0, benchmarkReturns.length).map((r, i) => r - benchmarkReturns[i]);
  const trackingError = Math.sqrt(
    returnDiffs.reduce((sum2, d) => sum2 + d * d, 0) / returnDiffs.length
  ) * Math.sqrt(252);
  const informationRatio = trackingError > 0 ? excessReturn / trackingError : 0;
  let maxDrawdownDuration = 0;
  for (const period of drawdownPeriods) {
    if (period.duration > maxDrawdownDuration) {
      maxDrawdownDuration = period.duration;
    }
  }
  const calmarRatio = maxDrawdown > 0 ? annualizedReturn / maxDrawdown : 0;
  const agentPerformance2 = Object.entries(agentStats).map(([agentType, stats]) => ({
    agentType,
    accuracy: stats.total > 0 ? stats.correct / stats.total : 0,
    profitableSignals: stats.profitable,
    totalSignals: stats.total,
    contribution: weights[agentType] || 0
  }));
  return {
    config,
    summary: {
      totalReturn,
      annualizedReturn,
      volatility,
      sharpeRatio,
      sortinoRatio,
      maxDrawdown,
      maxDrawdownDuration,
      winRate,
      profitFactor,
      totalTrades: trades2.length,
      avgTradeReturn: tradeReturns.length > 0 ? tradeReturns.reduce((a, b) => a + b, 0) / tradeReturns.length : 0,
      avgWin,
      avgLoss,
      avgHoldingPeriod: tradePairs.length > 0 ? tradePairs.reduce((sum2, p) => sum2 + (p.sell.timestamp - p.buy.timestamp) / (1e3 * 60 * 60 * 24), 0) / tradePairs.length : 0,
      calmarRatio,
      informationRatio,
      beta: 1,
      // Simplified
      alpha: excessReturn
    },
    dailySnapshots,
    trades: trades2,
    agentPerformance: agentPerformance2,
    benchmarkComparison: {
      benchmarkReturn,
      excessReturn,
      trackingError,
      informationRatio
    },
    monthlyReturns: Array.from(monthlyReturns.entries()).map(([month, data]) => ({
      month,
      return: data.return,
      benchmarkReturn: data.benchmarkReturn
    })),
    drawdownPeriods
  };
}
async function runQuickBacktest(symbol, days = 252) {
  const endDate = /* @__PURE__ */ new Date();
  const startDate = /* @__PURE__ */ new Date();
  startDate.setDate(startDate.getDate() - days);
  return runAgentBacktest({
    symbol,
    startDate: startDate.toISOString().split("T")[0],
    endDate: endDate.toISOString().split("T")[0],
    initialCapital: 1e5,
    positionSizing: "percent",
    positionSize: 50,
    maxPositionSize: 1e5,
    stopLoss: 5,
    takeProfit: 10,
    transactionCost: 0.1,
    slippage: 0.05,
    useAgentWeights: true,
    rebalanceFrequency: "daily",
    benchmark: symbol.includes("BTC") ? "BTC" : "SPY"
  });
}
var DEFAULT_WEIGHTS, StrategyBacktester_default;
var init_StrategyBacktester = __esm({
  "server/services/ai-agents/StrategyBacktester.ts"() {
    "use strict";
    DEFAULT_WEIGHTS = {
      technical: 0.2,
      fundamental: 0.18,
      sentiment: 0.12,
      risk: 0.15,
      regime: 0.12,
      execution: 0.08,
      coordinator: 0.15
    };
    StrategyBacktester_default = {
      runAgentBacktest,
      runQuickBacktest
    };
  }
});

// server/services/ai-agents/AdaptiveLearning.ts
function calculateAgentPerformance(predictions, agentType) {
  const agentPredictions = predictions.filter((p) => p.agentType === agentType);
  if (agentPredictions.length === 0) {
    return {
      agentType,
      agentName: getAgentName(agentType),
      totalPredictions: 0,
      correctPredictions: 0,
      accuracy: 0,
      profitablePredictions: 0,
      profitabilityRate: 0,
      averageReturn: 0,
      sharpeRatio: 0,
      maxDrawdown: 0,
      winRate: 0,
      avgWin: 0,
      avgLoss: 0,
      profitFactor: 0
    };
  }
  const totalPredictions = agentPredictions.length;
  const correctPredictions = agentPredictions.filter((p) => {
    if (p.prediction === "buy" && p.actualOutcome === "profit") return true;
    if (p.prediction === "sell" && p.actualOutcome === "profit") return true;
    if (p.prediction === "hold" && p.actualOutcome === "neutral") return true;
    return false;
  }).length;
  const accuracy = correctPredictions / totalPredictions;
  const profitablePredictions = agentPredictions.filter((p) => p.actualOutcome === "profit").length;
  const profitabilityRate = profitablePredictions / totalPredictions;
  const returns = agentPredictions.map((p) => p.returnPercent);
  const averageReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
  const returnStdDev = Math.sqrt(
    returns.reduce((sum2, r) => sum2 + Math.pow(r - averageReturn, 2), 0) / returns.length
  );
  const sharpeRatio = returnStdDev > 0 ? averageReturn * Math.sqrt(252) / returnStdDev : 0;
  let peak = 0;
  let maxDrawdown = 0;
  let cumReturn = 0;
  for (const r of returns) {
    cumReturn += r;
    if (cumReturn > peak) peak = cumReturn;
    const drawdown = peak - cumReturn;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
  }
  const wins = returns.filter((r) => r > 0);
  const losses = returns.filter((r) => r < 0);
  const winRate = wins.length / returns.length;
  const avgWin = wins.length > 0 ? wins.reduce((a, b) => a + b, 0) / wins.length : 0;
  const avgLoss = losses.length > 0 ? Math.abs(losses.reduce((a, b) => a + b, 0) / losses.length) : 0;
  const profitFactor = avgLoss > 0 ? avgWin * wins.length / (avgLoss * losses.length) : avgWin > 0 ? Infinity : 0;
  return {
    agentType,
    agentName: getAgentName(agentType),
    totalPredictions,
    correctPredictions,
    accuracy,
    profitablePredictions,
    profitabilityRate,
    averageReturn,
    sharpeRatio,
    maxDrawdown,
    winRate,
    avgWin,
    avgLoss,
    profitFactor
  };
}
function detectMarketRegime2(priceData, volatilityData) {
  if (priceData.length < 20) {
    return {
      type: "sideways",
      confidence: 0.5,
      indicators: { trendStrength: 0, volatility: 0, momentum: 0, volume: 0 }
    };
  }
  const recentPrices = priceData.slice(-20).map((p) => p.close);
  const priceChange = (recentPrices[recentPrices.length - 1] - recentPrices[0]) / recentPrices[0];
  const trendStrength = Math.abs(priceChange);
  const avgVolatility = volatilityData.length > 0 ? volatilityData.reduce((a, b) => a + b, 0) / volatilityData.length : 0;
  const shortMA = recentPrices.slice(-5).reduce((a, b) => a + b, 0) / 5;
  const longMA = recentPrices.reduce((a, b) => a + b, 0) / recentPrices.length;
  const momentum = (shortMA - longMA) / longMA;
  const recentVolumes = priceData.slice(-20).map((p) => p.volume);
  const avgVolume = recentVolumes.reduce((a, b) => a + b, 0) / recentVolumes.length;
  const recentAvgVolume = recentVolumes.slice(-5).reduce((a, b) => a + b, 0) / 5;
  const volumeTrend = avgVolume > 0 ? (recentAvgVolume - avgVolume) / avgVolume : 0;
  let regimeType;
  let confidence;
  if (avgVolatility > 0.03) {
    regimeType = "volatile";
    confidence = Math.min(0.9, 0.5 + avgVolatility * 10);
  } else if (avgVolatility < 0.01) {
    regimeType = "calm";
    confidence = Math.min(0.9, 0.5 + (0.01 - avgVolatility) * 50);
  } else if (priceChange > 0.05 && momentum > 0) {
    regimeType = "bull";
    confidence = Math.min(0.9, 0.5 + priceChange * 5);
  } else if (priceChange < -0.05 && momentum < 0) {
    regimeType = "bear";
    confidence = Math.min(0.9, 0.5 + Math.abs(priceChange) * 5);
  } else {
    regimeType = "sideways";
    confidence = Math.min(0.9, 0.5 + (1 - trendStrength) * 0.5);
  }
  return {
    type: regimeType,
    confidence,
    indicators: {
      trendStrength,
      volatility: avgVolatility,
      momentum,
      volume: volumeTrend
    }
  };
}
function calculateAdjustedWeights(performances, currentRegime, config = DEFAULT_CONFIG2) {
  const weights = [];
  for (const agentType of Object.keys(BASE_WEIGHTS)) {
    const baseWeight = BASE_WEIGHTS[agentType];
    const performance = performances.find((p) => p.agentType === agentType);
    const regimeModifier = config.regimeAdaptation ? REGIME_MODIFIERS[currentRegime.type][agentType] || 1 : 1;
    let performanceModifier = 1;
    if (performance && performance.totalPredictions >= 10) {
      const accuracyScore = performance.accuracy * 2;
      const profitScore = performance.profitabilityRate * 2;
      const sharpeScore = Math.min(2, Math.max(0, performance.sharpeRatio / 2));
      performanceModifier = (accuracyScore + profitScore + sharpeScore) / 3;
    }
    const recencyModifier = 1;
    let adjustedWeight = baseWeight * regimeModifier * performanceModifier * recencyModifier;
    adjustedWeight = baseWeight + (adjustedWeight - baseWeight) * config.learningRate;
    adjustedWeight = Math.max(config.minWeight, Math.min(config.maxWeight, adjustedWeight));
    const confidenceScore = performance ? Math.min(1, performance.totalPredictions / config.performanceWindow) : 0;
    weights.push({
      agentType,
      baseWeight,
      adjustedWeight,
      regimeModifier,
      performanceModifier,
      recencyModifier,
      confidenceScore
    });
  }
  const totalWeight = weights.reduce((sum2, w) => sum2 + w.adjustedWeight, 0);
  for (const weight of weights) {
    weight.adjustedWeight = weight.adjustedWeight / totalWeight;
  }
  return weights;
}
function updateWeights(currentWeights, newPredictions, currentRegime, config = DEFAULT_CONFIG2) {
  const previousWeights = { ...currentWeights };
  const newWeights = {};
  const changes = [];
  const performances = [];
  for (const agentType of Object.keys(BASE_WEIGHTS)) {
    const performance = calculateAgentPerformance(newPredictions, agentType);
    performances.push(performance);
  }
  const adjustedWeights = calculateAdjustedWeights(performances, currentRegime, config);
  for (const weight of adjustedWeights) {
    const currentWeight = currentWeights[weight.agentType] || weight.baseWeight;
    const targetWeight = weight.adjustedWeight;
    const newWeight = currentWeight + (targetWeight - currentWeight) * config.learningRate;
    newWeights[weight.agentType] = newWeight;
    const changePercent = (newWeight - currentWeight) / currentWeight * 100;
    let reason = "";
    if (changePercent > 5) {
      reason = `Strong performance in ${currentRegime.type} market`;
    } else if (changePercent < -5) {
      reason = `Underperformance in ${currentRegime.type} market`;
    } else if (Math.abs(changePercent) > 1) {
      reason = `Minor adjustment based on recent predictions`;
    } else {
      reason = "Stable performance";
    }
    changes.push({
      agentType: weight.agentType,
      previousWeight: currentWeight,
      newWeight,
      changePercent,
      reason
    });
  }
  const totalWeight = Object.values(newWeights).reduce((sum2, w) => sum2 + w, 0);
  for (const agentType of Object.keys(newWeights)) {
    newWeights[agentType] = newWeights[agentType] / totalWeight;
  }
  return {
    previousWeights,
    newWeights,
    changes,
    marketRegime: currentRegime,
    timestamp: Date.now()
  };
}
function getAgentName(agentType) {
  const names = {
    technical: "Technical Analysis Agent",
    fundamental: "Fundamental Analysis Agent",
    sentiment: "Sentiment Analysis Agent",
    risk: "Risk Management Agent",
    regime: "Regime Detection Agent",
    execution: "Execution Optimization Agent",
    coordinator: "Coordinator Agent"
  };
  return names[agentType] || agentType;
}
var DEFAULT_CONFIG2, BASE_WEIGHTS, REGIME_MODIFIERS;
var init_AdaptiveLearning = __esm({
  "server/services/ai-agents/AdaptiveLearning.ts"() {
    "use strict";
    DEFAULT_CONFIG2 = {
      learningRate: 0.1,
      decayFactor: 0.95,
      minWeight: 0.05,
      maxWeight: 0.35,
      lookbackPeriod: 30,
      regimeAdaptation: true,
      performanceWindow: 50
    };
    BASE_WEIGHTS = {
      technical: 0.2,
      fundamental: 0.18,
      sentiment: 0.12,
      risk: 0.15,
      regime: 0.12,
      execution: 0.08,
      coordinator: 0.15
    };
    REGIME_MODIFIERS = {
      bull: {
        technical: 1.2,
        fundamental: 1.1,
        sentiment: 1.3,
        risk: 0.8,
        regime: 1,
        execution: 1,
        coordinator: 1
      },
      bear: {
        technical: 1.1,
        fundamental: 1.2,
        sentiment: 0.9,
        risk: 1.4,
        regime: 1.2,
        execution: 1,
        coordinator: 1.1
      },
      sideways: {
        technical: 1.3,
        fundamental: 1,
        sentiment: 0.8,
        risk: 1.1,
        regime: 1,
        execution: 1.2,
        coordinator: 1
      },
      volatile: {
        technical: 0.9,
        fundamental: 0.8,
        sentiment: 0.7,
        risk: 1.5,
        regime: 1.3,
        execution: 1.1,
        coordinator: 1.2
      },
      calm: {
        technical: 1.1,
        fundamental: 1.2,
        sentiment: 1.1,
        risk: 0.9,
        regime: 0.9,
        execution: 1,
        coordinator: 1
      }
    };
  }
});

// server/services/ai-agents/PredictionTracking.ts
var PredictionTracking_exports = {};
__export(PredictionTracking_exports, {
  getAllPredictions: () => getAllPredictions,
  getCurrentWeights: () => getCurrentWeights,
  getPendingPredictions: () => getPendingPredictions,
  getPredictionStats: () => getPredictionStats,
  getWeightHistory: () => getWeightHistory,
  initializeSampleData: () => initializeSampleData,
  recordPrediction: () => recordPrediction,
  recordWeightSnapshot: () => recordWeightSnapshot,
  updatePredictionOutcome: () => updatePredictionOutcome
});
async function recordPrediction(entry) {
  const id = nextPredictionId++;
  const prediction = {
    id,
    ...entry,
    outcome: "pending",
    predictionTimestamp: /* @__PURE__ */ new Date(),
    actualExitPrice: null,
    actualReturnPct: null,
    outcomeTimestamp: null,
    holdingPeriodHours: null
  };
  predictionStore.set(id, prediction);
  return id;
}
async function updatePredictionOutcome(outcome) {
  const prediction = predictionStore.get(outcome.predictionId);
  if (!prediction) {
    throw new Error("Prediction not found");
  }
  const entryPrice = prediction.entryPrice;
  const exitPrice = outcome.actualExitPrice;
  let returnPct = 0;
  if (prediction.predictionSignal === "buy") {
    returnPct = (exitPrice - entryPrice) / entryPrice * 100;
  } else if (prediction.predictionSignal === "sell") {
    returnPct = (entryPrice - exitPrice) / entryPrice * 100;
  }
  let outcomeResult = "neutral";
  if (returnPct > 0.5) {
    outcomeResult = "profit";
  } else if (returnPct < -0.5) {
    outcomeResult = "loss";
  }
  const predictionTime = prediction.predictionTimestamp.getTime();
  const outcomeTime = outcome.outcomeTimestamp.getTime();
  const holdingPeriodHours = Math.round((outcomeTime - predictionTime) / (1e3 * 60 * 60));
  prediction.actualExitPrice = exitPrice;
  prediction.actualReturnPct = returnPct;
  prediction.outcome = outcomeResult;
  prediction.outcomeTimestamp = outcome.outcomeTimestamp;
  prediction.holdingPeriodHours = holdingPeriodHours;
  await triggerAdaptiveLearningUpdate(prediction.userId);
}
async function getPredictionStats(userId, days = 30) {
  const cutoffDate = /* @__PURE__ */ new Date();
  cutoffDate.setDate(cutoffDate.getDate() - days);
  const rows = Array.from(predictionStore.values()).filter(
    (p) => p.userId === userId && p.predictionTimestamp >= cutoffDate
  );
  const stats = {
    totalPredictions: rows.length,
    pendingPredictions: 0,
    completedPredictions: 0,
    profitablePredictions: 0,
    lossPredictions: 0,
    neutralPredictions: 0,
    overallAccuracy: 0,
    averageReturn: 0,
    winRate: 0,
    profitFactor: 0,
    bySignal: {
      buy: { total: 0, profitable: 0, accuracy: 0 },
      sell: { total: 0, profitable: 0, accuracy: 0 },
      hold: { total: 0, profitable: 0, accuracy: 0 }
    },
    byAgent: {}
  };
  let totalReturn = 0;
  let totalProfit = 0;
  let totalLoss = 0;
  const agentStats = {};
  for (const row of rows) {
    const signal = row.predictionSignal;
    stats.bySignal[signal].total++;
    if (row.outcome === "pending") {
      stats.pendingPredictions++;
    } else {
      stats.completedPredictions++;
      const returnPct = row.actualReturnPct || 0;
      totalReturn += returnPct;
      if (row.outcome === "profit") {
        stats.profitablePredictions++;
        stats.bySignal[signal].profitable++;
        totalProfit += returnPct;
      } else if (row.outcome === "loss") {
        stats.lossPredictions++;
        totalLoss += Math.abs(returnPct);
      } else {
        stats.neutralPredictions++;
      }
      const agentVotes = row.agentVotes || {};
      for (const [agent, vote] of Object.entries(agentVotes)) {
        if (!agentStats[agent]) {
          agentStats[agent] = { correct: 0, total: 0 };
        }
        agentStats[agent].total++;
        const wasCorrect = vote === "buy" && row.outcome === "profit" || vote === "sell" && row.outcome === "profit" || vote === "hold" && row.outcome === "neutral";
        if (wasCorrect) {
          agentStats[agent].correct++;
        }
      }
    }
  }
  if (stats.completedPredictions > 0) {
    stats.overallAccuracy = stats.profitablePredictions / stats.completedPredictions * 100;
    stats.averageReturn = totalReturn / stats.completedPredictions;
    stats.winRate = stats.profitablePredictions / stats.completedPredictions * 100;
    stats.profitFactor = totalLoss > 0 ? totalProfit / totalLoss : totalProfit > 0 ? Infinity : 0;
  }
  for (const signal of ["buy", "sell", "hold"]) {
    const signalStats = stats.bySignal[signal];
    if (signalStats.total > 0) {
      signalStats.accuracy = signalStats.profitable / signalStats.total * 100;
    }
  }
  for (const [agent, data] of Object.entries(agentStats)) {
    stats.byAgent[agent] = {
      accuracy: data.total > 0 ? data.correct / data.total * 100 : 0,
      contribution: data.total
    };
  }
  return stats;
}
async function getPendingPredictions(userId) {
  return Array.from(predictionStore.values()).filter(
    (p) => p.userId === userId && p.outcome === "pending"
  );
}
async function recordWeightSnapshot(snapshot) {
  const history = weightHistoryStore.get(snapshot.userId) || [];
  history.push(snapshot);
  weightHistoryStore.set(snapshot.userId, history);
}
async function getWeightHistory(userId, days = 30) {
  const cutoffDate = /* @__PURE__ */ new Date();
  cutoffDate.setDate(cutoffDate.getDate() - days);
  const history = weightHistoryStore.get(userId) || [];
  return history.filter((s) => s.snapshotTimestamp >= cutoffDate);
}
async function triggerAdaptiveLearningUpdate(userId) {
  const rows = Array.from(predictionStore.values()).filter((p) => p.userId === userId && p.outcome !== "pending").sort((a, b) => b.outcomeTimestamp.getTime() - a.outcomeTimestamp.getTime()).slice(0, 50);
  if (rows.length < 10) return;
  const history = weightHistoryStore.get(userId) || [];
  let currentWeights = {
    technical: 0.2,
    fundamental: 0.18,
    sentiment: 0.15,
    risk: 0.15,
    regime: 0.12,
    execution: 0.1,
    coordinator: 0.1
  };
  if (history.length > 0) {
    currentWeights = history[history.length - 1].weights;
  }
  const priceData = rows.map((r) => ({
    close: r.entryPrice,
    volume: 1e6
    // Placeholder
  }));
  const volatilityData = rows.map((r) => Math.abs(r.actualReturnPct || 0) / 100);
  const regime = detectMarketRegime2(priceData, volatilityData);
  const agentPredictions = [];
  for (const row of rows) {
    const agentVotes = row.agentVotes || {};
    for (const [agent, vote] of Object.entries(agentVotes)) {
      agentPredictions.push({
        id: `${row.id}-${agent}`,
        agentType: agent,
        symbol: row.symbol,
        prediction: vote,
        confidence: row.confidence,
        actualOutcome: row.outcome,
        returnPercent: row.actualReturnPct || 0,
        marketRegime: row.marketRegime,
        timestamp: row.outcomeTimestamp.getTime()
      });
    }
  }
  const result = updateWeights(currentWeights, agentPredictions, regime);
  await recordWeightSnapshot({
    userId,
    snapshotTimestamp: /* @__PURE__ */ new Date(),
    marketRegime: regime.type,
    weights: result.newWeights,
    triggerReason: "Automatic update from prediction outcomes",
    performanceMetrics: {
      recentPredictions: rows.length,
      accuracy: rows.filter((r) => r.outcome === "profit").length / rows.length * 100
    }
  });
}
async function getCurrentWeights(userId) {
  const history = weightHistoryStore.get(userId) || [];
  if (history.length > 0) {
    return history[history.length - 1].weights;
  }
  return {
    technical: 0.2,
    fundamental: 0.18,
    sentiment: 0.15,
    risk: 0.15,
    regime: 0.12,
    execution: 0.1,
    coordinator: 0.1
  };
}
async function getAllPredictions(userId) {
  return Array.from(predictionStore.values()).filter((p) => p.userId === userId).sort((a, b) => b.predictionTimestamp.getTime() - a.predictionTimestamp.getTime());
}
function initializeSampleData(userId) {
  const now = Date.now();
  const day = 24 * 60 * 60 * 1e3;
  const symbols = ["AAPL", "GOOGL", "MSFT", "TSLA", "NVDA"];
  const signals = ["buy", "sell", "hold"];
  for (let i = 0; i < 50; i++) {
    const timestamp2 = new Date(now - i * day * 0.6);
    const symbol = symbols[i % symbols.length];
    const signal = signals[Math.floor(Math.random() * 3)];
    const entryPrice = 100 + Math.random() * 100;
    const returnPct = (Math.random() - 0.4) * 10;
    const prediction = {
      id: nextPredictionId++,
      userId,
      symbol,
      assetType: "stock",
      predictionSignal: signal,
      confidence: 60 + Math.random() * 35,
      entryPrice,
      targetPrice: entryPrice * (1 + Math.random() * 0.1),
      stopLoss: entryPrice * (1 - Math.random() * 0.05),
      agentVotes: {
        technical: signals[Math.floor(Math.random() * 3)],
        fundamental: signals[Math.floor(Math.random() * 3)],
        sentiment: signals[Math.floor(Math.random() * 3)],
        risk: signals[Math.floor(Math.random() * 3)],
        regime: signals[Math.floor(Math.random() * 3)],
        execution: signals[Math.floor(Math.random() * 3)],
        coordinator: signal
      },
      consensusMethod: "weighted_voting",
      marketRegime: ["bull", "bear", "sideways", "volatile"][Math.floor(Math.random() * 4)],
      outcome: returnPct > 0.5 ? "profit" : returnPct < -0.5 ? "loss" : "neutral",
      predictionTimestamp: timestamp2,
      actualExitPrice: entryPrice * (1 + returnPct / 100),
      actualReturnPct: returnPct,
      outcomeTimestamp: new Date(timestamp2.getTime() + day * 2),
      holdingPeriodHours: 48
    };
    predictionStore.set(prediction.id, prediction);
  }
  const regimes = ["bull", "bear", "sideways", "volatile"];
  for (let i = 30; i >= 0; i--) {
    const snapshot = {
      userId,
      snapshotTimestamp: new Date(now - i * day),
      marketRegime: regimes[Math.floor(Math.random() * 4)],
      weights: {
        technical: 0.15 + Math.random() * 0.1,
        fundamental: 0.13 + Math.random() * 0.1,
        sentiment: 0.1 + Math.random() * 0.1,
        risk: 0.1 + Math.random() * 0.1,
        regime: 0.08 + Math.random() * 0.08,
        execution: 0.06 + Math.random() * 0.08,
        coordinator: 0.06 + Math.random() * 0.08
      },
      triggerReason: i === 30 ? "Initial weights" : "Automatic update from prediction outcomes",
      performanceMetrics: {
        recentPredictions: 10 + Math.floor(Math.random() * 40),
        accuracy: 50 + Math.random() * 30
      }
    };
    const total = Object.values(snapshot.weights).reduce((a, b) => a + b, 0);
    for (const key of Object.keys(snapshot.weights)) {
      snapshot.weights[key] /= total;
    }
    const history = weightHistoryStore.get(userId) || [];
    history.push(snapshot);
    weightHistoryStore.set(userId, history);
  }
}
var predictionStore, weightHistoryStore, nextPredictionId;
var init_PredictionTracking = __esm({
  "server/services/ai-agents/PredictionTracking.ts"() {
    "use strict";
    init_AdaptiveLearning();
    predictionStore = /* @__PURE__ */ new Map();
    weightHistoryStore = /* @__PURE__ */ new Map();
    nextPredictionId = 1;
  }
});

// server/services/ai-agents/BacktestComparison.ts
var BacktestComparison_exports = {};
__export(BacktestComparison_exports, {
  compareBacktests: () => compareBacktests,
  deleteBacktestRun: () => deleteBacktestRun,
  getBacktestRun: () => getBacktestRun,
  getUserBacktestRuns: () => getUserBacktestRuns,
  initializeSampleBacktests: () => initializeSampleBacktests,
  saveBacktestRun: () => saveBacktestRun
});
async function saveBacktestRun(userId, run) {
  const id = `bt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const backtestRun = {
    ...run,
    id,
    createdAt: /* @__PURE__ */ new Date()
  };
  backtestStore.set(`${userId}_${id}`, backtestRun);
  return id;
}
async function getUserBacktestRuns(userId) {
  const runs = [];
  const entries = Array.from(backtestStore.entries());
  for (const [key, run] of entries) {
    if (key.startsWith(`${userId}_`)) {
      runs.push(run);
    }
  }
  return runs.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
}
async function getBacktestRun(userId, runId) {
  return backtestStore.get(`${userId}_${runId}`) || null;
}
async function deleteBacktestRun(userId, runId) {
  return backtestStore.delete(`${userId}_${runId}`);
}
async function compareBacktests(userId, runIds) {
  const runs = [];
  for (const runId of runIds) {
    const run = await getBacktestRun(userId, runId);
    if (run) {
      runs.push(run);
    }
  }
  if (runs.length < 2) {
    throw new Error("Need at least 2 backtest runs to compare");
  }
  const metrics = calculateComparisonMetrics(runs);
  const correlationMatrix = calculateCorrelationMatrix2(runs);
  const equityCurveComparison = prepareEquityCurveComparison(runs);
  const drawdownComparison = prepareDrawdownComparison(runs);
  const monthlyComparison = prepareMonthlyComparison(runs);
  const summary = generateComparisonSummary(runs, metrics);
  return {
    runs,
    metrics,
    correlationMatrix,
    equityCurveComparison,
    drawdownComparison,
    monthlyComparison,
    summary
  };
}
function calculateComparisonMetrics(runs) {
  const metricDefinitions = [
    { key: "totalReturn", name: "Total Return", description: "Overall return percentage", higherBetter: true },
    { key: "annualizedReturn", name: "Annualized Return", description: "Return annualized over the period", higherBetter: true },
    { key: "sharpeRatio", name: "Sharpe Ratio", description: "Risk-adjusted return (higher is better)", higherBetter: true },
    { key: "maxDrawdown", name: "Max Drawdown", description: "Maximum peak-to-trough decline", higherBetter: false },
    { key: "winRate", name: "Win Rate", description: "Percentage of profitable trades", higherBetter: true },
    { key: "profitFactor", name: "Profit Factor", description: "Gross profit / Gross loss", higherBetter: true },
    { key: "volatility", name: "Volatility", description: "Standard deviation of returns", higherBetter: false },
    { key: "calmarRatio", name: "Calmar Ratio", description: "Return / Max Drawdown", higherBetter: true },
    { key: "sortinoRatio", name: "Sortino Ratio", description: "Return / Downside deviation", higherBetter: true },
    { key: "totalTrades", name: "Total Trades", description: "Number of trades executed", higherBetter: false }
  ];
  const metrics = [];
  for (const def of metricDefinitions) {
    const values = runs.map((run) => ({
      runId: run.id,
      value: run.results[def.key] || 0,
      rank: 0
    }));
    const sorted = [...values].sort(
      (a, b) => def.higherBetter ? b.value - a.value : a.value - b.value
    );
    sorted.forEach((v, i) => {
      const original = values.find((x) => x.runId === v.runId);
      if (original) original.rank = i + 1;
    });
    const winner = sorted[0].runId;
    const improvement = sorted.length > 1 ? Math.abs(sorted[0].value - sorted[1].value) / Math.abs(sorted[1].value || 1) * 100 : 0;
    metrics.push({
      metric: def.name,
      description: def.description,
      values,
      winner,
      improvement
    });
  }
  return metrics;
}
function calculateCorrelationMatrix2(runs) {
  const n = runs.length;
  const matrix = Array(n).fill(null).map(() => Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      if (i === j) {
        matrix[i][j] = 1;
      } else if (j > i) {
        const correlation2 = calculateCorrelation(
          runs[i].results.equityCurve.map((e) => e.value),
          runs[j].results.equityCurve.map((e) => e.value)
        );
        matrix[i][j] = correlation2;
        matrix[j][i] = correlation2;
      }
    }
  }
  return matrix;
}
function calculateCorrelation(x, y) {
  const n = Math.min(x.length, y.length);
  if (n < 2) return 0;
  const meanX = x.slice(0, n).reduce((a, b) => a + b, 0) / n;
  const meanY = y.slice(0, n).reduce((a, b) => a + b, 0) / n;
  let numerator = 0;
  let denomX = 0;
  let denomY = 0;
  for (let i = 0; i < n; i++) {
    const dx = x[i] - meanX;
    const dy = y[i] - meanY;
    numerator += dx * dy;
    denomX += dx * dx;
    denomY += dy * dy;
  }
  const denominator = Math.sqrt(denomX * denomY);
  return denominator === 0 ? 0 : numerator / denominator;
}
function prepareEquityCurveComparison(runs) {
  const allDates = /* @__PURE__ */ new Set();
  runs.forEach((run) => {
    run.results.equityCurve.forEach((point) => allDates.add(point.date));
  });
  const sortedDates = Array.from(allDates).sort();
  return sortedDates.map((date2) => {
    const point = { date: date2 };
    runs.forEach((run) => {
      const equity = run.results.equityCurve.find((e) => e.date === date2);
      point[run.name] = equity?.value || 0;
    });
    return point;
  });
}
function prepareDrawdownComparison(runs) {
  const allDates = /* @__PURE__ */ new Set();
  runs.forEach((run) => {
    run.results.drawdownCurve.forEach((point) => allDates.add(point.date));
  });
  const sortedDates = Array.from(allDates).sort();
  return sortedDates.map((date2) => {
    const point = { date: date2 };
    runs.forEach((run) => {
      const dd = run.results.drawdownCurve.find((d) => d.date === date2);
      point[run.name] = dd?.value || 0;
    });
    return point;
  });
}
function prepareMonthlyComparison(runs) {
  const allMonths = /* @__PURE__ */ new Set();
  runs.forEach((run) => {
    run.results.monthlyReturns.forEach((m) => allMonths.add(m.month));
  });
  const sortedMonths = Array.from(allMonths).sort();
  return sortedMonths.map((month) => {
    const point = { month };
    runs.forEach((run) => {
      const monthly = run.results.monthlyReturns.find((m) => m.month === month);
      point[run.name] = monthly?.return || 0;
    });
    return point;
  });
}
function generateComparisonSummary(runs, metrics) {
  const returnMetric = metrics.find((m) => m.metric === "Total Return");
  const sharpeMetric = metrics.find((m) => m.metric === "Sharpe Ratio");
  const drawdownMetric = metrics.find((m) => m.metric === "Max Drawdown");
  const winRateMetric = metrics.find((m) => m.metric === "Win Rate");
  const scores = runs.map((run) => {
    let score = 0;
    let weight = 0;
    const weights = {
      "Sharpe Ratio": 3,
      "Total Return": 2,
      "Max Drawdown": 2,
      "Win Rate": 1.5,
      "Profit Factor": 1.5,
      "Calmar Ratio": 1,
      "Sortino Ratio": 1
    };
    for (const metric of metrics) {
      const value = metric.values.find((v) => v.runId === run.id);
      if (value) {
        const w = weights[metric.metric] || 1;
        score += (runs.length - value.rank + 1) * w;
        weight += w;
      }
    }
    return { runId: run.id, score: score / weight };
  });
  scores.sort((a, b) => b.score - a.score);
  const recommendations = [];
  const bestRun = runs.find((r) => r.id === scores[0].runId);
  const worstRun = runs.find((r) => r.id === scores[scores.length - 1].runId);
  if (bestRun && worstRun) {
    const bestReturn = bestRun.results.totalReturn;
    const worstReturn = worstRun.results.totalReturn;
    if (bestReturn > worstReturn * 1.5) {
      recommendations.push(
        `"${bestRun.name}" significantly outperforms other configurations with ${bestReturn.toFixed(1)}% return`
      );
    }
    if (bestRun.results.maxDrawdown < worstRun.results.maxDrawdown * 0.7) {
      recommendations.push(
        `"${bestRun.name}" shows better risk management with ${bestRun.results.maxDrawdown.toFixed(1)}% max drawdown`
      );
    }
    if (bestRun.results.sharpeRatio > 1.5) {
      recommendations.push(
        `"${bestRun.name}" has excellent risk-adjusted returns (Sharpe: ${bestRun.results.sharpeRatio.toFixed(2)})`
      );
    }
  }
  const avgSharpe = runs.reduce((sum2, r) => sum2 + r.results.sharpeRatio, 0) / runs.length;
  if (avgSharpe < 1) {
    recommendations.push(
      "Consider adjusting agent weights or adding risk management rules to improve risk-adjusted returns"
    );
  }
  const avgDrawdown = runs.reduce((sum2, r) => sum2 + r.results.maxDrawdown, 0) / runs.length;
  if (avgDrawdown > 20) {
    recommendations.push(
      "High average drawdown detected. Consider implementing stop-loss rules or reducing position sizes"
    );
  }
  return {
    bestOverall: scores[0].runId,
    bestRiskAdjusted: sharpeMetric?.winner || scores[0].runId,
    lowestDrawdown: drawdownMetric?.winner || scores[0].runId,
    highestWinRate: winRateMetric?.winner || scores[0].runId,
    recommendations
  };
}
function initializeSampleBacktests(userId) {
  const existingRuns = Array.from(backtestStore.keys()).filter((k) => k.startsWith(`${userId}_`));
  if (existingRuns.length > 0) return;
  const configs = [
    { name: "Conservative Strategy", weights: { technical: 0.15, fundamental: 0.25, sentiment: 0.1, risk: 0.25, regime: 0.1, execution: 0.1, coordinator: 0.05 } },
    { name: "Aggressive Strategy", weights: { technical: 0.3, fundamental: 0.15, sentiment: 0.2, risk: 0.1, regime: 0.1, execution: 0.1, coordinator: 0.05 } },
    { name: "Balanced Strategy", weights: { technical: 0.2, fundamental: 0.2, sentiment: 0.15, risk: 0.15, regime: 0.1, execution: 0.1, coordinator: 0.1 } }
  ];
  const now = Date.now();
  const day = 24 * 60 * 60 * 1e3;
  configs.forEach((config, idx) => {
    const equityCurve = [];
    const drawdownCurve = [];
    const monthlyReturns = [];
    let equity = 1e5;
    let peak = equity;
    const baseReturn = idx === 0 ? 3e-4 : idx === 1 ? 5e-4 : 4e-4;
    const baseVol = idx === 0 ? 8e-3 : idx === 1 ? 0.015 : 0.012;
    for (let i = 365; i >= 0; i--) {
      const date2 = new Date(now - i * day).toISOString().split("T")[0];
      const dailyReturn = baseReturn + (Math.random() - 0.5) * baseVol;
      equity *= 1 + dailyReturn;
      peak = Math.max(peak, equity);
      const drawdown = (peak - equity) / peak * 100;
      equityCurve.push({ date: date2, value: equity });
      drawdownCurve.push({ date: date2, value: -drawdown });
      const month = date2.substring(0, 7);
      const existing = monthlyReturns.find((m) => m.month === month);
      if (!existing) {
        monthlyReturns.push({ month, return: dailyReturn * 100 * 20 });
      }
    }
    const totalReturn = (equity - 1e5) / 1e5 * 100;
    const maxDrawdown = Math.abs(Math.min(...drawdownCurve.map((d) => d.value)));
    const run = {
      id: `sample_${idx}`,
      name: config.name,
      symbol: "AAPL",
      startDate: new Date(now - 365 * day).toISOString().split("T")[0],
      endDate: new Date(now).toISOString().split("T")[0],
      config: {
        initialCapital: 1e5,
        transactionCost: 0.1,
        slippage: 0.05,
        useAgentWeights: true,
        rebalanceFrequency: "daily",
        agentWeights: config.weights
      },
      results: {
        totalReturn,
        annualizedReturn: totalReturn,
        sharpeRatio: totalReturn / (baseVol * Math.sqrt(252) * 100) * 2,
        maxDrawdown,
        winRate: 52 + Math.random() * 10,
        totalTrades: 150 + Math.floor(Math.random() * 100),
        profitFactor: 1.2 + Math.random() * 0.5,
        volatility: baseVol * Math.sqrt(252) * 100,
        calmarRatio: totalReturn / maxDrawdown,
        sortinoRatio: totalReturn / (baseVol * Math.sqrt(252) * 50),
        beta: 0.8 + Math.random() * 0.4,
        alpha: totalReturn * 0.3,
        informationRatio: 0.5 + Math.random() * 0.5,
        treynorRatio: totalReturn / (0.8 + Math.random() * 0.4),
        equityCurve,
        drawdownCurve,
        monthlyReturns,
        tradeLog: []
      },
      createdAt: new Date(now - idx * day * 7)
    };
    backtestStore.set(`${userId}_sample_${idx}`, run);
  });
}
var backtestStore;
var init_BacktestComparison = __esm({
  "server/services/ai-agents/BacktestComparison.ts"() {
    "use strict";
    backtestStore = /* @__PURE__ */ new Map();
  }
});

// server/services/ai-agents/WeightOptimizationWizard.ts
var WeightOptimizationWizard_exports = {};
__export(WeightOptimizationWizard_exports, {
  calculateRiskProfile: () => calculateRiskProfile,
  compareWeightConfigs: () => compareWeightConfigs,
  getOptimizedWeights: () => getOptimizedWeights,
  getPresetConfigurations: () => getPresetConfigurations,
  getUserProfile: () => getUserProfile2,
  getWizardSteps: () => getWizardSteps,
  initializeSampleProfile: () => initializeSampleProfile,
  updateUserProfile: () => updateUserProfile2
});
function getWizardSteps() {
  return [
    {
      step: 1,
      title: "Risk Assessment",
      description: "Help us understand your risk tolerance",
      questions: riskQuestionnaire
    },
    {
      step: 2,
      title: "Trading Style",
      description: "Tell us about your trading preferences",
      questions: styleQuestionnaire
    },
    {
      step: 3,
      title: "Experience Level",
      description: "Share your trading experience",
      questions: experienceQuestionnaire
    },
    {
      step: 4,
      title: "Goals & Preferences",
      description: "Define your trading goals",
      questions: goalsQuestionnaire
    }
  ];
}
function calculateRiskProfile(userId, responses) {
  const allQuestions = [
    ...riskQuestionnaire,
    ...styleQuestionnaire,
    ...experienceQuestionnaire,
    ...goalsQuestionnaire
  ];
  let riskScore = 0;
  let styleScore = 0;
  let experienceScore = 0;
  let riskCount = 0;
  let styleCount = 0;
  let experienceCount = 0;
  let marketFocus = "mixed";
  let automationPreference = "semi_auto";
  for (const response of responses) {
    const question = allQuestions.find((q) => q.id === response.questionId);
    if (!question) continue;
    const option = question.options.find((o) => o.value === response.selectedValue);
    if (!option) continue;
    if (question.category === "risk") {
      riskScore += option.weight;
      riskCount++;
    } else if (question.category === "style") {
      styleScore += option.weight;
      styleCount++;
    } else if (question.category === "experience") {
      experienceScore += option.weight;
      experienceCount++;
    } else if (question.category === "goals") {
      if (question.id === "goal_1") {
        marketFocus = response.selectedValue;
      } else if (question.id === "goal_2") {
        if (response.selectedValue === "manual") automationPreference = "manual";
        else if (response.selectedValue === "full") automationPreference = "full_auto";
        else automationPreference = "semi_auto";
      }
    }
  }
  const avgRisk = riskCount > 0 ? riskScore / riskCount : 2.5;
  const avgStyle = styleCount > 0 ? styleScore / styleCount : 2.5;
  const avgExperience = experienceCount > 0 ? experienceScore / experienceCount : 2;
  let riskTolerance;
  if (avgRisk <= 1.5) riskTolerance = "conservative";
  else if (avgRisk <= 2.5) riskTolerance = "moderate";
  else if (avgRisk <= 3.5) riskTolerance = "aggressive";
  else riskTolerance = "very_aggressive";
  let tradingStyle;
  if (avgStyle >= 3.5) tradingStyle = "day_trading";
  else if (avgStyle >= 2.5) tradingStyle = "swing_trading";
  else if (avgStyle >= 1.5) tradingStyle = "position_trading";
  else tradingStyle = "long_term_investing";
  let experienceLevel;
  if (avgExperience <= 1.5) experienceLevel = "beginner";
  else if (avgExperience <= 2.5) experienceLevel = "intermediate";
  else if (avgExperience <= 3.5) experienceLevel = "advanced";
  else experienceLevel = "expert";
  let investmentHorizon;
  if (tradingStyle === "day_trading" || tradingStyle === "swing_trading") {
    investmentHorizon = "short";
  } else if (tradingStyle === "position_trading") {
    investmentHorizon = "medium";
  } else {
    investmentHorizon = "long";
  }
  const maxDrawdownTolerance = avgRisk * 10;
  let preferredVolatility;
  if (avgRisk <= 2) preferredVolatility = "low";
  else if (avgRisk <= 3) preferredVolatility = "medium";
  else preferredVolatility = "high";
  const profile = {
    userId,
    riskTolerance,
    tradingStyle,
    marketFocus,
    experienceLevel,
    investmentHorizon,
    maxDrawdownTolerance,
    preferredVolatility,
    automationPreference,
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  };
  profileStore.set(userId, profile);
  return profile;
}
function getOptimizedWeights(profile) {
  let weights;
  let explanation;
  let warnings = [];
  let suitableFor = [];
  if (profile.riskTolerance === "conservative") {
    weights = {
      technical: 0.1,
      fundamental: 0.25,
      sentiment: 0.1,
      risk: 0.25,
      regime: 0.15,
      execution: 0.05,
      coordinator: 0.1
    };
    explanation = "Conservative weights prioritize risk management and fundamental analysis for capital preservation.";
    suitableFor = ["Capital preservation", "Steady income", "Low volatility"];
    warnings = ["May miss high-growth opportunities", "Lower potential returns"];
  } else if (profile.riskTolerance === "moderate") {
    weights = {
      technical: 0.18,
      fundamental: 0.2,
      sentiment: 0.15,
      risk: 0.18,
      regime: 0.14,
      execution: 0.07,
      coordinator: 0.08
    };
    explanation = "Balanced weights provide a mix of growth potential and risk management.";
    suitableFor = ["Balanced growth", "Moderate risk", "Diversification"];
    warnings = ["May underperform in strong bull markets"];
  } else if (profile.riskTolerance === "aggressive") {
    weights = {
      technical: 0.22,
      fundamental: 0.15,
      sentiment: 0.2,
      risk: 0.12,
      regime: 0.12,
      execution: 0.1,
      coordinator: 0.09
    };
    explanation = "Aggressive weights emphasize technical and sentiment analysis for higher returns.";
    suitableFor = ["Growth investing", "Active trading", "Higher returns"];
    warnings = ["Higher volatility expected", "Larger potential drawdowns"];
  } else {
    weights = {
      technical: 0.25,
      fundamental: 0.1,
      sentiment: 0.25,
      risk: 0.08,
      regime: 0.1,
      execution: 0.12,
      coordinator: 0.1
    };
    explanation = "Very aggressive weights maximize technical and sentiment signals for maximum returns.";
    suitableFor = ["Day trading", "Momentum trading", "High-risk/high-reward"];
    warnings = ["Significant risk of large losses", "Requires active monitoring", "Not suitable for beginners"];
  }
  if (profile.tradingStyle === "day_trading") {
    weights.technical += 0.05;
    weights.execution += 0.03;
    weights.fundamental -= 0.05;
    weights.regime -= 0.03;
  } else if (profile.tradingStyle === "long_term_investing") {
    weights.fundamental += 0.05;
    weights.regime += 0.03;
    weights.technical -= 0.05;
    weights.execution -= 0.03;
  }
  if (profile.marketFocus === "crypto") {
    weights.sentiment += 0.05;
    weights.technical += 0.03;
    weights.fundamental -= 0.05;
    weights.risk -= 0.03;
    warnings.push("Crypto markets are highly volatile");
  }
  if (profile.experienceLevel === "beginner") {
    weights.risk += 0.05;
    weights.coordinator += 0.03;
    weights.technical -= 0.05;
    weights.sentiment -= 0.03;
    warnings.push("Consider paper trading first");
  }
  const total = Object.values(weights).reduce((a, b) => a + b, 0);
  for (const key of Object.keys(weights)) {
    weights[key] = Math.max(0.05, weights[key] / total);
  }
  const newTotal = Object.values(weights).reduce((a, b) => a + b, 0);
  for (const key of Object.keys(weights)) {
    weights[key] = weights[key] / newTotal;
  }
  return {
    weights,
    explanation,
    confidence: profile.experienceLevel === "beginner" ? 0.7 : 0.85,
    riskLevel: profile.riskTolerance,
    expectedVolatility: profile.preferredVolatility,
    suitableFor,
    warnings
  };
}
function getUserProfile2(userId) {
  return profileStore.get(userId) || null;
}
function updateUserProfile2(userId, updates) {
  const profile = profileStore.get(userId);
  if (!profile) return null;
  const updatedProfile = {
    ...profile,
    ...updates,
    updatedAt: /* @__PURE__ */ new Date()
  };
  profileStore.set(userId, updatedProfile);
  return updatedProfile;
}
function compareWeightConfigs(config1, config2) {
  const differences = {};
  let totalDiff = 0;
  for (const key of Object.keys(config1)) {
    const diff = Math.abs(config1[key] - config2[key]);
    differences[key] = diff;
    totalDiff += diff;
  }
  let recommendation;
  if (totalDiff < 0.1) {
    recommendation = "Configurations are very similar. Minor adjustments only.";
  } else if (totalDiff < 0.3) {
    recommendation = "Moderate differences. Consider gradual transition.";
  } else {
    recommendation = "Significant differences. Test with paper trading first.";
  }
  return {
    differences,
    totalDifference: totalDiff,
    recommendation
  };
}
function getPresetConfigurations() {
  return [
    {
      name: "Conservative Income",
      description: "Focus on capital preservation and steady income",
      weights: {
        technical: 0.1,
        fundamental: 0.3,
        sentiment: 0.08,
        risk: 0.25,
        regime: 0.12,
        execution: 0.05,
        coordinator: 0.1
      },
      riskLevel: "conservative"
    },
    {
      name: "Balanced Growth",
      description: "Mix of growth and stability",
      weights: {
        technical: 0.18,
        fundamental: 0.2,
        sentiment: 0.15,
        risk: 0.18,
        regime: 0.14,
        execution: 0.07,
        coordinator: 0.08
      },
      riskLevel: "moderate"
    },
    {
      name: "Aggressive Growth",
      description: "Maximize returns with higher risk",
      weights: {
        technical: 0.22,
        fundamental: 0.12,
        sentiment: 0.22,
        risk: 0.1,
        regime: 0.12,
        execution: 0.12,
        coordinator: 0.1
      },
      riskLevel: "aggressive"
    },
    {
      name: "Day Trader",
      description: "Optimized for short-term trading",
      weights: {
        technical: 0.28,
        fundamental: 0.05,
        sentiment: 0.25,
        risk: 0.1,
        regime: 0.08,
        execution: 0.14,
        coordinator: 0.1
      },
      riskLevel: "very_aggressive"
    },
    {
      name: "Crypto Focus",
      description: "Tailored for cryptocurrency markets",
      weights: {
        technical: 0.25,
        fundamental: 0.08,
        sentiment: 0.28,
        risk: 0.12,
        regime: 0.1,
        execution: 0.1,
        coordinator: 0.07
      },
      riskLevel: "aggressive"
    },
    {
      name: "Value Investor",
      description: "Long-term fundamental approach",
      weights: {
        technical: 0.08,
        fundamental: 0.35,
        sentiment: 0.1,
        risk: 0.18,
        regime: 0.15,
        execution: 0.04,
        coordinator: 0.1
      },
      riskLevel: "moderate"
    }
  ];
}
function initializeSampleProfile(userId) {
  const profile = {
    userId,
    riskTolerance: "moderate",
    tradingStyle: "swing_trading",
    marketFocus: "mixed",
    experienceLevel: "intermediate",
    investmentHorizon: "medium",
    maxDrawdownTolerance: 20,
    preferredVolatility: "medium",
    automationPreference: "semi_auto",
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  };
  profileStore.set(userId, profile);
  return profile;
}
var riskQuestionnaire, styleQuestionnaire, experienceQuestionnaire, goalsQuestionnaire, profileStore;
var init_WeightOptimizationWizard = __esm({
  "server/services/ai-agents/WeightOptimizationWizard.ts"() {
    "use strict";
    riskQuestionnaire = [
      {
        id: "risk_1",
        category: "risk",
        question: "How would you react if your portfolio dropped 20% in a week?",
        options: [
          { value: "sell_all", label: "Sell everything immediately", description: "Cut losses and exit", weight: 1 },
          { value: "sell_some", label: "Sell some positions", description: "Reduce exposure", weight: 2 },
          { value: "hold", label: "Hold and wait", description: "Wait for recovery", weight: 3 },
          { value: "buy_more", label: "Buy more at lower prices", description: "Opportunity to average down", weight: 4 }
        ]
      },
      {
        id: "risk_2",
        category: "risk",
        question: "What is your primary investment goal?",
        options: [
          { value: "preserve", label: "Preserve capital", description: "Minimize losses", weight: 1 },
          { value: "income", label: "Generate steady income", description: "Dividends and interest", weight: 2 },
          { value: "growth", label: "Grow wealth over time", description: "Long-term appreciation", weight: 3 },
          { value: "maximize", label: "Maximize returns", description: "Aggressive growth", weight: 4 }
        ]
      },
      {
        id: "risk_3",
        category: "risk",
        question: "What percentage of your portfolio can you afford to lose?",
        options: [
          { value: "5", label: "Up to 5%", description: "Very low risk tolerance", weight: 1 },
          { value: "15", label: "Up to 15%", description: "Low risk tolerance", weight: 2 },
          { value: "30", label: "Up to 30%", description: "Moderate risk tolerance", weight: 3 },
          { value: "50", label: "More than 30%", description: "High risk tolerance", weight: 4 }
        ]
      }
    ];
    styleQuestionnaire = [
      {
        id: "style_1",
        category: "style",
        question: "How often do you plan to trade?",
        options: [
          { value: "daily", label: "Multiple times per day", description: "Day trading", weight: 4 },
          { value: "weekly", label: "Several times per week", description: "Swing trading", weight: 3 },
          { value: "monthly", label: "A few times per month", description: "Position trading", weight: 2 },
          { value: "rarely", label: "Rarely (buy and hold)", description: "Long-term investing", weight: 1 }
        ]
      },
      {
        id: "style_2",
        category: "style",
        question: "Which analysis method do you prefer?",
        options: [
          { value: "technical", label: "Technical analysis", description: "Charts and indicators", weight: 4 },
          { value: "fundamental", label: "Fundamental analysis", description: "Company financials", weight: 2 },
          { value: "both", label: "Both equally", description: "Balanced approach", weight: 3 },
          { value: "ai", label: "AI-driven decisions", description: "Let AI decide", weight: 3 }
        ]
      },
      {
        id: "style_3",
        category: "style",
        question: "What is your preferred holding period?",
        options: [
          { value: "minutes", label: "Minutes to hours", description: "Intraday", weight: 4 },
          { value: "days", label: "Days to weeks", description: "Short-term", weight: 3 },
          { value: "months", label: "Weeks to months", description: "Medium-term", weight: 2 },
          { value: "years", label: "Months to years", description: "Long-term", weight: 1 }
        ]
      }
    ];
    experienceQuestionnaire = [
      {
        id: "exp_1",
        category: "experience",
        question: "How long have you been trading?",
        options: [
          { value: "new", label: "Less than 1 year", description: "Beginner", weight: 1 },
          { value: "1-3", label: "1-3 years", description: "Some experience", weight: 2 },
          { value: "3-5", label: "3-5 years", description: "Experienced", weight: 3 },
          { value: "5+", label: "More than 5 years", description: "Expert", weight: 4 }
        ]
      },
      {
        id: "exp_2",
        category: "experience",
        question: "How familiar are you with technical indicators?",
        options: [
          { value: "none", label: "Not familiar at all", description: "Never used them", weight: 1 },
          { value: "basic", label: "Know the basics", description: "RSI, MACD, etc.", weight: 2 },
          { value: "intermediate", label: "Use them regularly", description: "Multiple indicators", weight: 3 },
          { value: "advanced", label: "Expert level", description: "Custom strategies", weight: 4 }
        ]
      }
    ];
    goalsQuestionnaire = [
      {
        id: "goal_1",
        category: "goals",
        question: "What markets are you most interested in?",
        options: [
          { value: "stocks", label: "Stocks only", description: "Traditional equities", weight: 2 },
          { value: "crypto", label: "Cryptocurrency only", description: "Digital assets", weight: 4 },
          { value: "forex", label: "Forex only", description: "Currency pairs", weight: 3 },
          { value: "mixed", label: "Multiple markets", description: "Diversified", weight: 3 }
        ]
      },
      {
        id: "goal_2",
        category: "goals",
        question: "How much automation do you want?",
        options: [
          { value: "manual", label: "Manual trading", description: "I make all decisions", weight: 1 },
          { value: "signals", label: "AI signals only", description: "I execute trades", weight: 2 },
          { value: "semi", label: "Semi-automated", description: "AI suggests, I approve", weight: 3 },
          { value: "full", label: "Fully automated", description: "AI handles everything", weight: 4 }
        ]
      }
    ];
    profileStore = /* @__PURE__ */ new Map();
  }
});

// server/services/ai-agents/PredictionAlerts.ts
var PredictionAlerts_exports = {};
__export(PredictionAlerts_exports, {
  acknowledgeAlert: () => acknowledgeAlert,
  checkPricesAndTriggerAlerts: () => checkPricesAndTriggerAlerts,
  createAlert: () => createAlert,
  createBulkAlerts: () => createBulkAlerts,
  deleteAlert: () => deleteAlert,
  getAlertStatistics: () => getAlertStatistics,
  getAlertSummary: () => getAlertSummary2,
  getUserAlerts: () => getUserAlerts,
  initializeSampleAlerts: () => initializeSampleAlerts,
  updateAlert: () => updateAlert
});
async function createAlert(config) {
  const id = nextAlertId++;
  let triggerCondition = "";
  let priority = "medium";
  if (config.targetPrice && config.stopLossPrice) {
    triggerCondition = `Price reaches $${config.targetPrice} (target) or $${config.stopLossPrice} (stop-loss)`;
    priority = "high";
  } else if (config.targetPrice) {
    triggerCondition = `Price reaches target of $${config.targetPrice}`;
    priority = "medium";
  } else if (config.stopLossPrice) {
    triggerCondition = `Price falls to stop-loss of $${config.stopLossPrice}`;
    priority = "high";
  } else if (config.trailingStopPct) {
    triggerCondition = `Trailing stop of ${config.trailingStopPct}% triggered`;
    priority = "high";
  } else if (config.breakoutThresholdPct) {
    triggerCondition = `Price breaks out by ${config.breakoutThresholdPct}%`;
    priority = "medium";
  }
  const alert = {
    id,
    userId: config.userId,
    predictionId: config.predictionId,
    symbol: config.symbol,
    alertType: config.targetPrice ? "target_reached" : "stop_loss_triggered",
    priority,
    status: "pending",
    targetPrice: config.targetPrice,
    stopLossPrice: config.stopLossPrice,
    triggerCondition,
    message: `Alert set for ${config.symbol}: ${triggerCondition}`,
    channels: config.channels || ["in_app"],
    createdAt: /* @__PURE__ */ new Date(),
    expiresAt: config.expiresInHours ? new Date(Date.now() + config.expiresInHours * 60 * 60 * 1e3) : void 0
  };
  alertStore.set(id, alert);
  const userConfigs2 = alertConfigStore.get(config.userId) || [];
  userConfigs2.push(config);
  alertConfigStore.set(config.userId, userConfigs2);
  return alert;
}
async function checkPricesAndTriggerAlerts(priceChecks) {
  const triggeredAlerts = [];
  const priceMap = new Map(priceChecks.map((p) => [p.symbol, p]));
  for (const [alertId, alert] of Array.from(alertStore.entries())) {
    if (alert.status !== "pending") continue;
    if (alert.expiresAt && /* @__PURE__ */ new Date() > alert.expiresAt) {
      alert.status = "expired";
      continue;
    }
    const priceData = priceMap.get(alert.symbol);
    if (!priceData) continue;
    const currentPrice = priceData.currentPrice;
    alert.currentPrice = currentPrice;
    let shouldTrigger = false;
    let alertType = alert.alertType;
    let message = "";
    if (alert.targetPrice && currentPrice >= alert.targetPrice) {
      shouldTrigger = true;
      alertType = "target_reached";
      message = `\u{1F3AF} Target reached! ${alert.symbol} hit $${currentPrice.toFixed(2)} (target: $${alert.targetPrice.toFixed(2)})`;
    }
    if (alert.stopLossPrice && currentPrice <= alert.stopLossPrice) {
      shouldTrigger = true;
      alertType = "stop_loss_triggered";
      message = `\u26A0\uFE0F Stop-loss triggered! ${alert.symbol} fell to $${currentPrice.toFixed(2)} (stop: $${alert.stopLossPrice.toFixed(2)})`;
    }
    if (priceData.volatility > 0.05) {
      const volatilityAlert = createVolatilityAlert(alert.userId, alert.symbol, priceData.volatility);
      triggeredAlerts.push(volatilityAlert);
    }
    if (shouldTrigger) {
      alert.status = "triggered";
      alert.alertType = alertType;
      alert.message = message;
      alert.triggeredAt = /* @__PURE__ */ new Date();
      triggeredAlerts.push(alert);
    }
  }
  return triggeredAlerts;
}
function createVolatilityAlert(userId, symbol, volatility) {
  const id = nextAlertId++;
  const alert = {
    id,
    userId,
    predictionId: 0,
    symbol,
    alertType: "volatility_spike",
    priority: volatility > 0.1 ? "critical" : "high",
    status: "triggered",
    triggerCondition: `Volatility exceeded ${(volatility * 100).toFixed(1)}%`,
    message: `\u{1F4CA} High volatility detected! ${symbol} showing ${(volatility * 100).toFixed(1)}% volatility`,
    channels: ["in_app"],
    createdAt: /* @__PURE__ */ new Date(),
    triggeredAt: /* @__PURE__ */ new Date()
  };
  alertStore.set(id, alert);
  return alert;
}
async function getUserAlerts(userId, options = {}) {
  let alerts = Array.from(alertStore.values()).filter((a) => a.userId === userId);
  if (options.status) {
    alerts = alerts.filter((a) => a.status === options.status);
  }
  if (options.type) {
    alerts = alerts.filter((a) => a.alertType === options.type);
  }
  alerts.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  if (options.limit) {
    alerts = alerts.slice(0, options.limit);
  }
  return alerts;
}
async function getAlertSummary2(userId) {
  const alerts = Array.from(alertStore.values()).filter((a) => a.userId === userId);
  const today = /* @__PURE__ */ new Date();
  today.setHours(0, 0, 0, 0);
  const summary = {
    totalAlerts: alerts.length,
    pendingAlerts: alerts.filter((a) => a.status === "pending").length,
    triggeredToday: alerts.filter(
      (a) => a.status === "triggered" && a.triggeredAt && a.triggeredAt >= today
    ).length,
    acknowledgedAlerts: alerts.filter((a) => a.status === "acknowledged").length,
    expiredAlerts: alerts.filter((a) => a.status === "expired").length,
    byType: {
      target_reached: alerts.filter((a) => a.alertType === "target_reached").length,
      stop_loss_triggered: alerts.filter((a) => a.alertType === "stop_loss_triggered").length,
      price_breakout: alerts.filter((a) => a.alertType === "price_breakout").length,
      trend_reversal: alerts.filter((a) => a.alertType === "trend_reversal").length,
      volatility_spike: alerts.filter((a) => a.alertType === "volatility_spike").length
    },
    byPriority: {
      low: alerts.filter((a) => a.priority === "low").length,
      medium: alerts.filter((a) => a.priority === "medium").length,
      high: alerts.filter((a) => a.priority === "high").length,
      critical: alerts.filter((a) => a.priority === "critical").length
    },
    recentAlerts: alerts.filter((a) => a.status === "triggered").sort((a, b) => (b.triggeredAt?.getTime() || 0) - (a.triggeredAt?.getTime() || 0)).slice(0, 5)
  };
  return summary;
}
async function acknowledgeAlert(alertId, userId) {
  const alert = alertStore.get(alertId);
  if (!alert || alert.userId !== userId) {
    return false;
  }
  alert.status = "acknowledged";
  alert.acknowledgedAt = /* @__PURE__ */ new Date();
  return true;
}
async function deleteAlert(alertId, userId) {
  const alert = alertStore.get(alertId);
  if (!alert || alert.userId !== userId) {
    return false;
  }
  alertStore.delete(alertId);
  return true;
}
async function updateAlert(alertId, userId, updates) {
  const alert = alertStore.get(alertId);
  if (!alert || alert.userId !== userId || alert.status !== "pending") {
    return null;
  }
  if (updates.targetPrice !== void 0) {
    alert.targetPrice = updates.targetPrice;
  }
  if (updates.stopLossPrice !== void 0) {
    alert.stopLossPrice = updates.stopLossPrice;
  }
  if (updates.channels !== void 0) {
    alert.channels = updates.channels;
  }
  if (updates.expiresAt !== void 0) {
    alert.expiresAt = updates.expiresAt;
  }
  if (alert.targetPrice && alert.stopLossPrice) {
    alert.triggerCondition = `Price reaches $${alert.targetPrice} (target) or $${alert.stopLossPrice} (stop-loss)`;
  } else if (alert.targetPrice) {
    alert.triggerCondition = `Price reaches target of $${alert.targetPrice}`;
  } else if (alert.stopLossPrice) {
    alert.triggerCondition = `Price falls to stop-loss of $${alert.stopLossPrice}`;
  }
  return alert;
}
async function createBulkAlerts(configs) {
  const alerts = [];
  for (const config of configs) {
    const alert = await createAlert(config);
    alerts.push(alert);
  }
  return alerts;
}
async function getAlertStatistics(userId, days = 30) {
  const cutoffDate = /* @__PURE__ */ new Date();
  cutoffDate.setDate(cutoffDate.getDate() - days);
  const alerts = Array.from(alertStore.values()).filter((a) => a.userId === userId && a.createdAt >= cutoffDate);
  const triggered = alerts.filter((a) => a.status === "triggered");
  const targetHits = triggered.filter((a) => a.alertType === "target_reached");
  const stopLossHits = triggered.filter((a) => a.alertType === "stop_loss_triggered");
  let totalTriggerTime = 0;
  let triggerCount = 0;
  for (const alert of triggered) {
    if (alert.triggeredAt) {
      totalTriggerTime += alert.triggeredAt.getTime() - alert.createdAt.getTime();
      triggerCount++;
    }
  }
  const symbolCounts = /* @__PURE__ */ new Map();
  for (const alert of alerts) {
    const count2 = symbolCounts.get(alert.symbol) || 0;
    symbolCounts.set(alert.symbol, count2 + 1);
  }
  const mostAlertedSymbols = Array.from(symbolCounts.entries()).map(([symbol, count2]) => ({ symbol, count: count2 })).sort((a, b) => b.count - a.count).slice(0, 5);
  return {
    totalCreated: alerts.length,
    totalTriggered: triggered.length,
    targetHitRate: alerts.length > 0 ? targetHits.length / alerts.length : 0,
    stopLossHitRate: alerts.length > 0 ? stopLossHits.length / alerts.length : 0,
    averageTimeToTrigger: triggerCount > 0 ? totalTriggerTime / triggerCount / (1e3 * 60 * 60) : 0,
    // in hours
    mostAlertedSymbols
  };
}
function initializeSampleAlerts(userId) {
  const sampleConfigs = [
    {
      userId,
      predictionId: 1,
      symbol: "AAPL",
      targetPrice: 200,
      stopLossPrice: 170,
      channels: ["in_app", "email"],
      expiresInHours: 168
      // 1 week
    },
    {
      userId,
      predictionId: 2,
      symbol: "GOOGL",
      targetPrice: 180,
      channels: ["in_app"],
      expiresInHours: 72
    },
    {
      userId,
      predictionId: 3,
      symbol: "MSFT",
      stopLossPrice: 380,
      channels: ["in_app", "push"],
      expiresInHours: 48
    }
  ];
  for (const config of sampleConfigs) {
    createAlert(config);
  }
  const triggeredAlert = {
    id: nextAlertId++,
    userId,
    predictionId: 4,
    symbol: "NVDA",
    alertType: "target_reached",
    priority: "high",
    status: "triggered",
    targetPrice: 500,
    currentPrice: 502.5,
    triggerCondition: "Price reaches target of $500",
    message: "\u{1F3AF} Target reached! NVDA hit $502.50 (target: $500.00)",
    channels: ["in_app"],
    createdAt: new Date(Date.now() - 24 * 60 * 60 * 1e3),
    triggeredAt: new Date(Date.now() - 2 * 60 * 60 * 1e3)
  };
  alertStore.set(triggeredAlert.id, triggeredAlert);
}
var alertStore, alertConfigStore, nextAlertId;
var init_PredictionAlerts = __esm({
  "server/services/ai-agents/PredictionAlerts.ts"() {
    "use strict";
    alertStore = /* @__PURE__ */ new Map();
    alertConfigStore = /* @__PURE__ */ new Map();
    nextAlertId = 1;
  }
});

// server/services/ai-agents/BacktestExport.ts
var BacktestExport_exports = {};
__export(BacktestExport_exports, {
  createExportData: () => createExportData,
  generateCSVExport: () => generateCSVExport,
  generatePDFContent: () => generatePDFContent,
  generateSampleExportData: () => generateSampleExportData,
  getExportFileName: () => getExportFileName
});
function generateCSVExport(data, options = {
  includeTradeDetails: true,
  includeAgentWeights: true,
  delimiter: ",",
  dateFormat: "ISO"
}) {
  const d = options.delimiter;
  const lines = [];
  lines.push(`# TradoVerse Backtest Report`);
  lines.push(`# Generated: ${formatDate(data.generatedAt, options.dateFormat)}`);
  lines.push(`# Title: ${data.title}`);
  lines.push("");
  lines.push("## BACKTEST SUMMARY");
  lines.push([
    "Backtest ID",
    "Name",
    "Symbol",
    "Start Date",
    "End Date",
    "Initial Capital",
    "Final Value",
    "Total Return %",
    "Annualized Return %",
    "Sharpe Ratio",
    "Max Drawdown %",
    "Win Rate %",
    "Total Trades",
    "Profit Factor"
  ].join(d));
  for (const bt of data.backtests) {
    lines.push([
      bt.id,
      bt.name,
      bt.symbol,
      formatDate(bt.startDate, options.dateFormat),
      formatDate(bt.endDate, options.dateFormat),
      bt.initialCapital.toFixed(2),
      bt.finalValue.toFixed(2),
      (bt.totalReturn * 100).toFixed(2),
      (bt.annualizedReturn * 100).toFixed(2),
      bt.sharpeRatio.toFixed(3),
      (bt.maxDrawdown * 100).toFixed(2),
      (bt.winRate * 100).toFixed(2),
      bt.totalTrades.toString(),
      bt.profitFactor.toFixed(2)
    ].join(d));
  }
  lines.push("");
  if (options.includeAgentWeights) {
    lines.push("## AGENT WEIGHTS");
    const agents = ["technical", "fundamental", "sentiment", "risk", "regime", "execution", "coordinator"];
    lines.push(["Backtest ID", ...agents.map((a) => `${a} %`)].join(d));
    for (const bt of data.backtests) {
      const weights = agents.map((a) => ((bt.agentWeights[a] || 0) * 100).toFixed(1));
      lines.push([bt.id, ...weights].join(d));
    }
    lines.push("");
  }
  if (data.comparison) {
    lines.push("## COMPARISON RESULTS");
    lines.push(`Best Performer: ${data.comparison.bestPerformer}`);
    lines.push(`Recommendation: ${data.comparison.recommendation}`);
    lines.push("");
    lines.push("### Metric Comparison");
    lines.push(["Metric", ...data.backtests.map((bt) => bt.name), "Winner"].join(d));
    for (const metric of data.comparison.metrics) {
      const values = data.backtests.map((bt) => {
        const mv = metric.values.find((v) => v.backtestId === bt.id);
        return mv ? mv.value.toFixed(4) : "N/A";
      });
      lines.push([metric.metric, ...values, metric.winner].join(d));
    }
    lines.push("");
  }
  if (options.includeTradeDetails) {
    lines.push("## TRADE DETAILS");
    for (const bt of data.backtests) {
      lines.push(`### ${bt.name} (${bt.id})`);
      lines.push(["Date", "Symbol", "Side", "Quantity", "Price", "Value", "P&L", "P&L %"].join(d));
      for (const trade of bt.trades) {
        lines.push([
          formatDate(trade.date, options.dateFormat),
          trade.symbol,
          trade.side.toUpperCase(),
          trade.quantity.toString(),
          trade.price.toFixed(2),
          trade.value.toFixed(2),
          trade.pnl !== void 0 ? trade.pnl.toFixed(2) : "",
          trade.pnlPct !== void 0 ? (trade.pnlPct * 100).toFixed(2) : ""
        ].join(d));
      }
      lines.push("");
    }
  }
  lines.push("## DISCLAIMER");
  lines.push(data.metadata.disclaimer);
  return lines.join("\n");
}
function generatePDFContent(data, options = {
  includeCharts: true,
  includeTradeLog: true,
  includeDisclaimer: true,
  paperSize: "A4",
  orientation: "portrait"
}) {
  const html = [];
  html.push(`<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${data.title}</title>
  <style>
    @page {
      size: ${options.paperSize} ${options.orientation};
      margin: 1cm;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 10pt;
      line-height: 1.4;
      color: #333;
      max-width: 100%;
    }
    .header {
      text-align: center;
      border-bottom: 2px solid #22c55e;
      padding-bottom: 15px;
      margin-bottom: 20px;
    }
    .header h1 {
      color: #22c55e;
      margin: 0;
      font-size: 24pt;
    }
    .header .subtitle {
      color: #666;
      font-size: 10pt;
    }
    .section {
      margin-bottom: 20px;
      page-break-inside: avoid;
    }
    .section h2 {
      color: #22c55e;
      border-bottom: 1px solid #ddd;
      padding-bottom: 5px;
      font-size: 14pt;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
      font-size: 9pt;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px 8px;
      text-align: left;
    }
    th {
      background-color: #f8f9fa;
      font-weight: 600;
    }
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    .metric-positive {
      color: #22c55e;
      font-weight: 600;
    }
    .metric-negative {
      color: #ef4444;
      font-weight: 600;
    }
    .winner-badge {
      background-color: #22c55e;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 8pt;
    }
    .disclaimer {
      background-color: #f8f9fa;
      border: 1px solid #ddd;
      padding: 10px;
      font-size: 8pt;
      color: #666;
      margin-top: 20px;
    }
    .summary-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      margin: 15px 0;
    }
    .summary-card {
      background: #f8f9fa;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      text-align: center;
    }
    .summary-card .value {
      font-size: 18pt;
      font-weight: 700;
      color: #22c55e;
    }
    .summary-card .label {
      font-size: 8pt;
      color: #666;
    }
    .chart-placeholder {
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border: 1px dashed #ddd;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      color: #999;
    }
  </style>
</head>
<body>`);
  html.push(`
  <div class="header">
    <h1>\u{1F4CA} ${data.title}</h1>
    <div class="subtitle">
      Generated by ${data.metadata.platform}<br>
      ${formatDate(data.generatedAt, "US")}
    </div>
  </div>`);
  if (data.backtests.length > 0) {
    const best = data.backtests.reduce(
      (a, b) => a.totalReturn > b.totalReturn ? a : b
    );
    html.push(`
  <div class="section">
    <h2>Executive Summary</h2>
    <div class="summary-grid">
      <div class="summary-card">
        <div class="value">${data.backtests.length}</div>
        <div class="label">Backtests Compared</div>
      </div>
      <div class="summary-card">
        <div class="value">${(best.totalReturn * 100).toFixed(1)}%</div>
        <div class="label">Best Return</div>
      </div>
      <div class="summary-card">
        <div class="value">${best.sharpeRatio.toFixed(2)}</div>
        <div class="label">Best Sharpe Ratio</div>
      </div>
      <div class="summary-card">
        <div class="value">${best.name}</div>
        <div class="label">Top Performer</div>
      </div>
    </div>
  </div>`);
  }
  html.push(`
  <div class="section">
    <h2>Backtest Performance</h2>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Symbol</th>
          <th>Period</th>
          <th>Return</th>
          <th>Sharpe</th>
          <th>Max DD</th>
          <th>Win Rate</th>
          <th>Trades</th>
        </tr>
      </thead>
      <tbody>`);
  for (const bt of data.backtests) {
    const returnClass = bt.totalReturn >= 0 ? "metric-positive" : "metric-negative";
    html.push(`
        <tr>
          <td><strong>${bt.name}</strong></td>
          <td>${bt.symbol}</td>
          <td>${formatDate(bt.startDate, "US")} - ${formatDate(bt.endDate, "US")}</td>
          <td class="${returnClass}">${(bt.totalReturn * 100).toFixed(2)}%</td>
          <td>${bt.sharpeRatio.toFixed(2)}</td>
          <td class="metric-negative">${(bt.maxDrawdown * 100).toFixed(2)}%</td>
          <td>${(bt.winRate * 100).toFixed(1)}%</td>
          <td>${bt.totalTrades}</td>
        </tr>`);
  }
  html.push(`
      </tbody>
    </table>
  </div>`);
  html.push(`
  <div class="section">
    <h2>Agent Weight Configuration</h2>
    <table>
      <thead>
        <tr>
          <th>Backtest</th>
          <th>Technical</th>
          <th>Fundamental</th>
          <th>Sentiment</th>
          <th>Risk</th>
          <th>Regime</th>
          <th>Execution</th>
          <th>Coordinator</th>
        </tr>
      </thead>
      <tbody>`);
  for (const bt of data.backtests) {
    const w = bt.agentWeights;
    html.push(`
        <tr>
          <td><strong>${bt.name}</strong></td>
          <td>${((w.technical || 0) * 100).toFixed(1)}%</td>
          <td>${((w.fundamental || 0) * 100).toFixed(1)}%</td>
          <td>${((w.sentiment || 0) * 100).toFixed(1)}%</td>
          <td>${((w.risk || 0) * 100).toFixed(1)}%</td>
          <td>${((w.regime || 0) * 100).toFixed(1)}%</td>
          <td>${((w.execution || 0) * 100).toFixed(1)}%</td>
          <td>${((w.coordinator || 0) * 100).toFixed(1)}%</td>
        </tr>`);
  }
  html.push(`
      </tbody>
    </table>
  </div>`);
  if (data.comparison) {
    html.push(`
  <div class="section">
    <h2>Comparison Analysis</h2>
    <p><strong>Best Overall Performer:</strong> ${data.comparison.bestPerformer}</p>
    <p><strong>Recommendation:</strong> ${data.comparison.recommendation}</p>
    
    <h3>Metric-by-Metric Comparison</h3>
    <table>
      <thead>
        <tr>
          <th>Metric</th>
          ${data.backtests.map((bt) => `<th>${bt.name}</th>`).join("")}
          <th>Winner</th>
        </tr>
      </thead>
      <tbody>`);
    for (const metric of data.comparison.metrics) {
      html.push(`
        <tr>
          <td><strong>${metric.metric}</strong></td>`);
      for (const bt of data.backtests) {
        const mv = metric.values.find((v) => v.backtestId === bt.id);
        const isWinner = metric.winner === bt.id;
        html.push(`
          <td${isWinner ? ' class="metric-positive"' : ""}>${mv ? mv.value.toFixed(4) : "N/A"}</td>`);
      }
      const winnerBt = data.backtests.find((bt) => bt.id === metric.winner);
      html.push(`
          <td><span class="winner-badge">${winnerBt?.name || metric.winner}</span></td>
        </tr>`);
    }
    html.push(`
      </tbody>
    </table>
  </div>`);
  }
  if (options.includeTradeLog && data.backtests.some((bt) => bt.trades.length > 0)) {
    html.push(`
  <div class="section">
    <h2>Trade Log</h2>`);
    for (const bt of data.backtests) {
      if (bt.trades.length === 0) continue;
      html.push(`
    <h3>${bt.name}</h3>
    <table>
      <thead>
        <tr>
          <th>Date</th>
          <th>Symbol</th>
          <th>Side</th>
          <th>Qty</th>
          <th>Price</th>
          <th>Value</th>
          <th>P&L</th>
        </tr>
      </thead>
      <tbody>`);
      for (const trade of bt.trades.slice(0, 20)) {
        const pnlClass = (trade.pnl || 0) >= 0 ? "metric-positive" : "metric-negative";
        html.push(`
        <tr>
          <td>${formatDate(trade.date, "US")}</td>
          <td>${trade.symbol}</td>
          <td>${trade.side.toUpperCase()}</td>
          <td>${trade.quantity}</td>
          <td>$${trade.price.toFixed(2)}</td>
          <td>$${trade.value.toFixed(2)}</td>
          <td class="${pnlClass}">${trade.pnl !== void 0 ? `$${trade.pnl.toFixed(2)}` : "-"}</td>
        </tr>`);
      }
      if (bt.trades.length > 20) {
        html.push(`
        <tr>
          <td colspan="7" style="text-align: center; font-style: italic;">
            ... and ${bt.trades.length - 20} more trades
          </td>
        </tr>`);
      }
      html.push(`
      </tbody>
    </table>`);
    }
    html.push(`
  </div>`);
  }
  if (options.includeDisclaimer) {
    html.push(`
  <div class="disclaimer">
    <strong>Disclaimer:</strong> ${data.metadata.disclaimer}
  </div>`);
  }
  html.push(`
</body>
</html>`);
  return html.join("");
}
function formatDate(date2, format) {
  if (format === "ISO") {
    return date2.toISOString().split("T")[0];
  } else if (format === "US") {
    return date2.toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric"
    });
  } else {
    return date2.toLocaleDateString("en-GB", {
      year: "numeric",
      month: "short",
      day: "numeric"
    });
  }
}
function createExportData(title, userId, backtests2, comparison) {
  return {
    title,
    generatedAt: /* @__PURE__ */ new Date(),
    userId,
    backtests: backtests2,
    comparison,
    metadata: DEFAULT_METADATA
  };
}
function generateSampleExportData(userId) {
  const backtests2 = [
    {
      id: "bt_001",
      name: "Conservative Strategy",
      symbol: "AAPL",
      startDate: /* @__PURE__ */ new Date("2024-01-01"),
      endDate: /* @__PURE__ */ new Date("2024-12-01"),
      initialCapital: 1e5,
      finalValue: 112500,
      totalReturn: 0.125,
      annualizedReturn: 0.136,
      sharpeRatio: 1.45,
      maxDrawdown: 0.08,
      winRate: 0.62,
      totalTrades: 45,
      profitFactor: 1.8,
      agentWeights: {
        technical: 0.15,
        fundamental: 0.25,
        sentiment: 0.1,
        risk: 0.2,
        regime: 0.15,
        execution: 0.05,
        coordinator: 0.1
      },
      trades: [
        { date: /* @__PURE__ */ new Date("2024-01-15"), symbol: "AAPL", side: "buy", quantity: 50, price: 185.5, value: 9275, pnl: void 0, pnlPct: void 0 },
        { date: /* @__PURE__ */ new Date("2024-02-20"), symbol: "AAPL", side: "sell", quantity: 50, price: 192.3, value: 9615, pnl: 340, pnlPct: 0.0367 },
        { date: /* @__PURE__ */ new Date("2024-03-10"), symbol: "AAPL", side: "buy", quantity: 60, price: 188.2, value: 11292, pnl: void 0, pnlPct: void 0 },
        { date: /* @__PURE__ */ new Date("2024-04-15"), symbol: "AAPL", side: "sell", quantity: 60, price: 195.8, value: 11748, pnl: 456, pnlPct: 0.0404 }
      ]
    },
    {
      id: "bt_002",
      name: "Aggressive Strategy",
      symbol: "AAPL",
      startDate: /* @__PURE__ */ new Date("2024-01-01"),
      endDate: /* @__PURE__ */ new Date("2024-12-01"),
      initialCapital: 1e5,
      finalValue: 128e3,
      totalReturn: 0.28,
      annualizedReturn: 0.305,
      sharpeRatio: 1.12,
      maxDrawdown: 0.18,
      winRate: 0.55,
      totalTrades: 120,
      profitFactor: 1.5,
      agentWeights: {
        technical: 0.25,
        fundamental: 0.1,
        sentiment: 0.25,
        risk: 0.1,
        regime: 0.1,
        execution: 0.12,
        coordinator: 0.08
      },
      trades: [
        { date: /* @__PURE__ */ new Date("2024-01-05"), symbol: "AAPL", side: "buy", quantity: 100, price: 182.5, value: 18250, pnl: void 0, pnlPct: void 0 },
        { date: /* @__PURE__ */ new Date("2024-01-12"), symbol: "AAPL", side: "sell", quantity: 100, price: 188.9, value: 18890, pnl: 640, pnlPct: 0.0351 },
        { date: /* @__PURE__ */ new Date("2024-01-20"), symbol: "AAPL", side: "buy", quantity: 120, price: 185.3, value: 22236, pnl: void 0, pnlPct: void 0 },
        { date: /* @__PURE__ */ new Date("2024-01-28"), symbol: "AAPL", side: "sell", quantity: 120, price: 191.5, value: 22980, pnl: 744, pnlPct: 0.0335 }
      ]
    }
  ];
  const comparison = {
    metrics: [
      {
        metric: "Total Return",
        values: [
          { backtestId: "bt_001", value: 0.125 },
          { backtestId: "bt_002", value: 0.28 }
        ],
        winner: "bt_002"
      },
      {
        metric: "Sharpe Ratio",
        values: [
          { backtestId: "bt_001", value: 1.45 },
          { backtestId: "bt_002", value: 1.12 }
        ],
        winner: "bt_001"
      },
      {
        metric: "Max Drawdown",
        values: [
          { backtestId: "bt_001", value: 0.08 },
          { backtestId: "bt_002", value: 0.18 }
        ],
        winner: "bt_001"
      },
      {
        metric: "Win Rate",
        values: [
          { backtestId: "bt_001", value: 0.62 },
          { backtestId: "bt_002", value: 0.55 }
        ],
        winner: "bt_001"
      }
    ],
    correlationMatrix: [
      [1, 0.72],
      [0.72, 1]
    ],
    bestPerformer: "Conservative Strategy",
    recommendation: "The Conservative Strategy offers better risk-adjusted returns with a higher Sharpe ratio and lower drawdown, making it suitable for most investors."
  };
  return createExportData(
    "Backtest Comparison Report",
    userId,
    backtests2,
    comparison
  );
}
function getExportFileName(title, format) {
  const sanitizedTitle = title.toLowerCase().replace(/[^a-z0-9]+/g, "_");
  const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
  return `${sanitizedTitle}_${timestamp2}.${format}`;
}
var DEFAULT_METADATA;
var init_BacktestExport = __esm({
  "server/services/ai-agents/BacktestExport.ts"() {
    "use strict";
    DEFAULT_METADATA = {
      version: "1.0.0",
      platform: "TradoVerse AI Trading Platform",
      disclaimer: "Past performance is not indicative of future results. This report is for informational purposes only and does not constitute financial advice. Trading involves risk and may result in loss of capital."
    };
  }
});

// server/services/ai-agents/AgentCommunicationHub.ts
var AgentCommunicationHub_exports = {};
__export(AgentCommunicationHub_exports, {
  addArgument: () => addArgument,
  clearOldDiscussions: () => clearOldDiscussions,
  conductVoting: () => conductVoting,
  generateDebate: () => generateDebate,
  getActiveDiscussions: () => getActiveDiscussions,
  getAgentProfile: () => getAgentProfile,
  getAllAgentProfiles: () => getAllAgentProfiles,
  getDiscussion: () => getDiscussion,
  getDiscussionHistory: () => getDiscussionHistory,
  runFullDiscussion: () => runFullDiscussion,
  startDiscussion: () => startDiscussion,
  subscribeToDiscussion: () => subscribeToDiscussion
});
function generateId2() {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
async function startDiscussion(symbol, assetType, topic, marketData) {
  const thread = {
    id: generateId2(),
    symbol,
    assetType,
    topic,
    startedAt: Date.now(),
    status: "active",
    messages: [],
    participants: ["technical", "fundamental", "sentiment", "risk", "regime", "execution", "coordinator"]
  };
  const initialAnalyses = await generateInitialAnalyses(symbol, assetType, topic, marketData);
  thread.messages.push(...initialAnalyses);
  activeDiscussions.set(thread.id, thread);
  return thread;
}
async function generateInitialAnalyses(symbol, assetType, topic, marketData) {
  const messages = [];
  const agents = ["technical", "fundamental", "sentiment", "risk", "regime", "execution"];
  for (const agentType of agents) {
    const profile = AGENT_PROFILES[agentType];
    const analysis = await generateAgentAnalysis(agentType, symbol, assetType, topic, marketData);
    messages.push({
      id: generateId2(),
      agentType,
      agentName: profile.name,
      messageType: "analysis",
      content: analysis.content,
      confidence: analysis.confidence,
      timestamp: Date.now(),
      supportingData: analysis.supportingData,
      sentiment: analysis.sentiment
    });
  }
  return messages;
}
async function generateAgentAnalysis(agentType, symbol, assetType, topic, marketData) {
  const profile = AGENT_PROFILES[agentType];
  const systemPrompt = `You are ${profile.name}, an AI trading agent with the following characteristics:
- Personality: ${profile.personality}
- Expertise: ${profile.expertise.join(", ")}
- Known biases: ${profile.biases.join(", ")}

Provide your analysis on the trading topic. Be specific, data-driven, and true to your personality.
Your response must be a JSON object with:
- content: Your analysis (2-3 sentences)
- confidence: A number 0-100 representing your confidence
- sentiment: "bullish", "bearish", or "neutral"
- keyPoints: Array of 2-3 key supporting points`;
  const userPrompt = `Analyze ${symbol} (${assetType}) regarding: ${topic}
${marketData ? `
Market Data: ${JSON.stringify(marketData)}` : ""}`;
  try {
    const response = await invokeLLM({
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "agent_analysis",
          strict: true,
          schema: {
            type: "object",
            properties: {
              content: { type: "string" },
              confidence: { type: "number" },
              sentiment: { type: "string", enum: ["bullish", "bearish", "neutral"] },
              keyPoints: { type: "array", items: { type: "string" } }
            },
            required: ["content", "confidence", "sentiment", "keyPoints"],
            additionalProperties: false
          }
        }
      }
    });
    const messageContent = response.choices[0].message.content;
    const result = JSON.parse(typeof messageContent === "string" ? messageContent : "{}");
    return {
      content: result.content || `${profile.name} is analyzing ${symbol}...`,
      confidence: Math.min(100, Math.max(0, result.confidence || 50)),
      supportingData: { keyPoints: result.keyPoints || [] },
      sentiment: result.sentiment || "neutral"
    };
  } catch (error) {
    return generateFallbackAnalysis(agentType, symbol);
  }
}
function generateFallbackAnalysis(agentType, symbol) {
  const fallbacks = {
    technical: () => ({
      content: `Technical analysis for ${symbol} shows mixed signals. RSI is neutral, MACD showing potential crossover. Waiting for confirmation.`,
      confidence: 55,
      sentiment: "neutral"
    }),
    fundamental: () => ({
      content: `Fundamental analysis indicates ${symbol} is trading near fair value. P/E ratio is in line with sector average.`,
      confidence: 60,
      sentiment: "neutral"
    }),
    sentiment: () => ({
      content: `Market sentiment for ${symbol} is cautiously optimistic. Social media mentions are stable with slight positive bias.`,
      confidence: 50,
      sentiment: "bullish"
    }),
    risk: () => ({
      content: `Risk assessment for ${symbol}: Moderate volatility expected. Current position sizing should account for potential 5-8% drawdown.`,
      confidence: 65,
      sentiment: "neutral"
    }),
    regime: () => ({
      content: `Current market regime appears to be in consolidation phase. ${symbol} likely to follow broader market trends.`,
      confidence: 55,
      sentiment: "neutral"
    }),
    execution: () => ({
      content: `Execution analysis: Liquidity for ${symbol} is adequate. Recommend limit orders with 0.5% buffer from current price.`,
      confidence: 70,
      sentiment: "neutral"
    }),
    coordinator: () => ({
      content: `Synthesizing all agent inputs for ${symbol}. Consensus building in progress.`,
      confidence: 50,
      sentiment: "neutral"
    })
  };
  const fallback = fallbacks[agentType]();
  return {
    ...fallback,
    supportingData: { source: "fallback" }
  };
}
async function addArgument(threadId, agentType, position, targetMessageId) {
  const thread = activeDiscussions.get(threadId);
  if (!thread || thread.status !== "active") return null;
  const profile = AGENT_PROFILES[agentType];
  const messageType = position === "for" ? "argument" : "counter_argument";
  const context = thread.messages.slice(-5).map((m) => `${m.agentName}: ${m.content}`).join("\n");
  try {
    const response = await invokeLLM({
      messages: [
        {
          role: "system",
          content: `You are ${profile.name}. Provide a ${position === "for" ? "supporting" : "counter"} argument based on your expertise. Be concise (1-2 sentences).`
        },
        {
          role: "user",
          content: `Discussion context:
${context}

Provide your ${position} argument for ${thread.symbol}.`
        }
      ]
    });
    const responseContent = response.choices[0].message.content;
    const content = (typeof responseContent === "string" ? responseContent : "") || `${profile.name} ${position === "for" ? "supports" : "opposes"} this position.`;
    const message = {
      id: generateId2(),
      agentType,
      agentName: profile.name,
      messageType,
      content,
      confidence: Math.floor(Math.random() * 30) + 50,
      timestamp: Date.now(),
      replyTo: targetMessageId,
      sentiment: position === "for" ? "bullish" : "bearish"
    };
    thread.messages.push(message);
    return message;
  } catch (error) {
    return null;
  }
}
async function generateDebate(threadId, rounds = 2) {
  const thread = activeDiscussions.get(threadId);
  if (!thread || thread.status !== "active") return [];
  const newMessages = [];
  const debatingAgents = ["technical", "fundamental", "sentiment", "risk"];
  for (let round = 0; round < rounds; round++) {
    for (const agent of debatingAgents) {
      const position = round % 2 === 0 ? "for" : "against";
      const message = await addArgument(threadId, agent, position);
      if (message) {
        newMessages.push(message);
      }
    }
  }
  return newMessages;
}
async function conductVoting(threadId) {
  const thread = activeDiscussions.get(threadId);
  if (!thread || thread.status !== "active") return null;
  const votes = [];
  const votingAgents = ["technical", "fundamental", "sentiment", "risk", "regime", "execution"];
  for (const agentType of votingAgents) {
    const agentMessages = thread.messages.filter((m) => m.agentType === agentType);
    const lastMessage = agentMessages[agentMessages.length - 1];
    let vote = "hold";
    if (lastMessage) {
      if (lastMessage.sentiment === "bullish" && lastMessage.confidence > 60) {
        vote = "buy";
      } else if (lastMessage.sentiment === "bearish" && lastMessage.confidence > 60) {
        vote = "sell";
      }
    }
    votes.push({
      agent: agentType,
      vote,
      confidence: lastMessage?.confidence || 50
    });
    const profile = AGENT_PROFILES[agentType];
    thread.messages.push({
      id: generateId2(),
      agentType,
      agentName: profile.name,
      messageType: "vote",
      content: `I vote to ${vote.toUpperCase()} with ${lastMessage?.confidence || 50}% confidence.`,
      confidence: lastMessage?.confidence || 50,
      timestamp: Date.now(),
      sentiment: vote === "buy" ? "bullish" : vote === "sell" ? "bearish" : "neutral"
    });
  }
  const buyVotes = votes.filter((v) => v.vote === "buy").length;
  const sellVotes = votes.filter((v) => v.vote === "sell").length;
  const holdVotes = votes.filter((v) => v.vote === "hold").length;
  let decision;
  let votesFor;
  let votesAgainst;
  if (buyVotes > sellVotes && buyVotes > holdVotes) {
    decision = "buy";
    votesFor = buyVotes;
    votesAgainst = sellVotes;
  } else if (sellVotes > buyVotes && sellVotes > holdVotes) {
    decision = "sell";
    votesFor = sellVotes;
    votesAgainst = buyVotes;
  } else {
    decision = "hold";
    votesFor = holdVotes;
    votesAgainst = Math.max(buyVotes, sellVotes);
  }
  const relevantVotes = votes.filter((v) => v.vote === decision);
  const avgConfidence = relevantVotes.length > 0 ? relevantVotes.reduce((sum2, v) => sum2 + v.confidence, 0) / relevantVotes.length : 50;
  const bullishMessages = thread.messages.filter((m) => m.sentiment === "bullish");
  const bearishMessages = thread.messages.filter((m) => m.sentiment === "bearish");
  const consensus = {
    decision,
    confidence: Math.round(avgConfidence),
    votesFor,
    votesAgainst,
    abstentions: holdVotes,
    reasoning: `Based on ${votesFor} votes for ${decision.toUpperCase()} vs ${votesAgainst} against, with ${avgConfidence.toFixed(0)}% average confidence.`,
    keyArguments: {
      forDecision: bullishMessages.slice(0, 3).map((m) => m.content),
      againstDecision: bearishMessages.slice(0, 3).map((m) => m.content)
    },
    timestamp: Date.now()
  };
  thread.messages.push({
    id: generateId2(),
    agentType: "coordinator",
    agentName: AGENT_PROFILES.coordinator.name,
    messageType: "consensus",
    content: `CONSENSUS REACHED: ${decision.toUpperCase()} ${thread.symbol} with ${consensus.confidence}% confidence. ${consensus.reasoning}`,
    confidence: consensus.confidence,
    timestamp: Date.now(),
    sentiment: decision === "buy" ? "bullish" : decision === "sell" ? "bearish" : "neutral"
  });
  thread.consensus = consensus;
  thread.status = "concluded";
  return consensus;
}
function getDiscussion(threadId) {
  return activeDiscussions.get(threadId) || null;
}
function getActiveDiscussions() {
  return Array.from(activeDiscussions.values()).filter((d) => d.status === "active");
}
function getDiscussionHistory(symbol, limit = 10) {
  return Array.from(activeDiscussions.values()).filter((d) => d.symbol === symbol).sort((a, b) => b.startedAt - a.startedAt).slice(0, limit);
}
async function runFullDiscussion(symbol, assetType, topic, marketData) {
  const thread = await startDiscussion(symbol, assetType, topic, marketData);
  await generateDebate(thread.id, 2);
  const consensus = await conductVoting(thread.id);
  return { thread, consensus };
}
function getAgentProfile(agentType) {
  return AGENT_PROFILES[agentType];
}
function getAllAgentProfiles() {
  return AGENT_PROFILES;
}
function subscribeToDiscussion(threadId, callback) {
  return () => {
  };
}
function clearOldDiscussions(maxAgeMs = 24 * 60 * 60 * 1e3) {
  const cutoff = Date.now() - maxAgeMs;
  let cleared = 0;
  const entries = Array.from(activeDiscussions.entries());
  for (const [id, thread] of entries) {
    if (thread.startedAt < cutoff) {
      activeDiscussions.delete(id);
      cleared++;
    }
  }
  return cleared;
}
var AGENT_PROFILES, activeDiscussions;
var init_AgentCommunicationHub = __esm({
  "server/services/ai-agents/AgentCommunicationHub.ts"() {
    "use strict";
    init_llm();
    AGENT_PROFILES = {
      technical: {
        name: "TechAnalyst",
        personality: "Data-driven, pattern-focused, relies heavily on charts and indicators",
        expertise: ["Chart patterns", "Technical indicators", "Price action", "Volume analysis"],
        biases: ["May ignore fundamental factors", "Can be late to trend changes"]
      },
      fundamental: {
        name: "FundaBot",
        personality: "Value-oriented, focuses on company financials and intrinsic value",
        expertise: ["Financial statements", "Valuation metrics", "Industry analysis", "Competitive positioning"],
        biases: ["May underweight market sentiment", "Can be slow to react to price movements"]
      },
      sentiment: {
        name: "SentiMind",
        personality: "Emotionally aware, tracks market psychology and social trends",
        expertise: ["Social media analysis", "News sentiment", "Fear/greed indicators", "Crowd behavior"],
        biases: ["Can be swayed by noise", "May overreact to short-term sentiment shifts"]
      },
      risk: {
        name: "RiskGuard",
        personality: "Cautious, protective, focuses on downside scenarios",
        expertise: ["Risk metrics", "Portfolio correlation", "Drawdown analysis", "Position sizing"],
        biases: ["May be overly conservative", "Can miss opportunities due to risk aversion"]
      },
      regime: {
        name: "RegimeDetector",
        personality: "Big-picture thinker, identifies market phases and macro trends",
        expertise: ["Market cycles", "Economic indicators", "Sector rotation", "Volatility regimes"],
        biases: ["May miss micro-level opportunities", "Can be slow to detect regime changes"]
      },
      execution: {
        name: "ExecBot",
        personality: "Practical, timing-focused, optimizes entry and exit points",
        expertise: ["Order flow", "Liquidity analysis", "Slippage minimization", "Timing optimization"],
        biases: ["May overthink execution", "Can delay decisions seeking perfect entry"]
      },
      coordinator: {
        name: "Consensus",
        personality: "Balanced, synthesizes all viewpoints, seeks agreement",
        expertise: ["Multi-factor analysis", "Conflict resolution", "Weight optimization", "Final decision making"],
        biases: ["May compromise too much", "Can be slow in volatile markets"]
      }
    };
    activeDiscussions = /* @__PURE__ */ new Map();
  }
});

// server/services/ai-agents/MarketRegimeAutoAdaptation.ts
var MarketRegimeAutoAdaptation_exports = {};
__export(MarketRegimeAutoAdaptation_exports, {
  autoAdaptWeights: () => autoAdaptWeights,
  clearRegimeHistory: () => clearRegimeHistory,
  detectRegime: () => detectRegime2,
  enhanceRegimeAnalysis: () => enhanceRegimeAnalysis,
  generateWeightAdjustment: () => generateWeightAdjustment,
  getAllRegimePresets: () => getAllRegimePresets,
  getCurrentRegimeState: () => getCurrentRegimeState,
  getDefaultConfig: () => getDefaultConfig,
  getRecommendedWeights: () => getRecommendedWeights,
  getRegimeHistory: () => getRegimeHistory,
  getRegimeStatistics: () => getRegimeStatistics,
  getUserConfig: () => getUserConfig,
  updateUserConfig: () => updateUserConfig,
  validateWeights: () => validateWeights
});
function getDefaultConfig() {
  return {
    enabled: true,
    sensitivity: "medium",
    minConfidenceThreshold: 60,
    cooldownPeriodMs: 36e5,
    // 1 hour
    maxWeightChange: 0.15,
    notifyOnChange: true
  };
}
function getUserConfig(userId) {
  return userConfigs.get(userId) || getDefaultConfig();
}
function updateUserConfig(userId, config) {
  const currentConfig = getUserConfig(userId);
  const newConfig = { ...currentConfig, ...config };
  userConfigs.set(userId, newConfig);
  return newConfig;
}
function calculateIndicators2(marketData) {
  const { prices, volumes, highs, lows } = marketData;
  if (prices.length < 20) {
    return { volatility: 20, trend: 0, momentum: 0, sentiment: 50, volume: 1 };
  }
  const returns = prices.slice(1).map((p, i) => (p - prices[i]) / prices[i]);
  const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
  const variance = returns.reduce((sum2, r) => sum2 + Math.pow(r - avgReturn, 2), 0) / returns.length;
  const volatility = Math.sqrt(variance) * Math.sqrt(252) * 100;
  const n = prices.length;
  const xSum = n * (n - 1) / 2;
  const xSquaredSum = n * (n - 1) * (2 * n - 1) / 6;
  const ySum = prices.reduce((a, b) => a + b, 0);
  const xySum = prices.reduce((sum2, p, i) => sum2 + p * i, 0);
  const slope = (n * xySum - xSum * ySum) / (n * xSquaredSum - xSum * xSum);
  const trend = slope / (ySum / n);
  const momentum = (prices[prices.length - 1] - prices[0]) / prices[0];
  const recentVolume = volumes.slice(-5).reduce((a, b) => a + b, 0) / 5;
  const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
  const volumeRatio = recentVolume / avgVolume;
  const bullishDays = prices.slice(1).filter((p, i) => p > prices[i]).length;
  const sentiment = bullishDays / (prices.length - 1) * 100;
  return {
    volatility: Math.min(100, volatility),
    trend: Math.max(-1, Math.min(1, trend * 100)),
    momentum: Math.max(-1, Math.min(1, momentum)),
    sentiment: Math.min(100, Math.max(0, sentiment)),
    volume: volumeRatio
  };
}
function detectRegimeFromIndicators(indicators) {
  const { volatility, trend, momentum, sentiment, volume } = indicators;
  if (volatility > REGIME_THRESHOLDS.volatility.extreme && trend < REGIME_THRESHOLDS.trend.bear) {
    return { regime: "crisis", confidence: 85 };
  }
  if (sentiment < REGIME_THRESHOLDS.sentiment.capitulation && volatility > REGIME_THRESHOLDS.volatility.high) {
    return { regime: "capitulation", confidence: 80 };
  }
  if (sentiment > REGIME_THRESHOLDS.sentiment.euphoria && trend > REGIME_THRESHOLDS.trend.bull) {
    return { regime: "euphoria", confidence: 75 };
  }
  if (volatility > REGIME_THRESHOLDS.volatility.high) {
    return { regime: "high_volatility", confidence: 70 };
  }
  if (trend > REGIME_THRESHOLDS.trend.strongBull && momentum > 0.1) {
    return { regime: "bull_trending", confidence: 75 };
  }
  if (trend < REGIME_THRESHOLDS.trend.bear && momentum < -0.1) {
    return { regime: "bear_trending", confidence: 75 };
  }
  if (trend > REGIME_THRESHOLDS.trend.bull && sentiment > 40 && sentiment < 60) {
    return { regime: "recovery", confidence: 65 };
  }
  if (Math.abs(trend) < REGIME_THRESHOLDS.trend.bull && volatility < REGIME_THRESHOLDS.volatility.medium) {
    return { regime: "sideways_range", confidence: 60 };
  }
  return { regime: "sideways_range", confidence: 50 };
}
async function detectRegime2(marketData) {
  const indicators = calculateIndicators2(marketData);
  const { regime, confidence } = detectRegimeFromIndicators(indicators);
  const previousRegime = currentRegimeState?.currentRegime || null;
  const regimeChangeDetected = previousRegime !== null && previousRegime !== regime;
  const result = {
    currentRegime: regime,
    confidence,
    previousRegime,
    regimeChangeDetected,
    indicators,
    timestamp: Date.now()
  };
  if (regimeChangeDetected && currentRegimeState) {
    const lastEntry = regimeHistory[regimeHistory.length - 1];
    if (lastEntry && lastEntry.endTime === null) {
      lastEntry.endTime = Date.now();
      lastEntry.duration = lastEntry.endTime - lastEntry.startTime;
    }
    regimeHistory.push({
      regime,
      startTime: Date.now(),
      endTime: null,
      duration: null,
      weights: REGIME_WEIGHT_PRESETS[regime],
      performance: null
    });
  } else if (!currentRegimeState) {
    regimeHistory.push({
      regime,
      startTime: Date.now(),
      endTime: null,
      duration: null,
      weights: REGIME_WEIGHT_PRESETS[regime],
      performance: null
    });
  }
  currentRegimeState = result;
  return result;
}
function getRecommendedWeights(regime) {
  return { ...REGIME_WEIGHT_PRESETS[regime] };
}
function generateWeightAdjustment(currentWeights, targetRegime, config) {
  const recommendedWeights = getRecommendedWeights(targetRegime);
  const adjustedWeights = { ...currentWeights };
  for (const key of Object.keys(recommendedWeights)) {
    const diff = recommendedWeights[key] - currentWeights[key];
    const maxDiff = config.maxWeightChange;
    adjustedWeights[key] = currentWeights[key] + Math.max(-maxDiff, Math.min(maxDiff, diff));
  }
  const total = Object.values(adjustedWeights).reduce((a, b) => a + b, 0);
  for (const key of Object.keys(adjustedWeights)) {
    adjustedWeights[key] = adjustedWeights[key] / total;
  }
  let riskLevel = "medium";
  if (["crisis", "capitulation", "high_volatility"].includes(targetRegime)) {
    riskLevel = "high";
  } else if (["sideways_range", "recovery"].includes(targetRegime)) {
    riskLevel = "low";
  }
  const adjustmentReason = getAdjustmentReason(targetRegime, currentWeights, adjustedWeights);
  const expectedImpact = getExpectedImpact(targetRegime);
  return {
    regime: targetRegime,
    recommendedWeights: adjustedWeights,
    previousWeights: currentWeights,
    adjustmentReason,
    expectedImpact,
    riskLevel
  };
}
function getAdjustmentReason(regime, oldWeights, newWeights) {
  const reasons = {
    bull_trending: "Market showing strong bullish trend. Increasing technical and sentiment weights to capture momentum.",
    bear_trending: "Market in bearish trend. Increasing risk and fundamental weights for protection and value identification.",
    sideways_range: "Market range-bound. Increasing technical weight for range trading signals.",
    high_volatility: "High volatility detected. Significantly increasing risk weight for protection.",
    crisis: "Crisis conditions detected. Maximum risk weight for capital preservation.",
    recovery: "Recovery phase identified. Balanced approach with focus on fundamentals and technicals.",
    euphoria: "Extreme bullish sentiment detected. Increasing sentiment and risk weights to identify potential top.",
    capitulation: "Extreme fear detected. Increasing fundamental weight to identify deep value opportunities."
  };
  return reasons[regime];
}
function getExpectedImpact(regime) {
  const impacts = {
    bull_trending: "Expected to capture more upside momentum with slightly higher risk tolerance.",
    bear_trending: "Expected to reduce drawdowns and identify value opportunities during decline.",
    sideways_range: "Expected to profit from range-bound conditions with mean reversion strategies.",
    high_volatility: "Expected to significantly reduce position sizes and protect capital.",
    crisis: "Expected to minimize losses and preserve capital during market stress.",
    recovery: "Expected to gradually build positions as market stabilizes.",
    euphoria: "Expected to take profits and reduce exposure before potential correction.",
    capitulation: "Expected to identify bottom and accumulate quality assets at deep discounts."
  };
  return impacts[regime];
}
async function autoAdaptWeights(userId, currentWeights, marketData) {
  const config = getUserConfig(userId);
  if (!config.enabled) {
    return { adapted: false, recommendation: null, reason: "Auto-adaptation is disabled" };
  }
  const now = Date.now();
  if (now - lastAdaptationTime < config.cooldownPeriodMs) {
    return { adapted: false, recommendation: null, reason: "Cooldown period active" };
  }
  const regimeResult = await detectRegime2(marketData);
  if (regimeResult.confidence < config.minConfidenceThreshold) {
    return {
      adapted: false,
      recommendation: null,
      reason: `Confidence (${regimeResult.confidence}%) below threshold (${config.minConfidenceThreshold}%)`
    };
  }
  if (!regimeResult.regimeChangeDetected) {
    return { adapted: false, recommendation: null, reason: "No regime change detected" };
  }
  const recommendation = generateWeightAdjustment(
    currentWeights,
    regimeResult.currentRegime,
    config
  );
  lastAdaptationTime = now;
  return {
    adapted: true,
    recommendation,
    reason: `Regime changed from ${regimeResult.previousRegime} to ${regimeResult.currentRegime}`
  };
}
function getRegimeHistory(limit = 50) {
  return regimeHistory.slice(-limit);
}
function getCurrentRegimeState() {
  return currentRegimeState;
}
function getRegimeStatistics() {
  const completedRegimes = regimeHistory.filter((r) => r.duration !== null);
  const totalRegimeChanges = regimeHistory.length - 1;
  const averageRegimeDuration = completedRegimes.length > 0 ? completedRegimes.reduce((sum2, r) => sum2 + (r.duration || 0), 0) / completedRegimes.length : 0;
  const regimeDistribution = {
    bull_trending: 0,
    bear_trending: 0,
    sideways_range: 0,
    high_volatility: 0,
    crisis: 0,
    recovery: 0,
    euphoria: 0,
    capitulation: 0
  };
  regimeHistory.forEach((r) => {
    regimeDistribution[r.regime]++;
  });
  let currentStreak = 0;
  if (regimeHistory.length > 0) {
    const currentRegime = regimeHistory[regimeHistory.length - 1].regime;
    for (let i = regimeHistory.length - 1; i >= 0; i--) {
      if (regimeHistory[i].regime === currentRegime) {
        currentStreak++;
      } else {
        break;
      }
    }
  }
  return {
    totalRegimeChanges,
    averageRegimeDuration,
    regimeDistribution,
    currentStreak
  };
}
function getAllRegimePresets() {
  return { ...REGIME_WEIGHT_PRESETS };
}
function validateWeights(weights) {
  const errors = [];
  const requiredKeys = ["technical", "fundamental", "sentiment", "risk", "regime", "execution"];
  for (const key of requiredKeys) {
    if (typeof weights[key] !== "number") {
      errors.push(`Missing or invalid weight for ${key}`);
    } else if (weights[key] < 0 || weights[key] > 1) {
      errors.push(`Weight for ${key} must be between 0 and 1`);
    }
  }
  const sum2 = Object.values(weights).reduce((a, b) => a + b, 0);
  if (Math.abs(sum2 - 1) > 0.01) {
    errors.push(`Weights must sum to 1 (current sum: ${sum2.toFixed(3)})`);
  }
  return { valid: errors.length === 0, errors };
}
async function enhanceRegimeAnalysis(regime, indicators, symbol) {
  try {
    const response = await invokeLLM({
      messages: [
        {
          role: "system",
          content: `You are a market regime analyst. Provide concise analysis and recommendations based on detected market regime and indicators.
Your response must be a JSON object with:
- analysis: Brief analysis of current market conditions (2-3 sentences)
- tradingRecommendations: Array of 3-4 specific trading recommendations
- riskWarnings: Array of 2-3 risk warnings to consider`
        },
        {
          role: "user",
          content: `Market Regime: ${regime}
${symbol ? `Symbol: ${symbol}` : ""}
Indicators:
- Volatility: ${indicators.volatility.toFixed(1)}%
- Trend: ${indicators.trend.toFixed(2)}
- Momentum: ${indicators.momentum.toFixed(2)}
- Sentiment: ${indicators.sentiment.toFixed(1)}
- Volume Ratio: ${indicators.volume.toFixed(2)}

Provide your analysis and recommendations.`
        }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "regime_analysis",
          strict: true,
          schema: {
            type: "object",
            properties: {
              analysis: { type: "string" },
              tradingRecommendations: { type: "array", items: { type: "string" } },
              riskWarnings: { type: "array", items: { type: "string" } }
            },
            required: ["analysis", "tradingRecommendations", "riskWarnings"],
            additionalProperties: false
          }
        }
      }
    });
    const content = response.choices[0].message.content;
    return JSON.parse(typeof content === "string" ? content : "{}");
  } catch (error) {
    return {
      analysis: `Market is currently in ${regime.replace("_", " ")} regime with ${indicators.volatility.toFixed(1)}% volatility.`,
      tradingRecommendations: [
        "Monitor key support and resistance levels",
        "Adjust position sizes according to volatility",
        "Consider hedging strategies if appropriate"
      ],
      riskWarnings: [
        "Past regime patterns may not predict future behavior",
        "Regime transitions can be sudden and unpredictable"
      ]
    };
  }
}
function clearRegimeHistory() {
  regimeHistory.length = 0;
  currentRegimeState = null;
  lastAdaptationTime = 0;
}
var REGIME_WEIGHT_PRESETS, REGIME_THRESHOLDS, regimeHistory, currentRegimeState, lastAdaptationTime, userConfigs;
var init_MarketRegimeAutoAdaptation = __esm({
  "server/services/ai-agents/MarketRegimeAutoAdaptation.ts"() {
    "use strict";
    init_llm();
    REGIME_WEIGHT_PRESETS = {
      bull_trending: {
        technical: 0.25,
        // Follow trends
        fundamental: 0.2,
        // Value matters less in bull
        sentiment: 0.15,
        // Sentiment confirms trend
        risk: 0.1,
        // Lower risk focus
        regime: 0.15,
        // Monitor for changes
        execution: 0.15
        // Timing matters
      },
      bear_trending: {
        technical: 0.2,
        // Identify support levels
        fundamental: 0.25,
        // Value becomes important
        sentiment: 0.1,
        // Sentiment often wrong at bottoms
        risk: 0.25,
        // High risk focus
        regime: 0.1,
        // Monitor for reversal
        execution: 0.1
        // Quick exits needed
      },
      sideways_range: {
        technical: 0.3,
        // Range trading signals
        fundamental: 0.15,
        // Less relevant in range
        sentiment: 0.1,
        // Noise in range
        risk: 0.15,
        // Moderate risk
        regime: 0.15,
        // Watch for breakout
        execution: 0.15
        // Entry/exit timing
      },
      high_volatility: {
        technical: 0.15,
        // Signals less reliable
        fundamental: 0.15,
        // Long-term view
        sentiment: 0.15,
        // Extreme sentiment
        risk: 0.3,
        // Maximum risk focus
        regime: 0.15,
        // Regime shifts likely
        execution: 0.1
        // Difficult execution
      },
      crisis: {
        technical: 0.1,
        // Patterns break down
        fundamental: 0.1,
        // Fundamentals ignored
        sentiment: 0.15,
        // Panic indicators
        risk: 0.4,
        // Survival mode
        regime: 0.15,
        // Watch for bottom
        execution: 0.1
        // Liquidity issues
      },
      recovery: {
        technical: 0.25,
        // New trends forming
        fundamental: 0.25,
        // Value opportunities
        sentiment: 0.15,
        // Improving sentiment
        risk: 0.15,
        // Moderate caution
        regime: 0.1,
        // Confirm recovery
        execution: 0.1
        // Build positions
      },
      euphoria: {
        technical: 0.15,
        // Overbought signals
        fundamental: 0.2,
        // Valuation warnings
        sentiment: 0.25,
        // Extreme greed
        risk: 0.25,
        // High risk awareness
        regime: 0.1,
        // Top detection
        execution: 0.05
        // Reduce positions
      },
      capitulation: {
        technical: 0.2,
        // Oversold signals
        fundamental: 0.3,
        // Deep value
        sentiment: 0.2,
        // Extreme fear
        risk: 0.15,
        // Calculated risk
        regime: 0.1,
        // Bottom detection
        execution: 0.05
        // Accumulate slowly
      }
    };
    REGIME_THRESHOLDS = {
      volatility: {
        low: 15,
        medium: 25,
        high: 40,
        extreme: 60
      },
      trend: {
        strongBull: 0.7,
        bull: 0.3,
        neutral: -0.3,
        bear: -0.7
      },
      sentiment: {
        euphoria: 80,
        bullish: 60,
        neutral: 40,
        bearish: 20,
        capitulation: 10
      }
    };
    regimeHistory = [];
    currentRegimeState = null;
    lastAdaptationTime = 0;
    userConfigs = /* @__PURE__ */ new Map();
  }
});

// server/services/ai-agents/MultiAssetCorrelationEngine.ts
var MultiAssetCorrelationEngine_exports = {};
__export(MultiAssetCorrelationEngine_exports, {
  analyzeCrossAssetCorrelations: () => analyzeCrossAssetCorrelations,
  analyzePortfolioCorrelation: () => analyzePortfolioCorrelation,
  analyzeRegimeCorrelations: () => analyzeRegimeCorrelations,
  calculateCorrelation: () => calculateCorrelation2,
  calculateCorrelationMatrix: () => calculateCorrelationMatrix3,
  calculateCorrelationStability: () => calculateCorrelationStability,
  calculateRollingCorrelation: () => calculateRollingCorrelation,
  findUncorrelatedAssets: () => findUncorrelatedAssets,
  generateSamplePriceData: () => generateSamplePriceData,
  getDefaultAssets: () => getDefaultAssets,
  interpretCorrelation: () => interpretCorrelation
});
function calculatePearsonCorrelation(x, y) {
  if (x.length !== y.length || x.length < 3) {
    return { correlation: 0, pValue: 1 };
  }
  const n = x.length;
  const sumX = x.reduce((a, b) => a + b, 0);
  const sumY = y.reduce((a, b) => a + b, 0);
  const sumXY = x.reduce((sum2, xi, i) => sum2 + xi * y[i], 0);
  const sumX2 = x.reduce((sum2, xi) => sum2 + xi * xi, 0);
  const sumY2 = y.reduce((sum2, yi) => sum2 + yi * yi, 0);
  const numerator = n * sumXY - sumX * sumY;
  const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
  if (denominator === 0) {
    return { correlation: 0, pValue: 1 };
  }
  const correlation2 = numerator / denominator;
  const t2 = correlation2 * Math.sqrt((n - 2) / (1 - correlation2 * correlation2));
  const pValue = 2 * (1 - tDistributionCDF(Math.abs(t2), n - 2));
  return { correlation: correlation2, pValue };
}
function tDistributionCDF(t2, df) {
  if (df > 30) {
    return normalCDF2(t2);
  }
  const x = df / (df + t2 * t2);
  return 1 - 0.5 * Math.pow(x, df / 2);
}
function normalCDF2(x) {
  const a1 = 0.254829592;
  const a2 = -0.284496736;
  const a3 = 1.421413741;
  const a4 = -1.453152027;
  const a5 = 1.061405429;
  const p = 0.3275911;
  const sign = x < 0 ? -1 : 1;
  x = Math.abs(x) / Math.sqrt(2);
  const t2 = 1 / (1 + p * x);
  const y = 1 - ((((a5 * t2 + a4) * t2 + a3) * t2 + a2) * t2 + a1) * t2 * Math.exp(-x * x);
  return 0.5 * (1 + sign * y);
}
function calculateReturns(prices) {
  const returns = [];
  for (let i = 1; i < prices.length; i++) {
    returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
  }
  return returns;
}
function getCorrelationStrength(correlation2) {
  const absCorr = Math.abs(correlation2);
  if (absCorr >= 0.8) return "very_strong";
  if (absCorr >= 0.6) return "strong";
  if (absCorr >= 0.4) return "moderate";
  if (absCorr >= 0.2) return "weak";
  return "very_weak";
}
function calculateCorrelation2(asset1, prices1, asset2, prices2, period = "1Y") {
  const returns1 = calculateReturns(prices1);
  const returns2 = calculateReturns(prices2);
  const minLength = Math.min(returns1.length, returns2.length);
  const alignedReturns1 = returns1.slice(-minLength);
  const alignedReturns2 = returns2.slice(-minLength);
  const { correlation: correlation2, pValue } = calculatePearsonCorrelation(alignedReturns1, alignedReturns2);
  return {
    asset1,
    asset2,
    correlation: correlation2,
    pValue,
    sampleSize: minLength,
    period,
    strength: getCorrelationStrength(correlation2),
    direction: correlation2 > 0.1 ? "positive" : correlation2 < -0.1 ? "negative" : "neutral"
  };
}
function calculateCorrelationMatrix3(assets, priceData, period = "1Y", method = "pearson") {
  const n = assets.length;
  const matrix = Array(n).fill(null).map(() => Array(n).fill(0));
  const returnsMap = /* @__PURE__ */ new Map();
  assets.forEach((asset) => {
    const prices = priceData.get(asset.symbol) || [];
    returnsMap.set(asset.symbol, calculateReturns(prices));
  });
  for (let i = 0; i < n; i++) {
    matrix[i][i] = 1;
    for (let j = i + 1; j < n; j++) {
      const returns1 = returnsMap.get(assets[i].symbol) || [];
      const returns2 = returnsMap.get(assets[j].symbol) || [];
      const minLength = Math.min(returns1.length, returns2.length);
      const alignedReturns1 = returns1.slice(-minLength);
      const alignedReturns2 = returns2.slice(-minLength);
      const { correlation: correlation2 } = calculatePearsonCorrelation(alignedReturns1, alignedReturns2);
      matrix[i][j] = correlation2;
      matrix[j][i] = correlation2;
    }
  }
  return {
    assets,
    matrix,
    timestamp: Date.now(),
    period,
    method
  };
}
function calculateRollingCorrelation(asset1, prices1, asset2, prices2, windowSize = 30) {
  const returns1 = calculateReturns(prices1);
  const returns2 = calculateReturns(prices2);
  const minLength = Math.min(returns1.length, returns2.length);
  const alignedReturns1 = returns1.slice(-minLength);
  const alignedReturns2 = returns2.slice(-minLength);
  const dataPoints = [];
  const correlations = [];
  for (let i = windowSize; i <= minLength; i++) {
    const window1 = alignedReturns1.slice(i - windowSize, i);
    const window2 = alignedReturns2.slice(i - windowSize, i);
    const { correlation: correlation2 } = calculatePearsonCorrelation(window1, window2);
    correlations.push(correlation2);
    dataPoints.push({
      timestamp: Date.now() - (minLength - i) * 24 * 60 * 60 * 1e3,
      correlation: correlation2,
      window: windowSize
    });
  }
  const averageCorrelation = correlations.length > 0 ? correlations.reduce((a, b) => a + b, 0) / correlations.length : 0;
  const volatility = correlations.length > 1 ? Math.sqrt(correlations.reduce((sum2, c) => sum2 + Math.pow(c - averageCorrelation, 2), 0) / (correlations.length - 1)) : 0;
  let trend = "stable";
  if (correlations.length >= 10) {
    const firstHalf = correlations.slice(0, Math.floor(correlations.length / 2));
    const secondHalf = correlations.slice(Math.floor(correlations.length / 2));
    const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
    const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
    if (secondAvg - firstAvg > 0.1) trend = "increasing";
    else if (firstAvg - secondAvg > 0.1) trend = "decreasing";
  }
  return {
    asset1,
    asset2,
    dataPoints,
    averageCorrelation,
    volatility,
    trend
  };
}
function analyzeCrossAssetCorrelations(assets, priceData) {
  const assetClasses = Array.from(new Set(assets.map((a) => a.assetClass)));
  const interClassCorrelations = {};
  const riskConcentrations = [];
  const assetsByClass = /* @__PURE__ */ new Map();
  assets.forEach((asset) => {
    const classAssets = assetsByClass.get(asset.assetClass) || [];
    classAssets.push(asset);
    assetsByClass.set(asset.assetClass, classAssets);
  });
  const classKeys = Array.from(assetsByClass.keys());
  for (let i = 0; i < classKeys.length; i++) {
    for (let j = i + 1; j < classKeys.length; j++) {
      const class1 = classKeys[i];
      const class2 = classKeys[j];
      const assets1 = assetsByClass.get(class1) || [];
      const assets2 = assetsByClass.get(class2) || [];
      let totalCorr = 0;
      let count2 = 0;
      for (const a1 of assets1) {
        for (const a2 of assets2) {
          const prices1 = priceData.get(a1.symbol) || [];
          const prices2 = priceData.get(a2.symbol) || [];
          if (prices1.length > 10 && prices2.length > 10) {
            const result = calculateCorrelation2(a1, prices1, a2, prices2);
            totalCorr += result.correlation;
            count2++;
            if (Math.abs(result.correlation) > 0.7) {
              riskConcentrations.push({
                assets: [a1, a2],
                correlation: result.correlation,
                risk: Math.abs(result.correlation) > 0.85 ? "high" : "medium"
              });
            }
          }
        }
      }
      if (count2 > 0) {
        interClassCorrelations[`${class1}-${class2}`] = totalCorr / count2;
      }
    }
  }
  const avgInterClassCorr = Object.values(interClassCorrelations).length > 0 ? Object.values(interClassCorrelations).reduce((a, b) => a + Math.abs(b), 0) / Object.values(interClassCorrelations).length : 0;
  const diversificationScore = Math.round((1 - avgInterClassCorr) * 100);
  const recommendations = [];
  if (diversificationScore < 40) {
    recommendations.push("Portfolio shows high correlation across asset classes. Consider adding uncorrelated assets.");
  }
  if (riskConcentrations.filter((r) => r.risk === "high").length > 0) {
    recommendations.push("High correlation detected between some assets. Review position sizing to manage concentration risk.");
  }
  const cryptoAssets = assets.filter((a) => a.assetClass === "crypto");
  const bondAssets = assets.filter((a) => a.assetClass === "bond");
  if (cryptoAssets.length > 0 && bondAssets.length === 0) {
    recommendations.push("Consider adding bonds for better diversification against crypto volatility.");
  }
  if (assetClasses.length < 3) {
    recommendations.push("Portfolio is concentrated in few asset classes. Consider expanding to more asset types.");
  }
  return {
    assetClasses,
    interClassCorrelations,
    diversificationScore,
    riskConcentrations,
    recommendations
  };
}
function analyzeRegimeCorrelations(assets, priceData, regimeData) {
  const regimes = ["bull", "bear", "crisis", "normal"];
  const results = [];
  for (const regime of regimes) {
    const regimePeriods = regimeData.filter((r) => r.regime === regime);
    if (regimePeriods.length < 10) {
      continue;
    }
    const correlations = [];
    for (let i = 0; i < assets.length; i++) {
      for (let j = i + 1; j < assets.length; j++) {
        const prices1 = priceData.get(assets[i].symbol) || [];
        const prices2 = priceData.get(assets[j].symbol) || [];
        if (prices1.length > 10 && prices2.length > 10) {
          const result = calculateCorrelation2(assets[i], prices1, assets[j], prices2, regime);
          correlations.push(result);
        }
      }
    }
    const avgCorrelation = correlations.length > 0 ? correlations.reduce((sum2, c) => sum2 + c.correlation, 0) / correlations.length : 0;
    let observation = "";
    if (regime === "crisis" && avgCorrelation > 0.6) {
      observation = "Correlations spike during crisis periods, reducing diversification benefits when needed most.";
    } else if (regime === "bull" && avgCorrelation > 0.5) {
      observation = "Assets tend to move together in bull markets.";
    } else if (regime === "bear" && avgCorrelation > 0.7) {
      observation = "High correlation in bear markets suggests limited downside protection.";
    } else {
      observation = `Average correlation of ${avgCorrelation.toFixed(2)} observed during ${regime} regime.`;
    }
    results.push({
      regime,
      correlations,
      averageCorrelation: avgCorrelation,
      observation
    });
  }
  return results;
}
function analyzePortfolioCorrelation(assets, weights, priceData) {
  if (assets.length !== weights.length) {
    throw new Error("Assets and weights must have the same length");
  }
  const correlationMatrix = calculateCorrelationMatrix3(assets, priceData);
  let portfolioVariance = 0;
  const correlationContribution = {};
  for (let i = 0; i < assets.length; i++) {
    for (let j = 0; j < assets.length; j++) {
      const contribution = weights[i] * weights[j] * correlationMatrix.matrix[i][j];
      portfolioVariance += contribution;
      if (i !== j) {
        const key = `${assets[i].symbol}-${assets[j].symbol}`;
        correlationContribution[key] = contribution;
      }
    }
  }
  const weightedAvgVol = weights.reduce((sum2, w) => sum2 + w, 0);
  const portfolioVol = Math.sqrt(portfolioVariance);
  const diversificationRatio = portfolioVol > 0 ? weightedAvgVol / portfolioVol : 1;
  const hhi = weights.reduce((sum2, w) => sum2 + w * w, 0);
  const effectiveAssets = hhi > 0 ? 1 / hhi : assets.length;
  const recommendations = [];
  if (diversificationRatio < 1.2) {
    recommendations.push("Low diversification ratio suggests high correlation between holdings.");
  }
  if (effectiveAssets < assets.length * 0.5) {
    recommendations.push("Portfolio is concentrated in few positions. Consider rebalancing for better diversification.");
  }
  const sortedContributions = Object.entries(correlationContribution).sort((a, b) => Math.abs(b[1]) - Math.abs(a[1])).slice(0, 3);
  if (sortedContributions.length > 0 && Math.abs(sortedContributions[0][1]) > 0.1) {
    recommendations.push(`Highest correlation impact: ${sortedContributions[0][0]} contributing ${(sortedContributions[0][1] * 100).toFixed(1)}% to portfolio variance.`);
  }
  return {
    assets,
    weights,
    portfolioVariance,
    diversificationRatio,
    effectiveAssets,
    correlationContribution,
    recommendations
  };
}
function findUncorrelatedAssets(currentAssets, candidateAssets, priceData, maxCorrelation = 0.3) {
  const uncorrelated = [];
  for (const candidate of candidateAssets) {
    const candidatePrices = priceData.get(candidate.symbol) || [];
    if (candidatePrices.length < 30) continue;
    let isUncorrelated = true;
    for (const current of currentAssets) {
      const currentPrices = priceData.get(current.symbol) || [];
      if (currentPrices.length < 30) continue;
      const result = calculateCorrelation2(current, currentPrices, candidate, candidatePrices);
      if (Math.abs(result.correlation) > maxCorrelation) {
        isUncorrelated = false;
        break;
      }
    }
    if (isUncorrelated) {
      uncorrelated.push(candidate);
    }
  }
  return uncorrelated;
}
function getDefaultAssets() {
  return [...DEFAULT_ASSETS];
}
function generateSamplePriceData(symbols, days = 252) {
  const priceData = /* @__PURE__ */ new Map();
  symbols.forEach((symbol) => {
    const prices = [];
    let price = 100 + Math.random() * 100;
    for (let i = 0; i < days; i++) {
      price = price * (1 + (Math.random() - 0.5) * 0.04);
      prices.push(price);
    }
    priceData.set(symbol, prices);
  });
  return priceData;
}
function interpretCorrelation(correlation2) {
  const absCorr = Math.abs(correlation2);
  const direction = correlation2 >= 0 ? "positive" : "negative";
  if (absCorr >= 0.8) {
    return `Very strong ${direction} correlation. Assets move almost in lockstep${direction === "negative" ? " but in opposite directions" : ""}.`;
  }
  if (absCorr >= 0.6) {
    return `Strong ${direction} correlation. Assets show significant co-movement.`;
  }
  if (absCorr >= 0.4) {
    return `Moderate ${direction} correlation. Some relationship exists but not dominant.`;
  }
  if (absCorr >= 0.2) {
    return `Weak ${direction} correlation. Limited relationship between assets.`;
  }
  return "Very weak or no correlation. Assets move independently.";
}
function calculateCorrelationStability(rollingCorrelation) {
  const { volatility, trend, averageCorrelation } = rollingCorrelation;
  let score = Math.max(0, 100 - volatility * 200);
  if (trend !== "stable") {
    score *= 0.8;
  }
  let interpretation = "";
  if (score >= 80) {
    interpretation = "Highly stable correlation. Reliable for portfolio construction.";
  } else if (score >= 60) {
    interpretation = "Moderately stable correlation. Monitor for changes.";
  } else if (score >= 40) {
    interpretation = "Unstable correlation. Use with caution in portfolio decisions.";
  } else {
    interpretation = "Very unstable correlation. Not reliable for diversification planning.";
  }
  return { score: Math.round(score), interpretation };
}
var DEFAULT_ASSETS;
var init_MultiAssetCorrelationEngine = __esm({
  "server/services/ai-agents/MultiAssetCorrelationEngine.ts"() {
    "use strict";
    DEFAULT_ASSETS = [
      // Stocks
      { symbol: "SPY", name: "S&P 500 ETF", assetClass: "etf", sector: "Index" },
      { symbol: "QQQ", name: "Nasdaq 100 ETF", assetClass: "etf", sector: "Tech" },
      { symbol: "AAPL", name: "Apple Inc.", assetClass: "stock", sector: "Technology" },
      { symbol: "MSFT", name: "Microsoft Corp.", assetClass: "stock", sector: "Technology" },
      { symbol: "GOOGL", name: "Alphabet Inc.", assetClass: "stock", sector: "Technology" },
      { symbol: "JPM", name: "JPMorgan Chase", assetClass: "stock", sector: "Finance" },
      { symbol: "XOM", name: "Exxon Mobil", assetClass: "stock", sector: "Energy" },
      // Crypto
      { symbol: "BTC", name: "Bitcoin", assetClass: "crypto" },
      { symbol: "ETH", name: "Ethereum", assetClass: "crypto" },
      { symbol: "SOL", name: "Solana", assetClass: "crypto" },
      // Forex
      { symbol: "EUR/USD", name: "Euro/US Dollar", assetClass: "forex" },
      { symbol: "GBP/USD", name: "British Pound/US Dollar", assetClass: "forex" },
      { symbol: "USD/JPY", name: "US Dollar/Japanese Yen", assetClass: "forex" },
      // Commodities
      { symbol: "GLD", name: "Gold", assetClass: "commodity" },
      { symbol: "SLV", name: "Silver", assetClass: "commodity" },
      { symbol: "USO", name: "Oil", assetClass: "commodity" },
      // Bonds
      { symbol: "TLT", name: "20+ Year Treasury", assetClass: "bond" },
      { symbol: "AGG", name: "Aggregate Bond", assetClass: "bond" }
    ];
  }
});

// server/services/ai-agents/SocialSentimentIntegration.ts
var SocialSentimentIntegration_exports = {};
__export(SocialSentimentIntegration_exports, {
  analyzePlatformSentiment: () => analyzePlatformSentiment,
  analyzeSentimentText: () => analyzeSentimentText,
  extractHashtags: () => extractHashtags,
  extractSymbols: () => extractSymbols,
  generateSamplePosts: () => generateSamplePosts,
  generateSentimentAlerts: () => generateSentimentAlerts,
  getDefaultConfig: () => getDefaultConfig2,
  getSentimentHeatmap: () => getSentimentHeatmap,
  getSentimentLabel: () => getSentimentLabel,
  getSymbolSentiment: () => getSymbolSentiment,
  getTrendingSymbols: () => getTrendingSymbols
});
function analyzeSentimentText(text2) {
  const lowerText = text2.toLowerCase();
  const bullishKeywords = [
    "buy",
    "long",
    "bullish",
    "moon",
    "rocket",
    "pump",
    "breakout",
    "undervalued",
    "accumulate",
    "hodl",
    "diamond hands",
    "to the moon",
    "ath",
    "all time high",
    "strong",
    "growth",
    "opportunity",
    "upside",
    "rally",
    "surge",
    "soar"
  ];
  const bearishKeywords = [
    "sell",
    "short",
    "bearish",
    "dump",
    "crash",
    "overvalued",
    "bubble",
    "puts",
    "downside",
    "weak",
    "decline",
    "drop",
    "fall",
    "plunge",
    "paper hands",
    "exit",
    "avoid",
    "warning",
    "risk",
    "correction"
  ];
  const neutralKeywords = [
    "hold",
    "wait",
    "sideways",
    "consolidation",
    "range",
    "uncertain",
    "mixed",
    "neutral",
    "watching",
    "monitoring"
  ];
  let bullishCount = 0;
  let bearishCount = 0;
  let neutralCount = 0;
  bullishKeywords.forEach((keyword) => {
    if (lowerText.includes(keyword)) bullishCount++;
  });
  bearishKeywords.forEach((keyword) => {
    if (lowerText.includes(keyword)) bearishCount++;
  });
  neutralKeywords.forEach((keyword) => {
    if (lowerText.includes(keyword)) neutralCount++;
  });
  const total = bullishCount + bearishCount + neutralCount;
  if (total === 0) {
    return { score: 0, confidence: 0.3 };
  }
  const netSentiment = (bullishCount - bearishCount) / total;
  const confidence = Math.min(0.95, 0.5 + total * 0.05);
  let score;
  if (netSentiment >= 0.6) score = 1;
  else if (netSentiment >= 0.2) score = 0.5;
  else if (netSentiment <= -0.6) score = -1;
  else if (netSentiment <= -0.2) score = -0.5;
  else score = 0;
  return { score, confidence };
}
function getSentimentLabel(score) {
  if (score >= 0.6) return "very_bullish";
  if (score >= 0.2) return "bullish";
  if (score <= -0.6) return "very_bearish";
  if (score <= -0.2) return "bearish";
  return "neutral";
}
function extractSymbols(text2) {
  const dollarPattern = /\$([A-Z]{1,5})\b/g;
  const matches = text2.match(dollarPattern) || [];
  return matches.map((m) => m.replace("$", "").toUpperCase());
}
function extractHashtags(text2) {
  const hashtagPattern = /#(\w+)/g;
  const matches = text2.match(hashtagPattern) || [];
  return matches.map((m) => m.replace("#", "").toLowerCase());
}
function generateSamplePosts(symbol, count2 = 50) {
  const platforms = ["twitter", "reddit", "stocktwits", "discord", "telegram"];
  const posts = [];
  const sampleContents = [
    `$${symbol} looking strong today! \u{1F680} Breaking out of resistance`,
    `Just bought more $${symbol}. This is undervalued at current levels`,
    `$${symbol} earnings coming up. Expecting big numbers`,
    `Sold my $${symbol} position. Taking profits here`,
    `$${symbol} chart looks bearish. Be careful`,
    `Diamond hands on $${symbol} \u{1F48E}\u{1F64C}`,
    `$${symbol} to the moon! \u{1F319}`,
    `Bearish on $${symbol}. Overvalued imo`,
    `$${symbol} consolidating. Waiting for breakout`,
    `Added $${symbol} to my watchlist. Interesting setup`,
    `$${symbol} volume picking up. Something brewing?`,
    `Long $${symbol} calls for next month`,
    `$${symbol} support holding strong at current levels`,
    `Neutral on $${symbol} here. Need more data`,
    `$${symbol} fundamentals look solid for long term`
  ];
  const now = Date.now();
  for (let i = 0; i < count2; i++) {
    const platform = platforms[Math.floor(Math.random() * platforms.length)];
    const content = sampleContents[Math.floor(Math.random() * sampleContents.length)];
    const { score, confidence } = analyzeSentimentText(content);
    const isInfluencer = Math.random() < 0.1;
    const followerCount = isInfluencer ? Math.floor(Math.random() * 9e5) + 1e5 : Math.floor(Math.random() * 1e4);
    posts.push({
      id: `post_${i}_${Date.now()}`,
      platform,
      author: `user_${Math.floor(Math.random() * 1e4)}`,
      content,
      timestamp: now - Math.floor(Math.random() * 864e5),
      // Last 24 hours
      likes: Math.floor(Math.random() * 1e3),
      shares: Math.floor(Math.random() * 200),
      comments: Math.floor(Math.random() * 100),
      sentiment: score,
      sentimentLabel: getSentimentLabel(score),
      relevanceScore: confidence,
      symbols: extractSymbols(content),
      hashtags: extractHashtags(content),
      isInfluencer,
      followerCount
    });
  }
  return posts.sort((a, b) => b.timestamp - a.timestamp);
}
function analyzePlatformSentiment(posts, platform) {
  const platformPosts = posts.filter((p) => p.platform === platform);
  if (platformPosts.length === 0) {
    return {
      platform,
      overallSentiment: 0,
      sentimentLabel: "neutral",
      postCount: 0,
      uniqueAuthors: 0,
      engagementScore: 0,
      influencerSentiment: 0,
      retailSentiment: 0,
      trendDirection: "stable",
      volumeChange24h: 0,
      topPosts: [],
      keyTopics: [],
      lastUpdated: Date.now()
    };
  }
  let totalWeight = 0;
  let weightedSentiment = 0;
  let influencerSentiment = 0;
  let influencerCount = 0;
  let retailSentiment = 0;
  let retailCount = 0;
  platformPosts.forEach((post) => {
    const weight = 1 + Math.log10(1 + post.likes + post.shares * 2 + post.comments);
    totalWeight += weight;
    weightedSentiment += post.sentiment * weight;
    if (post.isInfluencer) {
      influencerSentiment += post.sentiment;
      influencerCount++;
    } else {
      retailSentiment += post.sentiment;
      retailCount++;
    }
  });
  const overallSentiment = totalWeight > 0 ? weightedSentiment / totalWeight : 0;
  const uniqueAuthors = new Set(platformPosts.map((p) => p.author)).size;
  const totalEngagement = platformPosts.reduce((sum2, p) => sum2 + p.likes + p.shares + p.comments, 0);
  const engagementScore = totalEngagement / platformPosts.length;
  const topPosts = [...platformPosts].sort((a, b) => b.likes + b.shares + b.comments - (a.likes + a.shares + a.comments)).slice(0, 5);
  const hashtagCounts = {};
  platformPosts.forEach((post) => {
    post.hashtags.forEach((tag) => {
      hashtagCounts[tag] = (hashtagCounts[tag] || 0) + 1;
    });
  });
  const keyTopics = Object.entries(hashtagCounts).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([tag]) => tag);
  const recentPosts = platformPosts.filter((p) => p.timestamp > Date.now() - 36e5);
  const olderPosts = platformPosts.filter((p) => p.timestamp <= Date.now() - 36e5);
  const recentAvg = recentPosts.length > 0 ? recentPosts.reduce((sum2, p) => sum2 + p.sentiment, 0) / recentPosts.length : 0;
  const olderAvg = olderPosts.length > 0 ? olderPosts.reduce((sum2, p) => sum2 + p.sentiment, 0) / olderPosts.length : 0;
  let trendDirection = "stable";
  if (recentAvg - olderAvg > 0.2) trendDirection = "rising";
  else if (olderAvg - recentAvg > 0.2) trendDirection = "falling";
  return {
    platform,
    overallSentiment: Math.round(overallSentiment * 100) / 100,
    sentimentLabel: getSentimentLabel(overallSentiment),
    postCount: platformPosts.length,
    uniqueAuthors,
    engagementScore: Math.round(engagementScore),
    influencerSentiment: influencerCount > 0 ? Math.round(influencerSentiment / influencerCount * 100) / 100 : 0,
    retailSentiment: retailCount > 0 ? Math.round(retailSentiment / retailCount * 100) / 100 : 0,
    trendDirection,
    volumeChange24h: Math.round((Math.random() - 0.3) * 100),
    topPosts,
    keyTopics,
    lastUpdated: Date.now()
  };
}
function getSymbolSentiment(symbol) {
  const posts = generateSamplePosts(symbol, 100);
  const platforms = ["twitter", "reddit", "stocktwits", "discord", "telegram"];
  const platformBreakdown = platforms.map(
    (platform) => analyzePlatformSentiment(posts, platform)
  );
  const totalPosts = platformBreakdown.reduce((sum2, p) => sum2 + p.postCount, 0);
  const weightedSentiment = platformBreakdown.reduce(
    (sum2, p) => sum2 + p.overallSentiment * p.postCount,
    0
  );
  const overallSentiment = totalPosts > 0 ? weightedSentiment / totalPosts : 0;
  const sentimentTrend = [];
  const now = Date.now();
  for (let i = 24; i >= 0; i--) {
    const timestamp2 = now - i * 36e5;
    platforms.forEach((platform) => {
      sentimentTrend.push({
        timestamp: timestamp2,
        sentiment: overallSentiment + (Math.random() - 0.5) * 0.3,
        volume: Math.floor(Math.random() * 100) + 10,
        platform
      });
    });
  }
  const influencerPosts = posts.filter((p) => p.isInfluencer);
  const topInfluencers = influencerPosts.sort((a, b) => b.followerCount - a.followerCount).slice(0, 5).map((p) => ({
    author: p.author,
    platform: p.platform,
    sentiment: p.sentiment,
    followers: p.followerCount,
    engagement: p.likes + p.shares + p.comments
  }));
  const symbolCounts = {};
  posts.forEach((post) => {
    post.symbols.forEach((s) => {
      if (s !== symbol) {
        symbolCounts[s] = (symbolCounts[s] || 0) + 1;
      }
    });
  });
  const relatedSymbols = Object.entries(symbolCounts).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([sym, count2]) => ({
    symbol: sym,
    correlation: Math.random() * 0.5 + 0.3,
    coMentions: count2
  }));
  const keyNarratives = [
    `Strong institutional interest in ${symbol}`,
    `Technical breakout expected`,
    `Earnings anticipation driving sentiment`,
    `Sector rotation favoring ${symbol}`,
    `Retail momentum building`
  ].slice(0, 3);
  const riskSignals = [];
  if (overallSentiment > 0.7) {
    riskSignals.push("Extreme bullish sentiment may indicate overbought conditions");
  }
  if (overallSentiment < -0.7) {
    riskSignals.push("Extreme bearish sentiment may indicate oversold conditions");
  }
  const controversyScore = Math.abs(
    platformBreakdown.reduce((sum2, p) => sum2 + p.influencerSentiment - p.retailSentiment, 0)
  ) / platforms.length;
  if (controversyScore > 0.3) {
    riskSignals.push("Divergence between influencer and retail sentiment");
  }
  const buzzScore = Math.min(100, Math.floor(totalPosts / 20 * 100));
  const recentTrend = sentimentTrend.slice(-5);
  const olderTrend = sentimentTrend.slice(-10, -5);
  const recentAvg = recentTrend.reduce((sum2, t2) => sum2 + t2.sentiment, 0) / recentTrend.length;
  const olderAvg = olderTrend.reduce((sum2, t2) => sum2 + t2.sentiment, 0) / olderTrend.length;
  const sentimentMomentum = Math.round((recentAvg - olderAvg) * 100);
  return {
    symbol,
    name: getSymbolName(symbol),
    overallSentiment: Math.round(overallSentiment * 100) / 100,
    sentimentLabel: getSentimentLabel(overallSentiment),
    confidence: 0.75 + Math.random() * 0.2,
    platformBreakdown,
    sentimentTrend,
    socialVolume: totalPosts,
    volumeChange24h: Math.round((Math.random() - 0.3) * 100),
    mentionCount: totalPosts * 3,
    uniqueMentioners: new Set(posts.map((p) => p.author)).size,
    influencerMentions: influencerPosts.length,
    sentimentMomentum,
    buzzScore,
    controversyScore: Math.round(controversyScore * 100) / 100,
    topInfluencers,
    relatedSymbols,
    keyNarratives,
    riskSignals,
    lastUpdated: Date.now()
  };
}
function getSymbolName(symbol) {
  const names = {
    "AAPL": "Apple Inc.",
    "MSFT": "Microsoft Corporation",
    "GOOGL": "Alphabet Inc.",
    "AMZN": "Amazon.com Inc.",
    "TSLA": "Tesla Inc.",
    "META": "Meta Platforms Inc.",
    "NVDA": "NVIDIA Corporation",
    "BTC": "Bitcoin",
    "ETH": "Ethereum",
    "SPY": "SPDR S&P 500 ETF",
    "QQQ": "Invesco QQQ Trust"
  };
  return names[symbol] || symbol;
}
function generateSentimentAlerts(symbol, previousSentiment, currentSentiment) {
  const alerts = [];
  const now = Date.now();
  if (previousSentiment) {
    const sentimentChange = currentSentiment.overallSentiment - previousSentiment.overallSentiment;
    const changePercent = Math.abs(sentimentChange) * 100;
    if (sentimentChange > 0.3) {
      alerts.push({
        id: `alert_${now}_spike`,
        symbol,
        alertType: "sentiment_spike",
        severity: sentimentChange > 0.5 ? "high" : "medium",
        title: `Sentiment Spike for ${symbol}`,
        description: `Social sentiment for ${symbol} has increased significantly`,
        previousValue: previousSentiment.overallSentiment,
        currentValue: currentSentiment.overallSentiment,
        changePercent,
        platform: "all",
        timestamp: now,
        isRead: false
      });
    } else if (sentimentChange < -0.3) {
      alerts.push({
        id: `alert_${now}_crash`,
        symbol,
        alertType: "sentiment_crash",
        severity: sentimentChange < -0.5 ? "high" : "medium",
        title: `Sentiment Drop for ${symbol}`,
        description: `Social sentiment for ${symbol} has decreased significantly`,
        previousValue: previousSentiment.overallSentiment,
        currentValue: currentSentiment.overallSentiment,
        changePercent,
        platform: "all",
        timestamp: now,
        isRead: false
      });
    }
    if (currentSentiment.volumeChange24h > 100) {
      alerts.push({
        id: `alert_${now}_volume`,
        symbol,
        alertType: "volume_surge",
        severity: currentSentiment.volumeChange24h > 200 ? "high" : "medium",
        title: `Social Volume Surge for ${symbol}`,
        description: `Social media mentions of ${symbol} have surged ${currentSentiment.volumeChange24h}%`,
        previousValue: 100,
        currentValue: 100 + currentSentiment.volumeChange24h,
        changePercent: currentSentiment.volumeChange24h,
        platform: "all",
        timestamp: now,
        isRead: false
      });
    }
  }
  if (currentSentiment.influencerMentions > 5) {
    alerts.push({
      id: `alert_${now}_influencer`,
      symbol,
      alertType: "influencer_mention",
      severity: "low",
      title: `Influencer Activity for ${symbol}`,
      description: `${currentSentiment.influencerMentions} influencers have mentioned ${symbol}`,
      previousValue: 0,
      currentValue: currentSentiment.influencerMentions,
      changePercent: 0,
      platform: "all",
      timestamp: now,
      isRead: false
    });
  }
  if (currentSentiment.controversyScore > 0.4) {
    alerts.push({
      id: `alert_${now}_controversy`,
      symbol,
      alertType: "controversy",
      severity: currentSentiment.controversyScore > 0.6 ? "high" : "medium",
      title: `Sentiment Controversy for ${symbol}`,
      description: `Significant divergence between influencer and retail sentiment`,
      previousValue: 0,
      currentValue: currentSentiment.controversyScore,
      changePercent: currentSentiment.controversyScore * 100,
      platform: "all",
      timestamp: now,
      isRead: false
    });
  }
  return alerts;
}
function getTrendingSymbols(limit = 10) {
  const symbols = ["AAPL", "MSFT", "GOOGL", "TSLA", "NVDA", "META", "AMZN", "BTC", "ETH", "SPY", "QQQ", "AMD", "NFLX", "DIS"];
  return symbols.slice(0, limit).map((symbol) => {
    const sentiment = (Math.random() - 0.3) * 2;
    return {
      symbol,
      name: getSymbolName(symbol),
      sentiment: Math.round(sentiment * 100) / 100,
      sentimentLabel: getSentimentLabel(sentiment),
      volume: Math.floor(Math.random() * 5e3) + 500,
      volumeChange: Math.round((Math.random() - 0.3) * 200),
      buzzScore: Math.floor(Math.random() * 100)
    };
  }).sort((a, b) => b.buzzScore - a.buzzScore);
}
function getSentimentHeatmap() {
  const symbols = ["AAPL", "MSFT", "GOOGL", "TSLA", "NVDA", "META"];
  const platforms = ["twitter", "reddit", "stocktwits"];
  const data = [];
  symbols.forEach((symbol) => {
    platforms.forEach((platform) => {
      data.push({
        symbol,
        platform,
        sentiment: Math.round((Math.random() - 0.3) * 2 * 100) / 100,
        volume: Math.floor(Math.random() * 1e3) + 100
      });
    });
  });
  return data;
}
function getDefaultConfig2() {
  return {
    platforms: ["twitter", "reddit", "stocktwits"],
    refreshInterval: 3e5,
    // 5 minutes
    alertThresholds: {
      sentimentChange: 0.3,
      volumeChange: 100,
      influencerThreshold: 1e5
    },
    watchlist: ["AAPL", "MSFT", "GOOGL", "TSLA", "BTC", "ETH"]
  };
}
var init_SocialSentimentIntegration = __esm({
  "server/services/ai-agents/SocialSentimentIntegration.ts"() {
    "use strict";
  }
});

// server/services/ai-agents/PortfolioStressTesting.ts
var PortfolioStressTesting_exports = {};
__export(PortfolioStressTesting_exports, {
  CRISIS_SCENARIOS: () => CRISIS_SCENARIOS,
  calculateVaR: () => calculateVaR,
  compareStressTests: () => compareStressTests,
  getAvailableScenarios: () => getAvailableScenarios,
  getSamplePortfolio: () => getSamplePortfolio,
  runHistoricalScenario: () => runHistoricalScenario,
  runMonteCarloSimulation: () => runMonteCarloSimulation2,
  runSensitivityAnalysis: () => runSensitivityAnalysis
});
function runMonteCarloSimulation2(portfolio, config) {
  const portfolioValue = portfolio.reduce((sum2, h) => sum2 + h.quantity * h.currentPrice, 0);
  const simulations = [];
  for (let i = 0; i < config.simulations; i++) {
    let simulatedValue = portfolioValue;
    for (let day = 0; day < config.timeHorizon; day++) {
      portfolio.forEach((holding) => {
        const dailyReturn = generateRandomReturn(
          holding.volatility * config.volatilityMultiplier,
          1e-4
          // Small positive drift
        );
        simulatedValue += simulatedValue * (holding.weight / 100) * dailyReturn;
      });
    }
    simulations.push(simulatedValue);
  }
  simulations.sort((a, b) => a - b);
  const mean5 = simulations.reduce((a, b) => a + b, 0) / simulations.length;
  const worstCase = simulations[0];
  const bestCase = simulations[simulations.length - 1];
  const varIndex = Math.floor((1 - config.confidenceLevel) * config.simulations);
  const valueAtRisk = portfolioValue - simulations[varIndex];
  const tailSimulations = simulations.slice(0, varIndex);
  const conditionalVaR = portfolioValue - tailSimulations.reduce((a, b) => a + b, 0) / tailSimulations.length;
  const distribution = [1, 5, 10, 25, 50, 75, 90, 95, 99].map((p) => {
    const index = Math.floor(p / 100 * config.simulations);
    const value = simulations[index];
    return {
      percentile: p,
      value,
      loss: portfolioValue - value
    };
  });
  const assetImpacts = portfolio.map((holding) => {
    const holdingValue = holding.quantity * holding.currentPrice;
    const expectedLoss = holdingValue * (1 - mean5 / portfolioValue);
    return {
      symbol: holding.symbol,
      currentValue: holdingValue,
      stressedValue: holdingValue - expectedLoss,
      loss: expectedLoss,
      lossPercent: expectedLoss / holdingValue * 100,
      contribution: expectedLoss / (portfolioValue - mean5) * 100
    };
  });
  const lossPercent = (portfolioValue - mean5) / portfolioValue * 100;
  let riskLevel = "low";
  if (lossPercent > 30) riskLevel = "extreme";
  else if (lossPercent > 20) riskLevel = "high";
  else if (lossPercent > 10) riskLevel = "moderate";
  const recommendations = generateRecommendations2(portfolio, lossPercent, assetImpacts);
  return {
    id: `mc_${Date.now()}`,
    type: "monte_carlo",
    timestamp: Date.now(),
    portfolio,
    portfolioValue,
    expectedLoss: portfolioValue - mean5,
    expectedLossPercent: lossPercent,
    worstCase,
    worstCasePercent: (portfolioValue - worstCase) / portfolioValue * 100,
    bestCase,
    bestCasePercent: (bestCase - portfolioValue) / portfolioValue * 100,
    valueAtRisk,
    conditionalVaR,
    maxDrawdown: (portfolioValue - worstCase) / portfolioValue * 100,
    recoveryTime: Math.ceil(config.timeHorizon * (lossPercent / 10)),
    distribution,
    assetImpacts,
    recommendations,
    riskLevel
  };
}
function runHistoricalScenario(portfolio, scenario) {
  const config = CRISIS_SCENARIOS[scenario];
  const portfolioValue = portfolio.reduce((sum2, h) => sum2 + h.quantity * h.currentPrice, 0);
  const assetImpacts = portfolio.map((holding) => {
    const holdingValue = holding.quantity * holding.currentPrice;
    const impact = config.assetImpacts[holding.assetClass] || config.assetImpacts["stock"] || -0.3;
    const stressedValue = holdingValue * (1 + impact);
    const loss = holdingValue - stressedValue;
    return {
      symbol: holding.symbol,
      currentValue: holdingValue,
      stressedValue,
      loss,
      lossPercent: loss / holdingValue * 100,
      contribution: 0
      // Will be calculated after
    };
  });
  const totalLoss = assetImpacts.reduce((sum2, a) => sum2 + a.loss, 0);
  assetImpacts.forEach((a) => {
    a.contribution = totalLoss > 0 ? a.loss / totalLoss * 100 : 0;
  });
  const stressedPortfolioValue = portfolioValue - totalLoss;
  const lossPercent = totalLoss / portfolioValue * 100;
  const distribution = [1, 5, 10, 25, 50, 75, 90, 95, 99].map((p) => {
    const factor = 1 - p / 100 * (totalLoss / portfolioValue);
    const value = portfolioValue * factor;
    return {
      percentile: p,
      value,
      loss: portfolioValue - value
    };
  });
  let riskLevel = "low";
  if (lossPercent > 40) riskLevel = "extreme";
  else if (lossPercent > 25) riskLevel = "high";
  else if (lossPercent > 15) riskLevel = "moderate";
  const recommendations = generateRecommendations2(portfolio, lossPercent, assetImpacts);
  return {
    id: `hist_${Date.now()}`,
    type: "historical",
    timestamp: Date.now(),
    portfolio,
    portfolioValue,
    expectedLoss: totalLoss,
    expectedLossPercent: lossPercent,
    worstCase: stressedPortfolioValue * 0.85,
    worstCasePercent: lossPercent + 15,
    bestCase: stressedPortfolioValue * 1.1,
    bestCasePercent: Math.max(0, lossPercent - 10),
    valueAtRisk: totalLoss * 0.95,
    conditionalVaR: totalLoss * 1.2,
    maxDrawdown: Math.abs(config.peakToTrough),
    recoveryTime: config.recoveryDays,
    distribution,
    assetImpacts,
    scenario,
    scenarioName: config.name,
    recommendations,
    riskLevel
  };
}
function runSensitivityAnalysis(portfolio, factors) {
  const portfolioValue = portfolio.reduce((sum2, h) => sum2 + h.quantity * h.currentPrice, 0);
  return factors.map((factor) => {
    const changes = [-20, -15, -10, -5, 0, 5, 10, 15, 20];
    const impacts = changes.map((change) => {
      let portfolioChange = 0;
      switch (factor) {
        case "market":
          portfolioChange = change * 1;
          break;
        case "interest_rate":
          portfolioChange = portfolio.reduce((sum2, h) => {
            if (h.assetClass === "bond") return sum2 - change * 0.5 * (h.weight / 100);
            if (h.assetClass === "stock") return sum2 - change * 0.1 * (h.weight / 100);
            return sum2;
          }, 0);
          break;
        case "volatility":
          portfolioChange = change * -0.3;
          break;
        case "currency":
          portfolioChange = change * 0.2;
          break;
        case "inflation":
          portfolioChange = portfolio.reduce((sum2, h) => {
            if (h.assetClass === "commodity") return sum2 + change * 0.3 * (h.weight / 100);
            if (h.assetClass === "bond") return sum2 - change * 0.4 * (h.weight / 100);
            return sum2 - change * 0.1 * (h.weight / 100);
          }, 0);
          break;
        default:
          portfolioChange = change * 0.5;
      }
      return {
        change,
        portfolioChange,
        portfolioValue: portfolioValue * (1 + portfolioChange / 100)
      };
    });
    return {
      factor,
      baseValue: portfolioValue,
      impacts
    };
  });
}
function calculateVaR(portfolio, confidenceLevel = 0.95, timeHorizon = 1) {
  const portfolioValue = portfolio.reduce((sum2, h) => sum2 + h.quantity * h.currentPrice, 0);
  const portfolioVolatility = Math.sqrt(
    portfolio.reduce((sum2, h) => sum2 + Math.pow(h.volatility * h.weight / 100, 2), 0)
  );
  const zScore = confidenceLevel === 0.99 ? 2.33 : confidenceLevel === 0.95 ? 1.65 : 1.28;
  const varAmount = portfolioValue * portfolioVolatility * zScore * Math.sqrt(timeHorizon / 252);
  return {
    var: varAmount,
    varPercent: varAmount / portfolioValue * 100,
    method: "parametric"
  };
}
function generateRandomReturn(volatility, drift) {
  const u1 = Math.random();
  const u2 = Math.random();
  const z3 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  return drift + volatility * z3 / Math.sqrt(252);
}
function generateRecommendations2(portfolio, lossPercent, assetImpacts) {
  const recommendations = [];
  const topContributor = assetImpacts.reduce((max, a) => a.contribution > max.contribution ? a : max);
  if (topContributor.contribution > 30) {
    recommendations.push(`Consider reducing exposure to ${topContributor.symbol} (${topContributor.contribution.toFixed(1)}% of risk)`);
  }
  const assetClasses = new Set(portfolio.map((h) => h.assetClass));
  if (assetClasses.size < 3) {
    recommendations.push("Increase diversification across asset classes to reduce concentration risk");
  }
  const hasDefensive = portfolio.some((h) => h.assetClass === "bond" || h.assetClass === "gold");
  if (!hasDefensive && lossPercent > 15) {
    recommendations.push("Consider adding defensive assets (bonds, gold) to hedge downside risk");
  }
  const avgBeta = portfolio.reduce((sum2, h) => sum2 + h.beta * h.weight / 100, 0);
  if (avgBeta > 1.2) {
    recommendations.push(`Portfolio beta (${avgBeta.toFixed(2)}) is high. Consider lower-beta positions`);
  }
  const highVolAssets = portfolio.filter((h) => h.volatility > 0.4);
  if (highVolAssets.length > portfolio.length / 2) {
    recommendations.push("High proportion of volatile assets. Consider rebalancing to lower volatility");
  }
  if (lossPercent > 30) {
    recommendations.push("CRITICAL: Portfolio shows extreme stress vulnerability. Immediate risk reduction recommended");
  } else if (lossPercent > 20) {
    recommendations.push("Portfolio shows significant stress vulnerability. Review position sizing");
  }
  return recommendations;
}
function getSamplePortfolio() {
  return [
    { symbol: "AAPL", name: "Apple Inc.", quantity: 50, currentPrice: 180, weight: 25, assetClass: "stock", beta: 1.2, volatility: 0.28 },
    { symbol: "MSFT", name: "Microsoft", quantity: 30, currentPrice: 370, weight: 30, assetClass: "stock", beta: 1.1, volatility: 0.25 },
    { symbol: "GOOGL", name: "Alphabet", quantity: 10, currentPrice: 140, weight: 10, assetClass: "stock", beta: 1.15, volatility: 0.3 },
    { symbol: "BND", name: "Bond ETF", quantity: 100, currentPrice: 75, weight: 20, assetClass: "bond", beta: 0.1, volatility: 0.05 },
    { symbol: "GLD", name: "Gold ETF", quantity: 25, currentPrice: 180, weight: 15, assetClass: "gold", beta: 0, volatility: 0.15 }
  ];
}
function getAvailableScenarios() {
  return Object.values(CRISIS_SCENARIOS).filter((s) => s.id !== "custom");
}
function compareStressTests(results) {
  const comparison = results.map((r) => ({
    id: r.id,
    type: r.type,
    scenario: r.scenarioName,
    expectedLoss: r.expectedLossPercent,
    worstCase: r.worstCasePercent,
    riskLevel: r.riskLevel
  }));
  const losses = results.map((r) => r.expectedLossPercent);
  const maxLossResult = results.reduce((max, r) => r.expectedLossPercent > max.expectedLossPercent ? r : max);
  return {
    comparison,
    summary: {
      averageLoss: losses.reduce((a, b) => a + b, 0) / losses.length,
      maxLoss: Math.max(...losses),
      minLoss: Math.min(...losses),
      mostVulnerableScenario: maxLossResult.scenarioName || "Monte Carlo"
    }
  };
}
var CRISIS_SCENARIOS;
var init_PortfolioStressTesting = __esm({
  "server/services/ai-agents/PortfolioStressTesting.ts"() {
    "use strict";
    CRISIS_SCENARIOS = {
      financial_crisis_2008: {
        id: "financial_crisis_2008",
        name: "2008 Financial Crisis",
        description: "Global financial crisis triggered by subprime mortgage collapse",
        startDate: "2008-09-15",
        endDate: "2009-03-09",
        peakToTrough: -56.8,
        recoveryDays: 1400,
        assetImpacts: {
          stock: -0.55,
          bond: 0.05,
          gold: 0.25,
          crypto: -0.8,
          real_estate: -0.35,
          commodity: -0.4
        },
        characteristics: [
          "Credit market freeze",
          "Bank failures",
          "Housing market collapse",
          "Global contagion"
        ]
      },
      covid_crash_2020: {
        id: "covid_crash_2020",
        name: "COVID-19 Crash",
        description: "Market crash due to global pandemic",
        startDate: "2020-02-19",
        endDate: "2020-03-23",
        peakToTrough: -33.9,
        recoveryDays: 148,
        assetImpacts: {
          stock: -0.35,
          bond: 0.08,
          gold: 0.1,
          crypto: -0.5,
          real_estate: -0.15,
          commodity: -0.6
        },
        characteristics: [
          "Rapid decline",
          "V-shaped recovery",
          "Unprecedented stimulus",
          "Sector divergence"
        ]
      },
      dot_com_bubble_2000: {
        id: "dot_com_bubble_2000",
        name: "Dot-Com Bubble",
        description: "Technology stock bubble burst",
        startDate: "2000-03-10",
        endDate: "2002-10-09",
        peakToTrough: -78,
        recoveryDays: 5e3,
        assetImpacts: {
          stock: -0.5,
          tech_stock: -0.78,
          bond: 0.15,
          gold: 0.05,
          crypto: -0.9,
          real_estate: 0.1,
          commodity: -0.1
        },
        characteristics: [
          "Tech sector devastation",
          "Prolonged bear market",
          "Value rotation",
          "IPO collapse"
        ]
      },
      black_monday_1987: {
        id: "black_monday_1987",
        name: "Black Monday 1987",
        description: "Single-day market crash",
        startDate: "1987-10-19",
        endDate: "1987-10-19",
        peakToTrough: -22.6,
        recoveryDays: 450,
        assetImpacts: {
          stock: -0.23,
          bond: 0.03,
          gold: 0.02,
          crypto: -0.3,
          real_estate: -0.05,
          commodity: -0.1
        },
        characteristics: [
          "Single-day crash",
          "Program trading",
          "Global contagion",
          "Quick recovery"
        ]
      },
      flash_crash_2010: {
        id: "flash_crash_2010",
        name: "Flash Crash 2010",
        description: "Rapid intraday market crash",
        startDate: "2010-05-06",
        endDate: "2010-05-06",
        peakToTrough: -9.2,
        recoveryDays: 1,
        assetImpacts: {
          stock: -0.09,
          bond: 0.01,
          gold: 0.01,
          crypto: -0.15,
          real_estate: 0,
          commodity: -0.05
        },
        characteristics: [
          "Algorithmic trading",
          "Liquidity crisis",
          "Rapid recovery",
          "Market structure issues"
        ]
      },
      european_debt_2011: {
        id: "european_debt_2011",
        name: "European Debt Crisis",
        description: "Sovereign debt crisis in Europe",
        startDate: "2011-07-22",
        endDate: "2011-10-03",
        peakToTrough: -19.4,
        recoveryDays: 180,
        assetImpacts: {
          stock: -0.2,
          bond: -0.05,
          gold: 0.15,
          crypto: -0.4,
          real_estate: -0.1,
          commodity: -0.15
        },
        characteristics: [
          "Sovereign debt concerns",
          "Banking stress",
          "Currency volatility",
          "Flight to safety"
        ]
      },
      china_crash_2015: {
        id: "china_crash_2015",
        name: "China Stock Crash 2015",
        description: "Chinese stock market bubble burst",
        startDate: "2015-06-12",
        endDate: "2016-02-11",
        peakToTrough: -49,
        recoveryDays: 800,
        assetImpacts: {
          stock: -0.15,
          emerging_stock: -0.35,
          bond: 0.05,
          gold: 0.08,
          crypto: -0.25,
          commodity: -0.3
        },
        characteristics: [
          "Emerging market contagion",
          "Currency devaluation",
          "Commodity collapse",
          "Global growth fears"
        ]
      },
      volmageddon_2018: {
        id: "volmageddon_2018",
        name: "Volmageddon 2018",
        description: "Volatility spike causing short vol strategies to collapse",
        startDate: "2018-02-02",
        endDate: "2018-02-09",
        peakToTrough: -10.2,
        recoveryDays: 60,
        assetImpacts: {
          stock: -0.1,
          bond: 0.02,
          gold: 0.01,
          crypto: -0.2,
          volatility: 1.15,
          commodity: -0.05
        },
        characteristics: [
          "Volatility spike",
          "Short vol blowup",
          "Algorithmic selling",
          "Quick recovery"
        ]
      },
      custom: {
        id: "custom",
        name: "Custom Scenario",
        description: "User-defined stress scenario",
        startDate: "",
        endDate: "",
        peakToTrough: 0,
        recoveryDays: 0,
        assetImpacts: {},
        characteristics: []
      }
    };
  }
});

// server/services/ai-agents/AgentPerformanceLeaderboard.ts
var AgentPerformanceLeaderboard_exports = {};
__export(AgentPerformanceLeaderboard_exports, {
  compareAgents: () => compareAgents,
  getAgentDetails: () => getAgentDetails,
  getAgentRankingsHistory: () => getAgentRankingsHistory,
  getAgentTypes: () => getAgentTypes,
  getAllBadges: () => getAllBadges,
  getLeaderboard: () => getLeaderboard2,
  getLeaderboardStats: () => getLeaderboardStats,
  getMarketConditions: () => getMarketConditions,
  getTopPerformersByCondition: () => getTopPerformersByCondition
});
function generateAgentPerformance(agentDef, timeFrame) {
  const timeMultiplier = getTimeMultiplier(timeFrame);
  const baseSignals = Math.floor(50 * timeMultiplier);
  const randomFactor = 0.9 + Math.random() * 0.2;
  const accuracy = Math.min(0.95, agentDef.baseAccuracy * randomFactor);
  const avgReturn = agentDef.baseReturn * randomFactor;
  const totalSignals = baseSignals + Math.floor(Math.random() * 20);
  const accurateSignals = Math.floor(totalSignals * accuracy);
  const conditionPerformance = {};
  const conditionRanks = {};
  const conditions = [
    "bull_market",
    "bear_market",
    "high_volatility",
    "low_volatility",
    "trending",
    "ranging",
    "crash",
    "recovery"
  ];
  conditions.forEach((condition, index) => {
    const isStrength = agentDef.strengths.includes(condition);
    const conditionAccuracy = isStrength ? accuracy * (1.05 + Math.random() * 0.1) : accuracy * (0.85 + Math.random() * 0.1);
    conditionPerformance[condition] = {
      condition,
      signalCount: Math.floor(totalSignals / conditions.length * (0.8 + Math.random() * 0.4)),
      accuracy: Math.min(0.95, conditionAccuracy),
      avgReturn: isStrength ? avgReturn * 1.2 : avgReturn * 0.8,
      sharpeRatio: isStrength ? 1.5 + Math.random() * 1.5 : 0.5 + Math.random() * 1,
      rank: isStrength ? Math.floor(Math.random() * 3) + 1 : Math.floor(Math.random() * 5) + 3
    };
    conditionRanks[condition] = conditionPerformance[condition].rank;
  });
  const recentSignals = [];
  const symbols = ["AAPL", "MSFT", "GOOGL", "TSLA", "NVDA", "META", "AMZN"];
  for (let i = 0; i < 10; i++) {
    const isWin = Math.random() < accuracy;
    recentSignals.push({
      timestamp: Date.now() - i * 36e5 * (1 + Math.random() * 23),
      symbol: symbols[Math.floor(Math.random() * symbols.length)],
      direction: Math.random() > 0.3 ? "buy" : Math.random() > 0.5 ? "sell" : "hold",
      confidence: 0.6 + Math.random() * 0.35,
      outcome: i < 2 ? "pending" : isWin ? "win" : "loss",
      returnPercent: i < 2 ? void 0 : isWin ? Math.random() * avgReturn * 200 : -Math.random() * avgReturn * 100
    });
  }
  const badges = [];
  if (accuracy >= 0.8 && totalSignals >= 100) {
    badges.push({ ...BADGES.accuracy_master, earnedAt: Date.now() - Math.random() * 30 * 24 * 36e5 });
  }
  if (agentDef.strengths.includes("bull_market") && conditionPerformance.bull_market.rank <= 2) {
    badges.push({ ...BADGES.bull_specialist, earnedAt: Date.now() - Math.random() * 60 * 24 * 36e5 });
  }
  if (agentDef.strengths.includes("bear_market") && conditionPerformance.bear_market.avgReturn > 0) {
    badges.push({ ...BADGES.bear_survivor, earnedAt: Date.now() - Math.random() * 90 * 24 * 36e5 });
  }
  if (agentDef.strengths.includes("high_volatility")) {
    badges.push({ ...BADGES.volatility_hunter, earnedAt: Date.now() - Math.random() * 45 * 24 * 36e5 });
  }
  if (totalSignals >= 1e3) {
    badges.push({ ...BADGES.signal_volume, earnedAt: Date.now() - Math.random() * 180 * 24 * 36e5 });
  }
  const sharpeRatio = 0.8 + Math.random() * 2;
  if (sharpeRatio >= 2) {
    badges.push({ ...BADGES.risk_manager, earnedAt: Date.now() - Math.random() * 30 * 24 * 36e5 });
  }
  const profitFactor = 1.2 + Math.random() * 2.5;
  if (profitFactor >= 3) {
    badges.push({ ...BADGES.profit_machine, earnedAt: Date.now() - Math.random() * 60 * 24 * 36e5 });
  }
  const trendRandom = Math.random();
  const performanceTrend = trendRandom > 0.6 ? "improving" : trendRandom > 0.3 ? "stable" : "declining";
  return {
    agentId: agentDef.id,
    agentName: agentDef.name,
    agentType: agentDef.type,
    description: agentDef.description,
    totalSignals,
    accurateSignals,
    accuracy,
    avgReturn,
    totalReturn: avgReturn * timeMultiplier,
    bestReturn: avgReturn * 3 + Math.random() * avgReturn * 2,
    worstReturn: -(avgReturn * 2 + Math.random() * avgReturn),
    sharpeRatio,
    sortinoRatio: sharpeRatio * (1.1 + Math.random() * 0.3),
    maxDrawdown: 0.05 + Math.random() * 0.15,
    winRate: accuracy,
    profitFactor,
    avgHoldingPeriod: 1 + Math.random() * 10,
    avgTimeToProfit: 0.5 + Math.random() * 3,
    overallRank: 0,
    // Will be set later
    conditionRanks,
    badges,
    conditionPerformance,
    recentSignals,
    performanceTrend,
    trendChange: performanceTrend === "improving" ? Math.random() * 15 : performanceTrend === "declining" ? -Math.random() * 10 : Math.random() * 5 - 2.5
  };
}
function getTimeMultiplier(timeFrame) {
  switch (timeFrame) {
    case "1d":
      return 1;
    case "1w":
      return 7;
    case "1m":
      return 30;
    case "3m":
      return 90;
    case "6m":
      return 180;
    case "1y":
      return 365;
    case "all":
      return 730;
    default:
      return 30;
  }
}
function getLeaderboard2(filters) {
  const performances = AGENT_DEFINITIONS.map(
    (def) => generateAgentPerformance(def, filters.timeFrame)
  );
  let filtered = performances;
  if (filters.agentType) {
    filtered = filtered.filter((p) => p.agentType === filters.agentType);
  }
  if (filters.minSignals) {
    const minSignals = filters.minSignals;
    filtered = filtered.filter((p) => p.totalSignals >= minSignals);
  }
  if (filters.marketCondition) {
    filtered.sort((a, b) => {
      const aPerf = a.conditionPerformance[filters.marketCondition];
      const bPerf = b.conditionPerformance[filters.marketCondition];
      return bPerf.avgReturn * bPerf.accuracy - aPerf.avgReturn * aPerf.accuracy;
    });
  } else {
    filtered.sort((a, b) => {
      const aScore = a.accuracy * 0.3 + a.avgReturn * 0.3 + a.sharpeRatio * 0.2 + a.winRate * 0.2;
      const bScore = b.accuracy * 0.3 + b.avgReturn * 0.3 + b.sharpeRatio * 0.2 + b.winRate * 0.2;
      return bScore - aScore;
    });
  }
  return filtered.map((agent, index) => {
    agent.overallRank = index + 1;
    const previousRank = index + 1 + Math.floor(Math.random() * 3) - 1;
    return {
      rank: index + 1,
      previousRank,
      rankChange: previousRank - (index + 1),
      agent
    };
  });
}
function getAgentDetails(agentId, timeFrame = "1m") {
  const agentDef = AGENT_DEFINITIONS.find((a) => a.id === agentId);
  if (!agentDef) return null;
  return generateAgentPerformance(agentDef, timeFrame);
}
function compareAgents(agentIds, timeFrame = "1m") {
  return agentIds.map((id) => getAgentDetails(id, timeFrame)).filter((a) => a !== null);
}
function getTopPerformersByCondition(condition, limit = 3) {
  return getLeaderboard2({
    timeFrame: "1m",
    marketCondition: condition
  }).slice(0, limit);
}
function getAgentRankingsHistory(agentId, days = 30) {
  const history = [];
  for (let i = days; i >= 0; i--) {
    const date2 = Date.now() - i * 24 * 36e5;
    history.push({
      date: date2,
      rank: Math.floor(Math.random() * 5) + 1,
      accuracy: 0.6 + Math.random() * 0.25,
      returns: -0.05 + Math.random() * 0.15
    });
  }
  return history;
}
function getAllBadges() {
  return Object.values(BADGES);
}
function getMarketConditions() {
  return [
    { id: "bull_market", name: "Bull Market", description: "Rising prices, positive sentiment" },
    { id: "bear_market", name: "Bear Market", description: "Falling prices, negative sentiment" },
    { id: "high_volatility", name: "High Volatility", description: "Large price swings, uncertainty" },
    { id: "low_volatility", name: "Low Volatility", description: "Stable prices, low uncertainty" },
    { id: "trending", name: "Trending", description: "Clear directional movement" },
    { id: "ranging", name: "Ranging", description: "Sideways movement, consolidation" },
    { id: "crash", name: "Market Crash", description: "Rapid decline, panic selling" },
    { id: "recovery", name: "Recovery", description: "Bounce back from lows" }
  ];
}
function getAgentTypes() {
  return [
    { id: "technical", name: "Technical Analysis" },
    { id: "fundamental", name: "Fundamental Analysis" },
    { id: "sentiment", name: "Sentiment Analysis" },
    { id: "risk", name: "Risk Management" },
    { id: "portfolio", name: "Portfolio Optimization" },
    { id: "macro", name: "Macro Economic" },
    { id: "momentum", name: "Momentum Trading" }
  ];
}
function getLeaderboardStats() {
  const leaderboard = getLeaderboard2({ timeFrame: "1m" });
  return {
    totalAgents: leaderboard.length,
    totalSignals: leaderboard.reduce((sum2, e) => sum2 + e.agent.totalSignals, 0),
    avgAccuracy: leaderboard.reduce((sum2, e) => sum2 + e.agent.accuracy, 0) / leaderboard.length,
    topPerformer: leaderboard[0]?.agent.agentName || "N/A",
    mostImproved: leaderboard.find((e) => e.agent.performanceTrend === "improving")?.agent.agentName || "N/A"
  };
}
var BADGES, AGENT_DEFINITIONS;
var init_AgentPerformanceLeaderboard = __esm({
  "server/services/ai-agents/AgentPerformanceLeaderboard.ts"() {
    "use strict";
    BADGES = {
      accuracy_master: {
        id: "accuracy_master",
        name: "Accuracy Master",
        description: "Achieved 80%+ accuracy over 100 signals",
        icon: "\u{1F3AF}",
        rarity: "epic"
      },
      bull_specialist: {
        id: "bull_specialist",
        name: "Bull Specialist",
        description: "Top performer in bull market conditions",
        icon: "\u{1F402}",
        rarity: "rare"
      },
      bear_survivor: {
        id: "bear_survivor",
        name: "Bear Survivor",
        description: "Positive returns during bear markets",
        icon: "\u{1F43B}",
        rarity: "epic"
      },
      volatility_hunter: {
        id: "volatility_hunter",
        name: "Volatility Hunter",
        description: "Excels in high volatility conditions",
        icon: "\u26A1",
        rarity: "rare"
      },
      consistent_performer: {
        id: "consistent_performer",
        name: "Consistent Performer",
        description: "Maintained positive returns for 6 months",
        icon: "\u{1F4C8}",
        rarity: "legendary"
      },
      risk_manager: {
        id: "risk_manager",
        name: "Risk Manager",
        description: "Sharpe ratio above 2.0",
        icon: "\u{1F6E1}\uFE0F",
        rarity: "epic"
      },
      quick_winner: {
        id: "quick_winner",
        name: "Quick Winner",
        description: "Average time to profit under 24 hours",
        icon: "\u23F1\uFE0F",
        rarity: "rare"
      },
      profit_machine: {
        id: "profit_machine",
        name: "Profit Machine",
        description: "Profit factor above 3.0",
        icon: "\u{1F4B0}",
        rarity: "legendary"
      },
      signal_volume: {
        id: "signal_volume",
        name: "Signal Volume",
        description: "Generated 1000+ signals",
        icon: "\u{1F4CA}",
        rarity: "common"
      },
      comeback_king: {
        id: "comeback_king",
        name: "Comeback King",
        description: "Recovered from 20%+ drawdown",
        icon: "\u{1F451}",
        rarity: "epic"
      }
    };
    AGENT_DEFINITIONS = [
      {
        id: "technical_agent",
        name: "Technical Analysis Agent",
        type: "technical",
        description: "Uses chart patterns, indicators, and price action for trading signals",
        strengths: ["trending", "high_volatility"],
        baseAccuracy: 0.68,
        baseReturn: 0.12
      },
      {
        id: "fundamental_agent",
        name: "Fundamental Analysis Agent",
        type: "fundamental",
        description: "Analyzes financial statements, valuations, and company metrics",
        strengths: ["bull_market", "recovery"],
        baseAccuracy: 0.72,
        baseReturn: 0.15
      },
      {
        id: "sentiment_agent",
        name: "Sentiment Analysis Agent",
        type: "sentiment",
        description: "Monitors social media, news, and market sentiment",
        strengths: ["high_volatility", "crash"],
        baseAccuracy: 0.65,
        baseReturn: 0.1
      },
      {
        id: "risk_agent",
        name: "Risk Management Agent",
        type: "risk",
        description: "Focuses on position sizing, stop-losses, and risk-adjusted returns",
        strengths: ["bear_market", "crash"],
        baseAccuracy: 0.75,
        baseReturn: 0.08
      },
      {
        id: "portfolio_agent",
        name: "Portfolio Optimization Agent",
        type: "portfolio",
        description: "Optimizes asset allocation and portfolio diversification",
        strengths: ["ranging", "low_volatility"],
        baseAccuracy: 0.7,
        baseReturn: 0.11
      },
      {
        id: "macro_agent",
        name: "Macro Economic Agent",
        type: "macro",
        description: "Analyzes economic indicators, interest rates, and global trends",
        strengths: ["bull_market", "bear_market"],
        baseAccuracy: 0.67,
        baseReturn: 0.13
      },
      {
        id: "momentum_agent",
        name: "Momentum Trading Agent",
        type: "momentum",
        description: "Identifies and rides market momentum and trends",
        strengths: ["trending", "bull_market"],
        baseAccuracy: 0.63,
        baseReturn: 0.18
      }
    ];
  }
});

// server/services/ai-agents/AutomatedStrategyGeneration.ts
var AutomatedStrategyGeneration_exports = {};
__export(AutomatedStrategyGeneration_exports, {
  QUESTIONNAIRE: () => QUESTIONNAIRE,
  STRATEGY_TEMPLATES: () => STRATEGY_TEMPLATES,
  compareStrategies: () => compareStrategies,
  createRiskProfile: () => createRiskProfile,
  exportStrategy: () => exportStrategy,
  generateStrategy: () => generateStrategy,
  generateStrategyVariations: () => generateStrategyVariations,
  getQuestionnaire: () => getQuestionnaire,
  getStrategyTemplates: () => getStrategyTemplates,
  getSuitableTemplates: () => getSuitableTemplates,
  optimizeStrategy: () => optimizeStrategy,
  validateStrategy: () => validateStrategy
});
function generateId3() {
  return `strat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
function calculateRiskScore(responses) {
  let totalScore = 0;
  let count2 = 0;
  responses.forEach((response) => {
    const question = QUESTIONNAIRE.find((q) => q.id === response.questionId);
    if (question && question.options) {
      const option = question.options.find((o) => o.value === response.answer);
      if (option && option.score !== void 0) {
        totalScore += option.score;
        count2++;
      }
    }
  });
  return count2 > 0 ? totalScore / count2 : 2.5;
}
function determineRiskTolerance(score) {
  if (score <= 1.5) return "conservative";
  if (score <= 2.5) return "moderate";
  if (score <= 3.5) return "aggressive";
  return "very_aggressive";
}
function determineInvestmentHorizon(responses) {
  const horizonResponse = responses.find((r) => r.questionId === "q2_investment_horizon");
  return horizonResponse?.answer || "medium_term";
}
function determineTradingStyle(responses) {
  const styleResponse = responses.find((r) => r.questionId === "q3_trading_style");
  return styleResponse?.answer || "swing_trading";
}
function getPreferredAssetClasses(responses) {
  const assetsResponse = responses.find((r) => r.questionId === "q6_asset_classes");
  if (assetsResponse && Array.isArray(assetsResponse.answer)) {
    return assetsResponse.answer;
  }
  return ["stocks"];
}
function generateEntryRules(strategyType, riskTolerance) {
  const rules = [];
  switch (strategyType) {
    case "momentum":
      rules.push(
        {
          id: "entry_1",
          name: "RSI Momentum",
          description: "Enter when RSI shows strong momentum",
          indicator: "RSI",
          condition: riskTolerance === "conservative" ? "above" : "crosses_above",
          value: riskTolerance === "conservative" ? 55 : 50,
          timeframe: "1D",
          weight: 0.3,
          isRequired: true
        },
        {
          id: "entry_2",
          name: "MACD Signal",
          description: "MACD line crosses above signal line",
          indicator: "MACD",
          condition: "crosses_above",
          value: 0,
          timeframe: "1D",
          weight: 0.25,
          isRequired: true
        },
        {
          id: "entry_3",
          name: "Volume Confirmation",
          description: "Volume above 20-day average",
          indicator: "Volume",
          condition: "above",
          value: 1.2,
          // 120% of average
          timeframe: "1D",
          weight: 0.2,
          isRequired: false
        },
        {
          id: "entry_4",
          name: "Price Above EMA",
          description: "Price above 20 EMA",
          indicator: "EMA_20",
          condition: "above",
          value: 0,
          timeframe: "1D",
          weight: 0.25,
          isRequired: false
        }
      );
      break;
    case "mean_reversion":
      rules.push(
        {
          id: "entry_1",
          name: "RSI Oversold",
          description: "RSI indicates oversold condition",
          indicator: "RSI",
          condition: "below",
          value: riskTolerance === "conservative" ? 25 : 30,
          timeframe: "1D",
          weight: 0.35,
          isRequired: true
        },
        {
          id: "entry_2",
          name: "Bollinger Band Touch",
          description: "Price touches lower Bollinger Band",
          indicator: "BB_Lower",
          condition: "below",
          value: 0,
          timeframe: "1D",
          weight: 0.3,
          isRequired: true
        },
        {
          id: "entry_3",
          name: "Stochastic Oversold",
          description: "Stochastic below 20",
          indicator: "Stochastic",
          condition: "below",
          value: 20,
          timeframe: "1D",
          weight: 0.2,
          isRequired: false
        },
        {
          id: "entry_4",
          name: "Support Level",
          description: "Near historical support",
          indicator: "Support",
          condition: "below",
          value: 1.02,
          // Within 2% of support
          timeframe: "1D",
          weight: 0.15,
          isRequired: false
        }
      );
      break;
    case "trend_following":
      rules.push(
        {
          id: "entry_1",
          name: "EMA Crossover",
          description: "20 EMA crosses above 50 EMA",
          indicator: "EMA_20_50",
          condition: "crosses_above",
          value: 0,
          timeframe: "1D",
          weight: 0.35,
          isRequired: true
        },
        {
          id: "entry_2",
          name: "ADX Trend Strength",
          description: "ADX above 25 indicating strong trend",
          indicator: "ADX",
          condition: "above",
          value: 25,
          timeframe: "1D",
          weight: 0.25,
          isRequired: true
        },
        {
          id: "entry_3",
          name: "Price Above 200 SMA",
          description: "Long-term uptrend confirmation",
          indicator: "SMA_200",
          condition: "above",
          value: 0,
          timeframe: "1D",
          weight: 0.2,
          isRequired: false
        },
        {
          id: "entry_4",
          name: "Parabolic SAR",
          description: "SAR below price (bullish)",
          indicator: "PSAR",
          condition: "below",
          value: 0,
          timeframe: "1D",
          weight: 0.2,
          isRequired: false
        }
      );
      break;
    case "breakout":
      rules.push(
        {
          id: "entry_1",
          name: "Resistance Breakout",
          description: "Price breaks above resistance",
          indicator: "Resistance",
          condition: "above",
          value: 1.01,
          // 1% above resistance
          timeframe: "1D",
          weight: 0.35,
          isRequired: true
        },
        {
          id: "entry_2",
          name: "Volume Surge",
          description: "Volume 150%+ of average",
          indicator: "Volume",
          condition: "above",
          value: 1.5,
          timeframe: "1D",
          weight: 0.3,
          isRequired: true
        },
        {
          id: "entry_3",
          name: "ATR Expansion",
          description: "Volatility expanding",
          indicator: "ATR",
          condition: "above",
          value: 1.2,
          // 120% of average ATR
          timeframe: "1D",
          weight: 0.2,
          isRequired: false
        },
        {
          id: "entry_4",
          name: "Momentum Confirmation",
          description: "RSI above 50",
          indicator: "RSI",
          condition: "above",
          value: 50,
          timeframe: "1D",
          weight: 0.15,
          isRequired: false
        }
      );
      break;
    default:
      rules.push(
        {
          id: "entry_1",
          name: "Trend Confirmation",
          description: "Price above 50 SMA",
          indicator: "SMA_50",
          condition: "above",
          value: 0,
          timeframe: "1D",
          weight: 0.4,
          isRequired: true
        },
        {
          id: "entry_2",
          name: "Momentum Check",
          description: "RSI between 40-70",
          indicator: "RSI",
          condition: "between",
          value: [40, 70],
          timeframe: "1D",
          weight: 0.3,
          isRequired: false
        },
        {
          id: "entry_3",
          name: "Volume Confirmation",
          description: "Above average volume",
          indicator: "Volume",
          condition: "above",
          value: 1,
          timeframe: "1D",
          weight: 0.3,
          isRequired: false
        }
      );
  }
  return rules;
}
function generateExitRules(strategyType, riskTolerance) {
  const rules = [];
  const stopLossPercent = {
    conservative: 3,
    moderate: 5,
    aggressive: 8,
    very_aggressive: 12
  }[riskTolerance];
  rules.push({
    id: "exit_sl",
    name: "Stop Loss",
    type: "stop_loss",
    description: `Exit if price drops ${stopLossPercent}% from entry`,
    value: stopLossPercent,
    isPercentage: true
  });
  const takeProfitMultiplier = {
    conservative: 1.5,
    moderate: 2,
    aggressive: 2.5,
    very_aggressive: 3
  }[riskTolerance];
  rules.push({
    id: "exit_tp",
    name: "Take Profit",
    type: "take_profit",
    description: `Exit at ${stopLossPercent * takeProfitMultiplier}% profit`,
    value: stopLossPercent * takeProfitMultiplier,
    isPercentage: true
  });
  if (strategyType === "trend_following" || strategyType === "momentum") {
    rules.push({
      id: "exit_ts",
      name: "Trailing Stop",
      type: "trailing_stop",
      description: `Trail stop at ${stopLossPercent * 1.5}% from high`,
      value: stopLossPercent * 1.5,
      isPercentage: true
    });
  }
  if (strategyType === "mean_reversion") {
    rules.push({
      id: "exit_rsi",
      name: "RSI Overbought Exit",
      type: "indicator_based",
      description: "Exit when RSI reaches overbought",
      value: 70,
      isPercentage: false,
      indicator: "RSI",
      condition: "above"
    });
  }
  if (strategyType === "breakout" || strategyType === "momentum") {
    rules.push({
      id: "exit_time",
      name: "Time-Based Exit",
      type: "time_based",
      description: "Exit after 10 trading days if no target hit",
      value: 10,
      isPercentage: false
    });
  }
  return rules;
}
function generatePositionSizing(riskTolerance, capital) {
  const riskPerTrade = {
    conservative: 0.5,
    moderate: 1,
    aggressive: 2,
    very_aggressive: 3
  }[riskTolerance];
  const maxSize = {
    conservative: 5,
    moderate: 10,
    aggressive: 15,
    very_aggressive: 25
  }[riskTolerance];
  return {
    method: riskTolerance === "conservative" ? "percent_of_capital" : "risk_based",
    baseSize: capital * (riskPerTrade / 100),
    maxSize: capital * (maxSize / 100),
    riskPerTrade,
    scalingFactor: 1
  };
}
function generateIndicators(strategyType) {
  const indicators = [];
  switch (strategyType) {
    case "momentum":
      indicators.push(
        { name: "RSI", type: "momentum", parameters: { period: 14 }, weight: 0.25, description: "Relative Strength Index" },
        { name: "MACD", type: "momentum", parameters: { fast: 12, slow: 26, signal: 9 }, weight: 0.25, description: "Moving Average Convergence Divergence" },
        { name: "EMA", type: "trend", parameters: { period: 20 }, weight: 0.2, description: "20-period Exponential Moving Average" },
        { name: "Volume", type: "volume", parameters: { period: 20 }, weight: 0.15, description: "Volume with 20-day average" },
        { name: "ATR", type: "volatility", parameters: { period: 14 }, weight: 0.15, description: "Average True Range" }
      );
      break;
    case "mean_reversion":
      indicators.push(
        { name: "RSI", type: "momentum", parameters: { period: 14 }, weight: 0.3, description: "Relative Strength Index" },
        { name: "Bollinger Bands", type: "volatility", parameters: { period: 20, stdDev: 2 }, weight: 0.25, description: "Bollinger Bands" },
        { name: "Stochastic", type: "momentum", parameters: { k: 14, d: 3 }, weight: 0.2, description: "Stochastic Oscillator" },
        { name: "SMA", type: "trend", parameters: { period: 50 }, weight: 0.15, description: "50-period Simple Moving Average" },
        { name: "Volume", type: "volume", parameters: { period: 20 }, weight: 0.1, description: "Volume analysis" }
      );
      break;
    case "trend_following":
      indicators.push(
        { name: "EMA", type: "trend", parameters: { periods: [20, 50, 200] }, weight: 0.3, description: "Multiple EMAs" },
        { name: "ADX", type: "trend", parameters: { period: 14 }, weight: 0.25, description: "Average Directional Index" },
        { name: "MACD", type: "momentum", parameters: { fast: 12, slow: 26, signal: 9 }, weight: 0.2, description: "MACD" },
        { name: "Parabolic SAR", type: "trend", parameters: { step: 0.02, max: 0.2 }, weight: 0.15, description: "Parabolic SAR" },
        { name: "ATR", type: "volatility", parameters: { period: 14 }, weight: 0.1, description: "Average True Range" }
      );
      break;
    case "breakout":
      indicators.push(
        { name: "Volume", type: "volume", parameters: { period: 20 }, weight: 0.3, description: "Volume analysis" },
        { name: "ATR", type: "volatility", parameters: { period: 14 }, weight: 0.25, description: "Average True Range" },
        { name: "Bollinger Bands", type: "volatility", parameters: { period: 20, stdDev: 2 }, weight: 0.2, description: "Bollinger Bands" },
        { name: "OBV", type: "volume", parameters: {}, weight: 0.15, description: "On-Balance Volume" },
        { name: "RSI", type: "momentum", parameters: { period: 14 }, weight: 0.1, description: "RSI for confirmation" }
      );
      break;
    default:
      indicators.push(
        { name: "SMA", type: "trend", parameters: { period: 50 }, weight: 0.25, description: "Simple Moving Average" },
        { name: "RSI", type: "momentum", parameters: { period: 14 }, weight: 0.25, description: "Relative Strength Index" },
        { name: "Volume", type: "volume", parameters: { period: 20 }, weight: 0.25, description: "Volume analysis" },
        { name: "ATR", type: "volatility", parameters: { period: 14 }, weight: 0.25, description: "Average True Range" }
      );
  }
  return indicators;
}
function createRiskProfile(userId, responses) {
  const riskScore = calculateRiskScore(responses);
  const riskTolerance = determineRiskTolerance(riskScore);
  const investmentHorizon = determineInvestmentHorizon(responses);
  const tradingStyle = determineTradingStyle(responses);
  const preferredAssetClasses = getPreferredAssetClasses(responses);
  const maxDrawdownResponse = responses.find((r) => r.questionId === "q4_max_drawdown");
  const targetReturnResponse = responses.find((r) => r.questionId === "q5_target_return");
  const capitalResponse = responses.find((r) => r.questionId === "q7_capital");
  const experienceResponse = responses.find((r) => r.questionId === "q8_experience");
  const timeResponse = responses.find((r) => r.questionId === "q9_time_availability");
  const emotionalResponse = responses.find((r) => r.questionId === "q10_emotional_tolerance");
  return {
    id: `profile_${Date.now()}`,
    userId,
    riskTolerance,
    investmentHorizon,
    tradingStyle,
    maxDrawdownTolerance: maxDrawdownResponse?.answer || 20,
    targetAnnualReturn: targetReturnResponse?.answer || 15,
    preferredAssetClasses,
    capitalAllocation: capitalResponse?.answer || 1e4,
    maxPositionSize: riskTolerance === "conservative" ? 5 : riskTolerance === "moderate" ? 10 : 15,
    maxOpenPositions: riskTolerance === "conservative" ? 5 : riskTolerance === "moderate" ? 10 : 15,
    tradingFrequency: tradingStyle === "day_trading" ? "very_high" : tradingStyle === "swing_trading" ? "medium" : "low",
    experienceLevel: experienceResponse?.answer || "intermediate",
    emotionalTolerance: emotionalResponse?.answer || 5,
    timeAvailability: timeResponse?.answer || "part_time",
    createdAt: Date.now(),
    updatedAt: Date.now()
  };
}
function generateStrategy(profile, preferredType) {
  const suitableTemplates = STRATEGY_TEMPLATES.filter(
    (t2) => t2.suitableFor.includes(profile.riskTolerance) && t2.assetClasses.some((a) => profile.preferredAssetClasses.includes(a))
  );
  let selectedTemplate;
  if (preferredType) {
    selectedTemplate = suitableTemplates.find((t2) => t2.type === preferredType) || suitableTemplates[0];
  } else {
    const scoredTemplates = suitableTemplates.map((t2) => ({
      template: t2,
      score: calculateTemplateScore(t2, profile)
    })).sort((a, b) => b.score - a.score);
    selectedTemplate = scoredTemplates[0]?.template || STRATEGY_TEMPLATES[0];
  }
  const entryRules = generateEntryRules(selectedTemplate.type, profile.riskTolerance);
  const exitRules = generateExitRules(selectedTemplate.type, profile.riskTolerance);
  const positionSizing = generatePositionSizing(profile.riskTolerance, profile.capitalAllocation);
  const indicators = generateIndicators(selectedTemplate.type);
  const [minWinRate, maxWinRate] = selectedTemplate.expectedPerformance.winRate;
  const [minRR, maxRR] = selectedTemplate.expectedPerformance.riskReward;
  const [minDD, maxDD] = selectedTemplate.expectedPerformance.drawdown;
  const expectedWinRate = (minWinRate + maxWinRate) / 2;
  const expectedRiskReward = (minRR + maxRR) / 2;
  const expectedMaxDrawdown = (minDD + maxDD) / 2;
  const avgWin = positionSizing.riskPerTrade * expectedRiskReward;
  const avgLoss = positionSizing.riskPerTrade;
  const expectedPerTrade = expectedWinRate * avgWin - (1 - expectedWinRate) * avgLoss;
  const tradesPerYear = profile.tradingStyle === "day_trading" ? 200 : profile.tradingStyle === "swing_trading" ? 50 : 20;
  const expectedAnnualReturn = expectedPerTrade * tradesPerYear;
  const expectedSharpeRatio = expectedAnnualReturn / (expectedMaxDrawdown * 2);
  return {
    id: generateId3(),
    name: `${profile.riskTolerance.charAt(0).toUpperCase() + profile.riskTolerance.slice(1)} ${selectedTemplate.name}`,
    description: `${selectedTemplate.description} Customized for ${profile.riskTolerance} risk tolerance with ${profile.tradingStyle.replace("_", " ")} approach.`,
    type: selectedTemplate.type,
    riskLevel: profile.riskTolerance,
    targetMarkets: profile.preferredAssetClasses,
    suitableConditions: selectedTemplate.marketConditions,
    entryRules,
    exitRules,
    positionSizing,
    maxConcurrentPositions: profile.maxOpenPositions,
    indicators,
    expectedWinRate,
    expectedRiskReward,
    expectedSharpeRatio: Math.round(expectedSharpeRatio * 100) / 100,
    expectedMaxDrawdown,
    expectedAnnualReturn: Math.round(expectedAnnualReturn * 100) / 100,
    confidence: calculateStrategyConfidence(profile, selectedTemplate),
    complexity: selectedTemplate.complexity,
    timeToImplement: selectedTemplate.complexity === "simple" ? "1-2 days" : selectedTemplate.complexity === "moderate" ? "3-5 days" : "1-2 weeks",
    maintenanceLevel: selectedTemplate.complexity === "simple" ? "low" : selectedTemplate.complexity === "moderate" ? "medium" : "high",
    createdAt: Date.now(),
    createdFor: profile.userId
  };
}
function calculateTemplateScore(template, profile) {
  let score = 0;
  const riskIndex = template.suitableFor.indexOf(profile.riskTolerance);
  score += riskIndex >= 0 ? (4 - riskIndex) * 10 : 0;
  const assetMatches = template.assetClasses.filter((a) => profile.preferredAssetClasses.includes(a)).length;
  score += assetMatches * 5;
  const complexityScore = { simple: 1, moderate: 2, complex: 3, advanced: 4 };
  const experienceScore = { beginner: 1, intermediate: 2, advanced: 3, expert: 4 };
  const complexityMatch = Math.abs(complexityScore[template.complexity] - experienceScore[profile.experienceLevel]);
  score += (4 - complexityMatch) * 3;
  if (template.complexity === "advanced" && profile.timeAvailability === "minimal") {
    score -= 10;
  }
  return score;
}
function calculateStrategyConfidence(profile, template) {
  let confidence = 0.7;
  if (profile.experienceLevel === "advanced" || profile.experienceLevel === "expert") {
    confidence += 0.1;
  }
  if (template.suitableFor[0] === profile.riskTolerance) {
    confidence += 0.05;
  }
  if (profile.timeAvailability === "full_time" && template.complexity !== "simple") {
    confidence += 0.05;
  }
  if (profile.emotionalTolerance >= 7) {
    confidence += 0.05;
  }
  return Math.min(0.95, Math.round(confidence * 100) / 100);
}
function getStrategyTemplates() {
  return STRATEGY_TEMPLATES;
}
function getSuitableTemplates(profile) {
  return STRATEGY_TEMPLATES.filter(
    (t2) => t2.suitableFor.includes(profile.riskTolerance) && t2.assetClasses.some((a) => profile.preferredAssetClasses.includes(a))
  ).sort((a, b) => calculateTemplateScore(b, profile) - calculateTemplateScore(a, profile));
}
function getQuestionnaire() {
  return QUESTIONNAIRE;
}
function optimizeStrategy(strategy, optimizationGoal) {
  const optimized = { ...strategy };
  switch (optimizationGoal) {
    case "win_rate":
      optimized.entryRules = strategy.entryRules.map((rule) => ({
        ...rule,
        isRequired: true,
        weight: rule.weight * 1.1
      }));
      optimized.expectedWinRate = Math.min(0.75, strategy.expectedWinRate * 1.1);
      optimized.expectedRiskReward = strategy.expectedRiskReward * 0.9;
      break;
    case "risk_reward":
      optimized.exitRules = strategy.exitRules.map((rule) => {
        if (rule.type === "take_profit") {
          return { ...rule, value: rule.value * 1.3 };
        }
        if (rule.type === "stop_loss") {
          return { ...rule, value: rule.value * 0.8 };
        }
        return rule;
      });
      optimized.expectedRiskReward = strategy.expectedRiskReward * 1.2;
      optimized.expectedWinRate = strategy.expectedWinRate * 0.95;
      break;
    case "sharpe":
      optimized.positionSizing = {
        ...strategy.positionSizing,
        riskPerTrade: strategy.positionSizing.riskPerTrade * 0.8
      };
      optimized.expectedSharpeRatio = strategy.expectedSharpeRatio * 1.15;
      break;
    case "drawdown":
      optimized.positionSizing = {
        ...strategy.positionSizing,
        maxSize: strategy.positionSizing.maxSize * 0.7,
        riskPerTrade: strategy.positionSizing.riskPerTrade * 0.7
      };
      optimized.exitRules = strategy.exitRules.map((rule) => {
        if (rule.type === "stop_loss") {
          return { ...rule, value: rule.value * 0.7 };
        }
        return rule;
      });
      optimized.expectedMaxDrawdown = strategy.expectedMaxDrawdown * 0.7;
      break;
  }
  optimized.id = generateId3();
  optimized.name = `${strategy.name} (Optimized for ${optimizationGoal.replace("_", " ")})`;
  return optimized;
}
function compareStrategies(strategies) {
  const comparison = strategies.map((s) => {
    const score = s.expectedWinRate * 25 + s.expectedRiskReward * 15 + s.expectedSharpeRatio * 20 + (1 - s.expectedMaxDrawdown) * 20 + s.expectedAnnualReturn / 100 * 20;
    return {
      strategyId: s.id,
      name: s.name,
      winRate: s.expectedWinRate,
      riskReward: s.expectedRiskReward,
      sharpe: s.expectedSharpeRatio,
      maxDrawdown: s.expectedMaxDrawdown,
      expectedReturn: s.expectedAnnualReturn,
      score: Math.round(score * 100) / 100
    };
  }).sort((a, b) => b.score - a.score);
  const bestOverall = comparison[0]?.strategyId || "";
  const bestForRisk = [...comparison].sort((a, b) => a.maxDrawdown - b.maxDrawdown)[0]?.strategyId || "";
  const bestForReturn = [...comparison].sort((a, b) => b.expectedReturn - a.expectedReturn)[0]?.strategyId || "";
  let recommendation = `Based on comprehensive analysis, "${comparison[0]?.name}" offers the best overall balance. `;
  if (bestForRisk !== bestOverall) {
    const riskStrategy = strategies.find((s) => s.id === bestForRisk);
    recommendation += `For risk-averse traders, consider "${riskStrategy?.name}". `;
  }
  if (bestForReturn !== bestOverall) {
    const returnStrategy = strategies.find((s) => s.id === bestForReturn);
    recommendation += `For maximum returns, "${returnStrategy?.name}" shows the highest potential.`;
  }
  return {
    comparison,
    recommendation,
    bestOverall,
    bestForRisk,
    bestForReturn
  };
}
function generateStrategyVariations(profile, count2 = 3) {
  const suitableTemplates = getSuitableTemplates(profile);
  const variations = [];
  for (let i = 0; i < Math.min(count2, suitableTemplates.length); i++) {
    const strategy = generateStrategy(profile, suitableTemplates[i].type);
    variations.push(strategy);
  }
  return variations;
}
function exportStrategy(strategy) {
  return JSON.stringify(strategy, null, 2);
}
function validateStrategy(strategy) {
  const errors = [];
  const warnings = [];
  if (strategy.entryRules.length === 0) {
    errors.push("Strategy must have at least one entry rule");
  }
  const requiredEntryRules = strategy.entryRules.filter((r) => r.isRequired);
  if (requiredEntryRules.length === 0) {
    warnings.push("Consider marking at least one entry rule as required");
  }
  const hasStopLoss = strategy.exitRules.some((r) => r.type === "stop_loss");
  const hasTakeProfit = strategy.exitRules.some((r) => r.type === "take_profit");
  if (!hasStopLoss) {
    errors.push("Strategy must have a stop loss rule");
  }
  if (!hasTakeProfit) {
    warnings.push("Consider adding a take profit rule");
  }
  if (strategy.positionSizing.riskPerTrade > 5) {
    warnings.push("Risk per trade exceeds 5% - consider reducing for better risk management");
  }
  if (strategy.positionSizing.maxSize > 25) {
    warnings.push("Maximum position size exceeds 25% - high concentration risk");
  }
  if (strategy.indicators.length < 2) {
    warnings.push("Consider using multiple indicators for confirmation");
  }
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}
var STRATEGY_TEMPLATES, QUESTIONNAIRE;
var init_AutomatedStrategyGeneration = __esm({
  "server/services/ai-agents/AutomatedStrategyGeneration.ts"() {
    "use strict";
    STRATEGY_TEMPLATES = [
      {
        id: "momentum_breakout",
        name: "Momentum Breakout",
        type: "momentum",
        description: "Captures strong price movements when assets break out of consolidation patterns with high momentum.",
        suitableFor: ["moderate", "aggressive", "very_aggressive"],
        marketConditions: ["bull", "volatile"],
        assetClasses: ["stocks", "crypto", "forex"],
        baseIndicators: ["RSI", "MACD", "Volume", "ATR", "Bollinger Bands"],
        expectedPerformance: {
          winRate: [0.45, 0.55],
          riskReward: [2, 3.5],
          drawdown: [0.15, 0.3]
        },
        complexity: "moderate"
      },
      {
        id: "mean_reversion_rsi",
        name: "RSI Mean Reversion",
        type: "mean_reversion",
        description: "Trades oversold/overbought conditions expecting price to revert to the mean.",
        suitableFor: ["conservative", "moderate"],
        marketConditions: ["sideways", "low_volatility"],
        assetClasses: ["stocks", "etfs", "forex"],
        baseIndicators: ["RSI", "Bollinger Bands", "SMA", "Stochastic"],
        expectedPerformance: {
          winRate: [0.55, 0.65],
          riskReward: [1.2, 1.8],
          drawdown: [0.08, 0.15]
        },
        complexity: "simple"
      },
      {
        id: "trend_following_ma",
        name: "Moving Average Trend Following",
        type: "trend_following",
        description: "Follows established trends using moving average crossovers and trend strength indicators.",
        suitableFor: ["moderate", "aggressive"],
        marketConditions: ["bull", "bear"],
        assetClasses: ["stocks", "crypto", "commodities", "forex"],
        baseIndicators: ["EMA", "SMA", "ADX", "MACD", "Parabolic SAR"],
        expectedPerformance: {
          winRate: [0.4, 0.5],
          riskReward: [2.5, 4],
          drawdown: [0.2, 0.35]
        },
        complexity: "moderate"
      },
      {
        id: "breakout_volume",
        name: "Volume Breakout",
        type: "breakout",
        description: "Identifies breakouts confirmed by significant volume increases.",
        suitableFor: ["aggressive", "very_aggressive"],
        marketConditions: ["bull", "volatile"],
        assetClasses: ["stocks", "crypto"],
        baseIndicators: ["Volume", "OBV", "ATR", "Bollinger Bands", "VWAP"],
        expectedPerformance: {
          winRate: [0.35, 0.45],
          riskReward: [3, 5],
          drawdown: [0.25, 0.4]
        },
        complexity: "moderate"
      },
      {
        id: "value_investing",
        name: "Value Investing",
        type: "value",
        description: "Long-term strategy focusing on undervalued assets with strong fundamentals.",
        suitableFor: ["conservative", "moderate"],
        marketConditions: ["bear", "sideways"],
        assetClasses: ["stocks", "etfs"],
        baseIndicators: ["P/E Ratio", "P/B Ratio", "Dividend Yield", "ROE", "Debt/Equity"],
        expectedPerformance: {
          winRate: [0.55, 0.7],
          riskReward: [1.5, 2.5],
          drawdown: [0.1, 0.25]
        },
        complexity: "moderate"
      },
      {
        id: "growth_momentum",
        name: "Growth Momentum",
        type: "growth",
        description: "Targets high-growth companies with strong earnings momentum.",
        suitableFor: ["aggressive", "very_aggressive"],
        marketConditions: ["bull"],
        assetClasses: ["stocks"],
        baseIndicators: ["Revenue Growth", "EPS Growth", "RSI", "MACD", "Volume"],
        expectedPerformance: {
          winRate: [0.45, 0.55],
          riskReward: [2, 4],
          drawdown: [0.25, 0.45]
        },
        complexity: "complex"
      },
      {
        id: "dividend_income",
        name: "Dividend Income",
        type: "dividend",
        description: "Focuses on stable dividend-paying stocks for consistent income.",
        suitableFor: ["conservative"],
        marketConditions: ["bull", "sideways", "bear"],
        assetClasses: ["stocks", "etfs"],
        baseIndicators: ["Dividend Yield", "Payout Ratio", "Dividend Growth", "P/E Ratio"],
        expectedPerformance: {
          winRate: [0.6, 0.75],
          riskReward: [1, 1.5],
          drawdown: [0.05, 0.15]
        },
        complexity: "simple"
      },
      {
        id: "volatility_trading",
        name: "Volatility Trading",
        type: "volatility",
        description: "Profits from volatility expansion and contraction patterns.",
        suitableFor: ["aggressive", "very_aggressive"],
        marketConditions: ["volatile", "sideways"],
        assetClasses: ["stocks", "options", "crypto"],
        baseIndicators: ["ATR", "Bollinger Bands", "VIX", "Historical Volatility", "IV Rank"],
        expectedPerformance: {
          winRate: [0.5, 0.6],
          riskReward: [1.5, 2.5],
          drawdown: [0.2, 0.35]
        },
        complexity: "advanced"
      },
      {
        id: "pairs_trading",
        name: "Statistical Pairs Trading",
        type: "pairs_trading",
        description: "Market-neutral strategy trading correlated asset pairs.",
        suitableFor: ["moderate", "aggressive"],
        marketConditions: ["sideways", "low_volatility", "volatile"],
        assetClasses: ["stocks", "etfs", "forex"],
        baseIndicators: ["Correlation", "Z-Score", "Spread", "Cointegration"],
        expectedPerformance: {
          winRate: [0.55, 0.65],
          riskReward: [1.2, 2],
          drawdown: [0.08, 0.18]
        },
        complexity: "advanced"
      },
      {
        id: "scalping",
        name: "High-Frequency Scalping",
        type: "momentum",
        description: "Quick trades capturing small price movements with high frequency.",
        suitableFor: ["very_aggressive"],
        marketConditions: ["volatile", "bull", "bear"],
        assetClasses: ["forex", "crypto"],
        baseIndicators: ["VWAP", "Order Flow", "Tick Volume", "Spread", "EMA"],
        expectedPerformance: {
          winRate: [0.55, 0.7],
          riskReward: [0.8, 1.2],
          drawdown: [0.05, 0.15]
        },
        complexity: "advanced"
      }
    ];
    QUESTIONNAIRE = [
      {
        id: "q1_risk_tolerance",
        category: "risk",
        question: "How would you react if your portfolio dropped 20% in a month?",
        type: "single_choice",
        options: [
          { value: "sell_all", label: "Sell everything immediately", score: 1 },
          { value: "sell_some", label: "Sell some positions to reduce risk", score: 2 },
          { value: "hold", label: "Hold and wait for recovery", score: 3 },
          { value: "buy_more", label: "Buy more at lower prices", score: 4 }
        ],
        required: true
      },
      {
        id: "q2_investment_horizon",
        category: "goals",
        question: "What is your primary investment time horizon?",
        type: "single_choice",
        options: [
          { value: "short_term", label: "Less than 1 year", score: 1 },
          { value: "medium_term", label: "1-3 years", score: 2 },
          { value: "long_term", label: "3-10 years", score: 3 },
          { value: "very_long_term", label: "More than 10 years", score: 4 }
        ],
        required: true
      },
      {
        id: "q3_trading_style",
        category: "preferences",
        question: "Which trading style appeals to you most?",
        type: "single_choice",
        options: [
          { value: "day_trading", label: "Day Trading (multiple trades per day)" },
          { value: "swing_trading", label: "Swing Trading (days to weeks)" },
          { value: "position_trading", label: "Position Trading (weeks to months)" },
          { value: "buy_and_hold", label: "Buy and Hold (months to years)" }
        ],
        required: true
      },
      {
        id: "q4_max_drawdown",
        category: "risk",
        question: "What is the maximum portfolio drawdown you can tolerate?",
        type: "single_choice",
        options: [
          { value: 5, label: "5% - Very Conservative", score: 1 },
          { value: 10, label: "10% - Conservative", score: 2 },
          { value: 20, label: "20% - Moderate", score: 3 },
          { value: 30, label: "30% - Aggressive", score: 4 },
          { value: 50, label: "50%+ - Very Aggressive", score: 5 }
        ],
        required: true
      },
      {
        id: "q5_target_return",
        category: "goals",
        question: "What annual return are you targeting?",
        type: "single_choice",
        options: [
          { value: 5, label: "5-10% (Conservative)", score: 1 },
          { value: 15, label: "10-20% (Moderate)", score: 2 },
          { value: 30, label: "20-40% (Aggressive)", score: 3 },
          { value: 50, label: "40%+ (Very Aggressive)", score: 4 }
        ],
        required: true
      },
      {
        id: "q6_asset_classes",
        category: "preferences",
        question: "Which asset classes are you interested in trading?",
        type: "multiple_choice",
        options: [
          { value: "stocks", label: "Stocks" },
          { value: "crypto", label: "Cryptocurrency" },
          { value: "forex", label: "Forex" },
          { value: "commodities", label: "Commodities" },
          { value: "etfs", label: "ETFs" },
          { value: "options", label: "Options" }
        ],
        required: true
      },
      {
        id: "q7_capital",
        category: "constraints",
        question: "How much capital do you plan to allocate to trading?",
        type: "single_choice",
        options: [
          { value: 1e3, label: "Under $1,000" },
          { value: 5e3, label: "$1,000 - $10,000" },
          { value: 25e3, label: "$10,000 - $50,000" },
          { value: 1e5, label: "$50,000 - $250,000" },
          { value: 5e5, label: "$250,000+" }
        ],
        required: true
      },
      {
        id: "q8_experience",
        category: "experience",
        question: "How would you describe your trading experience?",
        type: "single_choice",
        options: [
          { value: "beginner", label: "Beginner (less than 1 year)", score: 1 },
          { value: "intermediate", label: "Intermediate (1-3 years)", score: 2 },
          { value: "advanced", label: "Advanced (3-7 years)", score: 3 },
          { value: "expert", label: "Expert (7+ years)", score: 4 }
        ],
        required: true
      },
      {
        id: "q9_time_availability",
        category: "constraints",
        question: "How much time can you dedicate to trading daily?",
        type: "single_choice",
        options: [
          { value: "minimal", label: "Minimal (check once a day)" },
          { value: "part_time", label: "Part-time (1-3 hours)" },
          { value: "full_time", label: "Full-time (4+ hours)" }
        ],
        required: true
      },
      {
        id: "q10_emotional_tolerance",
        category: "risk",
        question: "On a scale of 1-10, how well do you handle financial stress?",
        type: "scale",
        min: 1,
        max: 10,
        required: true
      }
    ];
  }
});

// server/services/ai-agents/StrategyBacktestingIntegration.ts
var StrategyBacktestingIntegration_exports = {};
__export(StrategyBacktestingIntegration_exports, {
  compareBacktestResults: () => compareBacktestResults,
  getBacktestSummary: () => getBacktestSummary,
  runBacktest: () => runBacktest2,
  runParameterSweep: () => runParameterSweep
});
function generateId4() {
  return `bt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
function calculateSMA4(prices, period) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      result.push(NaN);
    } else {
      const sum2 = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
      result.push(sum2 / period);
    }
  }
  return result;
}
function calculateEMA7(prices, period) {
  const result = [];
  const multiplier = 2 / (period + 1);
  for (let i = 0; i < prices.length; i++) {
    if (i === 0) {
      result.push(prices[0]);
    } else if (i < period - 1) {
      const sum2 = prices.slice(0, i + 1).reduce((a, b) => a + b, 0);
      result.push(sum2 / (i + 1));
    } else {
      const ema = (prices[i] - result[i - 1]) * multiplier + result[i - 1];
      result.push(ema);
    }
  }
  return result;
}
function calculateRSI5(prices, period = 14) {
  const result = [];
  const gains = [];
  const losses = [];
  for (let i = 0; i < prices.length; i++) {
    if (i === 0) {
      result.push(50);
      gains.push(0);
      losses.push(0);
      continue;
    }
    const change = prices[i] - prices[i - 1];
    gains.push(change > 0 ? change : 0);
    losses.push(change < 0 ? Math.abs(change) : 0);
    if (i < period) {
      result.push(50);
      continue;
    }
    const avgGain = gains.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0) / period;
    const avgLoss = losses.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0) / period;
    if (avgLoss === 0) {
      result.push(100);
    } else {
      const rs = avgGain / avgLoss;
      result.push(100 - 100 / (1 + rs));
    }
  }
  return result;
}
function calculateMACD4(prices) {
  const ema12 = calculateEMA7(prices, 12);
  const ema26 = calculateEMA7(prices, 26);
  const macd = ema12.map((v, i) => v - ema26[i]);
  const signal = calculateEMA7(macd, 9);
  const histogram = macd.map((v, i) => v - signal[i]);
  return { macd, signal, histogram };
}
function calculateBollingerBands3(prices, period = 20, stdDev = 2) {
  const middle = calculateSMA4(prices, period);
  const upper = [];
  const lower = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      upper.push(NaN);
      lower.push(NaN);
    } else {
      const slice = prices.slice(i - period + 1, i + 1);
      const mean5 = middle[i];
      const variance = slice.reduce((sum2, val) => sum2 + Math.pow(val - mean5, 2), 0) / period;
      const std4 = Math.sqrt(variance);
      upper.push(mean5 + stdDev * std4);
      lower.push(mean5 - stdDev * std4);
    }
  }
  return { upper, middle, lower };
}
function calculateATR3(bars, period = 14) {
  const result = [];
  const trueRanges = [];
  for (let i = 0; i < bars.length; i++) {
    if (i === 0) {
      trueRanges.push(bars[i].high - bars[i].low);
    } else {
      const tr = Math.max(
        bars[i].high - bars[i].low,
        Math.abs(bars[i].high - bars[i - 1].close),
        Math.abs(bars[i].low - bars[i - 1].close)
      );
      trueRanges.push(tr);
    }
    if (i < period - 1) {
      result.push(NaN);
    } else {
      const atr = trueRanges.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0) / period;
      result.push(atr);
    }
  }
  return result;
}
function calculateStochastic2(bars, period = 14) {
  const k = [];
  for (let i = 0; i < bars.length; i++) {
    if (i < period - 1) {
      k.push(50);
    } else {
      const slice = bars.slice(i - period + 1, i + 1);
      const high = Math.max(...slice.map((b) => b.high));
      const low = Math.min(...slice.map((b) => b.low));
      const close = bars[i].close;
      if (high === low) {
        k.push(50);
      } else {
        k.push((close - low) / (high - low) * 100);
      }
    }
  }
  const d = calculateSMA4(k, 3);
  return { k, d };
}
function calculateIndicators3(bars, strategy) {
  const closes = bars.map((b) => b.close);
  const indicators = /* @__PURE__ */ new Map();
  strategy.indicators.forEach((ind) => {
    const name = ind.name.toLowerCase();
    if (name.includes("rsi")) {
      const period = ind.parameters.period || 14;
      indicators.set("RSI", calculateRSI5(closes, period));
    }
    if (name.includes("sma")) {
      const period = ind.parameters.period || 50;
      indicators.set(`SMA_${period}`, calculateSMA4(closes, period));
    }
    if (name.includes("ema")) {
      const periods = ind.parameters.periods || [ind.parameters.period || 20];
      periods.forEach((p) => {
        indicators.set(`EMA_${p}`, calculateEMA7(closes, p));
      });
    }
    if (name.includes("macd")) {
      const macdData = calculateMACD4(closes);
      indicators.set("MACD", macdData.macd);
      indicators.set("MACD_Signal", macdData.signal);
      indicators.set("MACD_Histogram", macdData.histogram);
    }
    if (name.includes("bollinger")) {
      const period = ind.parameters.period || 20;
      const stdDev = ind.parameters.stdDev || 2;
      const bb = calculateBollingerBands3(closes, period, stdDev);
      indicators.set("BB_Upper", bb.upper);
      indicators.set("BB_Middle", bb.middle);
      indicators.set("BB_Lower", bb.lower);
    }
    if (name.includes("atr")) {
      const period = ind.parameters.period || 14;
      indicators.set("ATR", calculateATR3(bars, period));
    }
    if (name.includes("stochastic")) {
      const period = ind.parameters.k || 14;
      const stoch = calculateStochastic2(bars, period);
      indicators.set("Stochastic_K", stoch.k);
      indicators.set("Stochastic_D", stoch.d);
    }
  });
  if (!indicators.has("SMA_50")) indicators.set("SMA_50", calculateSMA4(closes, 50));
  if (!indicators.has("SMA_200")) indicators.set("SMA_200", calculateSMA4(closes, 200));
  if (!indicators.has("RSI")) indicators.set("RSI", calculateRSI5(closes, 14));
  if (!indicators.has("ATR")) indicators.set("ATR", calculateATR3(bars, 14));
  return indicators;
}
function checkEntryCondition(rule, bar, indicators, index, prevIndex) {
  const indicatorName = rule.indicator.toUpperCase();
  const indicatorValues = indicators.get(indicatorName) || indicators.get(rule.indicator);
  if (!indicatorValues || isNaN(indicatorValues[index])) {
    if (rule.indicator.toLowerCase().includes("price") || rule.indicator.toLowerCase().includes("close")) {
      const value = bar.close;
      return evaluateCondition(value, rule.condition, rule.value);
    }
    return false;
  }
  const currentValue = indicatorValues[index];
  const prevValue = prevIndex >= 0 ? indicatorValues[prevIndex] : currentValue;
  switch (rule.condition) {
    case "above":
      return currentValue > rule.value;
    case "below":
      return currentValue < rule.value;
    case "crosses_above":
      return prevValue <= rule.value && currentValue > rule.value;
    case "crosses_below":
      return prevValue >= rule.value && currentValue < rule.value;
    case "equals":
      return Math.abs(currentValue - rule.value) < 0.01;
    case "between":
      const [min, max] = rule.value;
      return currentValue >= min && currentValue <= max;
    default:
      return false;
  }
}
function evaluateCondition(value, condition, target) {
  switch (condition) {
    case "above":
      return value > target;
    case "below":
      return value < target;
    case "equals":
      return Math.abs(value - target) < 0.01;
    case "between":
      const [min, max] = target;
      return value >= min && value <= max;
    default:
      return false;
  }
}
function checkExitCondition(rule, entryPrice, currentPrice, highSinceEntry, bar) {
  switch (rule.type) {
    case "stop_loss":
      const stopPrice = rule.isPercentage ? entryPrice * (1 - rule.value / 100) : entryPrice - rule.value;
      return currentPrice <= stopPrice;
    case "take_profit":
      const targetPrice = rule.isPercentage ? entryPrice * (1 + rule.value / 100) : entryPrice + rule.value;
      return currentPrice >= targetPrice;
    case "trailing_stop":
      const trailPrice = rule.isPercentage ? highSinceEntry * (1 - rule.value / 100) : highSinceEntry - rule.value;
      return currentPrice <= trailPrice;
    case "time_based":
      return false;
    default:
      return false;
  }
}
function calculatePositionSize(sizing, capital, price, atr) {
  switch (sizing.method) {
    case "fixed":
      return sizing.baseSize;
    case "percent_of_capital":
      const percentAmount = capital * (sizing.riskPerTrade / 100);
      return Math.floor(percentAmount / price);
    case "risk_based":
      const riskAmount = capital * (sizing.riskPerTrade / 100);
      const stopDistance = atr * 2;
      return Math.floor(riskAmount / stopDistance);
    case "volatility_adjusted":
      const basePosition = capital * (sizing.riskPerTrade / 100) / price;
      const volatilityFactor = 1 / (atr / price * 100);
      return Math.floor(basePosition * Math.min(volatilityFactor, 2));
    case "kelly_criterion":
      const winRate = 0.55;
      const avgWinLoss = 1.5;
      const kelly = (avgWinLoss * winRate - (1 - winRate)) / avgWinLoss;
      const kellyFraction = Math.max(0, Math.min(kelly * 0.5, 0.25));
      return Math.floor(capital * kellyFraction / price);
    default:
      return Math.floor(capital * 0.02 / price);
  }
}
function generateSimulatedPriceData(symbol, startDate, endDate) {
  const bars = [];
  const msPerDay = 24 * 60 * 60 * 1e3;
  let currentDate = startDate;
  let price = symbol === "BTC" ? 3e4 : symbol === "ETH" ? 2e3 : 150;
  const volatility = symbol.includes("BTC") || symbol.includes("ETH") ? 0.03 : 0.015;
  while (currentDate <= endDate) {
    const date2 = new Date(currentDate);
    if (!symbol.includes("BTC") && !symbol.includes("ETH")) {
      const dayOfWeek = date2.getDay();
      if (dayOfWeek === 0 || dayOfWeek === 6) {
        currentDate += msPerDay;
        continue;
      }
    }
    const dailyReturn = (Math.random() - 0.48) * volatility * 2;
    const open = price;
    const close = price * (1 + dailyReturn);
    const high = Math.max(open, close) * (1 + Math.random() * volatility * 0.5);
    const low = Math.min(open, close) * (1 - Math.random() * volatility * 0.5);
    const volume = Math.floor(1e6 + Math.random() * 5e6);
    bars.push({
      timestamp: currentDate,
      open,
      high,
      low,
      close,
      volume
    });
    price = close;
    currentDate += msPerDay;
  }
  return bars;
}
function runBacktest2(strategy, config) {
  const startTime = Date.now();
  const bars = generateSimulatedPriceData(config.symbol, config.startDate, config.endDate);
  if (bars.length < 50) {
    throw new Error("Insufficient price data for backtesting");
  }
  const indicators = calculateIndicators3(bars, strategy);
  let capital = config.initialCapital;
  let position = 0;
  let entryPrice = 0;
  let entryTime = 0;
  let highSinceEntry = 0;
  const trades2 = [];
  const equityCurve = [];
  let peakEquity = capital;
  for (let i = 50; i < bars.length; i++) {
    const bar = bars[i];
    const atr = indicators.get("ATR")?.[i] || bar.close * 0.02;
    const currentEquity = capital + (position > 0 ? position * (bar.close - entryPrice) : 0);
    peakEquity = Math.max(peakEquity, currentEquity);
    const drawdown = peakEquity - currentEquity;
    const drawdownPercent = peakEquity > 0 ? drawdown / peakEquity * 100 : 0;
    equityCurve.push({
      timestamp: bar.timestamp,
      equity: currentEquity,
      drawdown,
      drawdownPercent
    });
    if (position > 0) {
      highSinceEntry = Math.max(highSinceEntry, bar.high);
      let exitReason = "";
      let shouldExit = false;
      for (const rule of strategy.exitRules) {
        if (checkExitCondition(rule, entryPrice, bar.close, highSinceEntry, bar)) {
          shouldExit = true;
          exitReason = rule.name;
          break;
        }
      }
      if (shouldExit) {
        const exitPrice = bar.close * (1 - config.slippage / 100);
        const pnl = (exitPrice - entryPrice) * position - exitPrice * position * config.commission / 100;
        const pnlPercent = (exitPrice - entryPrice) / entryPrice * 100;
        trades2.push({
          id: generateId4(),
          entryTime,
          exitTime: bar.timestamp,
          entryPrice,
          exitPrice,
          quantity: position,
          side: "long",
          pnl,
          pnlPercent,
          entryReason: "Strategy Entry",
          exitReason,
          holdingPeriod: (bar.timestamp - entryTime) / (24 * 60 * 60 * 1e3),
          maxDrawdownDuringTrade: (highSinceEntry - bar.low) / highSinceEntry * 100,
          maxProfitDuringTrade: (highSinceEntry - entryPrice) / entryPrice * 100
        });
        capital += pnl;
        position = 0;
        entryPrice = 0;
        entryTime = 0;
        highSinceEntry = 0;
      }
    } else {
      let shouldEnter = true;
      let entryReason = "";
      const requiredRules = strategy.entryRules.filter((r) => r.isRequired);
      for (const rule of requiredRules) {
        if (!checkEntryCondition(rule, bar, indicators, i, i - 1)) {
          shouldEnter = false;
          break;
        }
        entryReason = rule.name;
      }
      if (shouldEnter) {
        const optionalRules = strategy.entryRules.filter((r) => !r.isRequired);
        let optionalScore = 0;
        for (const rule of optionalRules) {
          if (checkEntryCondition(rule, bar, indicators, i, i - 1)) {
            optionalScore += rule.weight;
          }
        }
        if (optionalScore < 0.2 && optionalRules.length > 0) {
          shouldEnter = false;
        }
      }
      if (shouldEnter && trades2.length < strategy.maxConcurrentPositions * 10) {
        const positionSize = calculatePositionSize(strategy.positionSizing, capital, bar.close, atr);
        const maxPositionValue = capital * (strategy.positionSizing.maxSize / 100);
        const actualSize = Math.min(positionSize, Math.floor(maxPositionValue / bar.close));
        if (actualSize > 0 && actualSize * bar.close <= capital) {
          entryPrice = bar.close * (1 + config.slippage / 100);
          position = actualSize;
          entryTime = bar.timestamp;
          highSinceEntry = bar.high;
          capital -= entryPrice * position * config.commission / 100;
        }
      }
    }
  }
  if (position > 0) {
    const lastBar = bars[bars.length - 1];
    const exitPrice = lastBar.close;
    const pnl = (exitPrice - entryPrice) * position;
    trades2.push({
      id: generateId4(),
      entryTime,
      exitTime: lastBar.timestamp,
      entryPrice,
      exitPrice,
      quantity: position,
      side: "long",
      pnl,
      pnlPercent: (exitPrice - entryPrice) / entryPrice * 100,
      entryReason: "Strategy Entry",
      exitReason: "End of Backtest",
      holdingPeriod: (lastBar.timestamp - entryTime) / (24 * 60 * 60 * 1e3),
      maxDrawdownDuringTrade: 0,
      maxProfitDuringTrade: (highSinceEntry - entryPrice) / entryPrice * 100
    });
    capital += pnl;
  }
  const metrics = calculateBacktestMetrics(trades2, equityCurve, config.initialCapital, capital);
  const monthlyPerformance = calculateMonthlyPerformance(trades2);
  const yearlyPerformance = calculateYearlyPerformance(trades2);
  const benchmarkBars = generateSimulatedPriceData("SPY", config.startDate, config.endDate);
  const benchmarkReturn = benchmarkBars.length > 0 ? (benchmarkBars[benchmarkBars.length - 1].close - benchmarkBars[0].close) / benchmarkBars[0].close * 100 : 0;
  return {
    id: generateId4(),
    strategyId: strategy.id,
    strategyName: strategy.name,
    config,
    metrics,
    trades: trades2,
    equityCurve,
    monthlyPerformance,
    yearlyPerformance,
    benchmark: {
      symbol: "SPY",
      return: benchmarkReturn,
      sharpeRatio: benchmarkReturn / 15,
      // Approximate
      maxDrawdown: 10 + Math.random() * 10
    },
    executedAt: Date.now(),
    duration: Date.now() - startTime
  };
}
function calculateBacktestMetrics(trades2, equityCurve, initialCapital, finalCapital) {
  const totalReturn = finalCapital - initialCapital;
  const totalReturnPercent = totalReturn / initialCapital * 100;
  const tradingDays = equityCurve.length;
  const tradingYears = tradingDays / 252;
  const annualizedReturn = tradingYears > 0 ? (Math.pow(finalCapital / initialCapital, 1 / tradingYears) - 1) * 100 : 0;
  let maxDrawdown = 0;
  let maxDrawdownPercent = 0;
  let maxDrawdownDuration = 0;
  let currentDrawdownStart = 0;
  for (const point of equityCurve) {
    if (point.drawdown > maxDrawdown) {
      maxDrawdown = point.drawdown;
      maxDrawdownPercent = point.drawdownPercent;
    }
    if (point.drawdown > 0 && currentDrawdownStart === 0) {
      currentDrawdownStart = point.timestamp;
    } else if (point.drawdown === 0 && currentDrawdownStart > 0) {
      const duration = (point.timestamp - currentDrawdownStart) / (24 * 60 * 60 * 1e3);
      maxDrawdownDuration = Math.max(maxDrawdownDuration, duration);
      currentDrawdownStart = 0;
    }
  }
  const returns = equityCurve.slice(1).map(
    (p, i) => (p.equity - equityCurve[i].equity) / equityCurve[i].equity
  );
  const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
  const variance = returns.reduce((sum2, r) => sum2 + Math.pow(r - avgReturn, 2), 0) / returns.length;
  const volatility = Math.sqrt(variance * 252) * 100;
  const negativeReturns = returns.filter((r) => r < 0);
  const downsideVariance = negativeReturns.length > 0 ? negativeReturns.reduce((sum2, r) => sum2 + Math.pow(r, 2), 0) / negativeReturns.length : 0;
  const downsideVolatility = Math.sqrt(downsideVariance * 252) * 100;
  const riskFreeRate = 0.05;
  const sharpeRatio = volatility > 0 ? (annualizedReturn - riskFreeRate * 100) / volatility : 0;
  const sortinoRatio = downsideVolatility > 0 ? (annualizedReturn - riskFreeRate * 100) / downsideVolatility : 0;
  const calmarRatio = maxDrawdownPercent > 0 ? annualizedReturn / maxDrawdownPercent : 0;
  const winningTrades = trades2.filter((t2) => t2.pnl > 0);
  const losingTrades = trades2.filter((t2) => t2.pnl <= 0);
  const winRate = trades2.length > 0 ? winningTrades.length / trades2.length * 100 : 0;
  const avgWin = winningTrades.length > 0 ? winningTrades.reduce((sum2, t2) => sum2 + t2.pnl, 0) / winningTrades.length : 0;
  const avgLoss = losingTrades.length > 0 ? Math.abs(losingTrades.reduce((sum2, t2) => sum2 + t2.pnl, 0) / losingTrades.length) : 0;
  const largestWin = winningTrades.length > 0 ? Math.max(...winningTrades.map((t2) => t2.pnl)) : 0;
  const largestLoss = losingTrades.length > 0 ? Math.abs(Math.min(...losingTrades.map((t2) => t2.pnl))) : 0;
  const avgHoldingPeriod = trades2.length > 0 ? trades2.reduce((sum2, t2) => sum2 + t2.holdingPeriod, 0) / trades2.length : 0;
  const totalWins = winningTrades.reduce((sum2, t2) => sum2 + t2.pnl, 0);
  const totalLosses = Math.abs(losingTrades.reduce((sum2, t2) => sum2 + t2.pnl, 0));
  const profitFactor = totalLosses > 0 ? totalWins / totalLosses : totalWins > 0 ? Infinity : 0;
  let maxConsecutiveWins = 0;
  let maxConsecutiveLosses = 0;
  let currentConsecutiveWins = 0;
  let currentConsecutiveLosses = 0;
  let totalConsecutiveWinStreaks = 0;
  let totalConsecutiveLossStreaks = 0;
  let winStreakCount = 0;
  let lossStreakCount = 0;
  for (const trade of trades2) {
    if (trade.pnl > 0) {
      currentConsecutiveWins++;
      if (currentConsecutiveLosses > 0) {
        totalConsecutiveLossStreaks += currentConsecutiveLosses;
        lossStreakCount++;
      }
      currentConsecutiveLosses = 0;
      maxConsecutiveWins = Math.max(maxConsecutiveWins, currentConsecutiveWins);
    } else {
      currentConsecutiveLosses++;
      if (currentConsecutiveWins > 0) {
        totalConsecutiveWinStreaks += currentConsecutiveWins;
        winStreakCount++;
      }
      currentConsecutiveWins = 0;
      maxConsecutiveLosses = Math.max(maxConsecutiveLosses, currentConsecutiveLosses);
    }
  }
  const avgConsecutiveWins = winStreakCount > 0 ? totalConsecutiveWinStreaks / winStreakCount : 0;
  const avgConsecutiveLosses = lossStreakCount > 0 ? totalConsecutiveLossStreaks / lossStreakCount : 0;
  const totalHoldingTime = trades2.reduce((sum2, t2) => sum2 + t2.holdingPeriod, 0);
  const timeInMarket = tradingDays > 0 ? totalHoldingTime / tradingDays * 100 : 0;
  const positionSizes = trades2.map((t2) => t2.quantity * t2.entryPrice);
  const avgPositionSize = positionSizes.length > 0 ? positionSizes.reduce((a, b) => a + b, 0) / positionSizes.length : 0;
  const maxPositionSize = positionSizes.length > 0 ? Math.max(...positionSizes) : 0;
  const monthlyReturns = calculateMonthlyReturns(equityCurve);
  return {
    totalReturn,
    totalReturnPercent,
    annualizedReturn,
    monthlyReturns,
    maxDrawdown,
    maxDrawdownPercent,
    maxDrawdownDuration,
    volatility,
    downsidevVolatility: downsideVolatility,
    sharpeRatio,
    sortinoRatio,
    calmarRatio,
    totalTrades: trades2.length,
    winningTrades: winningTrades.length,
    losingTrades: losingTrades.length,
    winRate,
    avgWin,
    avgLoss,
    largestWin,
    largestLoss,
    avgHoldingPeriod,
    profitFactor,
    maxConsecutiveWins,
    maxConsecutiveLosses,
    avgConsecutiveWins,
    avgConsecutiveLosses,
    timeInMarket,
    avgPositionSize,
    maxPositionSize
  };
}
function calculateMonthlyReturns(equityCurve) {
  const monthlyReturns = [];
  let lastMonthEnd = equityCurve[0]?.equity || 0;
  let currentMonth = new Date(equityCurve[0]?.timestamp || 0).getMonth();
  for (const point of equityCurve) {
    const month = new Date(point.timestamp).getMonth();
    if (month !== currentMonth) {
      const monthReturn = lastMonthEnd > 0 ? (point.equity - lastMonthEnd) / lastMonthEnd * 100 : 0;
      monthlyReturns.push(monthReturn);
      lastMonthEnd = point.equity;
      currentMonth = month;
    }
  }
  return monthlyReturns;
}
function calculateMonthlyPerformance(trades2) {
  const monthlyData = /* @__PURE__ */ new Map();
  for (const trade of trades2) {
    const date2 = new Date(trade.exitTime);
    const monthKey = `${date2.getFullYear()}-${String(date2.getMonth() + 1).padStart(2, "0")}`;
    if (!monthlyData.has(monthKey)) {
      monthlyData.set(monthKey, []);
    }
    monthlyData.get(monthKey).push(trade);
  }
  const result = [];
  for (const [month, monthTrades] of Array.from(monthlyData)) {
    const totalPnl = monthTrades.reduce((sum2, t2) => sum2 + t2.pnl, 0);
    const wins = monthTrades.filter((t2) => t2.pnl > 0).length;
    result.push({
      month,
      return: totalPnl,
      trades: monthTrades.length,
      winRate: monthTrades.length > 0 ? wins / monthTrades.length * 100 : 0
    });
  }
  return result.sort((a, b) => a.month.localeCompare(b.month));
}
function calculateYearlyPerformance(trades2) {
  const yearlyData = /* @__PURE__ */ new Map();
  for (const trade of trades2) {
    const year = new Date(trade.exitTime).getFullYear();
    if (!yearlyData.has(year)) {
      yearlyData.set(year, []);
    }
    yearlyData.get(year).push(trade);
  }
  const result = [];
  for (const [year, yearTrades] of Array.from(yearlyData)) {
    const totalPnl = yearTrades.reduce((sum2, t2) => sum2 + t2.pnl, 0);
    const wins = yearTrades.filter((t2) => t2.pnl > 0).length;
    const maxLoss = yearTrades.length > 0 ? Math.abs(Math.min(...yearTrades.map((t2) => t2.pnl), 0)) : 0;
    result.push({
      year,
      return: totalPnl,
      trades: yearTrades.length,
      winRate: yearTrades.length > 0 ? wins / yearTrades.length * 100 : 0,
      maxDrawdown: maxLoss
    });
  }
  return result.sort((a, b) => a.year - b.year);
}
function runParameterSweep(strategy, baseConfig, parameterRanges) {
  const results = [];
  const stopLosses = parameterRanges.stopLossRange || [3];
  const takeProfits = parameterRanges.takeProfitRange || [6];
  const positionSizes = parameterRanges.positionSizeRange || [2];
  for (const sl of stopLosses) {
    for (const tp of takeProfits) {
      for (const ps of positionSizes) {
        const modifiedStrategy = {
          ...strategy,
          exitRules: strategy.exitRules.map((rule) => {
            if (rule.type === "stop_loss") return { ...rule, value: sl };
            if (rule.type === "take_profit") return { ...rule, value: tp };
            return rule;
          }),
          positionSizing: {
            ...strategy.positionSizing,
            riskPerTrade: ps
          }
        };
        const result = runBacktest2(modifiedStrategy, baseConfig);
        results.push(result);
      }
    }
  }
  return results;
}
function compareBacktestResults(results) {
  const comparison = results.map((r) => {
    const score = r.metrics.sharpeRatio * 20 + r.metrics.winRate * 0.3 + r.metrics.profitFactor * 10 + (100 - r.metrics.maxDrawdownPercent) * 0.2 + r.metrics.annualizedReturn * 0.5;
    return {
      id: r.id,
      strategyName: r.strategyName,
      totalReturn: r.metrics.totalReturnPercent,
      sharpeRatio: r.metrics.sharpeRatio,
      maxDrawdown: r.metrics.maxDrawdownPercent,
      winRate: r.metrics.winRate,
      profitFactor: r.metrics.profitFactor,
      score: Math.round(score * 100) / 100
    };
  }).sort((a, b) => b.score - a.score);
  const bestOverall = comparison[0]?.id || "";
  const bestRiskAdjusted = [...comparison].sort((a, b) => b.sharpeRatio - a.sharpeRatio)[0]?.id || "";
  const bestWinRate = [...comparison].sort((a, b) => b.winRate - a.winRate)[0]?.id || "";
  return {
    comparison,
    bestOverall,
    bestRiskAdjusted,
    bestWinRate
  };
}
function getBacktestSummary(result) {
  const m = result.metrics;
  const b = result.benchmark;
  return {
    overview: {
      totalReturn: `${m.totalReturnPercent >= 0 ? "+" : ""}${m.totalReturnPercent.toFixed(2)}%`,
      annualizedReturn: `${m.annualizedReturn >= 0 ? "+" : ""}${m.annualizedReturn.toFixed(2)}%`,
      sharpeRatio: m.sharpeRatio.toFixed(2),
      maxDrawdown: `${m.maxDrawdownPercent.toFixed(2)}%`,
      winRate: `${m.winRate.toFixed(1)}%`,
      profitFactor: m.profitFactor === Infinity ? "\u221E" : m.profitFactor.toFixed(2)
    },
    performance: {
      totalTrades: m.totalTrades,
      winningTrades: m.winningTrades,
      losingTrades: m.losingTrades,
      avgWin: `$${m.avgWin.toFixed(2)}`,
      avgLoss: `$${m.avgLoss.toFixed(2)}`,
      avgHoldingPeriod: `${m.avgHoldingPeriod.toFixed(1)} days`
    },
    risk: {
      volatility: `${m.volatility.toFixed(2)}%`,
      sortinoRatio: m.sortinoRatio.toFixed(2),
      calmarRatio: m.calmarRatio.toFixed(2),
      maxConsecutiveLosses: m.maxConsecutiveLosses,
      timeInMarket: `${m.timeInMarket.toFixed(1)}%`
    },
    vsBenchmark: {
      strategyReturn: `${m.totalReturnPercent >= 0 ? "+" : ""}${m.totalReturnPercent.toFixed(2)}%`,
      benchmarkReturn: b ? `${b.return >= 0 ? "+" : ""}${b.return.toFixed(2)}%` : "N/A",
      alpha: b ? `${m.totalReturnPercent - b.return >= 0 ? "+" : ""}${(m.totalReturnPercent - b.return).toFixed(2)}%` : "N/A"
    }
  };
}
var init_StrategyBacktestingIntegration = __esm({
  "server/services/ai-agents/StrategyBacktestingIntegration.ts"() {
    "use strict";
  }
});

// server/services/ai-agents/StrategyAlerts.ts
var StrategyAlerts_exports = {};
__export(StrategyAlerts_exports, {
  ALERT_TEMPLATES: () => ALERT_TEMPLATES,
  acknowledgeTrigger: () => acknowledgeTrigger,
  cancelAlert: () => cancelAlert,
  checkAlertConditions: () => checkAlertConditions,
  createAlert: () => createAlert2,
  createAlertFromStrategy: () => createAlertFromStrategy,
  createAlertFromTemplate: () => createAlertFromTemplate,
  createBulkAlerts: () => createBulkAlerts2,
  deleteAlert: () => deleteAlert2,
  exportAlerts: () => exportAlerts,
  getAlert: () => getAlert,
  getAlertSummary: () => getAlertSummary3,
  getAlertTemplates: () => getAlertTemplates,
  getAlertTriggers: () => getAlertTriggers,
  getRecentTriggers: () => getRecentTriggers,
  getUserAlerts: () => getUserAlerts2,
  importAlerts: () => importAlerts,
  processAlerts: () => processAlerts,
  simulateMarketSnapshot: () => simulateMarketSnapshot,
  updateAlert: () => updateAlert2
});
function generateId5() {
  return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
function generateTriggerId() {
  return `trigger_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}
function createAlert2(userId, strategyId, strategyName, symbol, config) {
  const alert = {
    id: generateId5(),
    userId,
    strategyId,
    strategyName,
    symbol: symbol.toUpperCase(),
    type: config.type,
    priority: config.priority || "medium",
    status: "active",
    conditions: config.conditions,
    conditionLogic: config.conditionLogic || "all",
    message: config.message || `Alert for ${symbol} - ${config.type}`,
    notificationChannels: config.notificationChannels || ["in_app"],
    cooldownMinutes: config.cooldownMinutes || 30,
    expiresAt: config.expiresAt,
    createdAt: Date.now(),
    updatedAt: Date.now(),
    triggerCount: 0,
    maxTriggers: config.maxTriggers
  };
  alertsStore.set(alert.id, alert);
  triggersStore.set(alert.id, []);
  return alert;
}
function createAlertFromStrategy(userId, strategy, symbol, ruleType) {
  const alerts = [];
  const rules = ruleType === "entry" ? strategy.entryRules : strategy.exitRules;
  for (const rule of rules) {
    if (ruleType === "entry") {
      const entryRule = rule;
      const conditions = [{
        type: entryRule.indicator.toLowerCase().includes("price") ? "price" : "indicator",
        indicator: entryRule.indicator,
        operator: entryRule.condition,
        value: entryRule.value
      }];
      const alert = createAlert2(userId, strategy.id, strategy.name, symbol, {
        type: "entry_signal",
        priority: entryRule.isRequired ? "high" : "medium",
        conditions,
        message: `Entry signal: ${entryRule.name} - ${entryRule.description}`,
        cooldownMinutes: 60
      });
      alerts.push(alert);
    } else {
      const exitRule = rule;
      let alertType = "exit_signal";
      if (exitRule.type === "stop_loss") alertType = "stop_loss";
      if (exitRule.type === "take_profit") alertType = "price_target";
      const conditions = [{
        type: "price",
        operator: exitRule.type === "stop_loss" ? "below" : "above",
        value: exitRule.value
      }];
      const alert = createAlert2(userId, strategy.id, strategy.name, symbol, {
        type: alertType,
        priority: exitRule.type === "stop_loss" ? "critical" : "high",
        conditions,
        message: `Exit signal: ${exitRule.name}`,
        cooldownMinutes: exitRule.type === "stop_loss" ? 5 : 30
      });
      alerts.push(alert);
    }
  }
  return alerts;
}
function createAlertFromTemplate(userId, strategyId, strategyName, symbol, templateId, overrides) {
  const template = ALERT_TEMPLATES.find((t2) => t2.id === templateId);
  if (!template) return null;
  return createAlert2(userId, strategyId, strategyName, symbol, {
    type: template.type,
    priority: overrides?.priority || template.defaultPriority,
    conditions: overrides?.conditions || template.conditions,
    conditionLogic: template.conditionLogic,
    message: `${template.name} alert for ${symbol}`,
    notificationChannels: overrides?.notificationChannels || ["in_app", "email"],
    cooldownMinutes: overrides?.cooldownMinutes || template.defaultCooldown
  });
}
function getAlert(alertId) {
  return alertsStore.get(alertId) || null;
}
function getUserAlerts2(userId, filters) {
  let alerts = Array.from(alertsStore.values()).filter((a) => a.userId === userId);
  if (filters?.status) {
    alerts = alerts.filter((a) => a.status === filters.status);
  }
  if (filters?.type) {
    alerts = alerts.filter((a) => a.type === filters.type);
  }
  if (filters?.symbol) {
    const symbolUpper = filters.symbol.toUpperCase();
    alerts = alerts.filter((a) => a.symbol === symbolUpper);
  }
  if (filters?.strategyId) {
    alerts = alerts.filter((a) => a.strategyId === filters.strategyId);
  }
  return alerts.sort((a, b) => b.createdAt - a.createdAt);
}
function updateAlert2(alertId, updates) {
  const alert = alertsStore.get(alertId);
  if (!alert) return null;
  const updated = {
    ...alert,
    ...updates,
    updatedAt: Date.now()
  };
  alertsStore.set(alertId, updated);
  return updated;
}
function cancelAlert(alertId) {
  const alert = alertsStore.get(alertId);
  if (!alert) return false;
  alert.status = "cancelled";
  alert.updatedAt = Date.now();
  alertsStore.set(alertId, alert);
  return true;
}
function deleteAlert2(alertId) {
  const deleted = alertsStore.delete(alertId);
  triggersStore.delete(alertId);
  return deleted;
}
function checkAlertConditions(alert, snapshot, previousSnapshot) {
  const conditionResults = [];
  for (const condition of alert.conditions) {
    let actualValue = 0;
    let met = false;
    switch (condition.type) {
      case "price":
        actualValue = snapshot.price;
        met = evaluateCondition2(actualValue, condition.operator, condition.value, previousSnapshot?.price);
        break;
      case "indicator":
        actualValue = snapshot.indicators.get(condition.indicator || "") || 0;
        const prevIndicatorValue = previousSnapshot?.indicators.get(condition.indicator || "");
        met = evaluateCondition2(actualValue, condition.operator, condition.value, prevIndicatorValue);
        break;
      case "volume":
        actualValue = snapshot.volume;
        met = evaluateCondition2(actualValue, condition.operator, condition.value);
        break;
      case "volatility":
        actualValue = Math.abs(snapshot.changePercent);
        met = evaluateCondition2(actualValue, condition.operator, condition.value);
        break;
      default:
        met = false;
    }
    conditionResults.push({ condition, actualValue, met });
  }
  const triggered = alert.conditionLogic === "all" ? conditionResults.every((r) => r.met) : conditionResults.some((r) => r.met);
  return { triggered, conditionResults };
}
function evaluateCondition2(value, operator, target, previousValue) {
  switch (operator) {
    case "above":
      return value > target;
    case "below":
      return value < target;
    case "equals":
      return Math.abs(value - target) < 1e-3;
    case "between":
      const [min, max] = target;
      return value >= min && value <= max;
    case "crosses_above":
      return previousValue !== void 0 && previousValue <= target && value > target;
    case "crosses_below":
      return previousValue !== void 0 && previousValue >= target && value < target;
    case "change_percent":
      return previousValue !== void 0 && Math.abs((value - previousValue) / previousValue * 100) >= target;
    default:
      return false;
  }
}
function processAlerts(symbol, snapshot) {
  const triggers = [];
  const previousSnapshot = marketDataCache.get(symbol);
  marketDataCache.set(symbol, snapshot);
  const alerts = Array.from(alertsStore.values()).filter(
    (a) => a.symbol === symbol.toUpperCase() && a.status === "active"
  );
  for (const alert of alerts) {
    if (alert.expiresAt && Date.now() > alert.expiresAt) {
      alert.status = "expired";
      alertsStore.set(alert.id, alert);
      continue;
    }
    if (alert.maxTriggers && alert.triggerCount >= alert.maxTriggers) {
      alert.status = "triggered";
      alertsStore.set(alert.id, alert);
      continue;
    }
    if (alert.lastTriggeredAt) {
      const cooldownMs = alert.cooldownMinutes * 60 * 1e3;
      if (Date.now() - alert.lastTriggeredAt < cooldownMs) {
        continue;
      }
    }
    const { triggered, conditionResults } = checkAlertConditions(alert, snapshot, previousSnapshot);
    if (triggered) {
      const trigger = {
        id: generateTriggerId(),
        alertId: alert.id,
        triggeredAt: Date.now(),
        price: snapshot.price,
        conditions: conditionResults,
        notificationsSent: alert.notificationChannels,
        acknowledged: false
      };
      alert.lastTriggeredAt = Date.now();
      alert.triggerCount++;
      alert.updatedAt = Date.now();
      alertsStore.set(alert.id, alert);
      const alertTriggers = triggersStore.get(alert.id) || [];
      alertTriggers.push(trigger);
      triggersStore.set(alert.id, alertTriggers);
      triggers.push(trigger);
    }
  }
  return triggers;
}
function getAlertTriggers(alertId) {
  return triggersStore.get(alertId) || [];
}
function acknowledgeTrigger(triggerId) {
  for (const triggers of Array.from(triggersStore.values())) {
    const trigger = triggers.find((t2) => t2.id === triggerId);
    if (trigger) {
      trigger.acknowledged = true;
      trigger.acknowledgedAt = Date.now();
      return true;
    }
  }
  return false;
}
function getAlertSummary3(userId) {
  const alerts = getUserAlerts2(userId);
  const now = Date.now();
  const dayMs = 24 * 60 * 60 * 1e3;
  const weekMs = 7 * dayMs;
  const activeAlerts2 = alerts.filter((a) => a.status === "active");
  let triggeredToday = 0;
  let triggeredThisWeek = 0;
  for (const alert of alerts) {
    const triggers = triggersStore.get(alert.id) || [];
    for (const trigger of triggers) {
      if (now - trigger.triggeredAt < dayMs) triggeredToday++;
      if (now - trigger.triggeredAt < weekMs) triggeredThisWeek++;
    }
  }
  const byType = {
    entry_signal: 0,
    exit_signal: 0,
    price_target: 0,
    stop_loss: 0,
    indicator_crossover: 0,
    volume_spike: 0,
    volatility_alert: 0,
    custom: 0
  };
  const byPriority = {
    low: 0,
    medium: 0,
    high: 0,
    critical: 0
  };
  const symbolCounts = /* @__PURE__ */ new Map();
  for (const alert of activeAlerts2) {
    byType[alert.type]++;
    byPriority[alert.priority]++;
    symbolCounts.set(alert.symbol, (symbolCounts.get(alert.symbol) || 0) + 1);
  }
  const topSymbols = Array.from(symbolCounts.entries()).map(([symbol, count2]) => ({ symbol, count: count2 })).sort((a, b) => b.count - a.count).slice(0, 5);
  return {
    totalAlerts: alerts.length,
    activeAlerts: activeAlerts2.length,
    triggeredToday,
    triggeredThisWeek,
    byType,
    byPriority,
    topSymbols
  };
}
function getAlertTemplates(category) {
  if (category) {
    return ALERT_TEMPLATES.filter((t2) => t2.category === category);
  }
  return ALERT_TEMPLATES;
}
function simulateMarketSnapshot(symbol) {
  const basePrice = symbol === "BTC" ? 45e3 : symbol === "ETH" ? 2500 : 150;
  const price = basePrice * (1 + (Math.random() - 0.5) * 0.02);
  const change = price - basePrice;
  const changePercent = change / basePrice * 100;
  const indicators = /* @__PURE__ */ new Map();
  indicators.set("RSI", 30 + Math.random() * 40);
  indicators.set("MACD", (Math.random() - 0.5) * 2);
  indicators.set("MACD_Histogram", (Math.random() - 0.5) * 0.5);
  indicators.set("SMA_50", price * (1 + (Math.random() - 0.5) * 0.05));
  indicators.set("SMA_200", price * (1 + (Math.random() - 0.5) * 0.1));
  indicators.set("BB_WIDTH", 0.05 + Math.random() * 0.15);
  return {
    symbol: symbol.toUpperCase(),
    timestamp: Date.now(),
    price,
    open: price * (1 - Math.random() * 0.01),
    high: price * (1 + Math.random() * 0.02),
    low: price * (1 - Math.random() * 0.02),
    volume: Math.floor(1e6 + Math.random() * 5e6),
    change,
    changePercent,
    indicators
  };
}
function createBulkAlerts2(userId, strategyId, strategyName, symbols, config) {
  return symbols.map(
    (symbol) => createAlert2(userId, strategyId, strategyName, symbol, config)
  );
}
function getRecentTriggers(userId, limit = 20) {
  const userAlerts = getUserAlerts2(userId);
  const allTriggers = [];
  for (const alert of userAlerts) {
    const triggers = triggersStore.get(alert.id) || [];
    for (const trigger of triggers) {
      allTriggers.push({ ...trigger, alert });
    }
  }
  return allTriggers.sort((a, b) => b.triggeredAt - a.triggeredAt).slice(0, limit);
}
function exportAlerts(userId) {
  const alerts = getUserAlerts2(userId);
  return JSON.stringify({
    exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
    version: "1.0",
    alerts: alerts.map((a) => ({
      ...a
      // Don't export triggers
    }))
  }, null, 2);
}
function importAlerts(userId, jsonData) {
  const errors = [];
  let imported = 0;
  try {
    const data = JSON.parse(jsonData);
    if (!data.alerts || !Array.isArray(data.alerts)) {
      errors.push("Invalid format: missing alerts array");
      return { imported, errors };
    }
    for (const alertData of data.alerts) {
      try {
        createAlert2(userId, alertData.strategyId, alertData.strategyName, alertData.symbol, {
          type: alertData.type,
          priority: alertData.priority,
          conditions: alertData.conditions,
          conditionLogic: alertData.conditionLogic,
          message: alertData.message,
          notificationChannels: alertData.notificationChannels,
          cooldownMinutes: alertData.cooldownMinutes
        });
        imported++;
      } catch (e) {
        errors.push(`Failed to import alert for ${alertData.symbol}: ${e}`);
      }
    }
  } catch (e) {
    errors.push(`Failed to parse JSON: ${e}`);
  }
  return { imported, errors };
}
var alertsStore, triggersStore, marketDataCache, ALERT_TEMPLATES;
var init_StrategyAlerts = __esm({
  "server/services/ai-agents/StrategyAlerts.ts"() {
    "use strict";
    alertsStore = /* @__PURE__ */ new Map();
    triggersStore = /* @__PURE__ */ new Map();
    marketDataCache = /* @__PURE__ */ new Map();
    ALERT_TEMPLATES = [
      {
        id: "template_rsi_oversold",
        name: "RSI Oversold Entry",
        description: "Alert when RSI drops below 30, indicating potential buying opportunity",
        type: "entry_signal",
        conditions: [
          { type: "indicator", indicator: "RSI", operator: "below", value: 30 }
        ],
        conditionLogic: "all",
        defaultPriority: "high",
        defaultCooldown: 60,
        category: "entry"
      },
      {
        id: "template_rsi_overbought",
        name: "RSI Overbought Exit",
        description: "Alert when RSI rises above 70, indicating potential selling opportunity",
        type: "exit_signal",
        conditions: [
          { type: "indicator", indicator: "RSI", operator: "above", value: 70 }
        ],
        conditionLogic: "all",
        defaultPriority: "high",
        defaultCooldown: 60,
        category: "exit"
      },
      {
        id: "template_macd_bullish",
        name: "MACD Bullish Crossover",
        description: "Alert when MACD crosses above signal line",
        type: "indicator_crossover",
        conditions: [
          { type: "indicator", indicator: "MACD_Histogram", operator: "crosses_above", value: 0 }
        ],
        conditionLogic: "all",
        defaultPriority: "medium",
        defaultCooldown: 240,
        category: "entry"
      },
      {
        id: "template_macd_bearish",
        name: "MACD Bearish Crossover",
        description: "Alert when MACD crosses below signal line",
        type: "indicator_crossover",
        conditions: [
          { type: "indicator", indicator: "MACD_Histogram", operator: "crosses_below", value: 0 }
        ],
        conditionLogic: "all",
        defaultPriority: "medium",
        defaultCooldown: 240,
        category: "exit"
      },
      {
        id: "template_golden_cross",
        name: "Golden Cross",
        description: "Alert when 50-day SMA crosses above 200-day SMA",
        type: "indicator_crossover",
        conditions: [
          { type: "indicator", indicator: "SMA_50_200_RATIO", operator: "crosses_above", value: 1 }
        ],
        conditionLogic: "all",
        defaultPriority: "high",
        defaultCooldown: 1440,
        category: "entry"
      },
      {
        id: "template_death_cross",
        name: "Death Cross",
        description: "Alert when 50-day SMA crosses below 200-day SMA",
        type: "indicator_crossover",
        conditions: [
          { type: "indicator", indicator: "SMA_50_200_RATIO", operator: "crosses_below", value: 1 }
        ],
        conditionLogic: "all",
        defaultPriority: "critical",
        defaultCooldown: 1440,
        category: "exit"
      },
      {
        id: "template_bollinger_squeeze",
        name: "Bollinger Band Squeeze",
        description: "Alert when Bollinger Bands narrow significantly, indicating potential breakout",
        type: "volatility_alert",
        conditions: [
          { type: "indicator", indicator: "BB_WIDTH", operator: "below", value: 0.1 }
        ],
        conditionLogic: "all",
        defaultPriority: "medium",
        defaultCooldown: 480,
        category: "opportunity"
      },
      {
        id: "template_volume_spike",
        name: "Volume Spike",
        description: "Alert when volume exceeds 200% of average",
        type: "volume_spike",
        conditions: [
          { type: "volume", operator: "above", value: 200 }
        ],
        conditionLogic: "all",
        defaultPriority: "medium",
        defaultCooldown: 120,
        category: "opportunity"
      },
      {
        id: "template_price_breakout",
        name: "Price Breakout",
        description: "Alert when price breaks above recent high",
        type: "entry_signal",
        conditions: [
          { type: "price", operator: "above", value: 0 }
          // Value set dynamically
        ],
        conditionLogic: "all",
        defaultPriority: "high",
        defaultCooldown: 60,
        category: "entry"
      },
      {
        id: "template_stop_loss",
        name: "Stop Loss Warning",
        description: "Alert when price approaches stop loss level",
        type: "stop_loss",
        conditions: [
          { type: "price", operator: "below", value: 0 }
          // Value set dynamically
        ],
        conditionLogic: "all",
        defaultPriority: "critical",
        defaultCooldown: 5,
        category: "risk"
      }
    ];
  }
});

// server/services/brokers/AlpacaBrokerAdapter.ts
var AlpacaBrokerAdapter_exports = {};
__export(AlpacaBrokerAdapter_exports, {
  AlpacaBrokerAdapter: () => AlpacaBrokerAdapter,
  createAlpacaBroker: () => createAlpacaBroker
});
function createAlpacaBroker() {
  return new AlpacaBrokerAdapter();
}
var ALPACA_PAPER_BASE_URL, ALPACA_LIVE_BASE_URL, ALPACA_DATA_BASE_URL, ALPACA_STREAM_URL2, AlpacaBrokerAdapter;
var init_AlpacaBrokerAdapter = __esm({
  "server/services/brokers/AlpacaBrokerAdapter.ts"() {
    "use strict";
    init_types();
    ALPACA_PAPER_BASE_URL = "https://paper-api.alpaca.markets";
    ALPACA_LIVE_BASE_URL = "https://api.alpaca.markets";
    ALPACA_DATA_BASE_URL = "https://data.alpaca.markets";
    ALPACA_STREAM_URL2 = "wss://stream.data.alpaca.markets";
    AlpacaBrokerAdapter = class {
      brokerType = "alpaca" /* ALPACA */;
      brokerName = "Alpaca Markets";
      constructor() {
        const apiKey = process.env.ALPACA_API_KEY || "";
        const apiSecret = process.env.ALPACA_API_SECRET || "";
        if (apiKey && apiSecret) {
          this.apiKey = apiKey;
          this.apiSecret = apiSecret;
          this.isPaper = apiKey.startsWith("PK") || apiKey.includes("paper");
          this.baseUrl = this.isPaper ? ALPACA_PAPER_BASE_URL : ALPACA_LIVE_BASE_URL;
          this.connected = true;
        }
      }
      capabilities = {
        supportedAssetClasses: ["us_equity" /* US_EQUITY */, "crypto" /* CRYPTO */, "options" /* OPTIONS */],
        supportedOrderTypes: [
          "market" /* MARKET */,
          "limit" /* LIMIT */,
          "stop" /* STOP */,
          "stop_limit" /* STOP_LIMIT */,
          "trailing_stop" /* TRAILING_STOP */
        ],
        supportedTimeInForce: [
          "day" /* DAY */,
          "gtc" /* GTC */,
          "ioc" /* IOC */,
          "fok" /* FOK */,
          "opg" /* OPG */,
          "cls" /* CLS */
        ],
        supportsExtendedHours: true,
        supportsFractionalShares: true,
        supportsShortSelling: true,
        supportsMarginTrading: true,
        supportsOptionsTrading: true,
        supportsCryptoTrading: true,
        supportsForexTrading: false,
        supportsPaperTrading: true,
        supportsWebSocket: true,
        supportsStreamingQuotes: true,
        supportsStreamingBars: true,
        supportsStreamingTrades: true,
        maxOrdersPerMinute: 200
      };
      apiKey = "";
      apiSecret = "";
      isPaper = true;
      connected = false;
      baseUrl = ALPACA_PAPER_BASE_URL;
      dataUrl = ALPACA_DATA_BASE_URL;
      connection = null;
      // WebSocket connections
      dataWs = null;
      tradeWs = null;
      quoteCallbacks = /* @__PURE__ */ new Map();
      barCallbacks = /* @__PURE__ */ new Map();
      orderCallbacks = [];
      positionCallbacks = [];
      // ============================================================================
      // Connection Management
      // ============================================================================
      async connect(credentials) {
        const apiCreds = credentials;
        if (!apiCreds.apiKey || !apiCreds.apiSecret) {
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            "API key and secret are required",
            this.brokerType
          );
        }
        this.apiKey = apiCreds.apiKey;
        this.apiSecret = apiCreds.apiSecret;
        this.isPaper = apiCreds.apiKey.startsWith("PK") || apiCreds.apiKey.includes("paper");
        this.baseUrl = this.isPaper ? ALPACA_PAPER_BASE_URL : ALPACA_LIVE_BASE_URL;
        try {
          const account = await this.getAccount();
          this.connected = true;
          this.connection = {
            id: `alpaca_${account.id}`,
            userId: "",
            // Set by caller
            brokerType: this.brokerType,
            credentials: apiCreds,
            isPaper: this.isPaper,
            isActive: true,
            lastConnected: /* @__PURE__ */ new Date(),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          };
          return this.connection;
        } catch (error) {
          this.connected = false;
          throw new BrokerError(
            "authentication_failed" /* AUTHENTICATION_FAILED */,
            `Failed to connect to Alpaca: ${error instanceof Error ? error.message : "Unknown error"}`,
            this.brokerType,
            error instanceof Error ? error : void 0
          );
        }
      }
      async disconnect() {
        this.connected = false;
        this.connection = null;
        this.apiKey = "";
        this.apiSecret = "";
        if (this.dataWs) {
          this.dataWs.close();
          this.dataWs = null;
        }
        if (this.tradeWs) {
          this.tradeWs.close();
          this.tradeWs = null;
        }
        this.quoteCallbacks.clear();
        this.barCallbacks.clear();
        this.orderCallbacks = [];
        this.positionCallbacks = [];
      }
      isConnected() {
        return this.connected;
      }
      // ============================================================================
      // HTTP Request Helper
      // ============================================================================
      async request(endpoint, options = {}) {
        const { method = "GET", body, baseUrl = this.baseUrl } = options;
        const url = `${baseUrl}${endpoint}`;
        const headers = {
          "APCA-API-KEY-ID": this.apiKey,
          "APCA-API-SECRET-KEY": this.apiSecret,
          "Content-Type": "application/json"
        };
        const response = await fetch(url, {
          method,
          headers,
          body: body ? JSON.stringify(body) : void 0
        });
        if (!response.ok) {
          const errorText = await response.text();
          let errorCode = "unknown_error" /* UNKNOWN_ERROR */;
          if (response.status === 401 || response.status === 403) {
            errorCode = "authentication_failed" /* AUTHENTICATION_FAILED */;
          } else if (response.status === 429) {
            errorCode = "rate_limited" /* RATE_LIMITED */;
          } else if (response.status === 422) {
            errorCode = "invalid_order" /* INVALID_ORDER */;
          }
          throw new BrokerError(
            errorCode,
            `Alpaca API error: ${errorText}`,
            this.brokerType
          );
        }
        return response.json();
      }
      // ============================================================================
      // Account Operations
      // ============================================================================
      async getAccount() {
        const account = await this.request("/v2/account");
        return {
          id: account.id,
          accountNumber: account.account_number,
          accountType: account.pattern_day_trader ? "day_trader" : "standard",
          currency: account.currency,
          status: account.status,
          isPaper: this.isPaper,
          createdAt: new Date(account.created_at)
        };
      }
      async getAccountBalance() {
        const account = await this.request("/v2/account");
        return {
          currency: account.currency,
          cash: parseFloat(account.cash),
          cashAvailable: parseFloat(account.cash),
          cashWithdrawable: parseFloat(account.cash),
          buyingPower: parseFloat(account.buying_power),
          portfolioValue: parseFloat(account.portfolio_value),
          equity: parseFloat(account.equity),
          lastEquity: parseFloat(account.last_equity),
          longMarketValue: parseFloat(account.long_market_value),
          shortMarketValue: parseFloat(account.short_market_value),
          initialMargin: parseFloat(account.initial_margin),
          maintenanceMargin: parseFloat(account.maintenance_margin),
          dayTradeCount: account.daytrade_count,
          patternDayTrader: account.pattern_day_trader
        };
      }
      async getPortfolioHistory(period = "1M", timeframe = "1D") {
        const params = new URLSearchParams({
          period,
          timeframe,
          extended_hours: "true"
        });
        const response = await this.request(`/v2/account/portfolio/history?${params}`);
        return {
          timestamps: response.timestamp.map((t2) => new Date(t2 * 1e3)),
          equity: response.equity,
          profitLoss: response.profit_loss,
          profitLossPct: response.profit_loss_pct,
          baseValue: response.base_value,
          timeframe: response.timeframe
        };
      }
      // ============================================================================
      // Order Operations
      // ============================================================================
      async placeOrder(order) {
        const alpacaOrder = {
          symbol: order.symbol,
          qty: order.quantity.toString(),
          side: order.side,
          type: this.mapOrderType(order.type),
          time_in_force: order.timeInForce
        };
        if (order.price) alpacaOrder.limit_price = order.price.toString();
        if (order.stopPrice) alpacaOrder.stop_price = order.stopPrice.toString();
        if (order.trailPercent) alpacaOrder.trail_percent = order.trailPercent.toString();
        if (order.trailPrice) alpacaOrder.trail_price = order.trailPrice.toString();
        if (order.extendedHours) alpacaOrder.extended_hours = order.extendedHours;
        if (order.clientOrderId) alpacaOrder.client_order_id = order.clientOrderId;
        if (order.orderClass) alpacaOrder.order_class = order.orderClass;
        if (order.takeProfit) {
          alpacaOrder.take_profit = { limit_price: order.takeProfit.limitPrice.toString() };
        }
        if (order.stopLoss) {
          alpacaOrder.stop_loss = {
            stop_price: order.stopLoss.stopPrice.toString(),
            ...order.stopLoss.limitPrice && { limit_price: order.stopLoss.limitPrice.toString() }
          };
        }
        const response = await this.request("/v2/orders", {
          method: "POST",
          body: alpacaOrder
        });
        return this.mapOrder(response);
      }
      async getOrder(orderId) {
        const order = await this.request(`/v2/orders/${orderId}`);
        return this.mapOrder(order);
      }
      async getOrders(status, limit = 100, after) {
        const params = new URLSearchParams({
          limit: limit.toString(),
          direction: "desc"
        });
        if (status) {
          params.set("status", this.mapOrderStatusToAlpaca(status));
        }
        if (after) {
          params.set("after", after.toISOString());
        }
        const orders = await this.request(`/v2/orders?${params}`);
        return orders.map((o) => this.mapOrder(o));
      }
      async modifyOrder(update) {
        const body = {};
        if (update.quantity) body.qty = update.quantity.toString();
        if (update.price) body.limit_price = update.price.toString();
        if (update.stopPrice) body.stop_price = update.stopPrice.toString();
        if (update.trailPercent) body.trail = update.trailPercent.toString();
        if (update.timeInForce) body.time_in_force = update.timeInForce;
        if (update.clientOrderId) body.client_order_id = update.clientOrderId;
        const order = await this.request(`/v2/orders/${update.orderId}`, {
          method: "PATCH",
          body
        });
        return this.mapOrder(order);
      }
      async cancelOrder(orderId) {
        try {
          await this.request(`/v2/orders/${orderId}`, { method: "DELETE" });
          return true;
        } catch {
          return false;
        }
      }
      async cancelAllOrders() {
        try {
          await this.request("/v2/orders", { method: "DELETE" });
          return true;
        } catch {
          return false;
        }
      }
      // ============================================================================
      // Position Operations
      // ============================================================================
      async getPositions() {
        const positions = await this.request("/v2/positions");
        return positions.map((p) => this.mapPosition(p));
      }
      async getPosition(symbol) {
        try {
          const position = await this.request(`/v2/positions/${symbol}`);
          return this.mapPosition(position);
        } catch {
          return null;
        }
      }
      async closePosition(symbol, qty, percentQty) {
        const params = new URLSearchParams();
        if (qty) params.set("qty", qty.toString());
        if (percentQty) params.set("percentage", percentQty.toString());
        const order = await this.request(
          `/v2/positions/${symbol}?${params}`,
          { method: "DELETE" }
        );
        return this.mapOrder(order);
      }
      async closeAllPositions() {
        const response = await this.request("/v2/positions", {
          method: "DELETE"
        });
        return response.map((o) => this.mapOrder(o));
      }
      // ============================================================================
      // Market Data
      // ============================================================================
      async getQuote(symbol) {
        const response = await this.request(
          `/v2/stocks/${symbol}/quotes/latest`,
          { baseUrl: this.dataUrl }
        );
        const quote = response.quotes[symbol];
        return this.mapQuote(symbol, quote);
      }
      async getQuotes(symbols) {
        const params = new URLSearchParams({
          symbols: symbols.join(",")
        });
        const response = await this.request(
          `/v2/stocks/quotes/latest?${params}`,
          { baseUrl: this.dataUrl }
        );
        const quotes = /* @__PURE__ */ new Map();
        for (const [symbol, quote] of Object.entries(response.quotes)) {
          quotes.set(symbol, this.mapQuote(symbol, quote));
        }
        return quotes;
      }
      async getBars(params) {
        const queryParams = new URLSearchParams({
          timeframe: params.timeframe,
          start: params.start.toISOString(),
          limit: (params.limit || 1e3).toString()
        });
        if (params.end) queryParams.set("end", params.end.toISOString());
        if (params.adjustment) queryParams.set("adjustment", params.adjustment);
        const response = await this.request(
          `/v2/stocks/${params.symbol}/bars?${queryParams}`,
          { baseUrl: this.dataUrl }
        );
        return response.bars.map((b) => this.mapBar(b));
      }
      async getSnapshot(symbol) {
        const response = await this.request(`/v2/stocks/${symbol}/snapshot`, { baseUrl: this.dataUrl });
        return {
          symbol,
          latestTrade: response.latestTrade ? this.mapTrade(symbol, response.latestTrade) : void 0,
          latestQuote: response.latestQuote ? this.mapQuote(symbol, response.latestQuote) : void 0,
          minuteBar: response.minuteBar ? this.mapBar(response.minuteBar) : void 0,
          dailyBar: response.dailyBar ? this.mapBar(response.dailyBar) : void 0,
          prevDailyBar: response.prevDailyBar ? this.mapBar(response.prevDailyBar) : void 0
        };
      }
      async getSnapshots(symbols) {
        const params = new URLSearchParams({
          symbols: symbols.join(",")
        });
        const response = await this.request(`/v2/stocks/snapshots?${params}`, { baseUrl: this.dataUrl });
        const snapshots = /* @__PURE__ */ new Map();
        for (const [symbol, data] of Object.entries(response)) {
          snapshots.set(symbol, {
            symbol,
            latestTrade: data.latestTrade ? this.mapTrade(symbol, data.latestTrade) : void 0,
            latestQuote: data.latestQuote ? this.mapQuote(symbol, data.latestQuote) : void 0,
            minuteBar: data.minuteBar ? this.mapBar(data.minuteBar) : void 0,
            dailyBar: data.dailyBar ? this.mapBar(data.dailyBar) : void 0,
            prevDailyBar: data.prevDailyBar ? this.mapBar(data.prevDailyBar) : void 0
          });
        }
        return snapshots;
      }
      async getTrades(symbol, start, end, limit = 1e3) {
        const params = new URLSearchParams({
          start: start.toISOString(),
          limit: limit.toString()
        });
        if (end) params.set("end", end.toISOString());
        const response = await this.request(
          `/v2/stocks/${symbol}/trades?${params}`,
          { baseUrl: this.dataUrl }
        );
        return response.trades.map((t2) => this.mapTrade(symbol, t2));
      }
      // ============================================================================
      // Asset Information
      // ============================================================================
      async getAsset(symbol) {
        const asset = await this.request(`/v2/assets/${symbol}`);
        return this.mapAsset(asset);
      }
      async getAssets(assetClass) {
        const params = new URLSearchParams({ status: "active" });
        if (assetClass) {
          params.set("asset_class", this.mapAssetClassToAlpaca(assetClass));
        }
        const assets = await this.request(`/v2/assets?${params}`);
        return assets.map((a) => this.mapAsset(a));
      }
      // ============================================================================
      // Options (Alpaca Options API)
      // ============================================================================
      async getOptionsChain(request) {
        const params = new URLSearchParams({
          underlying_symbols: request.underlyingSymbol
        });
        if (request.expirationDate) {
          params.set("expiration_date", request.expirationDate.toISOString().split("T")[0]);
        }
        if (request.strikePrice) {
          params.set("strike_price_gte", (request.strikePrice * 0.9).toString());
          params.set("strike_price_lte", (request.strikePrice * 1.1).toString());
        }
        if (request.type) {
          params.set("type", request.type);
        }
        const response = await this.request(`/v2/options/contracts?${params}`);
        return response.option_contracts.map((c) => ({
          id: c.id,
          symbol: c.symbol,
          underlyingSymbol: c.underlying_symbol,
          type: c.type === "call" ? "call" /* CALL */ : "put" /* PUT */,
          strikePrice: parseFloat(c.strike_price),
          expirationDate: new Date(c.expiration_date),
          openInterest: c.open_interest,
          lastPrice: c.close_price ? parseFloat(c.close_price) : void 0
        }));
      }
      async getOptionContract(contractId) {
        const contract = await this.request(`/v2/options/contracts/${contractId}`);
        return {
          id: contract.id,
          symbol: contract.symbol,
          underlyingSymbol: contract.underlying_symbol,
          type: contract.type === "call" ? "call" /* CALL */ : "put" /* PUT */,
          strikePrice: parseFloat(contract.strike_price),
          expirationDate: new Date(contract.expiration_date),
          openInterest: contract.open_interest,
          lastPrice: contract.close_price ? parseFloat(contract.close_price) : void 0
        };
      }
      // ============================================================================
      // News
      // ============================================================================
      async getNews(symbols, limit = 50) {
        const params = new URLSearchParams({
          limit: limit.toString()
        });
        if (symbols && symbols.length > 0) {
          params.set("symbols", symbols.join(","));
        }
        const response = await this.request(
          `/v1beta1/news?${params}`,
          { baseUrl: this.dataUrl }
        );
        return response.news.map((n) => ({
          id: n.id.toString(),
          headline: n.headline,
          summary: n.summary,
          author: n.author,
          source: n.source,
          url: n.url,
          symbols: n.symbols,
          images: n.images,
          createdAt: new Date(n.created_at),
          updatedAt: n.updated_at ? new Date(n.updated_at) : void 0
        }));
      }
      // ============================================================================
      // WebSocket Streaming
      // ============================================================================
      subscribeToQuotes(symbols, callback) {
        for (const symbol of symbols) {
          const callbacks = this.quoteCallbacks.get(symbol) || [];
          callbacks.push(callback);
          this.quoteCallbacks.set(symbol, callbacks);
        }
        this.ensureDataWebSocket();
        this.sendDataSubscription("quotes", symbols);
      }
      subscribeToBars(symbols, callback) {
        for (const symbol of symbols) {
          const callbacks = this.barCallbacks.get(symbol) || [];
          callbacks.push(callback);
          this.barCallbacks.set(symbol, callbacks);
        }
        this.ensureDataWebSocket();
        this.sendDataSubscription("bars", symbols);
      }
      subscribeToOrderUpdates(callback) {
        this.orderCallbacks.push(callback);
        this.ensureTradeWebSocket();
      }
      subscribeToPositionUpdates(callback) {
        this.positionCallbacks.push(callback);
        this.ensureTradeWebSocket();
      }
      unsubscribe(symbols) {
        for (const symbol of symbols) {
          this.quoteCallbacks.delete(symbol);
          this.barCallbacks.delete(symbol);
        }
        if (this.dataWs && this.dataWs.readyState === WebSocket.OPEN) {
          this.dataWs.send(JSON.stringify({
            action: "unsubscribe",
            quotes: symbols,
            bars: symbols
          }));
        }
      }
      unsubscribeAll() {
        this.quoteCallbacks.clear();
        this.barCallbacks.clear();
        this.orderCallbacks = [];
        this.positionCallbacks = [];
        if (this.dataWs) {
          this.dataWs.close();
          this.dataWs = null;
        }
        if (this.tradeWs) {
          this.tradeWs.close();
          this.tradeWs = null;
        }
      }
      ensureDataWebSocket() {
        if (this.dataWs && this.dataWs.readyState === WebSocket.OPEN) return;
        this.dataWs = new WebSocket(`${ALPACA_STREAM_URL2}/v2/iex`);
        this.dataWs.onopen = () => {
          this.dataWs?.send(JSON.stringify({
            action: "auth",
            key: this.apiKey,
            secret: this.apiSecret
          }));
        };
        this.dataWs.onmessage = (event) => {
          const messages = JSON.parse(event.data);
          for (const msg of messages) {
            if (msg.T === "q") {
              const callbacks = this.quoteCallbacks.get(msg.S);
              if (callbacks) {
                const quote = this.mapQuote(msg.S, msg);
                callbacks.forEach((cb) => cb(quote));
              }
            } else if (msg.T === "b") {
              const callbacks = this.barCallbacks.get(msg.S);
              if (callbacks) {
                const bar = this.mapBar(msg);
                callbacks.forEach((cb) => cb(bar));
              }
            }
          }
        };
      }
      ensureTradeWebSocket() {
        if (this.tradeWs && this.tradeWs.readyState === WebSocket.OPEN) return;
        const streamUrl = this.isPaper ? "wss://paper-api.alpaca.markets/stream" : "wss://api.alpaca.markets/stream";
        this.tradeWs = new WebSocket(streamUrl);
        this.tradeWs.onopen = () => {
          this.tradeWs?.send(JSON.stringify({
            action: "auth",
            key: this.apiKey,
            secret: this.apiSecret
          }));
          this.tradeWs?.send(JSON.stringify({
            action: "listen",
            data: { streams: ["trade_updates"] }
          }));
        };
        this.tradeWs.onmessage = (event) => {
          const msg = JSON.parse(event.data);
          if (msg.stream === "trade_updates") {
            const order = this.mapOrder(msg.data.order);
            this.orderCallbacks.forEach((cb) => cb(order));
          }
        };
      }
      sendDataSubscription(type, symbols) {
        if (this.dataWs && this.dataWs.readyState === WebSocket.OPEN) {
          this.dataWs.send(JSON.stringify({
            action: "subscribe",
            [type]: symbols
          }));
        }
      }
      // ============================================================================
      // Mapping Helpers
      // ============================================================================
      mapOrderType(type) {
        const mapping = {
          ["market" /* MARKET */]: "market",
          ["limit" /* LIMIT */]: "limit",
          ["stop" /* STOP */]: "stop",
          ["stop_limit" /* STOP_LIMIT */]: "stop_limit",
          ["trailing_stop" /* TRAILING_STOP */]: "trailing_stop"
        };
        return mapping[type];
      }
      mapOrderStatus(status) {
        const mapping = {
          "new": "new" /* NEW */,
          "pending_new": "pending" /* PENDING */,
          "accepted": "accepted" /* ACCEPTED */,
          "partially_filled": "partially_filled" /* PARTIALLY_FILLED */,
          "filled": "filled" /* FILLED */,
          "canceled": "cancelled" /* CANCELLED */,
          "cancelled": "cancelled" /* CANCELLED */,
          "rejected": "rejected" /* REJECTED */,
          "expired": "expired" /* EXPIRED */,
          "replaced": "replaced" /* REPLACED */,
          "pending_cancel": "pending" /* PENDING */,
          "pending_replace": "pending" /* PENDING */
        };
        return mapping[status] || "new" /* NEW */;
      }
      mapOrderStatusToAlpaca(status) {
        const mapping = {
          ["new" /* NEW */]: "new",
          ["pending" /* PENDING */]: "pending_new",
          ["accepted" /* ACCEPTED */]: "accepted",
          ["partially_filled" /* PARTIALLY_FILLED */]: "partially_filled",
          ["filled" /* FILLED */]: "filled",
          ["cancelled" /* CANCELLED */]: "canceled",
          ["rejected" /* REJECTED */]: "rejected",
          ["expired" /* EXPIRED */]: "expired",
          ["replaced" /* REPLACED */]: "replaced"
        };
        return mapping[status];
      }
      mapAssetClass(assetClass) {
        const mapping = {
          "us_equity": "us_equity" /* US_EQUITY */,
          "crypto": "crypto" /* CRYPTO */,
          "option": "options" /* OPTIONS */
        };
        return mapping[assetClass] || "us_equity" /* US_EQUITY */;
      }
      mapAssetClassToAlpaca(assetClass) {
        const mapping = {
          ["us_equity" /* US_EQUITY */]: "us_equity",
          ["crypto" /* CRYPTO */]: "crypto",
          ["options" /* OPTIONS */]: "option",
          ["forex" /* FOREX */]: "forex",
          ["futures" /* FUTURES */]: "futures"
        };
        return mapping[assetClass];
      }
      mapOrder(order) {
        return {
          id: order.id,
          clientOrderId: order.client_order_id,
          symbol: order.symbol,
          side: order.side,
          type: order.type,
          quantity: parseFloat(order.qty),
          filledQuantity: parseFloat(order.filled_qty),
          price: order.limit_price ? parseFloat(order.limit_price) : void 0,
          stopPrice: order.stop_price ? parseFloat(order.stop_price) : void 0,
          avgFillPrice: order.filled_avg_price ? parseFloat(order.filled_avg_price) : void 0,
          status: this.mapOrderStatus(order.status),
          timeInForce: order.time_in_force,
          extendedHours: order.extended_hours,
          createdAt: new Date(order.created_at),
          updatedAt: new Date(order.updated_at),
          filledAt: order.filled_at ? new Date(order.filled_at) : void 0,
          cancelledAt: order.canceled_at ? new Date(order.canceled_at) : void 0,
          expiredAt: order.expired_at ? new Date(order.expired_at) : void 0,
          failedAt: order.failed_at ? new Date(order.failed_at) : void 0,
          assetClass: this.mapAssetClass(order.asset_class),
          legs: order.legs ? order.legs.map((l) => this.mapOrder(l)) : void 0
        };
      }
      mapPosition(position) {
        return {
          symbol: position.symbol,
          quantity: parseFloat(position.qty),
          side: position.side,
          avgEntryPrice: parseFloat(position.avg_entry_price),
          marketValue: parseFloat(position.market_value),
          costBasis: parseFloat(position.cost_basis),
          unrealizedPL: parseFloat(position.unrealized_pl),
          unrealizedPLPercent: parseFloat(position.unrealized_plpc),
          currentPrice: parseFloat(position.current_price),
          lastDayPrice: parseFloat(position.lastday_price),
          changeToday: parseFloat(position.change_today),
          assetClass: this.mapAssetClass(position.asset_class),
          exchange: position.exchange
        };
      }
      mapQuote(symbol, quote) {
        return {
          symbol,
          bidPrice: quote.bp,
          bidSize: quote.bs,
          askPrice: quote.ap,
          askSize: quote.as,
          lastPrice: (quote.bp + quote.ap) / 2,
          // Mid price
          lastSize: 0,
          volume: 0,
          timestamp: new Date(quote.t)
        };
      }
      mapBar(bar) {
        return {
          timestamp: new Date(bar.t),
          open: bar.o,
          high: bar.h,
          low: bar.l,
          close: bar.c,
          volume: bar.v,
          vwap: bar.vw,
          tradeCount: bar.n
        };
      }
      mapTrade(symbol, trade) {
        return {
          symbol,
          price: trade.p,
          size: trade.s,
          timestamp: new Date(trade.t),
          exchange: trade.x,
          conditions: trade.c
        };
      }
      mapAsset(asset) {
        return {
          id: asset.id,
          symbol: asset.symbol,
          name: asset.name,
          exchange: asset.exchange,
          assetClass: this.mapAssetClass(asset.class),
          status: asset.status,
          tradable: asset.tradable,
          marginable: asset.marginable,
          shortable: asset.shortable,
          easyToBorrow: asset.easy_to_borrow,
          fractionable: asset.fractionable,
          minOrderSize: asset.min_order_size ? parseFloat(asset.min_order_size) : void 0,
          minPriceIncrement: asset.price_increment ? parseFloat(asset.price_increment) : void 0
        };
      }
      // ============================================================================
      // Watchlist Methods
      // ============================================================================
      async getWatchlists() {
        const response = await this.request("/v2/watchlists");
        return response;
      }
      async createWatchlist(name, symbols) {
        const response = await this.request("/v2/watchlists", {
          method: "POST",
          body: JSON.stringify({ name, symbols: symbols || [] })
        });
        return response;
      }
      async updateWatchlist(watchlistId, name, symbols) {
        const body = {};
        if (name) body.name = name;
        if (symbols) body.symbols = symbols;
        const response = await this.request(`/v2/watchlists/${watchlistId}`, {
          method: "PUT",
          body: JSON.stringify(body)
        });
        return response;
      }
      async deleteWatchlist(watchlistId) {
        await this.request(`/v2/watchlists/${watchlistId}`, { method: "DELETE" });
        return true;
      }
      // ============================================================================
      // Calendar & Clock Methods
      // ============================================================================
      async getClock() {
        const response = await this.request("/v2/clock");
        return response;
      }
      async getCalendar(start, end) {
        const params = new URLSearchParams();
        if (start) params.set("start", start);
        if (end) params.set("end", end);
        const query = params.toString() ? `?${params.toString()}` : "";
        const response = await this.request(`/v2/calendar${query}`);
        return response.map((day) => ({
          date: day.date,
          open: day.open,
          close: day.close,
          sessionOpen: day.session_open,
          sessionClose: day.session_close
        }));
      }
      // ============================================================================
      // Crypto Methods
      // ============================================================================
      async getCryptoQuote(symbol) {
        const response = await this.request(`/v1beta3/crypto/us/latest/quotes?symbols=${symbol}`, {
          baseUrl: ALPACA_DATA_BASE_URL
        });
        const quote = response.quotes[symbol];
        return this.mapQuote(symbol, quote);
      }
      async getCryptoBars(symbol, timeframe, options) {
        const params = new URLSearchParams();
        params.set("symbols", symbol);
        params.set("timeframe", timeframe);
        if (options?.start) params.set("start", options.start);
        if (options?.end) params.set("end", options.end);
        if (options?.limit) params.set("limit", options.limit.toString());
        const response = await this.request(`/v1beta3/crypto/us/bars?${params.toString()}`, {
          baseUrl: ALPACA_DATA_BASE_URL
        });
        return (response.bars[symbol] || []).map((bar) => this.mapBar(bar));
      }
      async getCryptoTrades(symbol, options) {
        const params = new URLSearchParams();
        params.set("symbols", symbol);
        if (options?.start) params.set("start", options.start);
        if (options?.end) params.set("end", options.end);
        if (options?.limit) params.set("limit", options.limit.toString());
        const response = await this.request(`/v1beta3/crypto/us/trades?${params.toString()}`, {
          baseUrl: ALPACA_DATA_BASE_URL
        });
        return (response.trades[symbol] || []).map((trade) => this.mapTrade(symbol, trade));
      }
      async getCryptoSnapshot(symbol) {
        const response = await this.request(`/v1beta3/crypto/us/snapshots?symbols=${symbol}`, {
          baseUrl: ALPACA_DATA_BASE_URL
        });
        const data = response.snapshots[symbol];
        return {
          symbol,
          latestTrade: data.latestTrade ? this.mapTrade(symbol, data.latestTrade) : void 0,
          latestQuote: data.latestQuote ? this.mapQuote(symbol, data.latestQuote) : void 0,
          minuteBar: data.minuteBar ? this.mapBar(data.minuteBar) : void 0,
          dailyBar: data.dailyBar ? this.mapBar(data.dailyBar) : void 0,
          prevDailyBar: data.prevDailyBar ? this.mapBar(data.prevDailyBar) : void 0
        };
      }
      // ============================================================================
      // Capability & Connection Methods
      // ============================================================================
      getCapabilities() {
        return this.capabilities;
      }
      async testConnection() {
        const start = Date.now();
        try {
          await this.getAccount();
          const latency = Date.now() - start;
          return { success: true, message: "Connection successful", latency };
        } catch (error) {
          return { success: false, message: error.message || "Connection failed" };
        }
      }
      // ============================================================================
      // Bracket & OCO Order Methods
      // ============================================================================
      async placeBracketOrder(params) {
        const order = {
          symbol: params.symbol,
          quantity: params.quantity,
          side: params.side,
          type: params.type,
          timeInForce: params.timeInForce,
          price: params.limitPrice,
          orderClass: "bracket",
          takeProfit: { limitPrice: params.takeProfitLimitPrice },
          stopLoss: {
            stopPrice: params.stopLossStopPrice,
            limitPrice: params.stopLossLimitPrice
          }
        };
        return this.placeOrder(order);
      }
      async placeOCOOrder(params) {
        const order = {
          symbol: params.symbol,
          quantity: params.quantity,
          side: params.side,
          type: "limit" /* LIMIT */,
          timeInForce: "gtc" /* GTC */,
          orderClass: "oco",
          takeProfit: { limitPrice: params.takeProfitLimitPrice },
          stopLoss: {
            stopPrice: params.stopLossStopPrice,
            limitPrice: params.stopLossLimitPrice
          }
        };
        return this.placeOrder(order);
      }
    };
  }
});

// server/services/newsSentimentAnalysis.ts
var newsSentimentAnalysis_exports = {};
__export(newsSentimentAnalysis_exports, {
  analyzeHeadlineSentiment: () => analyzeHeadlineSentiment,
  analyzeKeywordSentiment: () => analyzeKeywordSentiment,
  analyzeNewsBatchSentiment: () => analyzeNewsBatchSentiment,
  clearNewsSentimentCache: () => clearNewsSentimentCache,
  getNewsSentimentCacheStats: () => getNewsSentimentCacheStats
});
function getCacheKey(headline) {
  return headline.toLowerCase().trim();
}
function getCachedSentiment(headline) {
  const key = getCacheKey(headline);
  const cached = sentimentCache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL_MS) {
    return cached.result;
  }
  if (cached) {
    sentimentCache.delete(key);
  }
  return null;
}
function cacheSentiment(headline, result) {
  const key = getCacheKey(headline);
  sentimentCache.set(key, { result, timestamp: Date.now() });
  if (sentimentCache.size > 1e3) {
    const now = Date.now();
    const entries = Array.from(sentimentCache.entries());
    for (const [k, v] of entries) {
      if (now - v.timestamp > CACHE_TTL_MS) {
        sentimentCache.delete(k);
      }
    }
  }
}
async function analyzeHeadlineSentiment(headline) {
  const cached = getCachedSentiment(headline);
  if (cached) {
    return cached;
  }
  try {
    const response = await invokeLLM({
      messages: [
        {
          role: "system",
          content: `You are a financial sentiment analysis expert. Analyze the given news headline and determine its market sentiment.

Your response must be valid JSON with exactly these fields:
- sentiment: "bullish", "bearish", or "neutral"
- confidence: a number from 0 to 100 representing how confident you are
- reasoning: a brief 1-2 sentence explanation

Consider these factors:
- Bullish indicators: positive earnings, growth, upgrades, acquisitions, new products, market expansion, partnerships, innovation
- Bearish indicators: losses, layoffs, downgrades, lawsuits, regulatory issues, market decline, debt concerns, executive departures
- Neutral indicators: routine announcements, mixed signals, unclear impact, general market commentary

Be decisive - only use "neutral" when the headline truly has no clear market direction.`
        },
        {
          role: "user",
          content: `Analyze this headline: "${headline}"`
        }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "sentiment_analysis",
          strict: true,
          schema: {
            type: "object",
            properties: {
              sentiment: {
                type: "string",
                enum: ["bullish", "bearish", "neutral"],
                description: "The market sentiment of the headline"
              },
              confidence: {
                type: "integer",
                description: "Confidence level from 0 to 100"
              },
              reasoning: {
                type: "string",
                description: "Brief explanation for the sentiment classification"
              }
            },
            required: ["sentiment", "confidence", "reasoning"],
            additionalProperties: false
          }
        }
      }
    });
    const content = response.choices[0]?.message?.content;
    if (typeof content === "string") {
      const result = JSON.parse(content);
      const normalizedResult = {
        sentiment: ["bullish", "bearish", "neutral"].includes(result.sentiment) ? result.sentiment : "neutral",
        confidence: Math.min(100, Math.max(0, Math.round(result.confidence))),
        reasoning: result.reasoning || "No reasoning provided"
      };
      cacheSentiment(headline, normalizedResult);
      return normalizedResult;
    }
    throw new Error("Invalid LLM response format");
  } catch (error) {
    console.error("Sentiment analysis error:", error);
    return analyzeKeywordSentiment(headline);
  }
}
async function analyzeNewsBatchSentiment(articles) {
  const results = [];
  const uncachedArticles = [];
  for (const article of articles) {
    const cached = getCachedSentiment(article.headline);
    if (cached) {
      results.push({
        articleId: article.id,
        headline: article.headline,
        sentiment: cached
      });
    } else {
      uncachedArticles.push(article);
    }
  }
  const BATCH_SIZE = 5;
  for (let i = 0; i < uncachedArticles.length; i += BATCH_SIZE) {
    const batch = uncachedArticles.slice(i, i + BATCH_SIZE);
    const batchResults = await Promise.all(
      batch.map(async (article) => {
        const sentiment = await analyzeHeadlineSentiment(article.headline);
        return {
          articleId: article.id,
          headline: article.headline,
          sentiment
        };
      })
    );
    results.push(...batchResults);
  }
  const resultMap = new Map(results.map((r) => [r.articleId, r]));
  return articles.map((a) => resultMap.get(a.id));
}
function analyzeKeywordSentiment(headline) {
  const bullishKeywords = [
    "surge",
    "soar",
    "jump",
    "rally",
    "gain",
    "rise",
    "up",
    "high",
    "record",
    "beat",
    "exceed",
    "growth",
    "profit",
    "positive",
    "upgrade",
    "buy",
    "outperform",
    "strong",
    "boost",
    "breakthrough",
    "win",
    "success",
    "expand",
    "bullish",
    "optimistic",
    "boom",
    "skyrocket",
    "milestone",
    "innovation",
    "partnership",
    "acquisition",
    "dividend",
    "buyback",
    "approval"
  ];
  const bearishKeywords = [
    "fall",
    "drop",
    "plunge",
    "crash",
    "decline",
    "down",
    "low",
    "miss",
    "loss",
    "negative",
    "downgrade",
    "sell",
    "underperform",
    "weak",
    "cut",
    "layoff",
    "warning",
    "concern",
    "fear",
    "risk",
    "lawsuit",
    "investigation",
    "bearish",
    "pessimistic",
    "slump",
    "tumble",
    "crisis",
    "bankruptcy",
    "recall",
    "fraud",
    "scandal",
    "debt",
    "default",
    "fine"
  ];
  const lowerHeadline = headline.toLowerCase();
  const bullishCount = bullishKeywords.filter((kw) => lowerHeadline.includes(kw)).length;
  const bearishCount = bearishKeywords.filter((kw) => lowerHeadline.includes(kw)).length;
  const totalMatches = bullishCount + bearishCount;
  if (bullishCount > bearishCount) {
    return {
      sentiment: "bullish",
      confidence: Math.min(85, 50 + bullishCount * 10),
      reasoning: `Detected ${bullishCount} bullish keyword(s) in headline`
    };
  }
  if (bearishCount > bullishCount) {
    return {
      sentiment: "bearish",
      confidence: Math.min(85, 50 + bearishCount * 10),
      reasoning: `Detected ${bearishCount} bearish keyword(s) in headline`
    };
  }
  return {
    sentiment: "neutral",
    confidence: totalMatches === 0 ? 40 : 50,
    reasoning: totalMatches === 0 ? "No clear sentiment indicators found" : "Mixed sentiment signals detected"
  };
}
function clearNewsSentimentCache() {
  sentimentCache.clear();
}
function getNewsSentimentCacheStats() {
  return {
    size: sentimentCache.size
  };
}
var sentimentCache, CACHE_TTL_MS;
var init_newsSentimentAnalysis = __esm({
  "server/services/newsSentimentAnalysis.ts"() {
    "use strict";
    init_llm();
    sentimentCache = /* @__PURE__ */ new Map();
    CACHE_TTL_MS = 60 * 60 * 1e3;
  }
});

// server/services/sentimentTrendService.ts
var sentimentTrendService_exports = {};
__export(sentimentTrendService_exports, {
  clearSentimentHistory: () => clearSentimentHistory,
  generateMockTrendData: () => generateMockTrendData,
  getSentimentHistoryStats: () => getSentimentHistoryStats,
  getSentimentTrend: () => getSentimentTrend,
  getSentimentTrendWithFallback: () => getSentimentTrendWithFallback,
  recordSentiment: () => recordSentiment,
  recordSentimentBatch: () => recordSentimentBatch
});
function recordSentiment(articleId, sentiment, timestamp2) {
  const ts = timestamp2 || Date.now();
  sentimentHistory.set(articleId, { sentiment, timestamp: ts });
  cleanupOldEntries();
}
function recordSentimentBatch(articles) {
  const now = Date.now();
  articles.forEach((article) => {
    sentimentHistory.set(article.id, {
      sentiment: article.sentiment,
      timestamp: article.timestamp || now
    });
  });
  cleanupOldEntries();
}
function cleanupOldEntries() {
  const cutoff = Date.now() - MAX_HISTORY_MS;
  Array.from(sentimentHistory.entries()).forEach(([id, data]) => {
    if (data.timestamp < cutoff) {
      sentimentHistory.delete(id);
    }
  });
}
function getSentimentTrend(period) {
  const now = Date.now();
  const periodMs = period === "24h" ? 24 * 60 * 60 * 1e3 : 7 * 24 * 60 * 60 * 1e3;
  const cutoff = now - periodMs;
  const bucketCount = period === "24h" ? 24 : 7;
  const bucketSize = periodMs / bucketCount;
  const buckets = [];
  for (let i = 0; i < bucketCount; i++) {
    const bucketStart = cutoff + i * bucketSize;
    buckets.push({
      timestamp: bucketStart + bucketSize / 2,
      // Middle of bucket
      bullish: 0,
      bearish: 0,
      neutral: 0,
      total: 0
    });
  }
  let totalBullish = 0;
  let totalBearish = 0;
  let totalNeutral = 0;
  Array.from(sentimentHistory.entries()).forEach(([, data]) => {
    if (data.timestamp >= cutoff) {
      const bucketIndex = Math.min(
        Math.floor((data.timestamp - cutoff) / bucketSize),
        bucketCount - 1
      );
      if (bucketIndex >= 0 && bucketIndex < buckets.length) {
        buckets[bucketIndex].total++;
        switch (data.sentiment) {
          case "bullish":
            buckets[bucketIndex].bullish++;
            totalBullish++;
            break;
          case "bearish":
            buckets[bucketIndex].bearish++;
            totalBearish++;
            break;
          case "neutral":
            buckets[bucketIndex].neutral++;
            totalNeutral++;
            break;
        }
      }
    }
  });
  const totalArticles = totalBullish + totalBearish + totalNeutral;
  const bullishPercentage = totalArticles > 0 ? Math.round(totalBullish / totalArticles * 100) : 0;
  const bearishPercentage = totalArticles > 0 ? Math.round(totalBearish / totalArticles * 100) : 0;
  const neutralPercentage = totalArticles > 0 ? Math.round(totalNeutral / totalArticles * 100) : 0;
  let dominantSentiment = "neutral";
  if (totalBullish > totalBearish && totalBullish > totalNeutral) {
    dominantSentiment = "bullish";
  } else if (totalBearish > totalBullish && totalBearish > totalNeutral) {
    dominantSentiment = "bearish";
  }
  const midpoint = Math.floor(bucketCount / 2);
  let firstHalfBullish = 0;
  let secondHalfBullish = 0;
  let firstHalfTotal = 0;
  let secondHalfTotal = 0;
  buckets.forEach((bucket, index) => {
    if (index < midpoint) {
      firstHalfBullish += bucket.bullish;
      firstHalfTotal += bucket.total;
    } else {
      secondHalfBullish += bucket.bullish;
      secondHalfTotal += bucket.total;
    }
  });
  const firstHalfRatio = firstHalfTotal > 0 ? firstHalfBullish / firstHalfTotal : 0;
  const secondHalfRatio = secondHalfTotal > 0 ? secondHalfBullish / secondHalfTotal : 0;
  let trend = "stable";
  const trendThreshold = 0.1;
  if (secondHalfRatio - firstHalfRatio > trendThreshold) {
    trend = "improving";
  } else if (firstHalfRatio - secondHalfRatio > trendThreshold) {
    trend = "declining";
  }
  return {
    period,
    dataPoints: buckets,
    summary: {
      totalArticles,
      bullishPercentage,
      bearishPercentage,
      neutralPercentage,
      dominantSentiment,
      trend
    }
  };
}
function generateMockTrendData(period) {
  const now = Date.now();
  const periodMs = period === "24h" ? 24 * 60 * 60 * 1e3 : 7 * 24 * 60 * 60 * 1e3;
  const cutoff = now - periodMs;
  const bucketCount = period === "24h" ? 24 : 7;
  const bucketSize = periodMs / bucketCount;
  const dataPoints = [];
  let totalBullish = 0;
  let totalBearish = 0;
  let totalNeutral = 0;
  for (let i = 0; i < bucketCount; i++) {
    const bucketStart = cutoff + i * bucketSize;
    const recentBias = i / bucketCount;
    const baseTotal = Math.floor(Math.random() * 10) + 5;
    const bullish = Math.floor(baseTotal * (0.3 + recentBias * 0.2) + Math.random() * 3);
    const bearish = Math.floor(baseTotal * (0.3 - recentBias * 0.1) + Math.random() * 2);
    const neutral = Math.max(0, baseTotal - bullish - bearish);
    totalBullish += bullish;
    totalBearish += bearish;
    totalNeutral += neutral;
    dataPoints.push({
      timestamp: bucketStart + bucketSize / 2,
      bullish,
      bearish,
      neutral,
      total: bullish + bearish + neutral
    });
  }
  const totalArticles = totalBullish + totalBearish + totalNeutral;
  return {
    period,
    dataPoints,
    summary: {
      totalArticles,
      bullishPercentage: Math.round(totalBullish / totalArticles * 100),
      bearishPercentage: Math.round(totalBearish / totalArticles * 100),
      neutralPercentage: Math.round(totalNeutral / totalArticles * 100),
      dominantSentiment: totalBullish >= totalBearish ? "bullish" : "bearish",
      trend: "improving"
    }
  };
}
function getSentimentTrendWithFallback(period) {
  const realData = getSentimentTrend(period);
  if (realData.summary.totalArticles < 10) {
    return generateMockTrendData(period);
  }
  return realData;
}
function getSentimentHistoryStats() {
  let oldest = null;
  let newest = null;
  Array.from(sentimentHistory.entries()).forEach(([, data]) => {
    if (oldest === null || data.timestamp < oldest) {
      oldest = data.timestamp;
    }
    if (newest === null || data.timestamp > newest) {
      newest = data.timestamp;
    }
  });
  return {
    totalEntries: sentimentHistory.size,
    oldestTimestamp: oldest,
    newestTimestamp: newest
  };
}
function clearSentimentHistory() {
  sentimentHistory.clear();
}
var sentimentHistory, MAX_HISTORY_MS;
var init_sentimentTrendService = __esm({
  "server/services/sentimentTrendService.ts"() {
    "use strict";
    sentimentHistory = /* @__PURE__ */ new Map();
    MAX_HISTORY_MS = 7 * 24 * 60 * 60 * 1e3;
  }
});

// server/services/brokers/OrderRouter.ts
var OrderRouter_exports = {};
__export(OrderRouter_exports, {
  OrderRouter: () => OrderRouter,
  detectAssetClass: () => detectAssetClass,
  orderRouter: () => orderRouter
});
function detectAssetClass(symbol) {
  const normalizedSymbol = symbol.toUpperCase().replace(/[-_]/g, "");
  if (CRYPTO_SYMBOLS.has(normalizedSymbol) || normalizedSymbol.endsWith("USD") && CRYPTO_SYMBOLS.has(normalizedSymbol.replace("USD", "")) || normalizedSymbol.endsWith("USDT") && CRYPTO_SYMBOLS.has(normalizedSymbol.replace("USDT", "")) || normalizedSymbol.includes("/") && CRYPTO_SYMBOLS.has(normalizedSymbol.split("/")[0])) {
    return "crypto" /* CRYPTO */;
  }
  if (FOREX_PAIRS.has(normalizedSymbol) || normalizedSymbol.includes("/") && FOREX_PAIRS.has(normalizedSymbol.replace("/", ""))) {
    return "forex" /* FOREX */;
  }
  if (/\d{6}[CP]\d+/.test(normalizedSymbol) || normalizedSymbol.includes("CALL") || normalizedSymbol.includes("PUT")) {
    return "options" /* OPTIONS */;
  }
  if (/[A-Z]{2,4}[FGHJKMNQUVXZ]\d{1,2}$/.test(normalizedSymbol)) {
    return "futures" /* FUTURES */;
  }
  return "us_equity" /* US_EQUITY */;
}
var CRYPTO_SYMBOLS, FOREX_PAIRS, OrderRouter, orderRouter;
var init_OrderRouter = __esm({
  "server/services/brokers/OrderRouter.ts"() {
    "use strict";
    init_types();
    init_BrokerFactory();
    CRYPTO_SYMBOLS = /* @__PURE__ */ new Set([
      "BTC",
      "ETH",
      "XRP",
      "LTC",
      "BCH",
      "ADA",
      "DOT",
      "LINK",
      "XLM",
      "DOGE",
      "UNI",
      "AAVE",
      "SOL",
      "AVAX",
      "MATIC",
      "ATOM",
      "ALGO",
      "FIL",
      "TRX",
      "ETC",
      "XMR",
      "EOS",
      "XTZ",
      "THETA",
      "VET",
      "NEO",
      "MIOTA",
      "DASH",
      "ZEC",
      "MKR",
      "COMP",
      "SNX",
      "YFI",
      "SUSHI",
      "CRV",
      "BAL",
      "REN",
      "KNC",
      "ZRX",
      "BAT",
      "BTCUSD",
      "ETHUSD",
      "BTCUSDT",
      "ETHUSDT",
      "BNBUSD",
      "BNBUSDT",
      "SOLUSD",
      "BTC/USD",
      "ETH/USD",
      "BTC/USDT",
      "ETH/USDT",
      "SOL/USD",
      "SOL/USDT",
      "SHIB",
      "PEPE",
      "FLOKI",
      "BONK",
      "WIF",
      "ARB",
      "OP",
      "APT",
      "SUI",
      "SEI"
    ]);
    FOREX_PAIRS = /* @__PURE__ */ new Set([
      "EURUSD",
      "GBPUSD",
      "USDJPY",
      "USDCHF",
      "AUDUSD",
      "USDCAD",
      "NZDUSD",
      "EUR/USD",
      "GBP/USD",
      "USD/JPY",
      "USD/CHF",
      "AUD/USD",
      "USD/CAD",
      "NZD/USD",
      "EURGBP",
      "EURJPY",
      "GBPJPY",
      "AUDJPY",
      "CADJPY",
      "CHFJPY",
      "NZDJPY",
      "EUR/GBP",
      "EUR/JPY",
      "GBP/JPY",
      "AUD/JPY",
      "CAD/JPY",
      "CHF/JPY",
      "NZD/JPY"
    ]);
    OrderRouter = class _OrderRouter {
      brokerFactory;
      brokerHealth = /* @__PURE__ */ new Map();
      connectedBrokers = /* @__PURE__ */ new Map();
      // Default broker priorities by asset class
      static BROKER_PRIORITIES = {
        ["us_equity" /* US_EQUITY */]: ["alpaca" /* ALPACA */, "schwab" /* SCHWAB */, "interactive_brokers" /* INTERACTIVE_BROKERS */],
        ["crypto" /* CRYPTO */]: ["binance" /* BINANCE */, "coinbase" /* COINBASE */, "alpaca" /* ALPACA */],
        ["forex" /* FOREX */]: ["interactive_brokers" /* INTERACTIVE_BROKERS */],
        ["options" /* OPTIONS */]: ["interactive_brokers" /* INTERACTIVE_BROKERS */, "schwab" /* SCHWAB */],
        ["futures" /* FUTURES */]: ["interactive_brokers" /* INTERACTIVE_BROKERS */]
      };
      // Broker capabilities cache
      static BROKER_CAPABILITIES = {
        ["alpaca" /* ALPACA */]: {
          supportedAssetClasses: ["us_equity" /* US_EQUITY */, "crypto" /* CRYPTO */],
          supportedOrderTypes: ["market", "limit", "stop", "stop_limit", "trailing_stop"],
          supportedTimeInForce: ["day", "gtc", "ioc", "fok"],
          supportsExtendedHours: true,
          supportsFractionalShares: true,
          supportsShortSelling: true,
          supportsMarginTrading: true,
          supportsOptionsTrading: false,
          supportsCryptoTrading: true,
          supportsForexTrading: false,
          supportsPaperTrading: true,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 200
        },
        ["interactive_brokers" /* INTERACTIVE_BROKERS */]: {
          supportedAssetClasses: ["us_equity" /* US_EQUITY */, "options" /* OPTIONS */, "futures" /* FUTURES */, "forex" /* FOREX */],
          supportedOrderTypes: ["market", "limit", "stop", "stop_limit", "trailing_stop"],
          supportedTimeInForce: ["day", "gtc", "ioc", "fok", "opg", "cls"],
          supportsExtendedHours: true,
          supportsFractionalShares: true,
          supportsShortSelling: true,
          supportsMarginTrading: true,
          supportsOptionsTrading: true,
          supportsCryptoTrading: false,
          supportsForexTrading: true,
          supportsPaperTrading: true,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 50
        },
        ["binance" /* BINANCE */]: {
          supportedAssetClasses: ["crypto" /* CRYPTO */],
          supportedOrderTypes: ["market", "limit", "stop", "stop_limit"],
          supportedTimeInForce: ["gtc", "ioc", "fok"],
          supportsExtendedHours: true,
          // 24/7
          supportsFractionalShares: true,
          supportsShortSelling: true,
          // Futures
          supportsMarginTrading: true,
          supportsOptionsTrading: false,
          supportsCryptoTrading: true,
          supportsForexTrading: false,
          supportsPaperTrading: true,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 1200
        },
        ["coinbase" /* COINBASE */]: {
          supportedAssetClasses: ["crypto" /* CRYPTO */],
          supportedOrderTypes: ["market", "limit", "stop"],
          supportedTimeInForce: ["gtc", "ioc", "fok"],
          supportsExtendedHours: true,
          // 24/7
          supportsFractionalShares: true,
          supportsShortSelling: false,
          supportsMarginTrading: false,
          supportsOptionsTrading: false,
          supportsCryptoTrading: true,
          supportsForexTrading: false,
          supportsPaperTrading: true,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: false,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 100
        },
        ["schwab" /* SCHWAB */]: {
          supportedAssetClasses: ["us_equity" /* US_EQUITY */, "options" /* OPTIONS */],
          supportedOrderTypes: ["market", "limit", "stop", "stop_limit", "trailing_stop"],
          supportedTimeInForce: ["day", "gtc", "ioc", "fok"],
          supportsExtendedHours: true,
          supportsFractionalShares: true,
          supportsShortSelling: true,
          supportsMarginTrading: true,
          supportsOptionsTrading: true,
          supportsCryptoTrading: false,
          supportsForexTrading: false,
          supportsPaperTrading: false,
          supportsWebSocket: true,
          supportsStreamingQuotes: true,
          supportsStreamingBars: true,
          supportsStreamingTrades: true,
          maxOrdersPerMinute: 120
        }
      };
      constructor() {
        this.brokerFactory = new BrokerFactory();
      }
      /**
       * Register a connected broker adapter
       */
      registerBroker(brokerType, adapter) {
        this.connectedBrokers.set(brokerType, adapter);
        this.brokerHealth.set(brokerType, {
          brokerType,
          isConnected: true,
          isHealthy: true,
          lastChecked: /* @__PURE__ */ new Date()
        });
      }
      /**
       * Unregister a broker adapter
       */
      unregisterBroker(brokerType) {
        this.connectedBrokers.delete(brokerType);
        this.brokerHealth.delete(brokerType);
      }
      /**
       * Update broker health status
       */
      updateBrokerHealth(brokerType, health) {
        const existing = this.brokerHealth.get(brokerType);
        if (existing) {
          this.brokerHealth.set(brokerType, {
            ...existing,
            ...health,
            lastChecked: /* @__PURE__ */ new Date()
          });
        }
      }
      /**
       * Get all connected brokers
       */
      getConnectedBrokers() {
        return Array.from(this.connectedBrokers.keys());
      }
      /**
       * Check if a broker supports an asset class
       */
      brokerSupportsAsset(brokerType, assetClass) {
        const capabilities = _OrderRouter.BROKER_CAPABILITIES[brokerType];
        return capabilities?.supportedAssetClasses.includes(assetClass) ?? false;
      }
      /**
       * Get broker capabilities
       */
      getBrokerCapabilities(brokerType) {
        return _OrderRouter.BROKER_CAPABILITIES[brokerType];
      }
      /**
       * Select the best broker for an order
       */
      selectBroker(symbol, preferences = { enableSmartRouting: true, prioritizeLowFees: false, prioritizeFastExecution: false, allowFallback: true }) {
        const assetClass = detectAssetClass(symbol);
        const connectedBrokers = this.getConnectedBrokers();
        if (connectedBrokers.length === 0) {
          throw new BrokerError(
            "connection_error" /* CONNECTION_ERROR */,
            "No brokers connected. Please connect a broker first.",
            "alpaca" /* ALPACA */
          );
        }
        let preferredBroker;
        switch (assetClass) {
          case "us_equity" /* US_EQUITY */:
            preferredBroker = preferences.preferredStockBroker;
            break;
          case "crypto" /* CRYPTO */:
            preferredBroker = preferences.preferredCryptoBroker;
            break;
          case "forex" /* FOREX */:
            preferredBroker = preferences.preferredForexBroker;
            break;
          case "options" /* OPTIONS */:
            preferredBroker = preferences.preferredOptionsBroker;
            break;
        }
        if (preferredBroker && connectedBrokers.includes(preferredBroker) && this.brokerSupportsAsset(preferredBroker, assetClass)) {
          const health = this.brokerHealth.get(preferredBroker);
          if (health?.isHealthy) {
            return {
              selectedBroker: preferredBroker,
              reason: `User preferred broker for ${assetClass}`,
              alternatives: this.getAlternativeBrokers(assetClass, preferredBroker, connectedBrokers),
              confidence: 95
            };
          }
        }
        if (preferences.enableSmartRouting) {
          const priorityList = _OrderRouter.BROKER_PRIORITIES[assetClass] || [];
          for (const broker of priorityList) {
            if (connectedBrokers.includes(broker) && this.brokerSupportsAsset(broker, assetClass)) {
              const health = this.brokerHealth.get(broker);
              if (health?.isHealthy) {
                return {
                  selectedBroker: broker,
                  reason: `Best available broker for ${assetClass} (smart routing)`,
                  alternatives: this.getAlternativeBrokers(assetClass, broker, connectedBrokers),
                  confidence: 90
                };
              }
            }
          }
        }
        if (preferences.allowFallback) {
          for (const broker of connectedBrokers) {
            if (this.brokerSupportsAsset(broker, assetClass)) {
              const health = this.brokerHealth.get(broker);
              if (health?.isHealthy) {
                return {
                  selectedBroker: broker,
                  reason: `Fallback broker for ${assetClass}`,
                  alternatives: [],
                  confidence: 70
                };
              }
            }
          }
        }
        throw new BrokerError(
          "invalid_order" /* INVALID_ORDER */,
          `No connected broker supports ${assetClass}. Symbol: ${symbol}`,
          "alpaca" /* ALPACA */
        );
      }
      /**
       * Get alternative brokers for an asset class
       */
      getAlternativeBrokers(assetClass, excludeBroker, connectedBrokers) {
        return connectedBrokers.filter(
          (broker) => broker !== excludeBroker && this.brokerSupportsAsset(broker, assetClass) && this.brokerHealth.get(broker)?.isHealthy
        );
      }
      /**
       * Route and execute an order
       */
      async routeOrder(order, preferences = { enableSmartRouting: true, prioritizeLowFees: false, prioritizeFastExecution: false, allowFallback: true }) {
        const startTime = Date.now();
        const routingDecision = this.selectBroker(order.symbol, preferences);
        const adapter = this.connectedBrokers.get(routingDecision.selectedBroker);
        if (!adapter) {
          throw new BrokerError(
            "connection_error" /* CONNECTION_ERROR */,
            `Broker ${routingDecision.selectedBroker} is not connected`,
            routingDecision.selectedBroker
          );
        }
        try {
          const orderResponse = await adapter.placeOrder(order);
          this.updateBrokerHealth(routingDecision.selectedBroker, {
            isHealthy: true,
            lastResponseTime: Date.now() - startTime
          });
          return {
            order: orderResponse,
            routingDecision,
            executionTime: Date.now() - startTime
          };
        } catch (error) {
          this.updateBrokerHealth(routingDecision.selectedBroker, {
            isHealthy: false,
            lastError: error instanceof Error ? error.message : "Unknown error"
          });
          if (preferences.allowFallback && routingDecision.alternatives.length > 0) {
            const fallbackBroker = routingDecision.alternatives[0];
            const fallbackAdapter = this.connectedBrokers.get(fallbackBroker);
            if (fallbackAdapter) {
              const orderResponse = await fallbackAdapter.placeOrder(order);
              return {
                order: orderResponse,
                routingDecision: {
                  ...routingDecision,
                  selectedBroker: fallbackBroker,
                  reason: `Fallback after ${routingDecision.selectedBroker} failed`
                },
                executionTime: Date.now() - startTime
              };
            }
          }
          throw error;
        }
      }
      /**
       * Get routing recommendation without executing
       */
      getRoutingRecommendation(symbol, preferences) {
        return this.selectBroker(symbol, preferences);
      }
      /**
       * Get all broker health statuses
       */
      getAllBrokerHealth() {
        return Array.from(this.brokerHealth.values());
      }
      /**
       * Check health of all connected brokers
       */
      async checkAllBrokerHealth() {
        const healthChecks = Array.from(this.connectedBrokers.entries()).map(
          async ([brokerType, adapter]) => {
            const startTime = Date.now();
            try {
              await adapter.getAccounts();
              this.updateBrokerHealth(brokerType, {
                isConnected: true,
                isHealthy: true,
                lastResponseTime: Date.now() - startTime
              });
            } catch (error) {
              this.updateBrokerHealth(brokerType, {
                isConnected: false,
                isHealthy: false,
                lastError: error instanceof Error ? error.message : "Unknown error"
              });
            }
            return this.brokerHealth.get(brokerType);
          }
        );
        return Promise.all(healthChecks);
      }
      /**
       * Get supported asset classes for connected brokers
       */
      getSupportedAssetClasses() {
        const assetClasses = /* @__PURE__ */ new Set();
        const brokerTypes = Array.from(this.connectedBrokers.keys());
        for (const brokerType of brokerTypes) {
          const capabilities = _OrderRouter.BROKER_CAPABILITIES[brokerType];
          if (capabilities) {
            capabilities.supportedAssetClasses.forEach((ac) => assetClasses.add(ac));
          }
        }
        return Array.from(assetClasses);
      }
      /**
       * Get brokers that support a specific asset class
       */
      getBrokersForAssetClass(assetClass) {
        return Array.from(this.connectedBrokers.keys()).filter(
          (broker) => this.brokerSupportsAsset(broker, assetClass)
        );
      }
    };
    orderRouter = new OrderRouter();
  }
});

// server/services/ai-agents/EnhancedCryptoAgents.ts
var AdvancedOnChainAgent, DeFiAnalysisAgent2, WhaleTrackingAgent, CryptoDerivativesAgent, CryptoSocialAgent, EnhancedCryptoOrchestrator;
var init_EnhancedCryptoAgents = __esm({
  "server/services/ai-agents/EnhancedCryptoAgents.ts"() {
    "use strict";
    AdvancedOnChainAgent = class {
      agentName = "On-Chain Analysis";
      weight = 0.25;
      async analyze(input) {
        const metrics = input.onChain;
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const details = {};
        if (!metrics) {
          return {
            agentName: this.agentName,
            signal: "hold",
            confidence: 30,
            reasoning: "Insufficient on-chain data available",
            weight: this.weight,
            details: {}
          };
        }
        if (metrics.mvrv < 1) {
          signal = "strong_buy";
          confidence += 20;
          reasons.push(`MVRV below 1 (${metrics.mvrv.toFixed(2)}) indicates undervaluation`);
        } else if (metrics.mvrv > 3.5) {
          signal = "strong_sell";
          confidence += 20;
          reasons.push(`MVRV above 3.5 (${metrics.mvrv.toFixed(2)}) indicates overvaluation`);
        }
        details.mvrv = metrics.mvrv;
        if (metrics.sopr < 0.97) {
          if (signal !== "strong_sell") signal = "buy";
          confidence += 10;
          reasons.push(`SOPR below 0.97 (${metrics.sopr.toFixed(3)}) - holders selling at loss, potential capitulation`);
        } else if (metrics.sopr > 1.05) {
          if (signal !== "strong_buy") signal = "sell";
          confidence += 10;
          reasons.push(`SOPR above 1.05 (${metrics.sopr.toFixed(3)}) - profit taking occurring`);
        }
        details.sopr = metrics.sopr;
        if (metrics.supplyOnExchanges < 10) {
          confidence += 10;
          reasons.push(`Low exchange supply (${metrics.supplyOnExchanges.toFixed(1)}%) - bullish accumulation`);
        } else if (metrics.supplyOnExchanges > 20) {
          confidence -= 10;
          reasons.push(`High exchange supply (${metrics.supplyOnExchanges.toFixed(1)}%) - potential selling pressure`);
        }
        details.exchangeSupply = metrics.supplyOnExchanges;
        const addressGrowth = metrics.newAddresses24h / metrics.activeAddresses24h;
        if (addressGrowth > 0.1) {
          confidence += 5;
          reasons.push(`Strong new address growth (${(addressGrowth * 100).toFixed(1)}%)`);
        }
        details.addressGrowth = addressGrowth;
        if (metrics.whaleTransactions24h > 100) {
          reasons.push(`High whale activity (${metrics.whaleTransactions24h} large transactions)`);
          details.whaleActivity = "high";
        }
        return {
          agentName: this.agentName,
          signal,
          confidence: Math.min(95, Math.max(20, confidence)),
          reasoning: reasons.join(". ") || "On-chain metrics neutral",
          weight: this.weight,
          details
        };
      }
    };
    DeFiAnalysisAgent2 = class {
      agentName = "DeFi Analysis";
      weight = 0.2;
      async analyze(input) {
        const metrics = input.defi;
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const details = {};
        if (!metrics) {
          return {
            agentName: this.agentName,
            signal: "hold",
            confidence: 30,
            reasoning: "No DeFi metrics available",
            weight: this.weight,
            details: {}
          };
        }
        if (metrics.tvlChange24h > 5) {
          signal = "buy";
          confidence += 15;
          reasons.push(`TVL growing strongly (+${metrics.tvlChange24h.toFixed(1)}% 24h)`);
        } else if (metrics.tvlChange24h < -10) {
          signal = "sell";
          confidence += 15;
          reasons.push(`TVL declining sharply (${metrics.tvlChange24h.toFixed(1)}% 24h)`);
        }
        details.tvlChange = metrics.tvlChange24h;
        if (metrics.stakingAPY && metrics.stakingAPY > 10) {
          confidence += 10;
          reasons.push(`Attractive staking yield (${metrics.stakingAPY.toFixed(1)}% APY)`);
        }
        details.stakingAPY = metrics.stakingAPY;
        if (metrics.smartContractRisk === "low" && metrics.auditStatus === "audited") {
          confidence += 10;
          reasons.push("Strong security profile (audited, low risk)");
        } else if (metrics.smartContractRisk === "high" || metrics.auditStatus === "unaudited") {
          confidence -= 15;
          reasons.push("Security concerns (unaudited or high risk)");
        }
        details.securityProfile = { risk: metrics.smartContractRisk, audit: metrics.auditStatus };
        if (metrics.uniqueUsers24h > 1e4) {
          confidence += 5;
          reasons.push(`Strong user activity (${metrics.uniqueUsers24h.toLocaleString()} users 24h)`);
        }
        details.uniqueUsers = metrics.uniqueUsers24h;
        return {
          agentName: this.agentName,
          signal,
          confidence: Math.min(95, Math.max(20, confidence)),
          reasoning: reasons.join(". ") || "DeFi metrics neutral",
          weight: this.weight,
          details
        };
      }
    };
    WhaleTrackingAgent = class {
      agentName = "Whale Tracking";
      weight = 0.2;
      async analyze(input) {
        const metrics = input.onChain;
        const derivatives = input.derivatives;
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const details = {};
        if (!metrics) {
          return {
            agentName: this.agentName,
            signal: "hold",
            confidence: 30,
            reasoning: "Insufficient whale data available",
            weight: this.weight,
            details: {}
          };
        }
        if (metrics.whaleTransactions24h > 200) {
          confidence += 10;
          reasons.push(`Very high whale activity (${metrics.whaleTransactions24h} transactions)`);
          details.whaleActivityLevel = "very_high";
        } else if (metrics.whaleTransactions24h > 100) {
          confidence += 5;
          reasons.push(`High whale activity (${metrics.whaleTransactions24h} transactions)`);
          details.whaleActivityLevel = "high";
        }
        if (metrics.topHolderConcentration > 50) {
          confidence -= 10;
          reasons.push(`High concentration risk (top 100 hold ${metrics.topHolderConcentration.toFixed(1)}%)`);
          details.concentrationRisk = "high";
        } else if (metrics.topHolderConcentration < 20) {
          confidence += 5;
          reasons.push(`Well distributed (top 100 hold ${metrics.topHolderConcentration.toFixed(1)}%)`);
          details.concentrationRisk = "low";
        }
        if (metrics.institutionalHoldings && metrics.institutionalHoldings > 10) {
          confidence += 10;
          reasons.push(`Strong institutional presence (${metrics.institutionalHoldings.toFixed(1)}%)`);
          details.institutionalPresence = "strong";
        }
        if (derivatives) {
          if (derivatives.longShortRatio > 1.5) {
            signal = "buy";
            confidence += 10;
            reasons.push(`Whales heavily long (L/S ratio: ${derivatives.longShortRatio.toFixed(2)})`);
          } else if (derivatives.longShortRatio < 0.7) {
            signal = "sell";
            confidence += 10;
            reasons.push(`Whales heavily short (L/S ratio: ${derivatives.longShortRatio.toFixed(2)})`);
          }
          details.longShortRatio = derivatives.longShortRatio;
        }
        return {
          agentName: this.agentName,
          signal,
          confidence: Math.min(95, Math.max(20, confidence)),
          reasoning: reasons.join(". ") || "Whale metrics neutral",
          weight: this.weight,
          details
        };
      }
    };
    CryptoDerivativesAgent = class {
      agentName = "Crypto Derivatives";
      weight = 0.2;
      async analyze(input) {
        const metrics = input.derivatives;
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const details = {};
        if (!metrics) {
          return {
            agentName: this.agentName,
            signal: "hold",
            confidence: 30,
            reasoning: "No derivatives data available",
            weight: this.weight,
            details: {}
          };
        }
        if (metrics.fundingRate > 0.05) {
          signal = "sell";
          confidence += 15;
          reasons.push(`Extreme positive funding (${(metrics.fundingRate * 100).toFixed(2)}%) - overleveraged longs`);
        } else if (metrics.fundingRate < -0.03) {
          signal = "buy";
          confidence += 15;
          reasons.push(`Negative funding (${(metrics.fundingRate * 100).toFixed(2)}%) - shorts paying longs`);
        }
        details.fundingRate = metrics.fundingRate;
        if (metrics.openInterestChange24h > 20) {
          confidence += 10;
          reasons.push(`OI surge (+${metrics.openInterestChange24h.toFixed(1)}%) - new money entering`);
        } else if (metrics.openInterestChange24h < -20) {
          confidence += 5;
          reasons.push(`OI dropping (${metrics.openInterestChange24h.toFixed(1)}%) - deleveraging`);
        }
        details.openInterestChange = metrics.openInterestChange24h;
        const totalLiquidations = metrics.longLiquidations24h + metrics.shortLiquidations24h;
        const liquidationRatio = metrics.longLiquidations24h / (totalLiquidations || 1);
        if (liquidationRatio > 0.7) {
          signal = signal === "hold" ? "buy" : signal;
          confidence += 10;
          reasons.push(`Heavy long liquidations (${(liquidationRatio * 100).toFixed(0)}%) - potential bottom`);
        } else if (liquidationRatio < 0.3) {
          signal = signal === "hold" ? "sell" : signal;
          confidence += 10;
          reasons.push(`Heavy short liquidations (${((1 - liquidationRatio) * 100).toFixed(0)}%) - potential top`);
        }
        details.liquidationRatio = liquidationRatio;
        if (metrics.putCallRatio) {
          if (metrics.putCallRatio > 1.5) {
            confidence += 5;
            reasons.push(`High put/call ratio (${metrics.putCallRatio.toFixed(2)}) - bearish sentiment`);
          } else if (metrics.putCallRatio < 0.5) {
            confidence += 5;
            reasons.push(`Low put/call ratio (${metrics.putCallRatio.toFixed(2)}) - bullish sentiment`);
          }
          details.putCallRatio = metrics.putCallRatio;
        }
        return {
          agentName: this.agentName,
          signal,
          confidence: Math.min(95, Math.max(20, confidence)),
          reasoning: reasons.join(". ") || "Derivatives metrics neutral",
          weight: this.weight,
          details
        };
      }
    };
    CryptoSocialAgent = class {
      agentName = "Crypto Social";
      weight = 0.15;
      async analyze(input) {
        const metrics = input.social;
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const details = {};
        if (!metrics) {
          return {
            agentName: this.agentName,
            signal: "hold",
            confidence: 30,
            reasoning: "No social metrics available",
            weight: this.weight,
            details: {}
          };
        }
        if (metrics.overallSentiment > 70) {
          signal = "buy";
          confidence += 10;
          reasons.push(`Strong positive sentiment (${metrics.overallSentiment}/100)`);
        } else if (metrics.overallSentiment < 30) {
          signal = "sell";
          confidence += 10;
          reasons.push(`Strong negative sentiment (${metrics.overallSentiment}/100)`);
        }
        details.sentiment = metrics.overallSentiment;
        if (metrics.fearGreedIndex < 20) {
          signal = "buy";
          confidence += 15;
          reasons.push(`Extreme fear (${metrics.fearGreedIndex}) - contrarian buy signal`);
        } else if (metrics.fearGreedIndex > 80) {
          signal = "sell";
          confidence += 15;
          reasons.push(`Extreme greed (${metrics.fearGreedIndex}) - contrarian sell signal`);
        }
        details.fearGreed = metrics.fearGreedIndex;
        if (metrics.githubCommits30d > 100) {
          confidence += 10;
          reasons.push(`Active development (${metrics.githubCommits30d} commits/30d)`);
        } else if (metrics.githubCommits30d < 10) {
          confidence -= 5;
          reasons.push(`Low development activity (${metrics.githubCommits30d} commits/30d)`);
        }
        details.devActivity = metrics.githubCommits30d;
        const socialScore = metrics.twitterMentions24h / 1e3 + metrics.redditActiveUsers / 100;
        if (socialScore > 100) {
          confidence += 5;
          reasons.push("High social engagement");
          details.socialEngagement = "high";
        }
        return {
          agentName: this.agentName,
          signal,
          confidence: Math.min(95, Math.max(20, confidence)),
          reasoning: reasons.join(". ") || "Social metrics neutral",
          weight: this.weight,
          details
        };
      }
    };
    EnhancedCryptoOrchestrator = class {
      onChainAgent = new AdvancedOnChainAgent();
      defiAgent = new DeFiAnalysisAgent2();
      whaleAgent = new WhaleTrackingAgent();
      derivativesAgent = new CryptoDerivativesAgent();
      socialAgent = new CryptoSocialAgent();
      async analyze(input) {
        const [onChain, defi, whale, derivatives, social] = await Promise.all([
          this.onChainAgent.analyze(input),
          this.defiAgent.analyze(input),
          this.whaleAgent.analyze(input),
          this.derivativesAgent.analyze(input),
          this.socialAgent.analyze(input)
        ]);
        const analyses = [onChain, defi, whale, derivatives, social];
        const signalScores = {
          strong_buy: 0,
          buy: 0,
          hold: 0,
          sell: 0,
          strong_sell: 0
        };
        let totalWeight = 0;
        let weightedConfidence = 0;
        for (const analysis of analyses) {
          signalScores[analysis.signal] += analysis.weight * analysis.confidence;
          totalWeight += analysis.weight;
          weightedConfidence += analysis.weight * analysis.confidence;
        }
        let overallSignal = "hold";
        let maxScore = 0;
        for (const [signal, score] of Object.entries(signalScores)) {
          if (score > maxScore) {
            maxScore = score;
            overallSignal = signal;
          }
        }
        const confidence = Math.round(weightedConfidence / totalWeight);
        let riskLevel = "medium";
        if (input.category === "meme") {
          riskLevel = "extreme";
        } else if (input.category === "defi" && input.defi?.smartContractRisk === "high") {
          riskLevel = "high";
        } else if (confidence > 75 && (overallSignal === "buy" || overallSignal === "strong_buy")) {
          riskLevel = "low";
        }
        const bullishAgents = analyses.filter((a) => a.signal === "buy" || a.signal === "strong_buy").length;
        const bearishAgents = analyses.filter((a) => a.signal === "sell" || a.signal === "strong_sell").length;
        const summary = `${bullishAgents} of 5 agents bullish, ${bearishAgents} bearish. Overall ${overallSignal} signal with ${confidence}% confidence.`;
        const recommendation = this.generateRecommendation(overallSignal, confidence, riskLevel, input);
        const keyMetrics = {
          mvrv: input.onChain?.mvrv,
          sopr: input.onChain?.sopr,
          exchangeSupply: input.onChain?.supplyOnExchanges,
          tvl: input.defi?.totalValueLocked,
          fundingRate: input.derivatives?.fundingRate,
          fearGreed: input.social?.fearGreedIndex
        };
        return {
          symbol: input.symbol,
          category: input.category,
          overallSignal,
          confidence,
          riskLevel,
          analyses,
          summary,
          recommendation,
          keyMetrics
        };
      }
      generateRecommendation(signal, confidence, riskLevel, input) {
        if (signal === "strong_buy" && confidence > 70) {
          return `Strong accumulation opportunity for ${input.symbol}. Consider DCA entry with ${riskLevel} risk profile.`;
        } else if (signal === "buy") {
          return `Favorable conditions for ${input.symbol}. Consider small position with stop-loss.`;
        } else if (signal === "strong_sell") {
          return `Exit signal for ${input.symbol}. Consider reducing exposure or hedging.`;
        } else if (signal === "sell") {
          return `Caution advised for ${input.symbol}. Consider taking profits on existing positions.`;
        }
        return `Neutral outlook for ${input.symbol}. Wait for clearer signals before acting.`;
      }
    };
  }
});

// server/services/ai-agents/OptionsAnalysisAgents.ts
var GreeksAnalysisAgent, VolatilityAnalysisAgent, StrategyRecommendationAgent, OptionsRiskAgent, OptionsAnalysisOrchestrator;
var init_OptionsAnalysisAgents = __esm({
  "server/services/ai-agents/OptionsAnalysisAgents.ts"() {
    "use strict";
    GreeksAnalysisAgent = class {
      agentName = "Greeks Analysis";
      weight = 0.3;
      async analyze(input) {
        const greeks = input.greeks;
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const details = {};
        if (greeks.optionType === "call" && greeks.delta > 0.7) {
          signal = "buy";
          confidence += 15;
          reasons.push(`Deep ITM call (delta ${greeks.delta.toFixed(2)})`);
        }
        details.delta = greeks.delta;
        if (greeks.gamma > 0.1 && greeks.daysToExpiry < 7) {
          confidence -= 10;
          reasons.push(`High gamma risk near expiry`);
          details.gammaRisk = "high";
        }
        const dailyDecayPercent = Math.abs(greeks.theta) / greeks.lastPrice * 100;
        if (dailyDecayPercent > 2) {
          confidence -= 15;
          reasons.push(`High theta decay (${dailyDecayPercent.toFixed(1)}%/day)`);
        }
        details.theta = greeks.theta;
        details.vega = greeks.vega;
        return {
          agentName: this.agentName,
          signal,
          confidence: Math.min(95, Math.max(20, confidence)),
          reasoning: reasons.join(". ") || "Greeks analysis neutral",
          weight: this.weight,
          details
        };
      }
    };
    VolatilityAnalysisAgent = class {
      agentName = "Volatility Analysis";
      weight = 0.25;
      async analyze(input) {
        const greeks = input.greeks;
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const details = {};
        if (greeks.ivRank > 80) {
          signal = "sell";
          confidence += 20;
          reasons.push(`IV Rank at ${greeks.ivRank}% - premium selling opportunity`);
          details.ivEnvironment = "elevated";
        } else if (greeks.ivRank < 20) {
          signal = "buy";
          confidence += 20;
          reasons.push(`IV Rank at ${greeks.ivRank}% - cheap options`);
          details.ivEnvironment = "depressed";
        }
        details.ivRank = greeks.ivRank;
        const ivHvRatio = greeks.impliedVolatility / greeks.historicalVolatility;
        if (ivHvRatio > 1.3) {
          if (signal !== "buy") signal = "sell";
          confidence += 10;
          reasons.push(`IV premium above HV - overpriced`);
        }
        details.ivHvRatio = ivHvRatio;
        return {
          agentName: this.agentName,
          signal,
          confidence: Math.min(95, Math.max(20, confidence)),
          reasoning: reasons.join(". ") || "Volatility analysis neutral",
          weight: this.weight,
          details
        };
      }
    };
    StrategyRecommendationAgent = class {
      agentName = "Strategy Recommendation";
      weight = 0.25;
      async analyze(input) {
        const greeks = input.greeks;
        const market = input.marketConditions;
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const details = {};
        const strategies = [];
        let outlook = "neutral";
        if (market) {
          if (market.vixLevel > 30) outlook = "volatile";
          else if (market.marketTrend === "up" && greeks.ivRank < 50) outlook = "bullish";
          else if (market.marketTrend === "down") outlook = "bearish";
        }
        details.outlook = outlook;
        if (outlook === "neutral" && greeks.ivRank > 60) {
          strategies.push({
            name: "Iron Condor",
            type: "neutral",
            legs: [
              { type: "sell", optionType: "put", strike: greeks.underlyingPrice * 0.95, premium: 1.5, quantity: 1 },
              { type: "buy", optionType: "put", strike: greeks.underlyingPrice * 0.9, premium: 0.5, quantity: 1 },
              { type: "sell", optionType: "call", strike: greeks.underlyingPrice * 1.05, premium: 1.5, quantity: 1 },
              { type: "buy", optionType: "call", strike: greeks.underlyingPrice * 1.1, premium: 0.5, quantity: 1 }
            ],
            maxProfit: 200,
            maxLoss: 300,
            breakevens: [greeks.underlyingPrice * 0.93, greeks.underlyingPrice * 1.07],
            probabilityOfProfit: 68,
            requiredCapital: 500,
            greeksExposure: { netDelta: 0, netGamma: -0.04, netTheta: 0.1, netVega: -0.2 }
          });
          confidence += 20;
          reasons.push("Neutral outlook with high IV - iron condor recommended");
        }
        details.recommendedStrategies = strategies.map((s) => s.name);
        return {
          agentName: this.agentName,
          signal,
          confidence: Math.min(95, Math.max(20, confidence)),
          reasoning: reasons.join(". ") || "No clear strategy recommendation",
          weight: this.weight,
          details,
          strategies
        };
      }
    };
    OptionsRiskAgent = class {
      agentName = "Options Risk";
      weight = 0.2;
      async analyze(input) {
        const greeks = input.greeks;
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const details = {};
        const spreadPercent = greeks.bidAskSpread / greeks.lastPrice * 100;
        if (spreadPercent > 5) {
          confidence -= 20;
          reasons.push(`Wide bid-ask spread (${spreadPercent.toFixed(1)}%)`);
          details.liquidityRisk = "high";
        }
        if (greeks.openInterest < 100) {
          confidence -= 15;
          reasons.push(`Low open interest (${greeks.openInterest})`);
          details.oiRisk = "high";
        }
        if (greeks.daysToExpiry < 7) {
          confidence -= 15;
          reasons.push(`Near expiry (${greeks.daysToExpiry} days)`);
          details.expiryRisk = "high";
        }
        const riskScore = (spreadPercent > 3 ? 2 : 0) + (greeks.openInterest < 500 ? 2 : 0) + (greeks.daysToExpiry < 14 ? 2 : 0);
        if (riskScore >= 5) {
          signal = "strong_sell";
          details.overallRisk = "extreme";
        } else if (riskScore >= 3) {
          signal = "sell";
          details.overallRisk = "high";
        } else {
          details.overallRisk = "medium";
        }
        return {
          agentName: this.agentName,
          signal,
          confidence: Math.min(95, Math.max(20, confidence)),
          reasoning: reasons.join(". ") || "Risk metrics acceptable",
          weight: this.weight,
          details
        };
      }
    };
    OptionsAnalysisOrchestrator = class {
      greeksAgent = new GreeksAnalysisAgent();
      volatilityAgent = new VolatilityAnalysisAgent();
      strategyAgent = new StrategyRecommendationAgent();
      riskAgent = new OptionsRiskAgent();
      async analyze(input) {
        const [greeks, volatility, strategy, risk] = await Promise.all([
          this.greeksAgent.analyze(input),
          this.volatilityAgent.analyze(input),
          this.strategyAgent.analyze(input),
          this.riskAgent.analyze(input)
        ]);
        const analyses = [greeks, volatility, strategy, risk];
        const signalScores = { strong_buy: 0, buy: 0, hold: 0, sell: 0, strong_sell: 0 };
        let totalWeight = 0;
        let weightedConfidence = 0;
        for (const analysis of analyses) {
          signalScores[analysis.signal] += analysis.weight * analysis.confidence;
          totalWeight += analysis.weight;
          weightedConfidence += analysis.weight * analysis.confidence;
        }
        let overallSignal = "hold";
        let maxScore = 0;
        for (const [signal, score] of Object.entries(signalScores)) {
          if (score > maxScore) {
            maxScore = score;
            overallSignal = signal;
          }
        }
        const confidence = Math.round(weightedConfidence / totalWeight);
        const riskLevel = risk.details.overallRisk || "medium";
        const marketOutlook = strategy.details.outlook || "neutral";
        const recommendedStrategies = strategy.strategies || [];
        const keyInsights = [];
        if (greeks.details.gammaRisk === "high") keyInsights.push("High gamma risk near expiry");
        if (volatility.details.ivEnvironment === "elevated") keyInsights.push("Elevated IV - premium selling favored");
        if (risk.details.liquidityRisk === "high") keyInsights.push("Poor liquidity");
        const summary = `Options analysis for ${input.symbol}: ${overallSignal} signal with ${confidence}% confidence. IV Rank: ${input.greeks.ivRank}%, ${input.greeks.daysToExpiry} DTE.`;
        return {
          symbol: input.symbol,
          underlyingPrice: input.underlyingPrice,
          overallSignal,
          confidence,
          riskLevel,
          marketOutlook,
          analyses,
          recommendedStrategies,
          keyInsights,
          summary
        };
      }
    };
  }
});

// server/services/ai-agents/UnifiedMultiAssetOrchestrator.ts
var UnifiedMultiAssetOrchestrator_exports = {};
__export(UnifiedMultiAssetOrchestrator_exports, {
  CommodityAnalysisAgent: () => CommodityAnalysisAgent,
  ForexAnalysisAgent: () => ForexAnalysisAgent,
  UnifiedMultiAssetOrchestrator: () => UnifiedMultiAssetOrchestrator,
  detectAssetType: () => detectAssetType,
  detectCryptoCategory: () => detectCryptoCategory
});
function detectAssetType(symbol) {
  if (symbol.includes("-USD") || symbol.includes("USDT") || /^(BTC|ETH|XRP|SOL|ADA|DOT|DOGE|SHIB|AVAX|LINK|MATIC|UNI|AAVE|LTC|BCH)[A-Z]*$/.test(symbol)) return "crypto";
  if (/^[A-Z]+\d{6}[CP]\d{8}$/.test(symbol)) return "options";
  const forexPairs = ["EUR", "GBP", "JPY", "CHF", "AUD", "CAD", "NZD"];
  if (symbol.includes("/") && forexPairs.some((c) => symbol.includes(c))) return "forex";
  if (/^(EUR|GBP|USD|JPY|CHF|AUD|CAD|NZD){2}$/.test(symbol)) return "forex";
  if (symbol.includes("=F")) return "commodity";
  return "stock";
}
function detectCryptoCategory(symbol) {
  const layer1 = ["BTC", "ETH", "SOL", "ADA", "AVAX", "DOT", "ATOM"];
  const layer2 = ["ARB", "OP", "MATIC", "IMX"];
  const defi = ["UNI", "AAVE", "MKR", "CRV", "COMP", "SNX"];
  const meme = ["DOGE", "SHIB", "PEPE", "FLOKI", "BONK"];
  const stablecoin = ["USDT", "USDC", "DAI", "BUSD"];
  const base = symbol.split("-")[0].split("/")[0].toUpperCase();
  if (layer1.includes(base)) return "layer1";
  if (layer2.includes(base)) return "layer2";
  if (defi.includes(base)) return "defi";
  if (meme.includes(base)) return "meme";
  if (stablecoin.includes(base)) return "stablecoin";
  return "unknown";
}
var ForexAnalysisAgent, CommodityAnalysisAgent, UnifiedMultiAssetOrchestrator;
var init_UnifiedMultiAssetOrchestrator = __esm({
  "server/services/ai-agents/UnifiedMultiAssetOrchestrator.ts"() {
    "use strict";
    init_AgentOrchestrator();
    init_EnhancedCryptoAgents();
    init_OptionsAnalysisAgents();
    ForexAnalysisAgent = class {
      async analyze(input) {
        const forex = input.forexData;
        if (!forex) return { signal: "hold", confidence: 30, reasoning: "No forex data", details: {} };
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const details = {};
        if (forex.interestRateDiff > 2) {
          signal = "buy";
          confidence += 20;
          reasons.push(`Positive carry trade (${forex.interestRateDiff}% rate diff)`);
        } else if (forex.interestRateDiff < -2) {
          signal = "sell";
          confidence += 20;
          reasons.push(`Negative carry trade`);
        }
        details.interestRateDiff = forex.interestRateDiff;
        if (forex.centralBankBias === "hawkish") {
          if (signal !== "sell") signal = "buy";
          confidence += 15;
          reasons.push("Hawkish central bank stance");
        } else if (forex.centralBankBias === "dovish") {
          if (signal !== "buy") signal = "sell";
          confidence += 15;
          reasons.push("Dovish central bank stance");
        }
        details.centralBankBias = forex.centralBankBias;
        details.cotPositioning = forex.cotPositioning;
        return {
          signal,
          confidence: Math.min(95, Math.max(20, confidence)),
          reasoning: reasons.join(". ") || "Forex analysis neutral",
          details
        };
      }
    };
    CommodityAnalysisAgent = class {
      async analyze(input) {
        const commodity = input.commodityData;
        if (!commodity) return { signal: "hold", confidence: 30, reasoning: "No commodity data", details: {} };
        let signal = "hold";
        let confidence = 50;
        const reasons = [];
        const details = {};
        if (commodity.inventoryLevels < 30) {
          signal = "buy";
          confidence += 20;
          reasons.push(`Low inventory levels (${commodity.inventoryLevels}%)`);
        } else if (commodity.inventoryLevels > 70) {
          signal = "sell";
          confidence += 20;
          reasons.push(`High inventory levels`);
        }
        details.inventoryLevels = commodity.inventoryLevels;
        if (commodity.supplyDisruption) {
          signal = "strong_buy";
          confidence += 25;
          reasons.push("Supply disruption detected");
        }
        details.supplyDisruption = commodity.supplyDisruption;
        details.commodityType = commodity.commodityType;
        return {
          signal,
          confidence: Math.min(95, Math.max(20, confidence)),
          reasoning: reasons.join(". ") || "Commodity analysis neutral",
          details
        };
      }
    };
    UnifiedMultiAssetOrchestrator = class {
      stockOrchestrator = agentOrchestrator;
      cryptoOrchestrator = new EnhancedCryptoOrchestrator();
      optionsOrchestrator = new OptionsAnalysisOrchestrator();
      forexAgent = new ForexAnalysisAgent();
      commodityAgent = new CommodityAnalysisAgent();
      async analyze(input) {
        const assetType = input.assetType || detectAssetType(input.symbol);
        switch (assetType) {
          case "stock":
            return this.analyzeStock(input);
          case "crypto":
            return this.analyzeCrypto(input);
          case "options":
            return this.analyzeOptions(input);
          case "forex":
            return this.analyzeForex(input);
          case "commodity":
            return this.analyzeCommodity(input);
          default:
            return this.analyzeStock(input);
        }
      }
      async analyzeStock(input) {
        const marketData = {
          symbol: input.symbol,
          assetType: "stock",
          currentPrice: input.currentPrice,
          priceHistory: [],
          volume: input.volume24h,
          marketCap: input.marketCap,
          technicalIndicators: {
            rsi: 50,
            macd: { value: 0, signal: 0, histogram: 0 },
            ema20: input.currentPrice,
            ema50: input.currentPrice,
            bollingerBands: { upper: input.currentPrice * 1.02, middle: input.currentPrice, lower: input.currentPrice * 0.98 },
            atr: input.currentPrice * 0.02
          },
          fundamentals: {
            peRatio: input.stockData?.peRatio || 20,
            earningsGrowth: input.stockData?.earningsGrowth || 0,
            revenueGrowth: 0,
            debtToEquity: 0.5,
            roe: 15,
            freeCashFlow: 0
          },
          sentiment: { newsScore: 50, socialScore: 50, analystRating: 3, insiderActivity: 0 },
          riskMetrics: { beta: 1, volatility: 20, maxDrawdown: 10, sharpeRatio: 1 }
        };
        const portfolioContext = { currentPosition: { quantity: 0, averagePrice: 0, unrealizedPnL: 0 }, portfolioValue: 1e5, riskTolerance: "moderate", maxPositionSize: 0.1, availableCash: 1e5, maxDrawdown: 0.2, currentDrawdown: 0 };
        const result = await this.stockOrchestrator.orchestrate(marketData, portfolioContext);
        return {
          symbol: input.symbol,
          assetType: "stock",
          overallSignal: result.finalSignal,
          confidence: result.overallConfidence,
          riskLevel: result.riskApproved ? "medium" : "high",
          analyses: result.agentVotes.map((v) => ({
            agentName: v.agentType,
            signal: v.signal,
            confidence: v.confidence,
            reasoning: v.reasoning
          })),
          keyMetrics: {
            sector: input.stockData?.sector,
            peRatio: input.stockData?.peRatio,
            dividendYield: input.stockData?.dividendYield
          },
          recommendation: result.reasoning,
          timestamp: Date.now()
        };
      }
      async analyzeCrypto(input) {
        const cryptoInput = input.cryptoData || {
          symbol: input.symbol,
          category: detectCryptoCategory(input.symbol),
          currentPrice: input.currentPrice,
          priceChange24h: input.priceChange24h,
          priceChange7d: input.priceChange7d || 0,
          volume24h: input.volume24h,
          marketCap: input.marketCap || 0
        };
        const result = await this.cryptoOrchestrator.analyze(cryptoInput);
        return {
          symbol: input.symbol,
          assetType: "crypto",
          overallSignal: result.overallSignal,
          confidence: result.confidence,
          riskLevel: result.riskLevel,
          analyses: result.analyses.map((a) => ({
            agentName: a.agentName,
            signal: a.signal,
            confidence: a.confidence,
            reasoning: a.reasoning
          })),
          keyMetrics: result.keyMetrics,
          recommendation: result.recommendation,
          timestamp: Date.now()
        };
      }
      async analyzeOptions(input) {
        if (!input.optionsData) {
          return {
            symbol: input.symbol,
            assetType: "options",
            overallSignal: "hold",
            confidence: 30,
            riskLevel: "high",
            analyses: [],
            keyMetrics: {},
            recommendation: "Insufficient options data",
            timestamp: Date.now()
          };
        }
        const result = await this.optionsOrchestrator.analyze(input.optionsData);
        return {
          symbol: input.symbol,
          assetType: "options",
          overallSignal: result.overallSignal,
          confidence: result.confidence,
          riskLevel: result.riskLevel,
          analyses: result.analyses.map((a) => ({
            agentName: a.agentName,
            signal: a.signal,
            confidence: a.confidence,
            reasoning: a.reasoning
          })),
          keyMetrics: {
            ivRank: input.optionsData.greeks.ivRank,
            daysToExpiry: input.optionsData.greeks.daysToExpiry,
            delta: input.optionsData.greeks.delta,
            marketOutlook: result.marketOutlook
          },
          recommendation: result.summary,
          timestamp: Date.now()
        };
      }
      async analyzeForex(input) {
        const result = await this.forexAgent.analyze(input);
        return {
          symbol: input.symbol,
          assetType: "forex",
          overallSignal: result.signal,
          confidence: result.confidence,
          riskLevel: "medium",
          analyses: [{
            agentName: "Forex Analysis",
            signal: result.signal,
            confidence: result.confidence,
            reasoning: result.reasoning
          }],
          keyMetrics: result.details,
          recommendation: result.reasoning,
          timestamp: Date.now()
        };
      }
      async analyzeCommodity(input) {
        const result = await this.commodityAgent.analyze(input);
        return {
          symbol: input.symbol,
          assetType: "commodity",
          overallSignal: result.signal,
          confidence: result.confidence,
          riskLevel: result.details.supplyDisruption ? "high" : "medium",
          analyses: [{
            agentName: "Commodity Analysis",
            signal: result.signal,
            confidence: result.confidence,
            reasoning: result.reasoning
          }],
          keyMetrics: result.details,
          recommendation: result.reasoning,
          timestamp: Date.now()
        };
      }
      async analyzePortfolio(assets) {
        const individualAnalyses = await Promise.all(assets.map((asset) => this.analyze(asset)));
        const assetAllocation = { stock: 0, crypto: 0, options: 0, forex: 0, commodity: 0 };
        for (const asset of assets) {
          const type = asset.assetType || detectAssetType(asset.symbol);
          assetAllocation[type]++;
        }
        const totalAssets = assets.length || 1;
        const weights = Object.values(assetAllocation).map((count2) => count2 / totalAssets);
        const hhi = weights.reduce((sum2, w) => sum2 + Math.pow(w, 2), 0);
        const diversificationScore = Math.round((1 - hhi) * 100);
        const highRiskCount = individualAnalyses.filter((a) => a.riskLevel === "high" || a.riskLevel === "extreme").length;
        let overallRisk = "medium";
        if (highRiskCount > totalAssets * 0.5) overallRisk = "high";
        if (highRiskCount > totalAssets * 0.75) overallRisk = "extreme";
        if (highRiskCount < totalAssets * 0.2) overallRisk = "low";
        const correlationWarnings = [];
        if (assetAllocation.crypto > 2 && assetAllocation.stock > 2) {
          correlationWarnings.push("High crypto-stock correlation during risk-off events");
        }
        const recommendations = [];
        if (diversificationScore < 50) recommendations.push("Consider diversifying across more asset classes");
        if (assetAllocation.commodity === 0) recommendations.push("Adding commodities could provide inflation hedge");
        return { overallRisk, diversificationScore, assetAllocation, correlationWarnings, recommendations, individualAnalyses };
      }
    };
  }
});

// server/services/realtimePriceFeed.ts
var realtimePriceFeed_exports = {};
__export(realtimePriceFeed_exports, {
  DEFAULT_WATCHLIST: () => DEFAULT_WATCHLIST,
  detectAssetTypeFromSymbol: () => detectAssetTypeFromSymbol,
  generateSimulatedPrice: () => generateSimulatedPrice,
  getAggregatedPrices: () => getAggregatedPrices,
  initializeDefaultSubscriptions: () => initializeDefaultSubscriptions,
  realtimePriceFeed: () => realtimePriceFeed
});
function getCachedPrice2(symbol) {
  const cached = priceCache3.get(symbol.toUpperCase());
  if (cached && Date.now() - cached.timestamp < CACHE_TTL3) {
    return cached;
  }
  return null;
}
function setCachedPrice(symbol, data) {
  priceCache3.set(symbol.toUpperCase(), data);
}
function generateSimulatedPrice(symbol, assetType) {
  const cached = getCachedPrice2(symbol);
  const basePrices = {
    // Stocks
    "AAPL": 185.5,
    "GOOGL": 141.8,
    "MSFT": 378.9,
    "AMZN": 178.25,
    "META": 485.6,
    "TSLA": 248.5,
    "NVDA": 721.3,
    "JPM": 195.4,
    "V": 275.8,
    "JNJ": 156.2,
    // Crypto
    "BTC-USD": 43250,
    "ETH-USD": 2580,
    "SOL-USD": 98.5,
    "XRP-USD": 0.52,
    "ADA-USD": 0.58,
    "DOT-USD": 7.85,
    "DOGE-USD": 0.082,
    "AVAX-USD": 35.6,
    "LINK-USD": 14.8,
    "MATIC-USD": 0.92,
    // Forex
    "EUR/USD": 1.085,
    "GBP/USD": 1.272,
    "USD/JPY": 148.5,
    "USD/CHF": 0.878,
    "AUD/USD": 0.658,
    "USD/CAD": 1.352,
    "NZD/USD": 0.612,
    "EUR/GBP": 0.853,
    // Commodities
    "GC=F": 2045.5,
    "SI=F": 23.45,
    "CL=F": 78.2,
    "NG=F": 2.85,
    "HG=F": 3.82,
    "PL=F": 905.3,
    "PA=F": 985.6,
    "ZC=F": 485.25
  };
  const basePrice = cached?.price || basePrices[symbol.toUpperCase()] || 100;
  const volatility = assetType === "crypto" ? 2e-3 : assetType === "forex" ? 2e-4 : 1e-3;
  const randomChange = (Math.random() - 0.5) * 2 * volatility;
  const newPrice = basePrice * (1 + randomChange);
  const previousClose = basePrice * (1 - (Math.random() - 0.5) * 0.02);
  const change = newPrice - previousClose;
  const changePercent = change / previousClose * 100;
  const baseVolume = assetType === "crypto" ? 1e9 : assetType === "forex" ? 5e8 : 5e7;
  const volume = Math.floor(baseVolume * (0.8 + Math.random() * 0.4));
  const high24h = newPrice * (1 + Math.random() * 0.03);
  const low24h = newPrice * (1 - Math.random() * 0.03);
  const spreadPercent = assetType === "forex" ? 1e-4 : assetType === "crypto" ? 1e-3 : 5e-4;
  const spread = newPrice * spreadPercent;
  const bid = newPrice - spread / 2;
  const ask = newPrice + spread / 2;
  setCachedPrice(symbol, {
    price: newPrice,
    change,
    changePercent,
    volume,
    high24h,
    low24h,
    timestamp: Date.now(),
    provider: "simulated"
  });
  return {
    symbol: symbol.toUpperCase(),
    price: Number(newPrice.toFixed(assetType === "forex" ? 5 : 2)),
    change: Number(change.toFixed(assetType === "forex" ? 5 : 2)),
    changePercent: Number(changePercent.toFixed(2)),
    volume,
    timestamp: Date.now(),
    assetType,
    bid: Number(bid.toFixed(assetType === "forex" ? 5 : 2)),
    ask: Number(ask.toFixed(assetType === "forex" ? 5 : 2)),
    spread: Number(spread.toFixed(assetType === "forex" ? 5 : 4)),
    high24h: Number(high24h.toFixed(assetType === "forex" ? 5 : 2)),
    low24h: Number(low24h.toFixed(assetType === "forex" ? 5 : 2)),
    provider: "simulated"
  };
}
function detectAssetTypeFromSymbol(symbol) {
  const upperSymbol = symbol.toUpperCase();
  if (upperSymbol.includes("-USD") || upperSymbol.includes("USDT") || /^(BTC|ETH|XRP|SOL|ADA|DOT|DOGE|SHIB|AVAX|LINK|MATIC|UNI|AAVE|LTC|BCH)/.test(upperSymbol)) {
    return "crypto";
  }
  const forexCurrencies = ["EUR", "GBP", "JPY", "CHF", "AUD", "CAD", "NZD", "USD"];
  if (upperSymbol.includes("/") && forexCurrencies.some((c) => upperSymbol.includes(c))) {
    return "forex";
  }
  if (/^(EUR|GBP|USD|JPY|CHF|AUD|CAD|NZD){2}$/.test(upperSymbol)) {
    return "forex";
  }
  if (upperSymbol.includes("=F") || ["GC", "SI", "CL", "NG", "HG", "PL", "PA", "ZC", "ZW", "ZS"].some((c) => upperSymbol.startsWith(c))) {
    return "commodity";
  }
  return "stock";
}
function getAggregatedPrices(symbols) {
  const result = {
    stocks: [],
    crypto: [],
    forex: [],
    commodities: [],
    timestamp: Date.now()
  };
  if (symbols.stocks) {
    result.stocks = symbols.stocks.map((s) => generateSimulatedPrice(s, "stock"));
  }
  if (symbols.crypto) {
    result.crypto = symbols.crypto.map((s) => generateSimulatedPrice(s, "crypto"));
  }
  if (symbols.forex) {
    result.forex = symbols.forex.map((s) => generateSimulatedPrice(s, "forex"));
  }
  if (symbols.commodities) {
    result.commodities = symbols.commodities.map((s) => generateSimulatedPrice(s, "commodity"));
  }
  return result;
}
function initializeDefaultSubscriptions() {
  const allSymbols = [
    ...DEFAULT_WATCHLIST.stocks.map((s) => ({ symbol: s, assetType: "stock" })),
    ...DEFAULT_WATCHLIST.crypto.map((s) => ({ symbol: s, assetType: "crypto" })),
    ...DEFAULT_WATCHLIST.forex.map((s) => ({ symbol: s, assetType: "forex" })),
    ...DEFAULT_WATCHLIST.commodities.map((s) => ({ symbol: s, assetType: "commodity" }))
  ];
  realtimePriceFeed.subscribeMany(allSymbols);
}
var priceCache3, CACHE_TTL3, RealtimePriceFeedService, realtimePriceFeed, DEFAULT_WATCHLIST;
var init_realtimePriceFeed = __esm({
  "server/services/realtimePriceFeed.ts"() {
    "use strict";
    init_websocket();
    priceCache3 = /* @__PURE__ */ new Map();
    CACHE_TTL3 = 5e3;
    RealtimePriceFeedService = class {
      subscriptions = /* @__PURE__ */ new Map();
      updateIntervals = /* @__PURE__ */ new Map();
      isRunning = false;
      globalUpdateInterval = null;
      /**
       * Subscribe to real-time price updates for a symbol
       */
      subscribe(config) {
        const symbol = config.symbol.toUpperCase();
        const assetType = config.assetType || detectAssetTypeFromSymbol(symbol);
        this.subscriptions.set(symbol, {
          ...config,
          symbol,
          assetType,
          updateInterval: config.updateInterval || 5e3
        });
        console.log(`[PriceFeed] Subscribed to ${symbol} (${assetType})`);
        if (!this.isRunning) {
          this.start();
        }
      }
      /**
       * Subscribe to multiple symbols at once
       */
      subscribeMany(configs) {
        configs.forEach((config) => this.subscribe(config));
      }
      /**
       * Unsubscribe from a symbol
       */
      unsubscribe(symbol) {
        const upperSymbol = symbol.toUpperCase();
        this.subscriptions.delete(upperSymbol);
        const interval = this.updateIntervals.get(upperSymbol);
        if (interval) {
          clearInterval(interval);
          this.updateIntervals.delete(upperSymbol);
        }
        console.log(`[PriceFeed] Unsubscribed from ${upperSymbol}`);
        if (this.subscriptions.size === 0) {
          this.stop();
        }
      }
      /**
       * Get current price for a symbol
       */
      getPrice(symbol) {
        const upperSymbol = symbol.toUpperCase();
        const cached = getCachedPrice2(upperSymbol);
        if (cached) {
          const assetType = detectAssetTypeFromSymbol(upperSymbol);
          return {
            symbol: upperSymbol,
            price: cached.price,
            change: cached.change,
            changePercent: cached.changePercent,
            volume: cached.volume,
            timestamp: cached.timestamp,
            assetType,
            high24h: cached.high24h,
            low24h: cached.low24h,
            provider: cached.provider
          };
        }
        return null;
      }
      /**
       * Get prices for multiple symbols
       */
      getPrices(symbols) {
        const prices = /* @__PURE__ */ new Map();
        symbols.forEach((symbol) => {
          const price = this.getPrice(symbol);
          if (price) {
            prices.set(symbol.toUpperCase(), price);
          }
        });
        return prices;
      }
      /**
       * Force refresh price for a symbol
       */
      async refreshPrice(symbol) {
        const upperSymbol = symbol.toUpperCase();
        const assetType = detectAssetTypeFromSymbol(upperSymbol);
        const update = generateSimulatedPrice(upperSymbol, assetType);
        broadcastPriceUpdate({
          symbol: update.symbol,
          price: update.price,
          change: update.change,
          changePercent: update.changePercent,
          volume: update.volume,
          timestamp: update.timestamp
        });
        return update;
      }
      /**
       * Start the price feed service
       */
      start() {
        if (this.isRunning) return;
        this.isRunning = true;
        console.log("[PriceFeed] Service started");
        this.globalUpdateInterval = setInterval(() => {
          this.updateAllPrices();
        }, 3e3);
      }
      /**
       * Stop the price feed service
       */
      stop() {
        if (!this.isRunning) return;
        this.isRunning = false;
        if (this.globalUpdateInterval) {
          clearInterval(this.globalUpdateInterval);
          this.globalUpdateInterval = null;
        }
        this.updateIntervals.forEach((interval) => clearInterval(interval));
        this.updateIntervals.clear();
        console.log("[PriceFeed] Service stopped");
      }
      /**
       * Update prices for all subscribed symbols
       */
      updateAllPrices() {
        const wsSymbols = getActiveSymbolSubscriptions();
        const localSymbols = Array.from(this.subscriptions.keys());
        const allSymbols = Array.from(/* @__PURE__ */ new Set([...wsSymbols, ...localSymbols]));
        if (allSymbols.length === 0) return;
        const updates = [];
        allSymbols.forEach((symbol) => {
          const assetType = detectAssetTypeFromSymbol(symbol);
          const update = generateSimulatedPrice(symbol, assetType);
          updates.push({
            symbol: update.symbol,
            price: update.price,
            change: update.change,
            changePercent: update.changePercent,
            volume: update.volume,
            timestamp: update.timestamp
          });
        });
        broadcastPriceUpdates(updates);
      }
      /**
       * Get service status
       */
      getStatus() {
        return {
          isRunning: this.isRunning,
          subscriptionCount: this.subscriptions.size,
          symbols: Array.from(this.subscriptions.keys())
        };
      }
    };
    realtimePriceFeed = new RealtimePriceFeedService();
    DEFAULT_WATCHLIST = {
      stocks: ["AAPL", "GOOGL", "MSFT", "AMZN", "META", "TSLA", "NVDA"],
      crypto: ["BTC-USD", "ETH-USD", "SOL-USD", "XRP-USD", "ADA-USD"],
      forex: ["EUR/USD", "GBP/USD", "USD/JPY", "USD/CHF", "AUD/USD"],
      commodities: ["GC=F", "SI=F", "CL=F", "NG=F"]
    };
  }
});

// server/services/correlationService.ts
var correlationService_exports = {};
__export(correlationService_exports, {
  calculateAssetCorrelation: () => calculateAssetCorrelation,
  calculateCorrelationMatrix: () => calculateCorrelationMatrix4,
  clearPriceHistoryCache: () => clearPriceHistoryCache,
  default: () => correlationService_default,
  generateSimulatedPriceHistory: () => generateSimulatedPriceHistory,
  getCachedAssets: () => getCachedAssets,
  getCorrelationColor: () => getCorrelationColor,
  getCorrelationStrength: () => getCorrelationStrength2,
  getPriceHistory: () => getPriceHistory,
  pearsonCorrelation: () => pearsonCorrelation,
  seedDemoCorrelationData: () => seedDemoCorrelationData,
  updatePriceHistory: () => updatePriceHistory
});
function calculateReturns2(prices) {
  const returns = [];
  for (let i = 1; i < prices.length; i++) {
    if (prices[i - 1] !== 0) {
      returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
    }
  }
  return returns;
}
function mean4(arr) {
  if (arr.length === 0) return 0;
  return arr.reduce((sum2, val) => sum2 + val, 0) / arr.length;
}
function standardDeviation(arr, meanVal) {
  if (arr.length === 0) return 0;
  const avg = meanVal !== void 0 ? meanVal : mean4(arr);
  const squaredDiffs = arr.map((val) => Math.pow(val - avg, 2));
  return Math.sqrt(mean4(squaredDiffs));
}
function pearsonCorrelation(x, y) {
  if (x.length !== y.length || x.length < 2) {
    return 0;
  }
  const n = x.length;
  const meanX = mean4(x);
  const meanY = mean4(y);
  const stdX = standardDeviation(x, meanX);
  const stdY = standardDeviation(y, meanY);
  if (stdX === 0 || stdY === 0) {
    return 0;
  }
  let covariance2 = 0;
  for (let i = 0; i < n; i++) {
    covariance2 += (x[i] - meanX) * (y[i] - meanY);
  }
  covariance2 /= n;
  const correlation2 = covariance2 / (stdX * stdY);
  return Math.max(-1, Math.min(1, correlation2));
}
function getCorrelationStrength2(correlation2) {
  const absCorr = Math.abs(correlation2);
  if (correlation2 >= 0.7) return "strong_positive";
  if (correlation2 >= 0.4) return "moderate_positive";
  if (correlation2 >= 0.1) return "weak_positive";
  if (correlation2 > -0.1) return "neutral";
  if (correlation2 > -0.4) return "weak_negative";
  if (correlation2 > -0.7) return "moderate_negative";
  return "strong_negative";
}
function getTimeWindowMs(period) {
  switch (period) {
    case "24h":
      return 24 * 60 * 60 * 1e3;
    case "7d":
      return 7 * 24 * 60 * 60 * 1e3;
    case "30d":
      return 30 * 24 * 60 * 60 * 1e3;
  }
}
function filterPricesToWindow(prices, period) {
  const windowMs = getTimeWindowMs(period);
  const cutoff = Date.now() - windowMs;
  return prices.filter((p) => p.timestamp >= cutoff);
}
function alignPriceSeries(prices1, prices2) {
  const map1 = /* @__PURE__ */ new Map();
  const map2 = /* @__PURE__ */ new Map();
  const roundToMinute = (ts) => Math.floor(ts / 6e4) * 6e4;
  for (const p of prices1) {
    map1.set(roundToMinute(p.timestamp), p.price);
  }
  for (const p of prices2) {
    map2.set(roundToMinute(p.timestamp), p.price);
  }
  const commonTimestamps = [];
  const timestamps1 = Array.from(map1.keys());
  for (const ts of timestamps1) {
    if (map2.has(ts)) {
      commonTimestamps.push(ts);
    }
  }
  commonTimestamps.sort((a, b) => a - b);
  const aligned1 = commonTimestamps.map((ts) => map1.get(ts));
  const aligned2 = commonTimestamps.map((ts) => map2.get(ts));
  return { aligned1, aligned2 };
}
function updatePriceHistory(symbol, assetType, price, timestamp2) {
  const ts = timestamp2 || Date.now();
  const key = `${assetType}:${symbol}`;
  let history = priceHistoryCache.get(key);
  if (!history) {
    history = { symbol, assetType, prices: [] };
    priceHistoryCache.set(key, history);
  }
  history.prices.push({ timestamp: ts, price });
  const cutoff = Date.now() - 30 * 24 * 60 * 60 * 1e3;
  history.prices = history.prices.filter((p) => p.timestamp >= cutoff);
}
function getPriceHistory(symbol, assetType) {
  const key = `${assetType}:${symbol}`;
  return priceHistoryCache.get(key) || null;
}
function calculateAssetCorrelation(asset1, asset2, period) {
  const prices1 = filterPricesToWindow(asset1.prices, period);
  const prices2 = filterPricesToWindow(asset2.prices, period);
  const { aligned1, aligned2 } = alignPriceSeries(prices1, prices2);
  const returns1 = calculateReturns2(aligned1);
  const returns2 = calculateReturns2(aligned2);
  const correlation2 = pearsonCorrelation(returns1, returns2);
  return {
    asset1: asset1.symbol,
    asset2: asset2.symbol,
    correlation: Math.round(correlation2 * 1e3) / 1e3,
    // Round to 3 decimal places
    strength: getCorrelationStrength2(correlation2),
    sampleSize: returns1.length
  };
}
function calculateCorrelationMatrix4(assets, period) {
  const n = assets.length;
  const symbols = assets.map((a) => a.symbol);
  const correlations = [];
  const pairs = [];
  for (let i = 0; i < n; i++) {
    correlations.push(new Array(n).fill(0));
  }
  for (let i = 0; i < n; i++) {
    correlations[i][i] = 1;
    for (let j = i + 1; j < n; j++) {
      const pair = calculateAssetCorrelation(assets[i], assets[j], period);
      correlations[i][j] = pair.correlation;
      correlations[j][i] = pair.correlation;
      pairs.push(pair);
    }
  }
  const allCorrelations = pairs.map((p) => p.correlation);
  const avgCorrelation = allCorrelations.length > 0 ? mean4(allCorrelations) : 0;
  let strongestPositive = null;
  let strongestNegative = null;
  for (const pair of pairs) {
    if (!strongestPositive || pair.correlation > strongestPositive.correlation) {
      strongestPositive = pair;
    }
    if (!strongestNegative || pair.correlation < strongestNegative.correlation) {
      strongestNegative = pair;
    }
  }
  return {
    assets: symbols,
    correlations,
    pairs,
    period,
    calculatedAt: Date.now(),
    metadata: {
      totalPairs: pairs.length,
      avgCorrelation: Math.round(avgCorrelation * 1e3) / 1e3,
      strongestPositive,
      strongestNegative
    }
  };
}
function generateSimulatedPriceHistory(symbol, assetType, basePrice, volatility, correlationFactor = 0, referencePrices) {
  const now = Date.now();
  const prices = [];
  const dataPoints = 720;
  const hourMs = 60 * 60 * 1e3;
  let price = basePrice;
  for (let i = 0; i < dataPoints; i++) {
    const timestamp2 = now - (dataPoints - i) * hourMs;
    let randomComponent = (Math.random() - 0.5) * 2 * volatility;
    if (referencePrices && referencePrices[i] !== void 0 && i > 0) {
      const refReturn = (referencePrices[i] - referencePrices[i - 1]) / referencePrices[i - 1];
      randomComponent = correlationFactor * refReturn + (1 - Math.abs(correlationFactor)) * randomComponent;
    }
    price = price * (1 + randomComponent);
    price = Math.max(price * 0.1, price);
    prices.push({ timestamp: timestamp2, price });
  }
  return { symbol, assetType, prices };
}
function getCorrelationColor(correlation2) {
  if (correlation2 >= 0.7) return "#22c55e";
  if (correlation2 >= 0.4) return "#86efac";
  if (correlation2 >= 0.1) return "#dcfce7";
  if (correlation2 > -0.1) return "#f5f5f5";
  if (correlation2 > -0.4) return "#fecaca";
  if (correlation2 > -0.7) return "#f87171";
  return "#dc2626";
}
function getCachedAssets() {
  return Array.from(priceHistoryCache.values());
}
function clearPriceHistoryCache() {
  priceHistoryCache.clear();
}
function seedDemoCorrelationData() {
  const baseHistory = generateSimulatedPriceHistory("SPY", "stock", 450, 0.01);
  const basePrices = baseHistory.prices.map((p) => p.price);
  const stockAssets = [
    { symbol: "AAPL", base: 180, vol: 0.015, corr: 0.85 },
    { symbol: "MSFT", base: 380, vol: 0.012, corr: 0.82 },
    { symbol: "GOOGL", base: 140, vol: 0.018, corr: 0.78 },
    { symbol: "AMZN", base: 175, vol: 0.02, corr: 0.75 },
    { symbol: "NVDA", base: 480, vol: 0.025, corr: 0.7 }
  ];
  const cryptoAssets = [
    { symbol: "BTC", base: 42e3, vol: 0.03, corr: 0.3 },
    { symbol: "ETH", base: 2500, vol: 0.035, corr: 0.25 },
    { symbol: "SOL", base: 100, vol: 0.045, corr: 0.2 }
  ];
  const forexAssets = [
    { symbol: "EUR/USD", base: 1.08, vol: 5e-3, corr: -0.2 },
    { symbol: "GBP/USD", base: 1.27, vol: 6e-3, corr: -0.15 }
  ];
  const commodityAssets = [
    { symbol: "GOLD", base: 2e3, vol: 8e-3, corr: -0.1 },
    { symbol: "OIL", base: 75, vol: 0.02, corr: 0.4 }
  ];
  for (const asset of stockAssets) {
    const history = generateSimulatedPriceHistory(
      asset.symbol,
      "stock",
      asset.base,
      asset.vol,
      asset.corr,
      basePrices
    );
    priceHistoryCache.set(`stock:${asset.symbol}`, history);
  }
  for (const asset of cryptoAssets) {
    const history = generateSimulatedPriceHistory(
      asset.symbol,
      "crypto",
      asset.base,
      asset.vol,
      asset.corr,
      basePrices
    );
    priceHistoryCache.set(`crypto:${asset.symbol}`, history);
  }
  for (const asset of forexAssets) {
    const history = generateSimulatedPriceHistory(
      asset.symbol,
      "forex",
      asset.base,
      asset.vol,
      asset.corr,
      basePrices
    );
    priceHistoryCache.set(`forex:${asset.symbol}`, history);
  }
  for (const asset of commodityAssets) {
    const history = generateSimulatedPriceHistory(
      asset.symbol,
      "commodity",
      asset.base,
      asset.vol,
      asset.corr,
      basePrices
    );
    priceHistoryCache.set(`commodity:${asset.symbol}`, history);
  }
  priceHistoryCache.set("stock:SPY", baseHistory);
}
var priceHistoryCache, correlationService_default;
var init_correlationService = __esm({
  "server/services/correlationService.ts"() {
    "use strict";
    priceHistoryCache = /* @__PURE__ */ new Map();
    correlationService_default = {
      pearsonCorrelation,
      getCorrelationStrength: getCorrelationStrength2,
      calculateAssetCorrelation,
      calculateCorrelationMatrix: calculateCorrelationMatrix4,
      updatePriceHistory,
      getPriceHistory,
      getCachedAssets,
      clearPriceHistoryCache,
      seedDemoCorrelationData,
      getCorrelationColor,
      generateSimulatedPriceHistory
    };
  }
});

// server/services/portfolioOptimizer.ts
var portfolioOptimizer_exports = {};
__export(portfolioOptimizer_exports, {
  buildCovarianceMatrix: () => buildCovarianceMatrix,
  calculateCovariance: () => calculateCovariance,
  calculatePortfolioReturn: () => calculatePortfolioReturn,
  calculatePortfolioVolatility: () => calculatePortfolioVolatility,
  calculateRebalancing: () => calculateRebalancing,
  calculateSharpeRatio: () => calculateSharpeRatio,
  generateEfficientFrontier: () => generateEfficientFrontier2,
  generateSampleAssets: () => generateSampleAssets,
  getRiskProfileDescription: () => getRiskProfileDescription,
  optimizePortfolio: () => optimizePortfolio,
  runMonteCarloSimulation: () => runMonteCarloSimulation3
});
function calculateCovariance(returns1, returns2) {
  if (returns1.length !== returns2.length || returns1.length < 2) {
    return 0;
  }
  const mean1 = returns1.reduce((a, b) => a + b, 0) / returns1.length;
  const mean22 = returns2.reduce((a, b) => a + b, 0) / returns2.length;
  let covariance2 = 0;
  for (let i = 0; i < returns1.length; i++) {
    covariance2 += (returns1[i] - mean1) * (returns2[i] - mean22);
  }
  return covariance2 / (returns1.length - 1);
}
function buildCovarianceMatrix(assets) {
  const n = assets.length;
  const matrix = Array.from({ length: n }, () => Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      if (i === j) {
        matrix[i][j] = Math.pow(assets[i].volatility, 2);
      } else if (assets[i].historicalReturns && assets[j].historicalReturns) {
        matrix[i][j] = calculateCovariance(
          assets[i].historicalReturns,
          assets[j].historicalReturns
        );
      } else {
        const correlation2 = estimateCorrelation(assets[i], assets[j]);
        matrix[i][j] = correlation2 * assets[i].volatility * assets[j].volatility;
      }
    }
  }
  return matrix;
}
function estimateCorrelation(asset1, asset2) {
  const correlationMap = {
    stock: { stock: 0.6, crypto: 0.3, forex: 0.1, commodity: 0.2, bond: -0.2 },
    crypto: { stock: 0.3, crypto: 0.7, forex: 0.1, commodity: 0.15, bond: -0.1 },
    forex: { stock: 0.1, crypto: 0.1, forex: 0.5, commodity: 0.2, bond: 0.1 },
    commodity: { stock: 0.2, crypto: 0.15, forex: 0.2, commodity: 0.5, bond: 0 },
    bond: { stock: -0.2, crypto: -0.1, forex: 0.1, commodity: 0, bond: 0.8 }
  };
  return correlationMap[asset1.assetType]?.[asset2.assetType] ?? 0.3;
}
function calculatePortfolioReturn(assets, weights) {
  return assets.reduce((sum2, asset, i) => sum2 + asset.expectedReturn * weights[i], 0);
}
function calculatePortfolioVolatility(weights, covarianceMatrix) {
  let variance = 0;
  const n = weights.length;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      variance += weights[i] * weights[j] * covarianceMatrix[i][j];
    }
  }
  return Math.sqrt(variance);
}
function calculateSharpeRatio(expectedReturn, volatility, riskFreeRate = RISK_FREE_RATE) {
  if (volatility === 0) return 0;
  return (expectedReturn - riskFreeRate) / volatility;
}
function getTargetVolatility(riskProfile) {
  const profiles = {
    conservative: { min: 0.05, max: 0.1, target: 0.08 },
    moderate: { min: 0.08, max: 0.15, target: 0.12 },
    balanced: { min: 0.12, max: 0.2, target: 0.16 },
    growth: { min: 0.18, max: 0.28, target: 0.22 },
    aggressive: { min: 0.25, max: 0.4, target: 0.3 }
  };
  return profiles[riskProfile];
}
function generateRandomWeights(n) {
  const weights = Array.from({ length: n }, () => Math.random());
  const sum2 = weights.reduce((a, b) => a + b, 0);
  return weights.map((w) => w / sum2);
}
function optimizePortfolio(assets, riskProfile, iterations = 1e4) {
  const n = assets.length;
  const covarianceMatrix = buildCovarianceMatrix(assets);
  const targetVol = getTargetVolatility(riskProfile);
  let bestSharpe = -Infinity;
  let bestWeights = Array(n).fill(1 / n);
  let bestReturn = 0;
  let bestVolatility = 0;
  for (let i = 0; i < iterations; i++) {
    const weights = generateRandomWeights(n);
    const portfolioReturn = calculatePortfolioReturn(assets, weights);
    const portfolioVol = calculatePortfolioVolatility(weights, covarianceMatrix);
    const sharpe = calculateSharpeRatio(portfolioReturn, portfolioVol);
    if (portfolioVol >= targetVol.min && portfolioVol <= targetVol.max && sharpe > bestSharpe) {
      bestSharpe = sharpe;
      bestWeights = weights;
      bestReturn = portfolioReturn;
      bestVolatility = portfolioVol;
    }
  }
  if (bestSharpe === -Infinity) {
    bestWeights = Array(n).fill(1 / n);
    bestReturn = calculatePortfolioReturn(assets, bestWeights);
    bestVolatility = calculatePortfolioVolatility(bestWeights, covarianceMatrix);
    bestSharpe = calculateSharpeRatio(bestReturn, bestVolatility);
  }
  const allocations = assets.map((asset, i) => ({
    symbol: asset.symbol,
    name: asset.name,
    assetType: asset.assetType,
    weight: Math.round(bestWeights[i] * 1e4) / 1e4,
    expectedContribution: Math.round(bestWeights[i] * asset.expectedReturn * 1e4) / 1e4
  }));
  allocations.sort((a, b) => b.weight - a.weight);
  const diversificationScore = calculateDiversificationScore(allocations);
  return {
    allocations,
    expectedReturn: Math.round(bestReturn * 1e4) / 1e4,
    expectedVolatility: Math.round(bestVolatility * 1e4) / 1e4,
    sharpeRatio: Math.round(bestSharpe * 100) / 100,
    riskProfile,
    diversificationScore,
    efficientFrontierPosition: bestSharpe > 0.5 ? "optimal" : bestSharpe > 0 ? "suboptimal" : "inefficient"
  };
}
function calculateDiversificationScore(allocations) {
  const hhi = allocations.reduce((sum2, a) => sum2 + Math.pow(a.weight, 2), 0);
  const n = allocations.length;
  const minHHI = 1 / n;
  const normalizedHHI = (hhi - minHHI) / (1 - minHHI);
  const concentrationPenalty = normalizedHHI * 50;
  const assetTypes = new Set(allocations.map((a) => a.assetType));
  const typeDiversityBonus = Math.min(assetTypes.size * 10, 30);
  return Math.round(Math.max(0, Math.min(100, 70 - concentrationPenalty + typeDiversityBonus)));
}
function generateEfficientFrontier2(assets, points = 50) {
  const n = assets.length;
  const covarianceMatrix = buildCovarianceMatrix(assets);
  const frontier = [];
  const minReturn = Math.min(...assets.map((a) => a.expectedReturn));
  const maxReturn = Math.max(...assets.map((a) => a.expectedReturn));
  for (let i = 0; i < points; i++) {
    const targetReturn = minReturn + (maxReturn - minReturn) * (i / (points - 1));
    let minVol = Infinity;
    let bestWeights = [];
    for (let j = 0; j < 5e3; j++) {
      const weights = generateRandomWeights(n);
      const portfolioReturn = calculatePortfolioReturn(assets, weights);
      if (Math.abs(portfolioReturn - targetReturn) < 0.02) {
        const vol = calculatePortfolioVolatility(weights, covarianceMatrix);
        if (vol < minVol) {
          minVol = vol;
          bestWeights = weights;
        }
      }
    }
    if (bestWeights.length > 0) {
      const actualReturn = calculatePortfolioReturn(assets, bestWeights);
      frontier.push({
        expectedReturn: Math.round(actualReturn * 1e4) / 1e4,
        volatility: Math.round(minVol * 1e4) / 1e4,
        sharpeRatio: Math.round(calculateSharpeRatio(actualReturn, minVol) * 100) / 100,
        allocations: assets.map((a, idx) => ({
          symbol: a.symbol,
          weight: Math.round(bestWeights[idx] * 1e4) / 1e4
        }))
      });
    }
  }
  return frontier.sort((a, b) => a.volatility - b.volatility);
}
function runMonteCarloSimulation3(portfolio, initialValue, yearsToProject = 5, simulations = 1e4, targetReturn) {
  const annualReturn = portfolio.expectedReturn;
  const annualVol = portfolio.expectedVolatility;
  const results = [];
  for (let i = 0; i < simulations; i++) {
    let value = initialValue;
    for (let year = 0; year < yearsToProject; year++) {
      const u1 = Math.random();
      const u2 = Math.random();
      const z3 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      const yearReturn = annualReturn + annualVol * z3;
      value *= 1 + yearReturn;
    }
    results.push(value);
  }
  results.sort((a, b) => a - b);
  const targetValue = targetReturn ? initialValue * Math.pow(1 + targetReturn, yearsToProject) : initialValue * 1.5;
  return {
    percentile5: Math.round(results[Math.floor(simulations * 0.05)]),
    percentile25: Math.round(results[Math.floor(simulations * 0.25)]),
    median: Math.round(results[Math.floor(simulations * 0.5)]),
    percentile75: Math.round(results[Math.floor(simulations * 0.75)]),
    percentile95: Math.round(results[Math.floor(simulations * 0.95)]),
    mean: Math.round(results.reduce((a, b) => a + b, 0) / simulations),
    bestCase: Math.round(results[results.length - 1]),
    worstCase: Math.round(results[0]),
    probabilityOfLoss: Math.round(results.filter((r) => r < initialValue).length / simulations * 100),
    probabilityOfTarget: Math.round(results.filter((r) => r >= targetValue).length / simulations * 100)
  };
}
function calculateRebalancing(currentAllocations, targetAllocations, threshold = 0.05) {
  const recommendations = [];
  for (const target of targetAllocations) {
    const current = currentAllocations.find((c) => c.symbol === target.symbol);
    const currentWeight = current?.weight ?? 0;
    const diff = target.weight - currentWeight;
    if (Math.abs(diff) >= threshold) {
      recommendations.push({
        symbol: target.symbol,
        currentWeight: Math.round(currentWeight * 1e4) / 1e4,
        targetWeight: target.weight,
        action: diff > 0 ? "buy" : "sell",
        percentageChange: Math.round(diff * 1e4) / 100
      });
    }
  }
  for (const current of currentAllocations) {
    if (!targetAllocations.find((t2) => t2.symbol === current.symbol) && current.weight > 0) {
      recommendations.push({
        symbol: current.symbol,
        currentWeight: current.weight,
        targetWeight: 0,
        action: "sell",
        percentageChange: -Math.round(current.weight * 1e4) / 100
      });
    }
  }
  return recommendations.sort((a, b) => Math.abs(b.percentageChange) - Math.abs(a.percentageChange));
}
function generateSampleAssets() {
  return [
    // Stocks
    { symbol: "AAPL", name: "Apple Inc.", assetType: "stock", expectedReturn: 0.12, volatility: 0.25, currentPrice: 185 },
    { symbol: "MSFT", name: "Microsoft Corp.", assetType: "stock", expectedReturn: 0.11, volatility: 0.22, currentPrice: 378 },
    { symbol: "GOOGL", name: "Alphabet Inc.", assetType: "stock", expectedReturn: 0.1, volatility: 0.28, currentPrice: 142 },
    { symbol: "AMZN", name: "Amazon.com Inc.", assetType: "stock", expectedReturn: 0.13, volatility: 0.3, currentPrice: 178 },
    { symbol: "NVDA", name: "NVIDIA Corp.", assetType: "stock", expectedReturn: 0.18, volatility: 0.45, currentPrice: 495 },
    // Crypto
    { symbol: "BTC", name: "Bitcoin", assetType: "crypto", expectedReturn: 0.25, volatility: 0.65, currentPrice: 43e3 },
    { symbol: "ETH", name: "Ethereum", assetType: "crypto", expectedReturn: 0.22, volatility: 0.7, currentPrice: 2300 },
    // Commodities
    { symbol: "GOLD", name: "Gold", assetType: "commodity", expectedReturn: 0.05, volatility: 0.15, currentPrice: 2050 },
    { symbol: "SILVER", name: "Silver", assetType: "commodity", expectedReturn: 0.06, volatility: 0.22, currentPrice: 24 },
    // Bonds (represented as ETFs)
    { symbol: "BND", name: "Total Bond Market", assetType: "bond", expectedReturn: 0.04, volatility: 0.05, currentPrice: 72 },
    { symbol: "TLT", name: "20+ Year Treasury", assetType: "bond", expectedReturn: 0.035, volatility: 0.12, currentPrice: 92 },
    // Forex
    { symbol: "EUR/USD", name: "Euro/US Dollar", assetType: "forex", expectedReturn: 0.02, volatility: 0.08, currentPrice: 1.08 }
  ];
}
function getRiskProfileDescription(profile) {
  const descriptions = {
    conservative: {
      name: "Conservative",
      description: "Focuses on capital preservation with minimal risk exposure",
      targetReturn: "4-6%",
      targetVolatility: "5-10%",
      suitableFor: "Retirees, short-term goals, risk-averse investors"
    },
    moderate: {
      name: "Moderate",
      description: "Balanced approach with emphasis on stability",
      targetReturn: "6-9%",
      targetVolatility: "8-15%",
      suitableFor: "Near-retirement, moderate risk tolerance"
    },
    balanced: {
      name: "Balanced",
      description: "Equal focus on growth and income with moderate risk",
      targetReturn: "8-12%",
      targetVolatility: "12-20%",
      suitableFor: "Mid-career investors, medium-term goals"
    },
    growth: {
      name: "Growth",
      description: "Prioritizes capital appreciation over income",
      targetReturn: "12-18%",
      targetVolatility: "18-28%",
      suitableFor: "Young investors, long-term goals"
    },
    aggressive: {
      name: "Aggressive",
      description: "Maximum growth potential with high risk tolerance",
      targetReturn: "18-30%",
      targetVolatility: "25-40%",
      suitableFor: "Experienced investors, very long time horizon"
    }
  };
  return descriptions[profile];
}
var RISK_FREE_RATE;
var init_portfolioOptimizer = __esm({
  "server/services/portfolioOptimizer.ts"() {
    "use strict";
    RISK_FREE_RATE = 0.045;
  }
});

// server/services/backtesting/HistoricalSentimentCollector.ts
function createHistoricalSentimentCollector(apiKey) {
  return new HistoricalSentimentCollector(apiKey);
}
var POSITIVE_KEYWORDS, NEGATIVE_KEYWORDS, HEDGING_PHRASES, CONFIDENCE_PHRASES, FORWARD_LOOKING_PHRASES, HistoricalSentimentCollector;
var init_HistoricalSentimentCollector = __esm({
  "server/services/backtesting/HistoricalSentimentCollector.ts"() {
    "use strict";
    POSITIVE_KEYWORDS = [
      "growth",
      "strong",
      "record",
      "exceeded",
      "beat",
      "outperform",
      "momentum",
      "accelerate",
      "robust",
      "excellent",
      "outstanding",
      "impressive",
      "confident",
      "optimistic",
      "pleased",
      "excited",
      "thrilled",
      "remarkable",
      "exceptional"
    ];
    NEGATIVE_KEYWORDS = [
      "decline",
      "weak",
      "miss",
      "below",
      "challenge",
      "headwind",
      "pressure",
      "difficult",
      "uncertain",
      "concern",
      "disappointing",
      "shortfall",
      "slowdown",
      "cautious",
      "worried",
      "risk",
      "struggle",
      "underperform",
      "soft"
    ];
    HEDGING_PHRASES = [
      "we believe",
      "we think",
      "potentially",
      "possibly",
      "may",
      "might",
      "could",
      "should",
      "approximately",
      "roughly",
      "around",
      "about",
      "in the range of",
      "somewhere between",
      "give or take"
    ];
    CONFIDENCE_PHRASES = [
      "we are confident",
      "we are certain",
      "definitely",
      "absolutely",
      "without a doubt",
      "clearly",
      "certainly",
      "undoubtedly",
      "strong conviction",
      "we will",
      "we expect",
      "we anticipate"
    ];
    FORWARD_LOOKING_PHRASES = [
      "going forward",
      "in the future",
      "next quarter",
      "next year",
      "outlook",
      "guidance",
      "forecast",
      "expect",
      "anticipate",
      "project",
      "plan to",
      "intend to",
      "looking ahead",
      "on track to"
    ];
    HistoricalSentimentCollector = class {
      cache = /* @__PURE__ */ new Map();
      fmpApiKey;
      constructor(fmpApiKey) {
        this.fmpApiKey = fmpApiKey || process.env.FMP_API_KEY || "";
      }
      /**
       * Fetch historical transcripts for a symbol
       */
      async fetchHistoricalTranscripts(symbol, years = 3) {
        const transcripts = [];
        const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
        for (let year = currentYear; year > currentYear - years; year--) {
          for (let quarter = 4; quarter >= 1; quarter--) {
            try {
              const transcript = await this.fetchTranscript(symbol, year, quarter);
              if (transcript) {
                transcripts.push(transcript);
              }
            } catch (error) {
              console.log(`[HistoricalSentiment] No transcript for ${symbol} Q${quarter} ${year}`);
            }
          }
        }
        return transcripts;
      }
      /**
       * Fetch a single transcript from FMP API
       */
      async fetchTranscript(symbol, year, quarter) {
        if (!this.fmpApiKey) {
          return this.generateMockTranscript(symbol, year, quarter);
        }
        try {
          const url = `https://financialmodelingprep.com/api/v3/earning_call_transcript/${symbol}?year=${year}&quarter=${quarter}&apikey=${this.fmpApiKey}`;
          const response = await fetch(url);
          if (!response.ok) {
            return null;
          }
          const data = await response.json();
          if (!data || data.length === 0) {
            return null;
          }
          const transcript = data[0];
          return {
            symbol,
            date: transcript.date,
            fiscalYear: year,
            fiscalQuarter: quarter,
            content: transcript.content,
            speakers: this.parseTranscriptSpeakers(transcript.content)
          };
        } catch (error) {
          console.error(`[HistoricalSentiment] Error fetching transcript:`, error);
          return null;
        }
      }
      /**
       * Parse transcript content into speaker segments
       */
      parseTranscriptSpeakers(content) {
        const segments = [];
        const lines = content.split("\n");
        let currentSpeaker = "";
        let currentRole = "other_executive";
        let currentText = "";
        for (const line of lines) {
          const speakerMatch = line.match(/^([A-Z][a-zA-Z\s]+)(?:\s*-\s*([^:]+))?:/);
          if (speakerMatch) {
            if (currentSpeaker && currentText.trim()) {
              segments.push({
                speaker: currentSpeaker,
                role: currentRole,
                text: currentText.trim()
              });
            }
            currentSpeaker = speakerMatch[1].trim();
            const title = speakerMatch[2]?.toLowerCase() || "";
            currentRole = this.inferRole(title, currentSpeaker);
            currentText = line.substring(line.indexOf(":") + 1).trim();
          } else if (currentSpeaker) {
            currentText += " " + line.trim();
          }
        }
        if (currentSpeaker && currentText.trim()) {
          segments.push({
            speaker: currentSpeaker,
            role: currentRole,
            text: currentText.trim()
          });
        }
        return segments;
      }
      /**
       * Infer speaker role from title
       */
      inferRole(title, name) {
        const lowerTitle = title.toLowerCase();
        const lowerName = name.toLowerCase();
        if (lowerTitle.includes("ceo") || lowerTitle.includes("chief executive")) {
          return "ceo";
        }
        if (lowerTitle.includes("cfo") || lowerTitle.includes("chief financial")) {
          return "cfo";
        }
        if (lowerTitle.includes("coo") || lowerTitle.includes("chief operating")) {
          return "coo";
        }
        if (lowerTitle.includes("analyst") || lowerName.includes("analyst")) {
          return "analyst";
        }
        if (lowerTitle.includes("operator") || lowerName.includes("operator")) {
          return "operator";
        }
        if (lowerTitle.includes("president") || lowerTitle.includes("vp") || lowerTitle.includes("director") || lowerTitle.includes("executive")) {
          return "other_executive";
        }
        return "analyst";
      }
      /**
       * Analyze sentiment of a historical transcript
       */
      async analyzeSentiment(transcript) {
        const cacheKey = `${transcript.symbol}-${transcript.fiscalYear}-Q${transcript.fiscalQuarter}`;
        const cached = this.cache.get(cacheKey);
        if (cached) {
          return cached.sentiment;
        }
        const keyMetrics = this.calculateKeyMetrics(transcript.content);
        const managementTone = await this.analyzeManagementTone(transcript);
        const analystReaction = this.analyzeAnalystReaction(transcript);
        const guidanceSignal = this.detectGuidanceSignal(transcript.content);
        const overall = this.calculateOverallSentiment(keyMetrics, managementTone, guidanceSignal);
        const sentiment = {
          overall,
          confidence: this.calculateConfidence(keyMetrics, transcript.content.length),
          managementTone,
          analystReaction,
          guidanceSignal,
          keyMetrics
        };
        this.cache.set(cacheKey, {
          symbol: transcript.symbol,
          earningsDate: transcript.date,
          fiscalYear: transcript.fiscalYear,
          fiscalQuarter: transcript.fiscalQuarter,
          sentiment,
          processedAt: Date.now()
        });
        return sentiment;
      }
      /**
       * Calculate keyword-based metrics
       */
      calculateKeyMetrics(content) {
        const lowerContent = content.toLowerCase();
        return {
          positiveKeywords: POSITIVE_KEYWORDS.filter((kw) => lowerContent.includes(kw)).length,
          negativeKeywords: NEGATIVE_KEYWORDS.filter((kw) => lowerContent.includes(kw)).length,
          hedgingPhrases: HEDGING_PHRASES.filter((phrase) => lowerContent.includes(phrase)).length,
          confidencePhrases: CONFIDENCE_PHRASES.filter((phrase) => lowerContent.includes(phrase)).length,
          forwardLookingStatements: FORWARD_LOOKING_PHRASES.filter((phrase) => lowerContent.includes(phrase)).length
        };
      }
      /**
       * Analyze management tone using LLM
       */
      async analyzeManagementTone(transcript) {
        const managementSegments = transcript.speakers.filter((s) => ["ceo", "cfo", "coo", "other_executive"].includes(s.role)).map((s) => s.text).join("\n");
        if (!managementSegments || managementSegments.length < 100) {
          return this.getDefaultManagementTone();
        }
        try {
          const lowerText = managementSegments.toLowerCase();
          const optimismKeywords = ["confident", "strong", "growth", "excited", "pleased", "record"];
          const defensivenessKeywords = ["explain", "clarify", "understand", "context", "perspective"];
          const uncertaintyKeywords = ["may", "might", "could", "possibly", "uncertain", "depends"];
          const forwardKeywords = ["going forward", "next quarter", "outlook", "expect", "anticipate"];
          const optimism = Math.min(1, optimismKeywords.filter((kw) => lowerText.includes(kw)).length / 4);
          const defensiveness = Math.min(1, defensivenessKeywords.filter((kw) => lowerText.includes(kw)).length / 3);
          const uncertainty = Math.min(1, uncertaintyKeywords.filter((kw) => lowerText.includes(kw)).length / 4);
          const forwardLooking = Math.min(1, forwardKeywords.filter((kw) => lowerText.includes(kw)).length / 3);
          const confidence = Math.max(0, 1 - uncertainty);
          return {
            optimism,
            defensiveness,
            confidence,
            uncertainty,
            forwardLooking
          };
        } catch (error) {
          console.error("[HistoricalSentiment] Error analyzing management tone:", error);
          return this.getDefaultManagementTone();
        }
      }
      /**
       * Analyze analyst reaction from Q&A
       */
      analyzeAnalystReaction(transcript) {
        const analystSegments = transcript.speakers.filter((s) => s.role === "analyst").map((s) => s.text.toLowerCase());
        if (analystSegments.length === 0) {
          return { satisfaction: 0.5, skepticism: 0.3, followUpIntensity: 0.3 };
        }
        const allAnalystText = analystSegments.join(" ");
        const satisfactionKeywords = ["thank", "great", "impressive", "congratulations", "excellent"];
        const satisfaction = Math.min(1, satisfactionKeywords.filter((kw) => allAnalystText.includes(kw)).length / 3);
        const skepticismKeywords = ["but", "however", "concern", "worried", "why", "explain", "clarify"];
        const skepticism = Math.min(1, skepticismKeywords.filter((kw) => allAnalystText.includes(kw)).length / 4);
        const questionCount = (allAnalystText.match(/\?/g) || []).length;
        const followUpIntensity = Math.min(1, questionCount / (analystSegments.length * 2));
        return { satisfaction, skepticism, followUpIntensity };
      }
      /**
       * Detect guidance signals in transcript
       */
      detectGuidanceSignal(content) {
        const lowerContent = content.toLowerCase();
        const raisedKeywords = ["raised", "increased", "higher", "upgraded", "above"];
        const loweredKeywords = ["lowered", "reduced", "decreased", "downgraded", "below"];
        const maintainedKeywords = ["maintained", "reaffirmed", "unchanged", "consistent"];
        const withdrawnKeywords = ["withdrawn", "suspended", "removed", "no longer providing"];
        let direction = "none";
        let strength = 0;
        if (withdrawnKeywords.some((kw) => lowerContent.includes(kw + " guidance"))) {
          direction = "withdrawn";
          strength = 0.9;
        } else if (raisedKeywords.some((kw) => lowerContent.includes(kw + " guidance") || lowerContent.includes("guidance " + kw))) {
          direction = "raised";
          strength = 0.8;
        } else if (loweredKeywords.some((kw) => lowerContent.includes(kw + " guidance") || lowerContent.includes("guidance " + kw))) {
          direction = "lowered";
          strength = 0.8;
        } else if (maintainedKeywords.some((kw) => lowerContent.includes(kw + " guidance") || lowerContent.includes("guidance " + kw))) {
          direction = "maintained";
          strength = 0.6;
        }
        const guidanceContext = this.extractGuidanceContext(content);
        const hasNumbers = /\$?\d+(\.\d+)?[BMK]?/.test(guidanceContext);
        const specificity = hasNumbers ? 0.8 : 0.3;
        return { direction, strength, specificity };
      }
      /**
       * Extract context around guidance mentions
       */
      extractGuidanceContext(content) {
        const guidanceIndex = content.toLowerCase().indexOf("guidance");
        if (guidanceIndex === -1) return "";
        const start = Math.max(0, guidanceIndex - 200);
        const end = Math.min(content.length, guidanceIndex + 200);
        return content.substring(start, end);
      }
      /**
       * Calculate overall sentiment score
       */
      calculateOverallSentiment(keyMetrics, managementTone, guidanceSignal) {
        const keywordSentiment = keyMetrics.positiveKeywords > 0 || keyMetrics.negativeKeywords > 0 ? (keyMetrics.positiveKeywords - keyMetrics.negativeKeywords) / (keyMetrics.positiveKeywords + keyMetrics.negativeKeywords) : 0;
        const toneSentiment = (managementTone.optimism - managementTone.defensiveness + managementTone.confidence - managementTone.uncertainty) / 2;
        let guidanceSentiment = 0;
        if (guidanceSignal.direction === "raised") guidanceSentiment = 0.8;
        else if (guidanceSignal.direction === "maintained") guidanceSentiment = 0.2;
        else if (guidanceSignal.direction === "lowered") guidanceSentiment = -0.6;
        else if (guidanceSignal.direction === "withdrawn") guidanceSentiment = -0.8;
        const overall = keywordSentiment * 0.3 + toneSentiment * 0.4 + guidanceSentiment * 0.3;
        return Math.max(-1, Math.min(1, overall));
      }
      /**
       * Calculate confidence in sentiment score
       */
      calculateConfidence(keyMetrics, contentLength) {
        const keywordConfidence = Math.min(1, (keyMetrics.positiveKeywords + keyMetrics.negativeKeywords) / 20);
        const lengthConfidence = Math.min(1, contentLength / 5e4);
        return keywordConfidence * 0.6 + lengthConfidence * 0.4;
      }
      /**
       * Get default management tone
       */
      getDefaultManagementTone() {
        return {
          optimism: 0.5,
          defensiveness: 0.3,
          confidence: 0.5,
          uncertainty: 0.3,
          forwardLooking: 0.5
        };
      }
      /**
       * Generate mock transcript for testing
       */
      generateMockTranscript(symbol, year, quarter) {
        const date2 = new Date(year, (quarter - 1) * 3 + 1, 15).toISOString().split("T")[0];
        return {
          symbol,
          date: date2,
          fiscalYear: year,
          fiscalQuarter: quarter,
          content: `
        Operator: Good afternoon, and welcome to ${symbol}'s Q${quarter} ${year} earnings call.
        
        CEO - Chief Executive Officer: Thank you. We are pleased to report strong results this quarter.
        Our revenue grew significantly, and we exceeded our guidance. We remain confident in our 
        growth trajectory and are excited about the opportunities ahead.
        
        CFO - Chief Financial Officer: Total revenue was up year over year, driven by strong demand
        across all segments. We are maintaining our full-year guidance and expect continued momentum.
        
        Analyst: Can you provide more color on the margin expansion?
        
        CFO - Chief Financial Officer: Certainly. We've seen operational efficiencies and scale benefits
        that have contributed to improved margins. We expect this trend to continue.
        
        Analyst: What's your outlook for next quarter?
        
        CEO - Chief Executive Officer: We remain optimistic about our prospects. The pipeline is strong
        and we're well-positioned for continued growth.
      `,
          speakers: [
            { speaker: "Operator", role: "operator", text: `Good afternoon, and welcome to ${symbol}'s Q${quarter} ${year} earnings call.` },
            { speaker: "CEO", role: "ceo", text: "We are pleased to report strong results this quarter. Our revenue grew significantly, and we exceeded our guidance. We remain confident in our growth trajectory and are excited about the opportunities ahead." },
            { speaker: "CFO", role: "cfo", text: "Total revenue was up year over year, driven by strong demand across all segments. We are maintaining our full-year guidance and expect continued momentum." },
            { speaker: "Analyst", role: "analyst", text: "Can you provide more color on the margin expansion?" },
            { speaker: "CFO", role: "cfo", text: "Certainly. We've seen operational efficiencies and scale benefits that have contributed to improved margins. We expect this trend to continue." },
            { speaker: "Analyst", role: "analyst", text: "What's your outlook for next quarter?" },
            { speaker: "CEO", role: "ceo", text: "We remain optimistic about our prospects. The pipeline is strong and we're well-positioned for continued growth." }
          ]
        };
      }
      /**
       * Batch process multiple symbols
       */
      async batchCollectSentiment(symbols, years = 3) {
        const results = /* @__PURE__ */ new Map();
        for (const symbol of symbols) {
          try {
            const transcripts = await this.fetchHistoricalTranscripts(symbol, years);
            const sentimentData = [];
            for (const transcript of transcripts) {
              const sentiment = await this.analyzeSentiment(transcript);
              sentimentData.push({
                symbol,
                earningsDate: transcript.date,
                fiscalYear: transcript.fiscalYear,
                fiscalQuarter: transcript.fiscalQuarter,
                sentiment,
                processedAt: Date.now()
              });
            }
            results.set(symbol, sentimentData);
          } catch (error) {
            console.error(`[HistoricalSentiment] Error processing ${symbol}:`, error);
            results.set(symbol, []);
          }
        }
        return results;
      }
      /**
       * Get cached sentiment data
       */
      getCachedData() {
        return this.cache;
      }
      /**
       * Clear cache
       */
      clearCache() {
        this.cache.clear();
      }
    };
  }
});

// server/services/backtesting/PostEarningsPriceAnalyzer.ts
function createPostEarningsPriceAnalyzer(benchmarkSymbol) {
  return new PostEarningsPriceAnalyzer(benchmarkSymbol);
}
var PostEarningsPriceAnalyzer;
var init_PostEarningsPriceAnalyzer = __esm({
  "server/services/backtesting/PostEarningsPriceAnalyzer.ts"() {
    "use strict";
    init_dataApi();
    PostEarningsPriceAnalyzer = class {
      priceCache = /* @__PURE__ */ new Map();
      benchmarkSymbol = "SPY";
      // S&P 500 ETF as benchmark
      constructor(benchmarkSymbol) {
        if (benchmarkSymbol) {
          this.benchmarkSymbol = benchmarkSymbol;
        }
      }
      /**
       * Analyze price movements around an earnings date
       */
      async analyzePriceMovement(symbol, earningsDate) {
        const prices = await this.fetchHistoricalPrices(symbol, earningsDate, 60);
        const benchmarkPrices = await this.fetchHistoricalPrices(this.benchmarkSymbol, earningsDate, 60);
        const earningsIndex = this.findEarningsDateIndex(prices, earningsDate);
        if (earningsIndex === -1) {
          throw new Error(`Earnings date ${earningsDate} not found in price data for ${symbol}`);
        }
        const priceAtEarnings = prices[earningsIndex].close;
        const timeframes = ["1d", "3d", "5d", "10d", "30d"];
        const movements = [];
        const abnormalReturns = [];
        for (const timeframe of timeframes) {
          const days = this.timeframeToDays(timeframe);
          const movement = this.calculateMovement(prices, earningsIndex, days);
          movements.push({ timeframe, ...movement });
          const benchmarkMovement = this.calculateMovement(benchmarkPrices, earningsIndex, days);
          const abnormal = this.calculateAbnormalReturn(
            movement.percentChange,
            benchmarkMovement.percentChange,
            timeframe,
            abnormalReturns
          );
          abnormalReturns.push(abnormal);
        }
        const volatility = this.calculateVolatilityMetrics(prices, earningsIndex);
        const volume = this.calculateVolumeMetrics(prices, earningsIndex);
        return {
          symbol,
          earningsDate,
          priceAtEarnings,
          movements,
          abnormalReturns,
          volatility,
          volume
        };
      }
      /**
       * Fetch historical prices for a symbol
       */
      async fetchHistoricalPrices(symbol, centerDate, daysAround) {
        const cacheKey = `${symbol}-${centerDate}-${daysAround}`;
        if (this.priceCache.has(cacheKey)) {
          return this.priceCache.get(cacheKey);
        }
        try {
          const center = new Date(centerDate);
          const startDate = new Date(center);
          startDate.setDate(startDate.getDate() - daysAround);
          const endDate = new Date(center);
          endDate.setDate(endDate.getDate() + daysAround);
          const result = await callDataApi("YahooFinance/get_stock_chart", {
            query: {
              symbol,
              region: "US",
              interval: "1d",
              range: "6mo",
              includeAdjustedClose: true
            }
          });
          if (!result?.chart?.result?.[0]) {
            return this.generateMockPrices(symbol, centerDate, daysAround);
          }
          const chartData = result.chart.result[0];
          const timestamps = chartData.timestamp || [];
          const quotes = chartData.indicators?.quote?.[0] || {};
          const adjClose = chartData.indicators?.adjclose?.[0]?.adjclose || [];
          const prices = [];
          for (let i = 0; i < timestamps.length; i++) {
            const date2 = new Date(timestamps[i] * 1e3).toISOString().split("T")[0];
            prices.push({
              date: date2,
              open: quotes.open?.[i] || 0,
              high: quotes.high?.[i] || 0,
              low: quotes.low?.[i] || 0,
              close: quotes.close?.[i] || 0,
              volume: quotes.volume?.[i] || 0,
              adjustedClose: adjClose[i] || quotes.close?.[i] || 0
            });
          }
          this.priceCache.set(cacheKey, prices);
          return prices;
        } catch (error) {
          console.error(`[PriceAnalyzer] Error fetching prices for ${symbol}:`, error);
          return this.generateMockPrices(symbol, centerDate, daysAround);
        }
      }
      /**
       * Generate mock prices for testing
       */
      generateMockPrices(symbol, centerDate, daysAround) {
        const prices = [];
        const center = new Date(centerDate);
        let basePrice = 100 + Math.random() * 100;
        for (let i = -daysAround; i <= daysAround; i++) {
          const date2 = new Date(center);
          date2.setDate(date2.getDate() + i);
          if (date2.getDay() === 0 || date2.getDay() === 6) continue;
          const dailyReturn = (Math.random() - 0.48) * 0.03;
          basePrice *= 1 + dailyReturn;
          const high = basePrice * (1 + Math.random() * 0.02);
          const low = basePrice * (1 - Math.random() * 0.02);
          const open = low + Math.random() * (high - low);
          const close = low + Math.random() * (high - low);
          prices.push({
            date: date2.toISOString().split("T")[0],
            open,
            high,
            low,
            close,
            volume: Math.floor(1e6 + Math.random() * 5e6),
            adjustedClose: close
          });
        }
        return prices;
      }
      /**
       * Find the index of the earnings date in price data
       */
      findEarningsDateIndex(prices, earningsDate) {
        let index = prices.findIndex((p) => p.date === earningsDate);
        if (index === -1) {
          const earningsTime = new Date(earningsDate).getTime();
          for (let i = 0; i < prices.length; i++) {
            const priceTime = new Date(prices[i].date).getTime();
            if (priceTime >= earningsTime) {
              index = i;
              break;
            }
          }
        }
        return index;
      }
      /**
       * Convert timeframe string to number of days
       */
      timeframeToDays(timeframe) {
        const map = {
          "1d": 1,
          "3d": 3,
          "5d": 5,
          "10d": 10,
          "30d": 30
        };
        return map[timeframe] || 1;
      }
      /**
       * Calculate price movement for a specific timeframe
       */
      calculateMovement(prices, startIndex, days) {
        const endIndex = Math.min(startIndex + days, prices.length - 1);
        if (startIndex >= prices.length || endIndex >= prices.length) {
          return {
            startPrice: 0,
            endPrice: 0,
            percentChange: 0,
            absoluteChange: 0,
            high: 0,
            low: 0,
            maxDrawdown: 0,
            maxRunup: 0
          };
        }
        const startPrice = prices[startIndex].close;
        const endPrice = prices[endIndex].close;
        let high = startPrice;
        let low = startPrice;
        let maxDrawdown = 0;
        let maxRunup = 0;
        let peakPrice = startPrice;
        let troughPrice = startPrice;
        for (let i = startIndex; i <= endIndex; i++) {
          const price = prices[i].close;
          high = Math.max(high, prices[i].high);
          low = Math.min(low, prices[i].low);
          if (price > peakPrice) {
            peakPrice = price;
          }
          const drawdown = (peakPrice - price) / peakPrice;
          maxDrawdown = Math.max(maxDrawdown, drawdown);
          if (price < troughPrice) {
            troughPrice = price;
          }
          const runup = (price - troughPrice) / troughPrice;
          maxRunup = Math.max(maxRunup, runup);
        }
        return {
          startPrice,
          endPrice,
          percentChange: (endPrice - startPrice) / startPrice * 100,
          absoluteChange: endPrice - startPrice,
          high,
          low,
          maxDrawdown: maxDrawdown * 100,
          maxRunup: maxRunup * 100
        };
      }
      /**
       * Calculate abnormal return vs benchmark
       */
      calculateAbnormalReturn(stockReturn, benchmarkReturn, timeframe, previousReturns) {
        const abnormalReturn = stockReturn - benchmarkReturn;
        const previousCAR = previousReturns.length > 0 ? previousReturns[previousReturns.length - 1].cumulativeAbnormalReturn : 0;
        const cumulativeAbnormalReturn = previousCAR + abnormalReturn;
        return {
          timeframe,
          stockReturn,
          benchmarkReturn,
          abnormalReturn,
          cumulativeAbnormalReturn
        };
      }
      /**
       * Calculate volatility metrics around earnings
       */
      calculateVolatilityMetrics(prices, earningsIndex) {
        const lookback = 20;
        const preStart = Math.max(0, earningsIndex - lookback);
        const prePrices = prices.slice(preStart, earningsIndex);
        const preEarningsVolatility = this.calculateVolatility(prePrices);
        const postEnd = Math.min(prices.length, earningsIndex + lookback);
        const postPrices = prices.slice(earningsIndex, postEnd);
        const postEarningsVolatility = this.calculateVolatility(postPrices);
        const volatilityChange = postEarningsVolatility - preEarningsVolatility;
        const impliedVolCrush = volatilityChange < 0 ? Math.abs(volatilityChange) * 2 : 0;
        return {
          preEarningsVolatility,
          postEarningsVolatility,
          volatilityChange,
          impliedVolCrush
        };
      }
      /**
       * Calculate annualized volatility from price data
       */
      calculateVolatility(prices) {
        if (prices.length < 2) return 0;
        const returns = [];
        for (let i = 1; i < prices.length; i++) {
          const dailyReturn = Math.log(prices[i].close / prices[i - 1].close);
          returns.push(dailyReturn);
        }
        const mean5 = returns.reduce((a, b) => a + b, 0) / returns.length;
        const variance = returns.reduce((sum2, r) => sum2 + Math.pow(r - mean5, 2), 0) / returns.length;
        const stdDev = Math.sqrt(variance);
        return stdDev * Math.sqrt(252) * 100;
      }
      /**
       * Calculate volume metrics around earnings
       */
      calculateVolumeMetrics(prices, earningsIndex) {
        const lookback = 20;
        const preStart = Math.max(0, earningsIndex - lookback);
        const prePrices = prices.slice(preStart, earningsIndex);
        const averageVolume = prePrices.reduce((sum2, p) => sum2 + p.volume, 0) / prePrices.length;
        const earningsDayVolume = prices[earningsIndex]?.volume || averageVolume;
        const volumeRatio = earningsDayVolume / averageVolume;
        const postEarningsVolumeDecay = [];
        for (let i = 1; i <= 5; i++) {
          const idx = earningsIndex + i;
          if (idx < prices.length) {
            postEarningsVolumeDecay.push(prices[idx].volume / averageVolume);
          }
        }
        return {
          averageVolume,
          earningsDayVolume,
          volumeRatio,
          postEarningsVolumeDecay
        };
      }
      /**
       * Batch analyze multiple earnings events
       */
      async batchAnalyze(events) {
        const results = /* @__PURE__ */ new Map();
        for (const event of events) {
          try {
            const movement = await this.analyzePriceMovement(event.symbol, event.earningsDate);
            const key = `${event.symbol}-${event.earningsDate}`;
            results.set(key, movement);
          } catch (error) {
            console.error(`[PriceAnalyzer] Error analyzing ${event.symbol} on ${event.earningsDate}:`, error);
          }
        }
        return results;
      }
      /**
       * Get price at specific date
       */
      async getPriceAtDate(symbol, date2) {
        try {
          const prices = await this.fetchHistoricalPrices(symbol, date2, 5);
          const index = this.findEarningsDateIndex(prices, date2);
          return index !== -1 ? prices[index].close : null;
        } catch (error) {
          console.error(`[PriceAnalyzer] Error getting price for ${symbol} on ${date2}:`, error);
          return null;
        }
      }
      /**
       * Clear price cache
       */
      clearCache() {
        this.priceCache.clear();
      }
      /**
       * Set benchmark symbol
       */
      setBenchmark(symbol) {
        this.benchmarkSymbol = symbol;
      }
    };
  }
});

// server/services/backtesting/SentimentPriceCorrelation.ts
var SentimentPriceCorrelation_exports = {};
__export(SentimentPriceCorrelation_exports, {
  SentimentPriceCorrelation: () => SentimentPriceCorrelation,
  createSentimentPriceCorrelation: () => createSentimentPriceCorrelation
});
function createSentimentPriceCorrelation() {
  return new SentimentPriceCorrelation();
}
var SentimentPriceCorrelation;
var init_SentimentPriceCorrelation = __esm({
  "server/services/backtesting/SentimentPriceCorrelation.ts"() {
    "use strict";
    SentimentPriceCorrelation = class {
      dataPoints = [];
      correlationCache = /* @__PURE__ */ new Map();
      /**
       * Add data points for correlation analysis
       */
      addDataPoints(sentimentData, priceMovements) {
        for (const sentiment of sentimentData) {
          const key = `${sentiment.symbol}-${sentiment.earningsDate}`;
          const priceMovement = priceMovements.get(key);
          if (priceMovement) {
            for (const movement of priceMovement.movements) {
              this.dataPoints.push({
                symbol: sentiment.symbol,
                earningsDate: sentiment.earningsDate,
                sentimentScore: sentiment.sentiment.overall,
                priceMovement: movement.percentChange
              });
            }
          }
        }
      }
      /**
       * Calculate correlation between sentiment and price movement
       */
      calculateCorrelation(sentimentScores, priceMovements) {
        if (sentimentScores.length !== priceMovements.length || sentimentScores.length < 3) {
          return this.getEmptyCorrelationResult("overall", "all");
        }
        const n = sentimentScores.length;
        const meanSentiment = sentimentScores.reduce((a, b) => a + b, 0) / n;
        const meanPrice = priceMovements.reduce((a, b) => a + b, 0) / n;
        let numerator = 0;
        let denomSentiment = 0;
        let denomPrice = 0;
        for (let i = 0; i < n; i++) {
          const sentimentDiff = sentimentScores[i] - meanSentiment;
          const priceDiff = priceMovements[i] - meanPrice;
          numerator += sentimentDiff * priceDiff;
          denomSentiment += sentimentDiff * sentimentDiff;
          denomPrice += priceDiff * priceDiff;
        }
        const correlation2 = numerator / (Math.sqrt(denomSentiment) * Math.sqrt(denomPrice));
        const rSquared = correlation2 * correlation2;
        const tStat = correlation2 * Math.sqrt((n - 2) / (1 - rSquared));
        const pValue = this.calculatePValue(tStat, n - 2);
        const confidenceInterval = this.calculateConfidenceInterval(correlation2, n);
        const significance = this.determineSignificance(pValue, Math.abs(correlation2));
        return {
          factor: "overall",
          timeframe: "all",
          correlation: isNaN(correlation2) ? 0 : correlation2,
          pValue,
          confidenceInterval,
          sampleSize: n,
          rSquared: isNaN(rSquared) ? 0 : rSquared,
          significance
        };
      }
      /**
       * Calculate correlation matrix for all factors and timeframes
       */
      calculateCorrelationMatrix(sentimentData, priceMovements) {
        const factors = [
          "overall",
          "managementOptimism",
          "managementConfidence",
          "analystSatisfaction",
          "guidanceStrength"
        ];
        const timeframes = ["1d", "3d", "5d", "10d", "30d"];
        const correlations = [];
        const pValues = [];
        for (const factor of factors) {
          const factorCorrelations = [];
          const factorPValues = [];
          for (const timeframe of timeframes) {
            const result = this.calculateFactorTimeframeCorrelation(
              sentimentData,
              priceMovements,
              factor,
              timeframe
            );
            factorCorrelations.push(result.correlation);
            factorPValues.push(result.pValue);
          }
          correlations.push(factorCorrelations);
          pValues.push(factorPValues);
        }
        return { factors, timeframes, correlations, pValues };
      }
      /**
       * Calculate correlation for a specific factor and timeframe
       */
      calculateFactorTimeframeCorrelation(sentimentData, priceMovements, factor, timeframe) {
        const cacheKey = `${factor}-${timeframe}`;
        if (this.correlationCache.has(cacheKey)) {
          return this.correlationCache.get(cacheKey);
        }
        const sentimentScores = [];
        const priceChanges = [];
        for (const sentiment of sentimentData) {
          const key = `${sentiment.symbol}-${sentiment.earningsDate}`;
          const priceMovement = priceMovements.get(key);
          if (priceMovement) {
            const movement = priceMovement.movements.find((m) => m.timeframe === timeframe);
            if (movement) {
              const sentimentScore = this.extractFactorScore(sentiment.sentiment, factor);
              sentimentScores.push(sentimentScore);
              priceChanges.push(movement.percentChange);
            }
          }
        }
        const result = this.calculateCorrelation(sentimentScores, priceChanges);
        result.factor = factor;
        result.timeframe = timeframe;
        this.correlationCache.set(cacheKey, result);
        return result;
      }
      /**
       * Extract specific factor score from sentiment
       */
      extractFactorScore(sentiment, factor) {
        switch (factor) {
          case "overall":
            return sentiment.overall;
          case "managementOptimism":
            return sentiment.managementTone.optimism;
          case "managementConfidence":
            return sentiment.managementTone.confidence;
          case "managementUncertainty":
            return sentiment.managementTone.uncertainty;
          case "analystSatisfaction":
            return sentiment.analystReaction.satisfaction;
          case "analystSkepticism":
            return sentiment.analystReaction.skepticism;
          case "guidanceStrength":
            return sentiment.guidanceSignal.strength;
          case "positiveKeywords":
            return sentiment.keyMetrics.positiveKeywords / 20;
          // Normalize
          case "negativeKeywords":
            return sentiment.keyMetrics.negativeKeywords / 20;
          default:
            return sentiment.overall;
        }
      }
      /**
       * Decompose correlation by sentiment factors
       */
      decomposeByFactor(sentimentData, priceMovements, timeframe = "5d") {
        const factors = [
          "managementOptimism",
          "managementConfidence",
          "managementUncertainty",
          "analystSatisfaction",
          "analystSkepticism",
          "guidanceStrength",
          "positiveKeywords",
          "negativeKeywords"
        ];
        const decompositions = [];
        let totalContribution = 0;
        for (const factor of factors) {
          const result = this.calculateFactorTimeframeCorrelation(
            sentimentData,
            priceMovements,
            factor,
            timeframe
          );
          const contribution = Math.abs(result.correlation) * result.rSquared;
          totalContribution += contribution;
          decompositions.push({
            factor,
            contribution,
            weight: result.correlation,
            significance: 1 - result.pValue
          });
        }
        if (totalContribution > 0) {
          for (const decomp of decompositions) {
            decomp.contribution = decomp.contribution / totalContribution * 100;
          }
        }
        decompositions.sort((a, b) => b.contribution - a.contribution);
        return decompositions;
      }
      /**
       * Calculate sector-adjusted correlations
       */
      calculateSectorAdjustedCorrelations(sentimentData, priceMovements, sectorMap, timeframe = "5d") {
        const sectorGroups = /* @__PURE__ */ new Map();
        for (const sentiment of sentimentData) {
          const sector = sectorMap.get(sentiment.symbol) || "Unknown";
          const key = `${sentiment.symbol}-${sentiment.earningsDate}`;
          const priceMovement = priceMovements.get(key);
          if (priceMovement) {
            const movement = priceMovement.movements.find((m) => m.timeframe === timeframe);
            if (movement) {
              if (!sectorGroups.has(sector)) {
                sectorGroups.set(sector, { sentiments: [], prices: [] });
              }
              const group = sectorGroups.get(sector);
              group.sentiments.push(sentiment.sentiment.overall);
              group.prices.push(movement.percentChange);
            }
          }
        }
        const allSentiments = [];
        const allPrices = [];
        for (const group of Array.from(sectorGroups.values())) {
          allSentiments.push(...group.sentiments);
          allPrices.push(...group.prices);
        }
        const baseResult = this.calculateCorrelation(allSentiments, allPrices);
        const results = [];
        for (const [sector, group] of Array.from(sectorGroups.entries())) {
          if (group.sentiments.length >= 5) {
            const sectorResult = this.calculateCorrelation(group.sentiments, group.prices);
            results.push({
              sector,
              baseCorrelation: baseResult.correlation,
              sectorAdjustedCorrelation: sectorResult.correlation,
              sectorEffect: sectorResult.correlation - baseResult.correlation
            });
          }
        }
        return results.sort((a, b) => Math.abs(b.sectorEffect) - Math.abs(a.sectorEffect));
      }
      /**
       * Calculate market-cap adjusted correlations
       */
      calculateMarketCapAdjustedCorrelations(sentimentData, priceMovements, marketCapMap, timeframe = "5d") {
        const buckets = [
          { name: "mega", min: 200, max: Infinity },
          { name: "large", min: 10, max: 200 },
          { name: "mid", min: 2, max: 10 },
          { name: "small", min: 0.3, max: 2 },
          { name: "micro", min: 0, max: 0.3 }
        ];
        const bucketGroups = /* @__PURE__ */ new Map();
        for (const sentiment of sentimentData) {
          const marketCap = marketCapMap.get(sentiment.symbol) || 0;
          const bucket = buckets.find((b) => marketCap >= b.min && marketCap < b.max);
          const bucketName = bucket?.name || "unknown";
          const key = `${sentiment.symbol}-${sentiment.earningsDate}`;
          const priceMovement = priceMovements.get(key);
          if (priceMovement) {
            const movement = priceMovement.movements.find((m) => m.timeframe === timeframe);
            if (movement) {
              if (!bucketGroups.has(bucketName)) {
                bucketGroups.set(bucketName, { sentiments: [], prices: [] });
              }
              const group = bucketGroups.get(bucketName);
              group.sentiments.push(sentiment.sentiment.overall);
              group.prices.push(movement.percentChange);
            }
          }
        }
        const allSentiments = [];
        const allPrices = [];
        for (const group of Array.from(bucketGroups.values())) {
          allSentiments.push(...group.sentiments);
          allPrices.push(...group.prices);
        }
        const baseResult = this.calculateCorrelation(allSentiments, allPrices);
        const results = [];
        for (const [bucketName, group] of Array.from(bucketGroups.entries())) {
          if (group.sentiments.length >= 5 && bucketName !== "unknown") {
            const bucketResult = this.calculateCorrelation(group.sentiments, group.prices);
            results.push({
              marketCapBucket: bucketName,
              baseCorrelation: baseResult.correlation,
              adjustedCorrelation: bucketResult.correlation,
              sizeEffect: bucketResult.correlation - baseResult.correlation
            });
          }
        }
        return results;
      }
      /**
       * Calculate p-value from t-statistic
       */
      calculatePValue(tStat, df) {
        if (df > 30) {
          const z3 = Math.abs(tStat);
          return 2 * (1 - this.normalCDF(z3));
        }
        const x = df / (df + tStat * tStat);
        return this.incompleteBeta(df / 2, 0.5, x);
      }
      /**
       * Normal CDF approximation
       */
      normalCDF(x) {
        const a1 = 0.254829592;
        const a2 = -0.284496736;
        const a3 = 1.421413741;
        const a4 = -1.453152027;
        const a5 = 1.061405429;
        const p = 0.3275911;
        const sign = x < 0 ? -1 : 1;
        x = Math.abs(x) / Math.sqrt(2);
        const t2 = 1 / (1 + p * x);
        const y = 1 - ((((a5 * t2 + a4) * t2 + a3) * t2 + a2) * t2 + a1) * t2 * Math.exp(-x * x);
        return 0.5 * (1 + sign * y);
      }
      /**
       * Incomplete beta function approximation
       */
      incompleteBeta(a, b, x) {
        if (x === 0) return 0;
        if (x === 1) return 1;
        const bt = Math.exp(
          this.logGamma(a + b) - this.logGamma(a) - this.logGamma(b) + a * Math.log(x) + b * Math.log(1 - x)
        );
        if (x < (a + 1) / (a + b + 2)) {
          return bt * this.betaCF(a, b, x) / a;
        } else {
          return 1 - bt * this.betaCF(b, a, 1 - x) / b;
        }
      }
      /**
       * Log gamma function approximation
       */
      logGamma(x) {
        const c = [
          76.18009172947146,
          -86.50532032941678,
          24.01409824083091,
          -1.231739572450155,
          0.001208650973866179,
          -5395239384953e-18
        ];
        let y = x;
        let tmp = x + 5.5;
        tmp -= (x + 0.5) * Math.log(tmp);
        let ser = 1.000000000190015;
        for (let j = 0; j < 6; j++) {
          ser += c[j] / ++y;
        }
        return -tmp + Math.log(2.5066282746310007 * ser / x);
      }
      /**
       * Continued fraction for beta function
       */
      betaCF(a, b, x) {
        const maxIterations = 100;
        const eps = 3e-7;
        let qab = a + b;
        let qap = a + 1;
        let qam = a - 1;
        let c = 1;
        let d = 1 - qab * x / qap;
        if (Math.abs(d) < 1e-30) d = 1e-30;
        d = 1 / d;
        let h = d;
        for (let m = 1; m <= maxIterations; m++) {
          const m2 = 2 * m;
          let aa = m * (b - m) * x / ((qam + m2) * (a + m2));
          d = 1 + aa * d;
          if (Math.abs(d) < 1e-30) d = 1e-30;
          c = 1 + aa / c;
          if (Math.abs(c) < 1e-30) c = 1e-30;
          d = 1 / d;
          h *= d * c;
          aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
          d = 1 + aa * d;
          if (Math.abs(d) < 1e-30) d = 1e-30;
          c = 1 + aa / c;
          if (Math.abs(c) < 1e-30) c = 1e-30;
          d = 1 / d;
          const del = d * c;
          h *= del;
          if (Math.abs(del - 1) < eps) break;
        }
        return h;
      }
      /**
       * Calculate confidence interval for correlation
       */
      calculateConfidenceInterval(correlation2, n, confidence = 0.95) {
        const z3 = 0.5 * Math.log((1 + correlation2) / (1 - correlation2));
        const se = 1 / Math.sqrt(n - 3);
        const zScore = confidence === 0.95 ? 1.96 : confidence === 0.99 ? 2.576 : 1.645;
        const zLower = z3 - zScore * se;
        const zUpper = z3 + zScore * se;
        const lower = (Math.exp(2 * zLower) - 1) / (Math.exp(2 * zLower) + 1);
        const upper = (Math.exp(2 * zUpper) - 1) / (Math.exp(2 * zUpper) + 1);
        return [
          isNaN(lower) ? -1 : Math.max(-1, lower),
          isNaN(upper) ? 1 : Math.min(1, upper)
        ];
      }
      /**
       * Determine significance level
       */
      determineSignificance(pValue, absCorrelation) {
        if (pValue < 0.01 && absCorrelation > 0.5) return "high";
        if (pValue < 0.05 && absCorrelation > 0.3) return "medium";
        if (pValue < 0.1 && absCorrelation > 0.2) return "low";
        return "none";
      }
      /**
       * Get empty correlation result
       */
      getEmptyCorrelationResult(factor, timeframe) {
        return {
          factor,
          timeframe,
          correlation: 0,
          pValue: 1,
          confidenceInterval: [-1, 1],
          sampleSize: 0,
          rSquared: 0,
          significance: "none"
        };
      }
      /**
       * Clear correlation cache
       */
      clearCache() {
        this.correlationCache.clear();
        this.dataPoints = [];
      }
      /**
       * Get all data points
       */
      getDataPoints() {
        return this.dataPoints;
      }
    };
  }
});

// server/services/backtesting/EarningsSentimentBacktester.ts
var EarningsSentimentBacktester_exports = {};
__export(EarningsSentimentBacktester_exports, {
  EarningsSentimentBacktester: () => EarningsSentimentBacktester,
  createEarningsSentimentBacktester: () => createEarningsSentimentBacktester
});
function createEarningsSentimentBacktester(benchmarkSymbol) {
  return new EarningsSentimentBacktester(benchmarkSymbol);
}
var EarningsSentimentBacktester;
var init_EarningsSentimentBacktester = __esm({
  "server/services/backtesting/EarningsSentimentBacktester.ts"() {
    "use strict";
    init_HistoricalSentimentCollector();
    init_PostEarningsPriceAnalyzer();
    init_SentimentPriceCorrelation();
    EarningsSentimentBacktester = class {
      sentimentCollector;
      priceAnalyzer;
      correlationEngine;
      isRunning = false;
      progress = 0;
      constructor(benchmarkSymbol = "SPY") {
        this.sentimentCollector = createHistoricalSentimentCollector();
        this.priceAnalyzer = createPostEarningsPriceAnalyzer(benchmarkSymbol);
        this.correlationEngine = createSentimentPriceCorrelation();
      }
      /**
       * Run full backtest
       */
      async runBacktest(config) {
        this.isRunning = true;
        this.progress = 0;
        try {
          this.progress = 5;
          const sentimentData = await this.collectSentimentData(config);
          this.progress = 30;
          const priceMovements = await this.analyzePriceMovements(sentimentData);
          this.progress = 50;
          const correlationMatrix = this.correlationEngine.calculateCorrelationMatrix(
            sentimentData,
            priceMovements
          );
          this.progress = 70;
          const factorDecomposition = this.correlationEngine.decomposeByFactor(
            sentimentData,
            priceMovements,
            "5d"
          );
          this.progress = 80;
          const tradingSignals = this.analyzeTradingSignals(sentimentData, priceMovements);
          this.progress = 90;
          const statisticalTests = this.runStatisticalTests(sentimentData, priceMovements);
          const bestPredictors = this.findBestPredictors(correlationMatrix, sentimentData, priceMovements);
          const summary = this.generateSummary(config, sentimentData, correlationMatrix, tradingSignals);
          const recommendations = this.generateRecommendations(summary, correlationMatrix, tradingSignals);
          this.progress = 100;
          const rawData = {
            sentimentData,
            priceMovements: Array.from(priceMovements.entries()).map(([key, movement]) => ({ key, movement })),
            correlationResults: this.extractCorrelationResults(correlationMatrix)
          };
          return {
            config,
            summary,
            correlationMatrix,
            factorDecomposition,
            bestPredictors,
            tradingSignals,
            statisticalTests,
            recommendations,
            rawData
          };
        } finally {
          this.isRunning = false;
        }
      }
      /**
       * Collect historical sentiment data for all symbols
       */
      async collectSentimentData(config) {
        const allSentimentData = [];
        const startYear = new Date(config.startDate).getFullYear();
        const endYear = new Date(config.endDate).getFullYear();
        const years = endYear - startYear + 1;
        for (const symbol of config.symbols) {
          try {
            const transcripts = await this.sentimentCollector.fetchHistoricalTranscripts(
              symbol,
              years
            );
            for (const transcript of transcripts) {
              const transcriptDate = new Date(transcript.date);
              if (transcriptDate >= new Date(config.startDate) && transcriptDate <= new Date(config.endDate)) {
                const sentiment = await this.sentimentCollector.analyzeSentiment(transcript);
                allSentimentData.push({
                  symbol: transcript.symbol,
                  earningsDate: transcript.date,
                  fiscalYear: transcript.fiscalYear,
                  fiscalQuarter: transcript.fiscalQuarter,
                  sentiment,
                  processedAt: Date.now()
                });
              }
            }
          } catch (error) {
            console.error(`[Backtester] Error collecting sentiment for ${symbol}:`, error);
          }
        }
        return allSentimentData;
      }
      /**
       * Analyze price movements for all sentiment data
       */
      async analyzePriceMovements(sentimentData) {
        const events = sentimentData.map((s) => ({
          symbol: s.symbol,
          earningsDate: s.earningsDate
        }));
        return this.priceAnalyzer.batchAnalyze(events);
      }
      /**
       * Analyze trading signals based on sentiment thresholds
       */
      analyzeTradingSignals(sentimentData, priceMovements) {
        const signals = [];
        const returns = [];
        const bullishThreshold = 0.6;
        const bearishThreshold = 0.4;
        for (const sentiment of sentimentData) {
          const key = `${sentiment.symbol}-${sentiment.earningsDate}`;
          const priceMovement = priceMovements.get(key);
          if (priceMovement) {
            const movement5d = priceMovement.movements.find((m) => m.timeframe === "5d");
            if (movement5d) {
              const sentimentScore = sentiment.sentiment.overall;
              const actualReturn = movement5d.percentChange;
              returns.push(actualReturn);
              let signal;
              if (sentimentScore >= bullishThreshold) {
                signal = "bullish";
              } else if (sentimentScore <= bearishThreshold) {
                signal = "bearish";
              } else {
                signal = "neutral";
              }
              const correct = signal === "bullish" && actualReturn > 0 || signal === "bearish" && actualReturn < 0 || signal === "neutral";
              signals.push({
                signal,
                sentimentThreshold: sentimentScore,
                actualReturn,
                correct
              });
            }
          }
        }
        const bullishSignals = signals.filter((s) => s.signal === "bullish");
        const bearishSignals = signals.filter((s) => s.signal === "bearish");
        const neutralSignals = signals.filter((s) => s.signal === "neutral");
        const bullishAccuracy = bullishSignals.length > 0 ? bullishSignals.filter((s) => s.correct).length / bullishSignals.length : 0;
        const bearishAccuracy = bearishSignals.length > 0 ? bearishSignals.filter((s) => s.correct).length / bearishSignals.length : 0;
        const winningTrades = signals.filter((s) => s.correct && s.signal !== "neutral");
        const losingTrades = signals.filter((s) => !s.correct && s.signal !== "neutral");
        const winRate = winningTrades.length + losingTrades.length > 0 ? winningTrades.length / (winningTrades.length + losingTrades.length) : 0;
        const averageReturn = returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0;
        const grossProfit = returns.filter((r) => r > 0).reduce((a, b) => a + b, 0);
        const grossLoss = Math.abs(returns.filter((r) => r < 0).reduce((a, b) => a + b, 0));
        const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? Infinity : 0;
        let peak = 0;
        let maxDrawdown = 0;
        let cumulative = 0;
        for (const ret of returns) {
          cumulative += ret;
          if (cumulative > peak) peak = cumulative;
          const drawdown = (peak - cumulative) / Math.max(peak, 1);
          if (drawdown > maxDrawdown) maxDrawdown = drawdown;
        }
        const riskFreeRate = 0.02 / 252;
        const excessReturns = returns.map((r) => r / 100 - riskFreeRate);
        const meanExcess = excessReturns.reduce((a, b) => a + b, 0) / excessReturns.length;
        const stdDev = Math.sqrt(
          excessReturns.reduce((sum2, r) => sum2 + Math.pow(r - meanExcess, 2), 0) / excessReturns.length
        );
        const sharpeRatio = stdDev > 0 ? meanExcess / stdDev * Math.sqrt(252) : 0;
        return {
          totalSignals: signals.length,
          bullishSignals: bullishSignals.length,
          bearishSignals: bearishSignals.length,
          neutralSignals: neutralSignals.length,
          bullishAccuracy: bullishAccuracy * 100,
          bearishAccuracy: bearishAccuracy * 100,
          averageReturn,
          winRate: winRate * 100,
          profitFactor,
          maxDrawdown: maxDrawdown * 100,
          sharpeRatio
        };
      }
      /**
       * Run statistical tests on the data
       */
      runStatisticalTests(sentimentData, priceMovements) {
        const returns = [];
        for (const sentiment of sentimentData) {
          const key = `${sentiment.symbol}-${sentiment.earningsDate}`;
          const priceMovement = priceMovements.get(key);
          if (priceMovement) {
            const movement = priceMovement.movements.find((m) => m.timeframe === "5d");
            if (movement) {
              returns.push(movement.percentChange);
            }
          }
        }
        return {
          normalityTest: this.jarqueBeraTest(returns),
          autocorrelationTest: this.ljungBoxTest(returns),
          heteroskedasticityTest: this.breuschPaganTest(returns),
          stationarityTest: this.augmentedDickeyFullerTest(returns)
        };
      }
      /**
       * Jarque-Bera normality test
       */
      jarqueBeraTest(data) {
        if (data.length < 4) {
          return { testName: "Jarque-Bera", statistic: 0, pValue: 1, isNormal: true };
        }
        const n = data.length;
        const mean5 = data.reduce((a, b) => a + b, 0) / n;
        let m2 = 0, m3 = 0, m4 = 0;
        for (const x of data) {
          const diff = x - mean5;
          m2 += diff * diff;
          m3 += diff * diff * diff;
          m4 += diff * diff * diff * diff;
        }
        m2 /= n;
        m3 /= n;
        m4 /= n;
        const skewness2 = m3 / Math.pow(m2, 1.5);
        const kurtosis2 = m4 / (m2 * m2) - 3;
        const jb = n / 6 * (skewness2 * skewness2 + kurtosis2 * kurtosis2 / 4);
        const pValue = Math.exp(-jb / 2);
        return {
          testName: "Jarque-Bera",
          statistic: jb,
          pValue,
          isNormal: pValue > 0.05
        };
      }
      /**
       * Ljung-Box autocorrelation test
       */
      ljungBoxTest(data, lags = 10) {
        if (data.length < lags + 1) {
          return { testName: "Ljung-Box", statistic: 0, pValue: 1, hasAutocorrelation: false };
        }
        const n = data.length;
        const mean5 = data.reduce((a, b) => a + b, 0) / n;
        let variance = 0;
        for (const x of data) {
          variance += (x - mean5) * (x - mean5);
        }
        variance /= n;
        let q = 0;
        for (let k = 1; k <= lags; k++) {
          let autocov = 0;
          for (let t2 = k; t2 < n; t2++) {
            autocov += (data[t2] - mean5) * (data[t2 - k] - mean5);
          }
          autocov /= n;
          const rho = autocov / variance;
          q += rho * rho / (n - k);
        }
        q *= n * (n + 2);
        const pValue = 1 - this.chiSquaredCDF(q, lags);
        return {
          testName: "Ljung-Box",
          statistic: q,
          pValue,
          hasAutocorrelation: pValue < 0.05
        };
      }
      /**
       * Breusch-Pagan heteroskedasticity test (simplified)
       */
      breuschPaganTest(data) {
        if (data.length < 10) {
          return { testName: "Breusch-Pagan", statistic: 0, pValue: 1, isHomoscedastic: true };
        }
        const mid = Math.floor(data.length / 2);
        const firstHalf = data.slice(0, mid);
        const secondHalf = data.slice(mid);
        const var1 = this.calculateVariance(firstHalf);
        const var2 = this.calculateVariance(secondHalf);
        const fStat = var1 > var2 ? var1 / var2 : var2 / var1;
        const df1 = mid - 1;
        const df2 = data.length - mid - 1;
        const pValue = 1 - this.fDistributionCDF(fStat, df1, df2);
        return {
          testName: "Breusch-Pagan",
          statistic: fStat,
          pValue,
          isHomoscedastic: pValue > 0.05
        };
      }
      /**
       * Augmented Dickey-Fuller stationarity test (simplified)
       */
      augmentedDickeyFullerTest(data) {
        if (data.length < 20) {
          return { testName: "ADF", statistic: 0, pValue: 0.5, isStationary: true };
        }
        const diffs = [];
        for (let i = 1; i < data.length; i++) {
          diffs.push(data[i] - data[i - 1]);
        }
        const mean5 = diffs.reduce((a, b) => a + b, 0) / diffs.length;
        const variance = this.calculateVariance(diffs);
        const tStat = mean5 / Math.sqrt(variance / diffs.length);
        const criticalValue = -2.86;
        const isStationary = tStat < criticalValue;
        const pValue = isStationary ? 0.01 : 0.1;
        return {
          testName: "ADF",
          statistic: tStat,
          pValue,
          isStationary
        };
      }
      /**
       * Calculate variance
       */
      calculateVariance(data) {
        if (data.length < 2) return 0;
        const mean5 = data.reduce((a, b) => a + b, 0) / data.length;
        return data.reduce((sum2, x) => sum2 + Math.pow(x - mean5, 2), 0) / (data.length - 1);
      }
      /**
       * Chi-squared CDF approximation
       */
      chiSquaredCDF(x, df) {
        if (x <= 0) return 0;
        return this.gammaCDF(x / 2, df / 2);
      }
      /**
       * Gamma CDF approximation
       */
      gammaCDF(x, a) {
        if (x <= 0) return 0;
        if (a <= 0) return 1;
        const iterations = 100;
        let sum2 = 0;
        let term = 1 / a;
        sum2 = term;
        for (let n = 1; n < iterations; n++) {
          term *= x / (a + n);
          sum2 += term;
          if (Math.abs(term) < 1e-10) break;
        }
        return sum2 * Math.exp(-x + a * Math.log(x) - this.logGamma(a));
      }
      /**
       * F-distribution CDF approximation
       */
      fDistributionCDF(x, df1, df2) {
        if (x <= 0) return 0;
        const t2 = df1 * x / (df1 * x + df2);
        return this.incompleteBeta(df1 / 2, df2 / 2, t2);
      }
      /**
       * Incomplete beta function
       */
      incompleteBeta(a, b, x) {
        if (x === 0) return 0;
        if (x === 1) return 1;
        return 0.5;
      }
      /**
       * Log gamma function
       */
      logGamma(x) {
        const c = [
          76.18009172947146,
          -86.50532032941678,
          24.01409824083091,
          -1.231739572450155,
          0.001208650973866179,
          -5395239384953e-18
        ];
        let y = x;
        let tmp = x + 5.5;
        tmp -= (x + 0.5) * Math.log(tmp);
        let ser = 1.000000000190015;
        for (let j = 0; j < 6; j++) {
          ser += c[j] / ++y;
        }
        return -tmp + Math.log(2.5066282746310007 * ser / x);
      }
      /**
       * Find best predictors from correlation matrix
       */
      findBestPredictors(correlationMatrix, sentimentData, priceMovements) {
        const predictors = [];
        for (let i = 0; i < correlationMatrix.factors.length; i++) {
          for (let j = 0; j < correlationMatrix.timeframes.length; j++) {
            const correlation2 = correlationMatrix.correlations[i][j];
            const pValue = correlationMatrix.pValues[i][j];
            const accuracy = this.calculatePredictiveAccuracy(
              sentimentData,
              priceMovements,
              correlationMatrix.factors[i],
              correlationMatrix.timeframes[j]
            );
            const sharpeRatio = this.calculateFactorSharpeRatio(
              sentimentData,
              priceMovements,
              correlationMatrix.factors[i],
              correlationMatrix.timeframes[j]
            );
            predictors.push({
              factor: correlationMatrix.factors[i],
              timeframe: correlationMatrix.timeframes[j],
              correlation: correlation2,
              pValue,
              predictiveAccuracy: accuracy,
              sharpeRatio,
              rank: 0
            });
          }
        }
        predictors.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
        predictors.forEach((p, i) => p.rank = i + 1);
        return predictors.slice(0, 10);
      }
      /**
       * Calculate predictive accuracy for a factor/timeframe combination
       */
      calculatePredictiveAccuracy(sentimentData, priceMovements, factor, timeframe) {
        let correct = 0;
        let total = 0;
        for (const sentiment of sentimentData) {
          const key = `${sentiment.symbol}-${sentiment.earningsDate}`;
          const priceMovement = priceMovements.get(key);
          if (priceMovement) {
            const movement = priceMovement.movements.find((m) => m.timeframe === timeframe);
            if (movement) {
              const sentimentScore = this.extractFactorScore(sentiment, factor);
              const predictedDirection = sentimentScore > 0.5 ? 1 : -1;
              const actualDirection = movement.percentChange > 0 ? 1 : -1;
              if (predictedDirection === actualDirection) correct++;
              total++;
            }
          }
        }
        return total > 0 ? correct / total * 100 : 50;
      }
      /**
       * Calculate Sharpe ratio for a factor/timeframe combination
       */
      calculateFactorSharpeRatio(sentimentData, priceMovements, factor, timeframe) {
        const returns = [];
        for (const sentiment of sentimentData) {
          const key = `${sentiment.symbol}-${sentiment.earningsDate}`;
          const priceMovement = priceMovements.get(key);
          if (priceMovement) {
            const movement = priceMovement.movements.find((m) => m.timeframe === timeframe);
            if (movement) {
              const sentimentScore = this.extractFactorScore(sentiment, factor);
              const position = sentimentScore > 0.5 ? 1 : -1;
              returns.push(position * movement.percentChange);
            }
          }
        }
        if (returns.length < 2) return 0;
        const mean5 = returns.reduce((a, b) => a + b, 0) / returns.length;
        const variance = returns.reduce((sum2, r) => sum2 + Math.pow(r - mean5, 2), 0) / returns.length;
        const stdDev = Math.sqrt(variance);
        return stdDev > 0 ? mean5 / stdDev * Math.sqrt(252 / 5) : 0;
      }
      /**
       * Extract factor score from sentiment data
       */
      extractFactorScore(sentiment, factor) {
        switch (factor) {
          case "overall":
            return sentiment.sentiment.overall;
          case "managementOptimism":
            return sentiment.sentiment.managementTone.optimism;
          case "managementConfidence":
            return sentiment.sentiment.managementTone.confidence;
          case "analystSatisfaction":
            return sentiment.sentiment.analystReaction.satisfaction;
          case "guidanceStrength":
            return sentiment.sentiment.guidanceSignal.strength;
          default:
            return sentiment.sentiment.overall;
        }
      }
      /**
       * Generate backtest summary
       */
      generateSummary(config, sentimentData, correlationMatrix, tradingSignals) {
        let bestCorrelation = 0;
        let bestTimeframe = "";
        let bestFactor = "";
        for (let i = 0; i < correlationMatrix.factors.length; i++) {
          for (let j = 0; j < correlationMatrix.timeframes.length; j++) {
            if (Math.abs(correlationMatrix.correlations[i][j]) > Math.abs(bestCorrelation)) {
              bestCorrelation = correlationMatrix.correlations[i][j];
              bestFactor = correlationMatrix.factors[i];
              bestTimeframe = correlationMatrix.timeframes[j];
            }
          }
        }
        const overallIdx = correlationMatrix.factors.indexOf("overall");
        const timeframeIdx = correlationMatrix.timeframes.indexOf("5d");
        const overallCorrelation = overallIdx >= 0 && timeframeIdx >= 0 ? correlationMatrix.correlations[overallIdx][timeframeIdx] : 0;
        const overallPValue = overallIdx >= 0 && timeframeIdx >= 0 ? correlationMatrix.pValues[overallIdx][timeframeIdx] : 1;
        return {
          totalEarningsEvents: sentimentData.length,
          symbolsCovered: new Set(sentimentData.map((s) => s.symbol)).size,
          dateRange: { start: config.startDate, end: config.endDate },
          overallCorrelation,
          overallPValue,
          bestTimeframe,
          bestFactor,
          predictiveAccuracy: tradingSignals.winRate,
          profitFactor: tradingSignals.profitFactor
        };
      }
      /**
       * Generate recommendations based on backtest results
       */
      generateRecommendations(summary, correlationMatrix, tradingSignals) {
        const recommendations = [];
        if (summary.overallCorrelation > 0.3) {
          recommendations.push({
            type: "strategy",
            priority: "high",
            title: "Strong Sentiment-Price Correlation Detected",
            description: `The overall correlation of ${(summary.overallCorrelation * 100).toFixed(1)}% suggests sentiment analysis can be a valuable trading signal.`,
            expectedImpact: "Consider incorporating sentiment scores into your trading strategy with higher weight."
          });
        }
        if (tradingSignals.winRate > 55) {
          recommendations.push({
            type: "strategy",
            priority: "high",
            title: "Above-Average Win Rate",
            description: `The ${tradingSignals.winRate.toFixed(1)}% win rate exceeds random chance, indicating predictive value.`,
            expectedImpact: "Sentiment-based signals can improve trade selection accuracy."
          });
        }
        if (tradingSignals.maxDrawdown > 20) {
          recommendations.push({
            type: "risk",
            priority: "high",
            title: "High Maximum Drawdown",
            description: `The ${tradingSignals.maxDrawdown.toFixed(1)}% max drawdown suggests significant risk during adverse periods.`,
            expectedImpact: "Implement position sizing and stop-loss rules to manage downside risk."
          });
        }
        if (tradingSignals.sharpeRatio < 0.5) {
          recommendations.push({
            type: "risk",
            priority: "medium",
            title: "Low Risk-Adjusted Returns",
            description: `The Sharpe ratio of ${tradingSignals.sharpeRatio.toFixed(2)} indicates moderate risk-adjusted performance.`,
            expectedImpact: "Consider combining sentiment with other factors to improve risk-adjusted returns."
          });
        }
        if (summary.bestFactor !== "overall") {
          recommendations.push({
            type: "improvement",
            priority: "medium",
            title: `Best Predictor: ${summary.bestFactor}`,
            description: `The ${summary.bestFactor} factor shows stronger correlation than overall sentiment.`,
            expectedImpact: `Focus on ${summary.bestFactor} for improved prediction accuracy.`
          });
        }
        if (summary.bestTimeframe !== "5d") {
          recommendations.push({
            type: "improvement",
            priority: "medium",
            title: `Optimal Timeframe: ${summary.bestTimeframe}`,
            description: `The ${summary.bestTimeframe} timeframe shows the strongest sentiment-price relationship.`,
            expectedImpact: `Adjust holding period to ${summary.bestTimeframe} for better alignment with sentiment signals.`
          });
        }
        if (summary.totalEarningsEvents < 50) {
          recommendations.push({
            type: "caution",
            priority: "high",
            title: "Limited Sample Size",
            description: `Only ${summary.totalEarningsEvents} earnings events analyzed. Results may not be statistically robust.`,
            expectedImpact: "Expand the date range or symbol list for more reliable conclusions."
          });
        }
        if (summary.overallPValue > 0.1) {
          recommendations.push({
            type: "caution",
            priority: "medium",
            title: "Low Statistical Significance",
            description: `The p-value of ${summary.overallPValue.toFixed(3)} suggests the correlation may not be statistically significant.`,
            expectedImpact: "Use sentiment signals as one of multiple factors rather than the primary signal."
          });
        }
        return recommendations;
      }
      /**
       * Extract correlation results from matrix
       */
      extractCorrelationResults(matrix) {
        const results = [];
        for (let i = 0; i < matrix.factors.length; i++) {
          for (let j = 0; j < matrix.timeframes.length; j++) {
            results.push({
              factor: matrix.factors[i],
              timeframe: matrix.timeframes[j],
              correlation: matrix.correlations[i][j],
              pValue: matrix.pValues[i][j],
              confidenceInterval: [-1, 1],
              sampleSize: 0,
              rSquared: matrix.correlations[i][j] * matrix.correlations[i][j],
              significance: this.determineSignificance(matrix.pValues[i][j], Math.abs(matrix.correlations[i][j]))
            });
          }
        }
        return results;
      }
      /**
       * Determine significance level
       */
      determineSignificance(pValue, absCorrelation) {
        if (pValue < 0.01 && absCorrelation > 0.5) return "high";
        if (pValue < 0.05 && absCorrelation > 0.3) return "medium";
        if (pValue < 0.1 && absCorrelation > 0.2) return "low";
        return "none";
      }
      /**
       * Get current progress
       */
      getProgress() {
        return this.progress;
      }
      /**
       * Check if backtest is running
       */
      isBacktestRunning() {
        return this.isRunning;
      }
      /**
       * Cancel running backtest
       */
      cancelBacktest() {
        this.isRunning = false;
      }
    };
  }
});

// server/services/priceTrackingService.ts
var priceTrackingService_exports = {};
__export(priceTrackingService_exports, {
  calculatePredictionAccuracy: () => calculatePredictionAccuracy,
  createPriceTrackingForNewAnalyses: () => createPriceTrackingForNewAnalyses,
  createPriceTrackingRecord: () => createPriceTrackingRecord,
  getAccuracyStats: () => getAccuracyStats,
  runPriceTrackingJob: () => runPriceTrackingJob,
  updatePriceTrackingRecords: () => updatePriceTrackingRecords
});
import { eq as eq16, and as and16, isNull as isNull2, gte as gte6, sql as sql6, desc as desc13 } from "drizzle-orm";
async function fetchStockPrice2(symbol) {
  try {
    const response = await callDataApi("YahooFinance/get_stock_chart", {
      query: {
        symbol: symbol.toUpperCase(),
        region: "US",
        interval: "1d",
        range: "1d",
        includeAdjustedClose: true
      }
    });
    if (response?.chart?.result?.[0]?.meta?.regularMarketPrice) {
      return {
        symbol: symbol.toUpperCase(),
        price: response.chart.result[0].meta.regularMarketPrice,
        timestamp: /* @__PURE__ */ new Date()
      };
    }
    if (response?.chart?.result?.[0]?.indicators?.quote?.[0]?.close) {
      const closes = response.chart.result[0].indicators.quote[0].close;
      const lastClose = closes.filter((c) => c !== null).pop();
      if (lastClose) {
        return {
          symbol: symbol.toUpperCase(),
          price: lastClose,
          timestamp: /* @__PURE__ */ new Date()
        };
      }
    }
    console.warn(`[PriceTracking] No price data found for ${symbol}`);
    return null;
  } catch (error) {
    console.error(`[PriceTracking] Error fetching price for ${symbol}:`, error);
    return null;
  }
}
async function fetchMultipleStockPrices2(symbols) {
  const prices = /* @__PURE__ */ new Map();
  const batchSize = 5;
  for (let i = 0; i < symbols.length; i += batchSize) {
    const batch = symbols.slice(i, i + batchSize);
    await Promise.all(batch.map(async (symbol) => {
      const price = await fetchStockPrice2(symbol);
      if (price) {
        prices.set(symbol.toUpperCase(), price);
      }
    }));
    if (i + batchSize < symbols.length) {
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
  }
  return prices;
}
async function createPriceTrackingForNewAnalyses() {
  const db = await getDb();
  if (!db) return { success: false, tracked: 0, errors: 0, details: ["Database not available"] };
  const result = { success: true, tracked: 0, errors: 0, details: [] };
  try {
    const oneDayAgo = new Date(Date.now() - TRACKING_INTERVALS["24h"]);
    const newAnalyses = await db.select({
      id: agentAnalyses.id,
      symbol: agentAnalyses.symbol,
      consensusAction: agentAnalyses.consensusAction,
      confidence: agentAnalyses.confidence,
      createdAt: agentAnalyses.createdAt
    }).from(agentAnalyses).where(
      and16(
        gte6(agentAnalyses.createdAt, oneDayAgo),
        sql6`${agentAnalyses.id} NOT IN (SELECT analysisId FROM price_tracking)`
      )
    ).limit(100);
    if (newAnalyses.length === 0) {
      result.details.push("No new analyses to track");
      return result;
    }
    const symbols = Array.from(new Set(newAnalyses.map((a) => a.symbol)));
    const prices = await fetchMultipleStockPrices2(symbols);
    for (const analysis of newAnalyses) {
      const price = prices.get(analysis.symbol.toUpperCase());
      if (!price) {
        result.errors++;
        result.details.push(`No price data for ${analysis.symbol}`);
        continue;
      }
      try {
        await db.insert(priceTracking).values({
          analysisId: analysis.id,
          symbol: analysis.symbol.toUpperCase(),
          priceAtRecommendation: String(price.price),
          recommendedAction: analysis.consensusAction || "hold",
          confidence: analysis.confidence || "0.5",
          recommendedAt: analysis.createdAt
        });
        result.tracked++;
      } catch (error) {
        result.errors++;
        result.details.push(`Failed to create tracking for analysis ${analysis.id}: ${error}`);
      }
    }
    result.details.push(`Created ${result.tracked} new tracking records`);
    return result;
  } catch (error) {
    result.success = false;
    result.details.push(`Error: ${error}`);
    return result;
  }
}
async function updatePriceTrackingRecords() {
  const db = await getDb();
  if (!db) return { success: false, tracked: 0, errors: 0, details: ["Database not available"] };
  const result = { success: true, tracked: 0, errors: 0, details: [] };
  const now = /* @__PURE__ */ new Date();
  try {
    const trackingRecords = await db.select().from(priceTracking).where(
      sql6`(
          (price1Day IS NULL AND recommendedAt <= DATE_SUB(NOW(), INTERVAL 1 DAY)) OR
          (price3Day IS NULL AND recommendedAt <= DATE_SUB(NOW(), INTERVAL 3 DAY)) OR
          (price7Day IS NULL AND recommendedAt <= DATE_SUB(NOW(), INTERVAL 7 DAY)) OR
          (price14Day IS NULL AND recommendedAt <= DATE_SUB(NOW(), INTERVAL 14 DAY)) OR
          (price30Day IS NULL AND recommendedAt <= DATE_SUB(NOW(), INTERVAL 30 DAY))
        )`
    ).limit(200);
    if (trackingRecords.length === 0) {
      result.details.push("No tracking records need updates");
      return result;
    }
    const symbols = Array.from(new Set(trackingRecords.map((t2) => t2.symbol)));
    const prices = await fetchMultipleStockPrices2(symbols);
    for (const tracking of trackingRecords) {
      const price = prices.get(tracking.symbol.toUpperCase());
      if (!price) {
        result.errors++;
        continue;
      }
      const recommendedAt = new Date(tracking.recommendedAt);
      const timeSinceRecommendation = now.getTime() - recommendedAt.getTime();
      const originalPrice = Number(tracking.priceAtRecommendation);
      const currentPrice = price.price;
      const calculateReturn = (current, original) => {
        return (current - original) / original * 100;
      };
      const updates = {};
      if (!tracking.price1Day && timeSinceRecommendation >= TRACKING_INTERVALS["1d"]) {
        updates.price1Day = String(currentPrice);
        updates.return1Day = String(calculateReturn(currentPrice, originalPrice));
      }
      if (!tracking.price3Day && timeSinceRecommendation >= TRACKING_INTERVALS["3d"]) {
        updates.price3Day = String(currentPrice);
        updates.return3Day = String(calculateReturn(currentPrice, originalPrice));
      }
      if (!tracking.price7Day && timeSinceRecommendation >= TRACKING_INTERVALS["7d"]) {
        updates.price7Day = String(currentPrice);
        updates.return7Day = String(calculateReturn(currentPrice, originalPrice));
      }
      if (!tracking.price14Day && timeSinceRecommendation >= TRACKING_INTERVALS["14d"]) {
        updates.price14Day = String(currentPrice);
        updates.return14Day = String(calculateReturn(currentPrice, originalPrice));
      }
      if (!tracking.price30Day && timeSinceRecommendation >= TRACKING_INTERVALS["30d"]) {
        updates.price30Day = String(currentPrice);
        updates.return30Day = String(calculateReturn(currentPrice, originalPrice));
      }
      if (Object.keys(updates).length > 0) {
        try {
          const returnValue = calculateReturn(currentPrice, originalPrice);
          const action = tracking.recommendedAction;
          let isCorrect = false;
          if (action === "strong_buy" || action === "buy") {
            isCorrect = returnValue > 0;
          } else if (action === "strong_sell" || action === "sell") {
            isCorrect = returnValue < 0;
          } else {
            isCorrect = Math.abs(returnValue) <= 5;
          }
          await db.update(priceTracking).set({
            ...updates,
            wasAccurate1Day: updates.price1Day ? isCorrect : tracking.wasAccurate1Day,
            lastUpdatedAt: now
          }).where(eq16(priceTracking.id, tracking.id));
          result.tracked++;
        } catch (error) {
          result.errors++;
          result.details.push(`Failed to update tracking ${tracking.id}: ${error}`);
        }
      }
    }
    result.details.push(`Updated ${result.tracked} tracking records`);
    return result;
  } catch (error) {
    result.success = false;
    result.details.push(`Error: ${error}`);
    return result;
  }
}
async function calculatePredictionAccuracy() {
  const db = await getDb();
  if (!db) return { success: false, tracked: 0, errors: 0, details: ["Database not available"] };
  const result = { success: true, tracked: 0, errors: 0, details: [] };
  try {
    const completedTracking = await db.select().from(priceTracking).where(sql6`price1Day IS NOT NULL`).limit(1e3);
    if (completedTracking.length === 0) {
      result.details.push("No completed tracking records to analyze");
      return result;
    }
    const agentTypes = ["technical", "fundamental", "sentiment", "risk", "microstructure", "macro", "quant", "consensus"];
    for (const agentType of agentTypes) {
      const metrics = calculateMetricsForAgent(completedTracking, agentType);
      if (metrics.totalPredictions === 0) continue;
      try {
        const existingRecord = await db.select().from(predictionAccuracy).where(
          and16(
            eq16(predictionAccuracy.agentType, agentType),
            eq16(predictionAccuracy.timeframe, "1day"),
            isNull2(predictionAccuracy.symbol)
          )
        ).limit(1);
        if (existingRecord.length > 0) {
          await db.update(predictionAccuracy).set({
            totalPredictions: metrics.totalPredictions,
            correctPredictions: metrics.correctPredictions,
            accuracyRate: String(metrics.accuracyRate),
            avgConfidence: String(metrics.avgConfidence),
            avgReturn: String(metrics.avgReturn),
            buyAccuracy: String(metrics.buyAccuracy),
            sellAccuracy: String(metrics.sellAccuracy),
            holdAccuracy: String(metrics.holdAccuracy),
            periodEnd: /* @__PURE__ */ new Date()
          }).where(eq16(predictionAccuracy.id, existingRecord[0].id));
        } else {
          await db.insert(predictionAccuracy).values({
            agentType,
            timeframe: "1day",
            totalPredictions: metrics.totalPredictions,
            correctPredictions: metrics.correctPredictions,
            accuracyRate: String(metrics.accuracyRate),
            avgConfidence: String(metrics.avgConfidence),
            avgReturn: String(metrics.avgReturn),
            buyAccuracy: String(metrics.buyAccuracy),
            sellAccuracy: String(metrics.sellAccuracy),
            holdAccuracy: String(metrics.holdAccuracy),
            periodStart: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
            periodEnd: /* @__PURE__ */ new Date()
          });
        }
        result.tracked++;
      } catch (error) {
        result.errors++;
        result.details.push(`Failed to update accuracy for ${agentType}: ${error}`);
      }
    }
    result.details.push(`Updated accuracy metrics for ${result.tracked} agent types`);
    return result;
  } catch (error) {
    result.success = false;
    result.details.push(`Error: ${error}`);
    return result;
  }
}
function calculateMetricsForAgent(trackingRecords, agentType) {
  const records = trackingRecords.filter((t2) => t2.wasAccurate1Day !== null);
  if (records.length === 0) {
    return {
      totalPredictions: 0,
      correctPredictions: 0,
      accuracyRate: 0,
      avgConfidence: 0,
      avgReturn: 0,
      buyAccuracy: 0,
      sellAccuracy: 0,
      holdAccuracy: 0
    };
  }
  const totalPredictions = records.length;
  const correctPredictions = records.filter((r) => r.wasAccurate1Day).length;
  const accuracyRate = correctPredictions / totalPredictions;
  const avgConfidence = records.reduce((sum2, r) => sum2 + Number(r.confidence || 0), 0) / totalPredictions;
  const avgReturn = records.reduce((sum2, r) => sum2 + Number(r.return1Day || 0), 0) / totalPredictions;
  const buyRecords = records.filter((r) => r.recommendedAction === "buy" || r.recommendedAction === "strong_buy");
  const sellRecords = records.filter((r) => r.recommendedAction === "sell" || r.recommendedAction === "strong_sell");
  const holdRecords = records.filter((r) => r.recommendedAction === "hold");
  const buyAccuracy = buyRecords.length > 0 ? buyRecords.filter((r) => r.wasAccurate1Day).length / buyRecords.length : 0;
  const sellAccuracy = sellRecords.length > 0 ? sellRecords.filter((r) => r.wasAccurate1Day).length / sellRecords.length : 0;
  const holdAccuracy = holdRecords.length > 0 ? holdRecords.filter((r) => r.wasAccurate1Day).length / holdRecords.length : 0;
  return {
    totalPredictions,
    correctPredictions,
    accuracyRate,
    avgConfidence,
    avgReturn,
    buyAccuracy,
    sellAccuracy,
    holdAccuracy
  };
}
async function runPriceTrackingJob() {
  console.log("[PriceTracking] Starting price tracking job...");
  const results = {
    success: true,
    tracked: 0,
    errors: 0,
    details: []
  };
  const createResult = await createPriceTrackingForNewAnalyses();
  results.tracked += createResult.tracked;
  results.errors += createResult.errors;
  results.details.push(...createResult.details.map((d) => `[Create] ${d}`));
  if (!createResult.success) results.success = false;
  const updateResult = await updatePriceTrackingRecords();
  results.tracked += updateResult.tracked;
  results.errors += updateResult.errors;
  results.details.push(...updateResult.details.map((d) => `[Update] ${d}`));
  if (!updateResult.success) results.success = false;
  const accuracyResult = await calculatePredictionAccuracy();
  results.tracked += accuracyResult.tracked;
  results.errors += accuracyResult.errors;
  results.details.push(...accuracyResult.details.map((d) => `[Accuracy] ${d}`));
  if (!accuracyResult.success) results.success = false;
  console.log(`[PriceTracking] Job completed: ${results.tracked} tracked, ${results.errors} errors`);
  return results;
}
async function getAccuracyStats(symbol) {
  const db = await getDb();
  if (!db) return null;
  try {
    const records = await db.select().from(predictionAccuracy).where(
      symbol ? eq16(predictionAccuracy.symbol, symbol.toUpperCase()) : isNull2(predictionAccuracy.symbol)
    ).orderBy(desc13(predictionAccuracy.periodEnd)).limit(1);
    if (records.length === 0) return null;
    const record = records[0];
    return {
      totalPredictions: record.totalPredictions,
      correctPredictions: record.correctPredictions,
      accuracyRate: Number(record.accuracyRate || 0),
      avgConfidence: Number(record.avgConfidence || 0),
      avgReturn: Number(record.avgReturn || 0),
      buyAccuracy: Number(record.buyAccuracy || 0),
      sellAccuracy: Number(record.sellAccuracy || 0),
      holdAccuracy: Number(record.holdAccuracy || 0)
    };
  } catch (error) {
    console.error("[PriceTracking] Error getting accuracy stats:", error);
    return null;
  }
}
var TRACKING_INTERVALS, createPriceTrackingRecord;
var init_priceTrackingService = __esm({
  "server/services/priceTrackingService.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_dataApi();
    TRACKING_INTERVALS = {
      "1h": 60 * 60 * 1e3,
      "4h": 4 * 60 * 60 * 1e3,
      "24h": 24 * 60 * 60 * 1e3,
      "1d": 24 * 60 * 60 * 1e3,
      "3d": 3 * 24 * 60 * 60 * 1e3,
      "7d": 7 * 24 * 60 * 60 * 1e3,
      "14d": 14 * 24 * 60 * 60 * 1e3,
      "30d": 30 * 24 * 60 * 60 * 1e3
    };
    createPriceTrackingRecord = createPriceTrackingForNewAnalyses;
  }
});

// server/_core/index.ts
import "dotenv/config";
import express2 from "express";
import { createServer } from "http";
import net from "net";
import { createExpressMiddleware } from "@trpc/server/adapters/express";

// shared/const.ts
var COOKIE_NAME = "app_session_id";
var ONE_YEAR_MS = 1e3 * 60 * 60 * 24 * 365;
var AXIOS_TIMEOUT_MS = 3e4;
var UNAUTHED_ERR_MSG = "Please login (10001)";
var NOT_ADMIN_ERR_MSG = "You do not have required permission (10002)";

// server/_core/oauth.ts
init_db();

// server/_core/cookies.ts
function isSecureRequest(req) {
  if (req.protocol === "https") return true;
  const forwardedProto = req.headers["x-forwarded-proto"];
  if (!forwardedProto) return false;
  const protoList = Array.isArray(forwardedProto) ? forwardedProto : forwardedProto.split(",");
  return protoList.some((proto) => proto.trim().toLowerCase() === "https");
}
function getSessionCookieOptions(req) {
  return {
    httpOnly: true,
    path: "/",
    sameSite: "none",
    secure: isSecureRequest(req)
  };
}

// shared/_core/errors.ts
var HttpError = class extends Error {
  constructor(statusCode, message) {
    super(message);
    this.statusCode = statusCode;
    this.name = "HttpError";
  }
};
var ForbiddenError = (msg) => new HttpError(403, msg);

// server/_core/sdk.ts
init_db();
init_env();
import axios from "axios";
import { parse as parseCookieHeader } from "cookie";
import { SignJWT, jwtVerify } from "jose";
var isNonEmptyString = (value) => typeof value === "string" && value.length > 0;
var EXCHANGE_TOKEN_PATH = `/webdev.v1.WebDevAuthPublicService/ExchangeToken`;
var GET_USER_INFO_PATH = `/webdev.v1.WebDevAuthPublicService/GetUserInfo`;
var GET_USER_INFO_WITH_JWT_PATH = `/webdev.v1.WebDevAuthPublicService/GetUserInfoWithJwt`;
var OAuthService = class {
  constructor(client) {
    this.client = client;
    console.log("[OAuth] Initialized with baseURL:", ENV.oAuthServerUrl);
    if (!ENV.oAuthServerUrl) {
      console.error(
        "[OAuth] ERROR: OAUTH_SERVER_URL is not configured! Set OAUTH_SERVER_URL environment variable."
      );
    }
  }
  decodeState(state) {
    const redirectUri = atob(state);
    return redirectUri;
  }
  async getTokenByCode(code, state) {
    const payload = {
      clientId: ENV.appId,
      grantType: "authorization_code",
      code,
      redirectUri: this.decodeState(state)
    };
    const { data } = await this.client.post(
      EXCHANGE_TOKEN_PATH,
      payload
    );
    return data;
  }
  async getUserInfoByToken(token) {
    const { data } = await this.client.post(
      GET_USER_INFO_PATH,
      {
        accessToken: token.accessToken
      }
    );
    return data;
  }
};
var createOAuthHttpClient = () => axios.create({
  baseURL: ENV.oAuthServerUrl,
  timeout: AXIOS_TIMEOUT_MS
});
var SDKServer = class {
  client;
  oauthService;
  constructor(client = createOAuthHttpClient()) {
    this.client = client;
    this.oauthService = new OAuthService(this.client);
  }
  deriveLoginMethod(platforms, fallback) {
    if (fallback && fallback.length > 0) return fallback;
    if (!Array.isArray(platforms) || platforms.length === 0) return null;
    const set = new Set(
      platforms.filter((p) => typeof p === "string")
    );
    if (set.has("REGISTERED_PLATFORM_EMAIL")) return "email";
    if (set.has("REGISTERED_PLATFORM_GOOGLE")) return "google";
    if (set.has("REGISTERED_PLATFORM_APPLE")) return "apple";
    if (set.has("REGISTERED_PLATFORM_MICROSOFT") || set.has("REGISTERED_PLATFORM_AZURE"))
      return "microsoft";
    if (set.has("REGISTERED_PLATFORM_GITHUB")) return "github";
    const first = Array.from(set)[0];
    return first ? first.toLowerCase() : null;
  }
  /**
   * Exchange OAuth authorization code for access token
   * @example
   * const tokenResponse = await sdk.exchangeCodeForToken(code, state);
   */
  async exchangeCodeForToken(code, state) {
    return this.oauthService.getTokenByCode(code, state);
  }
  /**
   * Get user information using access token
   * @example
   * const userInfo = await sdk.getUserInfo(tokenResponse.accessToken);
   */
  async getUserInfo(accessToken) {
    const data = await this.oauthService.getUserInfoByToken({
      accessToken
    });
    const loginMethod = this.deriveLoginMethod(
      data?.platforms,
      data?.platform ?? data.platform ?? null
    );
    return {
      ...data,
      platform: loginMethod,
      loginMethod
    };
  }
  parseCookies(cookieHeader) {
    if (!cookieHeader) {
      return /* @__PURE__ */ new Map();
    }
    const parsed = parseCookieHeader(cookieHeader);
    return new Map(Object.entries(parsed));
  }
  getSessionSecret() {
    const secret = ENV.cookieSecret;
    return new TextEncoder().encode(secret);
  }
  /**
   * Create a session token for a Manus user openId
   * @example
   * const sessionToken = await sdk.createSessionToken(userInfo.openId);
   */
  async createSessionToken(openId, options = {}) {
    return this.signSession(
      {
        openId,
        appId: ENV.appId,
        name: options.name || ""
      },
      options
    );
  }
  async signSession(payload, options = {}) {
    const issuedAt = Date.now();
    const expiresInMs = options.expiresInMs ?? ONE_YEAR_MS;
    const expirationSeconds = Math.floor((issuedAt + expiresInMs) / 1e3);
    const secretKey = this.getSessionSecret();
    return new SignJWT({
      openId: payload.openId,
      appId: payload.appId,
      name: payload.name
    }).setProtectedHeader({ alg: "HS256", typ: "JWT" }).setExpirationTime(expirationSeconds).sign(secretKey);
  }
  async verifySession(cookieValue) {
    if (!cookieValue) {
      console.warn("[Auth] Missing session cookie");
      return null;
    }
    try {
      const secretKey = this.getSessionSecret();
      const { payload } = await jwtVerify(cookieValue, secretKey, {
        algorithms: ["HS256"]
      });
      const { openId, appId, name } = payload;
      if (!isNonEmptyString(openId) || !isNonEmptyString(appId) || !isNonEmptyString(name)) {
        console.warn("[Auth] Session payload missing required fields");
        return null;
      }
      return {
        openId,
        appId,
        name
      };
    } catch (error) {
      console.warn("[Auth] Session verification failed", String(error));
      return null;
    }
  }
  async getUserInfoWithJwt(jwtToken) {
    const payload = {
      jwtToken,
      projectId: ENV.appId
    };
    const { data } = await this.client.post(
      GET_USER_INFO_WITH_JWT_PATH,
      payload
    );
    const loginMethod = this.deriveLoginMethod(
      data?.platforms,
      data?.platform ?? data.platform ?? null
    );
    return {
      ...data,
      platform: loginMethod,
      loginMethod
    };
  }
  async authenticateRequest(req) {
    const cookies = this.parseCookies(req.headers.cookie);
    const sessionCookie = cookies.get(COOKIE_NAME);
    const session = await this.verifySession(sessionCookie);
    if (!session) {
      throw ForbiddenError("Invalid session cookie");
    }
    const sessionUserId = session.openId;
    const signedInAt = /* @__PURE__ */ new Date();
    let user = await getUserByOpenId(sessionUserId);
    if (!user) {
      try {
        const userInfo = await this.getUserInfoWithJwt(sessionCookie ?? "");
        await upsertUser({
          openId: userInfo.openId,
          name: userInfo.name || null,
          email: userInfo.email ?? null,
          loginMethod: userInfo.loginMethod ?? userInfo.platform ?? null,
          lastSignedIn: signedInAt
        });
        user = await getUserByOpenId(userInfo.openId);
      } catch (error) {
        console.error("[Auth] Failed to sync user from OAuth:", error);
        throw ForbiddenError("Failed to sync user info");
      }
    }
    if (!user) {
      throw ForbiddenError("User not found");
    }
    await upsertUser({
      openId: user.openId,
      lastSignedIn: signedInAt
    });
    return user;
  }
};
var sdk = new SDKServer();

// server/_core/oauth.ts
function getQueryParam(req, key) {
  const value = req.query[key];
  return typeof value === "string" ? value : void 0;
}
function registerOAuthRoutes(app) {
  app.get("/api/oauth/callback", async (req, res) => {
    const code = getQueryParam(req, "code");
    const state = getQueryParam(req, "state");
    if (!code || !state) {
      res.status(400).json({ error: "code and state are required" });
      return;
    }
    try {
      const tokenResponse = await sdk.exchangeCodeForToken(code, state);
      const userInfo = await sdk.getUserInfo(tokenResponse.accessToken);
      if (!userInfo.openId) {
        res.status(400).json({ error: "openId missing from user info" });
        return;
      }
      await upsertUser({
        openId: userInfo.openId,
        name: userInfo.name || null,
        email: userInfo.email ?? null,
        loginMethod: userInfo.loginMethod ?? userInfo.platform ?? null,
        lastSignedIn: /* @__PURE__ */ new Date()
      });
      const sessionToken = await sdk.createSessionToken(userInfo.openId, {
        name: userInfo.name || "",
        expiresInMs: ONE_YEAR_MS
      });
      const cookieOptions = getSessionCookieOptions(req);
      res.cookie(COOKIE_NAME, sessionToken, { ...cookieOptions, maxAge: ONE_YEAR_MS });
      res.redirect(302, "/");
    } catch (error) {
      console.error("[OAuth] Callback failed", error);
      res.status(500).json({ error: "OAuth callback failed" });
    }
  });
}

// server/_core/systemRouter.ts
import { z } from "zod";

// server/_core/notification.ts
init_env();
import { TRPCError } from "@trpc/server";
var TITLE_MAX_LENGTH = 1200;
var CONTENT_MAX_LENGTH = 2e4;
var trimValue = (value) => value.trim();
var isNonEmptyString2 = (value) => typeof value === "string" && value.trim().length > 0;
var buildEndpointUrl = (baseUrl) => {
  const normalizedBase = baseUrl.endsWith("/") ? baseUrl : `${baseUrl}/`;
  return new URL(
    "webdevtoken.v1.WebDevService/SendNotification",
    normalizedBase
  ).toString();
};
var validatePayload = (input) => {
  if (!isNonEmptyString2(input.title)) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "Notification title is required."
    });
  }
  if (!isNonEmptyString2(input.content)) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "Notification content is required."
    });
  }
  const title = trimValue(input.title);
  const content = trimValue(input.content);
  if (title.length > TITLE_MAX_LENGTH) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: `Notification title must be at most ${TITLE_MAX_LENGTH} characters.`
    });
  }
  if (content.length > CONTENT_MAX_LENGTH) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: `Notification content must be at most ${CONTENT_MAX_LENGTH} characters.`
    });
  }
  return { title, content };
};
async function notifyOwner(payload) {
  const { title, content } = validatePayload(payload);
  if (!ENV.forgeApiUrl) {
    throw new TRPCError({
      code: "INTERNAL_SERVER_ERROR",
      message: "Notification service URL is not configured."
    });
  }
  if (!ENV.forgeApiKey) {
    throw new TRPCError({
      code: "INTERNAL_SERVER_ERROR",
      message: "Notification service API key is not configured."
    });
  }
  const endpoint = buildEndpointUrl(ENV.forgeApiUrl);
  try {
    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        accept: "application/json",
        authorization: `Bearer ${ENV.forgeApiKey}`,
        "content-type": "application/json",
        "connect-protocol-version": "1"
      },
      body: JSON.stringify({ title, content })
    });
    if (!response.ok) {
      const detail = await response.text().catch(() => "");
      console.warn(
        `[Notification] Failed to notify owner (${response.status} ${response.statusText})${detail ? `: ${detail}` : ""}`
      );
      return false;
    }
    return true;
  } catch (error) {
    console.warn("[Notification] Error calling notification service:", error);
    return false;
  }
}

// server/_core/trpc.ts
import { initTRPC, TRPCError as TRPCError2 } from "@trpc/server";
import superjson from "superjson";
var t = initTRPC.context().create({
  transformer: superjson
});
var router = t.router;
var publicProcedure = t.procedure;
var requireUser = t.middleware(async (opts) => {
  const { ctx, next } = opts;
  if (!ctx.user) {
    throw new TRPCError2({ code: "UNAUTHORIZED", message: UNAUTHED_ERR_MSG });
  }
  return next({
    ctx: {
      ...ctx,
      user: ctx.user
    }
  });
});
var protectedProcedure = t.procedure.use(requireUser);
var adminProcedure = t.procedure.use(
  t.middleware(async (opts) => {
    const { ctx, next } = opts;
    if (!ctx.user || ctx.user.role !== "admin") {
      throw new TRPCError2({ code: "FORBIDDEN", message: NOT_ADMIN_ERR_MSG });
    }
    return next({
      ctx: {
        ...ctx,
        user: ctx.user
      }
    });
  })
);

// server/services/alpacaWebSocket.ts
init_websocket();
import WebSocket2 from "ws";
var ALPACA_STREAM_URL = "wss://stream.data.alpaca.markets/v2/iex";
var ws = null;
var isConnected = false;
var isAuthenticated = false;
var reconnectAttempts = 0;
var reconnectTimeout = null;
var heartbeatInterval = null;
var subscribedSymbols = /* @__PURE__ */ new Set();
var MAX_RECONNECT_ATTEMPTS = 10;
var RECONNECT_DELAY_BASE = 1e3;
var RECONNECT_DELAY_MAX = 3e4;
var HEARTBEAT_INTERVAL = 3e4;
var lastPrices = /* @__PURE__ */ new Map();
var ALPACA_API_KEY = process.env.ALPACA_API_KEY || "";
var ALPACA_API_SECRET = process.env.ALPACA_API_SECRET || "";
function initializeAlpacaStream() {
  if (!ALPACA_API_KEY || !ALPACA_API_SECRET) {
    console.log("[AlpacaWS] API credentials not configured, skipping WebSocket initialization");
    return;
  }
  connect();
}
function connect() {
  if (ws && (ws.readyState === WebSocket2.OPEN || ws.readyState === WebSocket2.CONNECTING)) {
    console.log("[AlpacaWS] Already connected or connecting");
    return;
  }
  console.log("[AlpacaWS] Connecting to Alpaca streaming API...");
  ws = new WebSocket2(ALPACA_STREAM_URL);
  ws.on("open", () => {
    console.log("[AlpacaWS] WebSocket connection opened");
    isConnected = true;
    reconnectAttempts = 0;
    authenticate();
    startHeartbeat();
  });
  ws.on("message", (data) => {
    try {
      const messages = JSON.parse(data.toString());
      handleMessages(messages);
    } catch (error) {
      console.error("[AlpacaWS] Error parsing message:", error);
    }
  });
  ws.on("error", (error) => {
    console.error("[AlpacaWS] WebSocket error:", error.message);
  });
  ws.on("close", (code, reason) => {
    console.log(`[AlpacaWS] WebSocket closed: ${code} - ${reason.toString()}`);
    isConnected = false;
    isAuthenticated = false;
    stopHeartbeat();
    scheduleReconnect();
  });
}
function authenticate() {
  if (!ws || ws.readyState !== WebSocket2.OPEN) return;
  const authMessage = {
    action: "auth",
    key: ALPACA_API_KEY,
    secret: ALPACA_API_SECRET
  };
  ws.send(JSON.stringify(authMessage));
  console.log("[AlpacaWS] Sent authentication request");
}
function handleMessages(messages) {
  for (const msg of messages) {
    switch (msg.T) {
      case "success":
        if (msg.msg === "connected") {
          console.log("[AlpacaWS] Connected to Alpaca stream");
        } else if (msg.msg === "authenticated") {
          console.log("[AlpacaWS] Successfully authenticated");
          isAuthenticated = true;
          if (subscribedSymbols.size > 0) {
            subscribeToSymbols(Array.from(subscribedSymbols));
          }
          syncWithClientSubscriptions();
        }
        break;
      case "error":
        console.error(`[AlpacaWS] Error: ${msg.msg}`);
        if (msg.msg?.includes("auth")) {
          console.error("[AlpacaWS] Authentication failed - check API credentials");
        }
        break;
      case "subscription":
        console.log("[AlpacaWS] Subscription confirmed");
        break;
      case "t":
        handleTrade(msg);
        break;
      case "q":
        handleQuote(msg);
        break;
      case "b":
        handleBar(msg);
        break;
      default:
        break;
    }
  }
}
function handleTrade(msg) {
  if (!msg.S || !msg.p) return;
  const symbol = msg.S;
  const price = msg.p;
  const timestamp2 = msg.t ? new Date(msg.t).getTime() : Date.now();
  const lastPrice = lastPrices.get(symbol);
  let change = 0;
  let changePercent = 0;
  if (lastPrice) {
    change = price - lastPrice.price;
    changePercent = change / lastPrice.price * 100;
  }
  lastPrices.set(symbol, { price, timestamp: timestamp2 });
  const update = {
    symbol,
    price,
    change,
    changePercent,
    volume: msg.s || 0,
    timestamp: timestamp2
  };
  broadcastPriceUpdate(update);
}
function handleQuote(msg) {
  if (!msg.S) return;
  const symbol = msg.S;
  const bidPrice = msg.bp || 0;
  const askPrice = msg.ap || 0;
  const midPrice = (bidPrice + askPrice) / 2;
  const timestamp2 = msg.t ? new Date(msg.t).getTime() : Date.now();
  if (bidPrice > 0 && askPrice > 0) {
    const lastPrice = lastPrices.get(symbol);
    let change = 0;
    let changePercent = 0;
    if (lastPrice) {
      change = midPrice - lastPrice.price;
      changePercent = change / lastPrice.price * 100;
    }
    lastPrices.set(symbol, { price: midPrice, timestamp: timestamp2 });
    const update = {
      symbol,
      price: midPrice,
      change,
      changePercent,
      volume: 0,
      timestamp: timestamp2
    };
    broadcastPriceUpdate(update);
  }
}
function handleBar(msg) {
}
function subscribeToSymbols(symbols) {
  if (!ws || ws.readyState !== WebSocket2.OPEN || !isAuthenticated) {
    symbols.forEach((s) => subscribedSymbols.add(s.toUpperCase()));
    console.log(`[AlpacaWS] Queued subscription for: ${symbols.join(", ")}`);
    return;
  }
  const upperSymbols = symbols.map((s) => s.toUpperCase());
  upperSymbols.forEach((s) => subscribedSymbols.add(s));
  const subscribeMessage = {
    action: "subscribe",
    trades: upperSymbols,
    quotes: upperSymbols
  };
  ws.send(JSON.stringify(subscribeMessage));
  console.log(`[AlpacaWS] Subscribed to: ${upperSymbols.join(", ")}`);
}
function unsubscribeFromSymbols(symbols) {
  if (!ws || ws.readyState !== WebSocket2.OPEN) return;
  const upperSymbols = symbols.map((s) => s.toUpperCase());
  upperSymbols.forEach((s) => subscribedSymbols.delete(s));
  const unsubscribeMessage = {
    action: "unsubscribe",
    trades: upperSymbols,
    quotes: upperSymbols
  };
  ws.send(JSON.stringify(unsubscribeMessage));
  console.log(`[AlpacaWS] Unsubscribed from: ${upperSymbols.join(", ")}`);
}
function syncWithClientSubscriptions() {
  const activeSymbols = getActiveSymbolSubscriptions();
  if (activeSymbols.length > 0) {
    subscribeToSymbols(activeSymbols);
  }
}
function scheduleReconnect() {
  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
    console.error("[AlpacaWS] Max reconnection attempts reached");
    return;
  }
  const delay = Math.min(
    RECONNECT_DELAY_BASE * Math.pow(2, reconnectAttempts),
    RECONNECT_DELAY_MAX
  );
  reconnectAttempts++;
  console.log(`[AlpacaWS] Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
  reconnectTimeout = setTimeout(() => {
    connect();
  }, delay);
}
function startHeartbeat() {
  stopHeartbeat();
  heartbeatInterval = setInterval(() => {
    if (ws && ws.readyState === WebSocket2.OPEN) {
    }
  }, HEARTBEAT_INTERVAL);
}
function stopHeartbeat() {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
  }
}
function getAlpacaStreamStatus() {
  return {
    connected: isConnected,
    authenticated: isAuthenticated,
    subscribedSymbols: Array.from(subscribedSymbols),
    reconnectAttempts
  };
}
function disconnectAlpacaStream() {
  if (reconnectTimeout) {
    clearTimeout(reconnectTimeout);
    reconnectTimeout = null;
  }
  stopHeartbeat();
  if (ws) {
    ws.close();
    ws = null;
  }
  isConnected = false;
  isAuthenticated = false;
  subscribedSymbols.clear();
  console.log("[AlpacaWS] Disconnected from Alpaca stream");
}
function reconnectAlpacaStream() {
  disconnectAlpacaStream();
  reconnectAttempts = 0;
  connect();
}

// server/_core/systemRouter.ts
var systemRouter = router({
  health: publicProcedure.input(
    z.object({
      timestamp: z.number().min(0, "timestamp cannot be negative")
    })
  ).query(() => ({
    ok: true
  })),
  notifyOwner: adminProcedure.input(
    z.object({
      title: z.string().min(1, "title is required"),
      content: z.string().min(1, "content is required")
    })
  ).mutation(async ({ input }) => {
    const delivered = await notifyOwner(input);
    return {
      success: delivered
    };
  }),
  // Alpaca WebSocket stream status
  alpacaStreamStatus: publicProcedure.query(() => {
    return getAlpacaStreamStatus();
  }),
  // Subscribe to Alpaca stream symbols
  subscribeAlpacaSymbols: publicProcedure.input(z.object({
    symbols: z.array(z.string()).min(1)
  })).mutation(({ input }) => {
    subscribeToSymbols(input.symbols);
    return { success: true, symbols: input.symbols };
  }),
  // Unsubscribe from Alpaca stream symbols
  unsubscribeAlpacaSymbols: publicProcedure.input(z.object({
    symbols: z.array(z.string()).min(1)
  })).mutation(({ input }) => {
    unsubscribeFromSymbols(input.symbols);
    return { success: true, symbols: input.symbols };
  }),
  // Reconnect Alpaca stream
  reconnectAlpacaStream: adminProcedure.mutation(() => {
    reconnectAlpacaStream();
    return { success: true };
  })
});

// server/routers.ts
init_db();
import { TRPCError as TRPCError3 } from "@trpc/server";
import { z as z2 } from "zod";

// server/services/aiAgents.ts
init_llm();
init_dataApi();

// server/services/llmProvider.ts
init_env();
import { createCipheriv, createDecipheriv, randomBytes, scryptSync } from "crypto";
var ENCRYPTION_KEY = scryptSync(ENV.cookieSecret || "default-key", "salt", 32);
var IV_LENGTH = 16;
var llmPricing2 = {
  openai: {
    "gpt-4-turbo": { input: 1e3, output: 3e3 },
    "gpt-4o": { input: 250, output: 1e3 },
    "gpt-4o-mini": { input: 15, output: 60 },
    "o1-preview": { input: 1500, output: 6e3 },
    "o1-mini": { input: 300, output: 1200 }
  },
  deepseek: {
    "deepseek-reasoner": { input: 55, output: 219 },
    "deepseek-chat": { input: 14, output: 28 },
    "deepseek-coder": { input: 14, output: 28 }
  },
  claude: {
    "claude-sonnet-4-20250514": { input: 300, output: 1500 },
    "claude-3-5-sonnet-20241022": { input: 300, output: 1500 },
    "claude-3-5-haiku-20241022": { input: 100, output: 500 },
    "claude-3-opus-20240229": { input: 1500, output: 7500 }
  },
  gemini: {
    "gemini-2.0-flash": { input: 10, output: 40 },
    "gemini-1.5-pro": { input: 125, output: 500 },
    "gemini-1.5-flash": { input: 8, output: 30 }
  }
};
function calculateCost(provider, model, promptTokens, completionTokens) {
  const pricing = llmPricing2[provider]?.[model];
  if (!pricing) {
    return Math.ceil((promptTokens * 100 + completionTokens * 300) / 1e6);
  }
  const inputCost = promptTokens * pricing.input / 1e6;
  const outputCost = completionTokens * pricing.output / 1e6;
  return Math.ceil(inputCost + outputCost);
}
function estimateCost(provider, model, inputText, estimatedOutputTokens = 1e3) {
  const estimatedInputTokens = Math.ceil(inputText.length / 4);
  const costCents = calculateCost(provider, model, estimatedInputTokens, estimatedOutputTokens);
  return { estimatedCostCents: costCents, estimatedInputTokens };
}
function encryptApiKey(apiKey) {
  const iv = randomBytes(IV_LENGTH);
  const cipher = createCipheriv("aes-256-cbc", ENCRYPTION_KEY, iv);
  let encrypted = cipher.update(apiKey, "utf8", "hex");
  encrypted += cipher.final("hex");
  return iv.toString("hex") + ":" + encrypted;
}
function decryptApiKey(encryptedKey) {
  try {
    const [ivHex, encrypted] = encryptedKey.split(":");
    if (!ivHex || !encrypted) return "";
    const iv = Buffer.from(ivHex, "hex");
    const decipher = createDecipheriv("aes-256-cbc", ENCRYPTION_KEY, iv);
    let decrypted = decipher.update(encrypted, "hex", "utf8");
    decrypted += decipher.final("utf8");
    return decrypted;
  } catch {
    return "";
  }
}
function isRateLimitError(error) {
  const message = error.message.toLowerCase();
  return message.includes("rate limit") || message.includes("429") || message.includes("too many requests") || message.includes("quota exceeded");
}
function isProviderUnavailable(error) {
  const message = error.message.toLowerCase();
  return message.includes("503") || message.includes("502") || message.includes("500") || message.includes("service unavailable") || message.includes("internal server error") || message.includes("timeout");
}
async function callOpenAI(messages, config) {
  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${config.apiKey}`
    },
    body: JSON.stringify({
      model: config.model,
      messages,
      temperature: config.temperature ?? 0.7,
      max_tokens: config.maxTokens ?? 4096
    })
  });
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`OpenAI API error (${response.status}): ${error}`);
  }
  const data = await response.json();
  return {
    content: data.choices[0]?.message?.content || "",
    usage: {
      promptTokens: data.usage?.prompt_tokens || 0,
      completionTokens: data.usage?.completion_tokens || 0,
      totalTokens: data.usage?.total_tokens || 0
    },
    model: config.model,
    provider: "openai"
  };
}
async function callDeepSeek(messages, config) {
  const response = await fetch("https://api.deepseek.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${config.apiKey}`
    },
    body: JSON.stringify({
      model: config.model,
      messages,
      temperature: config.temperature ?? 0.7,
      max_tokens: config.maxTokens ?? 4096
    })
  });
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`DeepSeek API error (${response.status}): ${error}`);
  }
  const data = await response.json();
  return {
    content: data.choices[0]?.message?.content || "",
    usage: {
      promptTokens: data.usage?.prompt_tokens || 0,
      completionTokens: data.usage?.completion_tokens || 0,
      totalTokens: data.usage?.total_tokens || 0
    },
    model: config.model,
    provider: "deepseek"
  };
}
async function callClaude(messages, config) {
  const systemMessage = messages.find((m) => m.role === "system")?.content || "";
  const chatMessages = messages.filter((m) => m.role !== "system");
  const response = await fetch("https://api.anthropic.com/v1/messages", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": config.apiKey,
      "anthropic-version": "2023-06-01"
    },
    body: JSON.stringify({
      model: config.model,
      max_tokens: config.maxTokens ?? 4096,
      system: systemMessage,
      messages: chatMessages.map((m) => ({
        role: m.role,
        content: m.content
      }))
    })
  });
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Claude API error (${response.status}): ${error}`);
  }
  const data = await response.json();
  return {
    content: data.content[0]?.text || "",
    usage: {
      promptTokens: data.usage?.input_tokens || 0,
      completionTokens: data.usage?.output_tokens || 0,
      totalTokens: (data.usage?.input_tokens || 0) + (data.usage?.output_tokens || 0)
    },
    model: config.model,
    provider: "claude"
  };
}
async function callGemini(messages, config) {
  const systemInstruction = messages.find((m) => m.role === "system")?.content || "";
  const contents = messages.filter((m) => m.role !== "system").map((m) => ({
    role: m.role === "assistant" ? "model" : "user",
    parts: [{ text: m.content }]
  }));
  const response = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/${config.model}:generateContent?key=${config.apiKey}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        systemInstruction: systemInstruction ? { parts: [{ text: systemInstruction }] } : void 0,
        contents,
        generationConfig: {
          temperature: config.temperature ?? 0.7,
          maxOutputTokens: config.maxTokens ?? 4096
        }
      })
    }
  );
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Gemini API error (${response.status}): ${error}`);
  }
  const data = await response.json();
  return {
    content: data.candidates?.[0]?.content?.parts?.[0]?.text || "",
    usage: {
      promptTokens: data.usageMetadata?.promptTokenCount || 0,
      completionTokens: data.usageMetadata?.candidatesTokenCount || 0,
      totalTokens: data.usageMetadata?.totalTokenCount || 0
    },
    model: config.model,
    provider: "gemini"
  };
}
async function callProvider(messages, config) {
  const startTime = Date.now();
  let result;
  switch (config.provider) {
    case "openai":
      result = await callOpenAI(messages, config);
      break;
    case "deepseek":
      result = await callDeepSeek(messages, config);
      break;
    case "claude":
      result = await callClaude(messages, config);
      break;
    case "gemini":
      result = await callGemini(messages, config);
      break;
    default:
      throw new Error(`Unsupported LLM provider: ${config.provider}`);
  }
  const responseTimeMs = Date.now() - startTime;
  const costCents = calculateCost(
    config.provider,
    config.model,
    result.usage.promptTokens,
    result.usage.completionTokens
  );
  return {
    ...result,
    costCents,
    responseTimeMs
  };
}
async function invokeLlm(messages, config, fallbackConfig, availableKeys) {
  const originalProvider = config.provider;
  let lastError = null;
  try {
    return await callProvider(messages, config);
  } catch (error) {
    lastError = error;
    if (!fallbackConfig?.enabled || !availableKeys) {
      throw error;
    }
    const shouldFallback = isRateLimitError(lastError) || isProviderUnavailable(lastError);
    if (!shouldFallback) {
      throw error;
    }
  }
  const fallbackProviders = fallbackConfig.priority.filter(
    (p) => p !== originalProvider && availableKeys[p]
  );
  for (let retry = 0; retry < fallbackConfig.maxRetries && retry < fallbackProviders.length; retry++) {
    const fallbackProvider = fallbackProviders[retry];
    const fallbackKey = availableKeys[fallbackProvider];
    if (!fallbackKey) continue;
    if (fallbackConfig.retryDelayMs > 0) {
      await new Promise((resolve) => setTimeout(resolve, fallbackConfig.retryDelayMs));
    }
    try {
      const fallbackModel = getDefaultModel(fallbackProvider);
      const result = await callProvider(messages, {
        ...config,
        provider: fallbackProvider,
        apiKey: fallbackKey,
        model: fallbackModel
      });
      return {
        ...result,
        wasFallback: true,
        originalProvider,
        fallbackReason: lastError?.message || "Primary provider failed"
      };
    } catch (error) {
      lastError = error;
      continue;
    }
  }
  throw new Error(`All LLM providers failed. Last error: ${lastError?.message}`);
}
async function validateApiKey(provider, apiKey) {
  const startTime = Date.now();
  try {
    const testMessages = [
      { role: "user", content: "Say 'OK' if you can hear me." }
    ];
    const config = {
      provider,
      apiKey,
      model: getDefaultModel(provider),
      maxTokens: 10
    };
    await callProvider(testMessages, config);
    return {
      valid: true,
      responseTimeMs: Date.now() - startTime,
      modelsTested: [config.model]
    };
  } catch (error) {
    const err = error;
    let errorMessage = err.message;
    if (errorMessage.includes("401") || errorMessage.includes("invalid_api_key")) {
      errorMessage = "Invalid API key. Please check your key and try again.";
    } else if (errorMessage.includes("403")) {
      errorMessage = "API key does not have permission. Check your account settings.";
    } else if (errorMessage.includes("429")) {
      errorMessage = "Rate limit exceeded. Your key is valid but temporarily blocked.";
    } else if (errorMessage.includes("insufficient_quota")) {
      errorMessage = "Insufficient quota. Please add credits to your account.";
    }
    return {
      valid: false,
      error: errorMessage,
      responseTimeMs: Date.now() - startTime
    };
  }
}
function validateApiKeyFormat(provider, apiKey) {
  if (!apiKey || apiKey.trim().length === 0) {
    return { valid: false, error: "API key is required" };
  }
  switch (provider) {
    case "openai":
      if (!apiKey.startsWith("sk-")) {
        return { valid: false, error: "OpenAI API keys should start with 'sk-'" };
      }
      if (apiKey.length < 40) {
        return { valid: false, error: "OpenAI API key seems too short" };
      }
      break;
    case "deepseek":
      if (apiKey.length < 20) {
        return { valid: false, error: "DeepSeek API key seems too short" };
      }
      break;
    case "claude":
      if (!apiKey.startsWith("sk-ant-")) {
        return { valid: false, error: "Anthropic API keys should start with 'sk-ant-'" };
      }
      break;
    case "gemini":
      if (apiKey.length < 30) {
        return { valid: false, error: "Gemini API key seems too short" };
      }
      break;
  }
  return { valid: true };
}
function getDefaultModel(provider) {
  switch (provider) {
    case "openai":
      return "gpt-4-turbo";
    case "deepseek":
      return "deepseek-reasoner";
    case "claude":
      return "claude-sonnet-4-20250514";
    case "gemini":
      return "gemini-2.0-flash";
    default:
      return "gpt-4-turbo";
  }
}
function getAvailableModels(provider) {
  const models = {
    openai: [
      { id: "gpt-4-turbo", name: "GPT-4 Turbo", description: "Most capable model, best for complex analysis" },
      { id: "gpt-4o", name: "GPT-4o", description: "Optimized for speed and quality balance" },
      { id: "gpt-4o-mini", name: "GPT-4o Mini", description: "Fast and cost-effective" },
      { id: "o1-preview", name: "O1 Preview", description: "Advanced reasoning capabilities" },
      { id: "o1-mini", name: "O1 Mini", description: "Fast reasoning model" }
    ],
    deepseek: [
      { id: "deepseek-reasoner", name: "DeepSeek R1", description: "Advanced reasoning with chain-of-thought" },
      { id: "deepseek-chat", name: "DeepSeek Chat", description: "General purpose chat model" },
      { id: "deepseek-coder", name: "DeepSeek Coder", description: "Specialized for code analysis" }
    ],
    claude: [
      { id: "claude-sonnet-4-20250514", name: "Claude Sonnet 4", description: "Best balance of speed and intelligence" },
      { id: "claude-3-5-sonnet-20241022", name: "Claude 3.5 Sonnet", description: "Previous generation, very capable" },
      { id: "claude-3-5-haiku-20241022", name: "Claude 3.5 Haiku", description: "Fast and efficient" },
      { id: "claude-3-opus-20240229", name: "Claude 3 Opus", description: "Most powerful for complex tasks" }
    ],
    gemini: [
      { id: "gemini-2.0-flash", name: "Gemini 2.0 Flash", description: "Latest fast model with multimodal" },
      { id: "gemini-1.5-pro", name: "Gemini 1.5 Pro", description: "Advanced reasoning and long context" },
      { id: "gemini-1.5-flash", name: "Gemini 1.5 Flash", description: "Fast and efficient" }
    ]
  };
  return (models[provider] || []).map((model) => ({
    ...model,
    costPer1MTokens: llmPricing2[provider]?.[model.id]
  }));
}
var providerMetadata = {
  openai: {
    name: "OpenAI",
    description: "Industry-leading AI models including GPT-4 and O1 series",
    website: "https://platform.openai.com/api-keys",
    icon: "\u{1F916}"
  },
  deepseek: {
    name: "DeepSeek",
    description: "Advanced reasoning AI with DeepSeek R1 chain-of-thought",
    website: "https://platform.deepseek.com/api_keys",
    icon: "\u{1F52E}"
  },
  claude: {
    name: "Anthropic Claude",
    description: "Safe and helpful AI assistant with strong reasoning",
    website: "https://console.anthropic.com/settings/keys",
    icon: "\u{1F9E0}"
  },
  gemini: {
    name: "Google Gemini",
    description: "Google's multimodal AI with long context support",
    website: "https://aistudio.google.com/app/apikey",
    icon: "\u2728"
  }
};
function formatCost(costCents) {
  if (costCents < 1) {
    return "< $0.01";
  }
  return `$${(costCents / 100).toFixed(2)}`;
}
function formatTokens(tokens) {
  if (tokens >= 1e6) {
    return `${(tokens / 1e6).toFixed(2)}M`;
  }
  if (tokens >= 1e3) {
    return `${(tokens / 1e3).toFixed(1)}K`;
  }
  return tokens.toString();
}

// server/services/aiAgents.ts
init_db();
async function getUserLlmConfig(userId) {
  try {
    const settings = await getUserLlmSettings(userId);
    if (!settings) return null;
    const provider = settings.activeProvider;
    let encryptedKey = null;
    switch (provider) {
      case "openai":
        encryptedKey = settings.openaiApiKey;
        break;
      case "deepseek":
        encryptedKey = settings.deepseekApiKey;
        break;
      case "claude":
        encryptedKey = settings.claudeApiKey;
        break;
      case "gemini":
        encryptedKey = settings.geminiApiKey;
        break;
    }
    if (!encryptedKey) return null;
    const apiKey = decryptApiKey(encryptedKey);
    if (!apiKey) return null;
    let model;
    switch (provider) {
      case "openai":
        model = settings.openaiModel || "gpt-4-turbo";
        break;
      case "deepseek":
        model = settings.deepseekModel || "deepseek-reasoner";
        break;
      case "claude":
        model = settings.claudeModel || "claude-sonnet-4-20250514";
        break;
      case "gemini":
        model = settings.geminiModel || "gemini-2.0-flash";
        break;
    }
    return {
      provider,
      apiKey,
      model,
      temperature: parseFloat(settings.temperature || "0.7"),
      maxTokens: settings.maxTokens || 4096
    };
  } catch (error) {
    console.error("Error getting user LLM config:", error);
    return null;
  }
}
async function invokeUserLlm(userId, messages, jsonSchema) {
  const userConfig = await getUserLlmConfig(userId);
  if (userConfig) {
    try {
      const response2 = await invokeLlm(messages, {
        provider: userConfig.provider,
        apiKey: userConfig.apiKey,
        model: userConfig.model,
        temperature: userConfig.temperature,
        maxTokens: userConfig.maxTokens
      });
      if (response2.usage) {
        await updateLlmUsage(userId, response2.usage.totalTokens);
      }
      return {
        content: response2.content,
        provider: userConfig.provider,
        model: userConfig.model
      };
    } catch (error) {
      console.error(`User LLM (${userConfig.provider}) failed, falling back to built-in:`, error);
    }
  }
  const response = await invokeLLM({
    messages: messages.map((m) => ({ role: m.role, content: m.content })),
    response_format: jsonSchema ? {
      type: "json_schema",
      json_schema: jsonSchema
    } : void 0
  });
  const content = response.choices[0]?.message?.content;
  return {
    content: typeof content === "string" ? content : JSON.stringify(content),
    provider: "built-in",
    model: "default"
  };
}
async function getMarketData(symbol) {
  try {
    const response = await callDataApi("YahooFinance/get_stock_chart", {
      query: {
        symbol,
        region: "US",
        interval: "1d",
        range: "3mo",
        includeAdjustedClose: true
      }
    });
    return response;
  } catch (error) {
    console.error(`Failed to fetch market data for ${symbol}:`, error);
    return null;
  }
}
async function getStockInsights(symbol) {
  try {
    const response = await callDataApi("YahooFinance/get_stock_insights", {
      query: { symbol }
    });
    return response;
  } catch (error) {
    console.error(`Failed to fetch insights for ${symbol}:`, error);
    return null;
  }
}
async function getStockHolders(symbol) {
  try {
    const response = await callDataApi("YahooFinance/get_stock_holders", {
      query: { symbol, region: "US", lang: "en-US" }
    });
    return response;
  } catch (error) {
    console.error(`Failed to fetch holders for ${symbol}:`, error);
    return null;
  }
}
function scoreToSignal(score) {
  if (score >= 0.6) return "strong_buy";
  if (score >= 0.2) return "buy";
  if (score >= -0.2) return "hold";
  if (score >= -0.6) return "sell";
  return "strong_sell";
}
function parseJsonResponse(content) {
  try {
    const jsonMatch = content.match(/```(?:json)?\s*([\s\S]*?)```/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[1].trim());
    }
    return JSON.parse(content);
  } catch {
    return null;
  }
}
async function runTechnicalAgent(userId, symbol, marketData) {
  const messages = [
    {
      role: "system",
      content: "You are a technical analysis expert. Analyze market data and provide trading signals. Always respond with valid JSON."
    },
    {
      role: "user",
      content: `Analyze the following market data for ${symbol} and provide a trading signal.

Market Data Summary:
${JSON.stringify(marketData?.chart?.result?.[0]?.meta || {}, null, 2)}

Consider: Price trends, moving averages, support/resistance, volume patterns, momentum indicators (RSI, MACD).

Respond in JSON format:
{
  "score": <number between -1 and 1>,
  "confidence": <number between 0 and 1>,
  "reasoning": "<brief explanation>",
  "keyFactors": ["<factor1>", "<factor2>", "<factor3>"]
}`
    }
  ];
  try {
    const response = await invokeUserLlm(userId, messages);
    const result = parseJsonResponse(response.content);
    if (!result) throw new Error("Failed to parse response");
    return {
      agent: "technical",
      score: Math.max(-1, Math.min(1, result.score || 0)),
      signal: scoreToSignal(result.score || 0),
      confidence: Math.max(0, Math.min(1, result.confidence || 0.5)),
      reasoning: result.reasoning || "Technical analysis completed",
      keyFactors: result.keyFactors || []
    };
  } catch (error) {
    console.error("Technical agent error:", error);
    return {
      agent: "technical",
      score: 0,
      signal: "hold",
      confidence: 0.3,
      reasoning: "Unable to complete technical analysis",
      keyFactors: []
    };
  }
}
async function runFundamentalAgent(userId, symbol, insights, holders) {
  const messages = [
    {
      role: "system",
      content: "You are a fundamental analysis expert. Analyze company fundamentals and provide trading signals. Always respond with valid JSON."
    },
    {
      role: "user",
      content: `Analyze the following data for ${symbol}.

Stock Insights:
${JSON.stringify(insights || {}, null, 2).slice(0, 2e3)}

Institutional Holders Summary:
${JSON.stringify(holders?.quoteSummary?.result?.[0]?.institutionOwnership || {}, null, 2).slice(0, 1e3)}

Consider: Valuation metrics (P/E, P/B, PEG), growth prospects, competitive position, institutional ownership, earnings quality.

Respond in JSON format:
{
  "score": <number between -1 and 1>,
  "confidence": <number between 0 and 1>,
  "reasoning": "<brief explanation>",
  "keyFactors": ["<factor1>", "<factor2>", "<factor3>"]
}`
    }
  ];
  try {
    const response = await invokeUserLlm(userId, messages);
    const result = parseJsonResponse(response.content);
    if (!result) throw new Error("Failed to parse response");
    return {
      agent: "fundamental",
      score: Math.max(-1, Math.min(1, result.score || 0)),
      signal: scoreToSignal(result.score || 0),
      confidence: Math.max(0, Math.min(1, result.confidence || 0.5)),
      reasoning: result.reasoning || "Fundamental analysis completed",
      keyFactors: result.keyFactors || []
    };
  } catch (error) {
    console.error("Fundamental agent error:", error);
    return {
      agent: "fundamental",
      score: 0,
      signal: "hold",
      confidence: 0.3,
      reasoning: "Unable to complete fundamental analysis",
      keyFactors: []
    };
  }
}
async function runSentimentAgent(userId, symbol, insights) {
  const messages = [
    {
      role: "system",
      content: "You are a sentiment analysis expert. Analyze market sentiment and provide trading signals. Always respond with valid JSON."
    },
    {
      role: "user",
      content: `Analyze market sentiment for ${symbol}.

Available Insights:
${JSON.stringify(insights || {}, null, 2).slice(0, 2e3)}

Consider: News sentiment, social media trends, analyst ratings, insider trading activity, options market sentiment.

Respond in JSON format:
{
  "score": <number between -1 and 1>,
  "confidence": <number between 0 and 1>,
  "reasoning": "<brief explanation>",
  "keyFactors": ["<factor1>", "<factor2>", "<factor3>"]
}`
    }
  ];
  try {
    const response = await invokeUserLlm(userId, messages);
    const result = parseJsonResponse(response.content);
    if (!result) throw new Error("Failed to parse response");
    return {
      agent: "sentiment",
      score: Math.max(-1, Math.min(1, result.score || 0)),
      signal: scoreToSignal(result.score || 0),
      confidence: Math.max(0, Math.min(1, result.confidence || 0.5)),
      reasoning: result.reasoning || "Sentiment analysis completed",
      keyFactors: result.keyFactors || []
    };
  } catch (error) {
    console.error("Sentiment agent error:", error);
    return {
      agent: "sentiment",
      score: 0,
      signal: "hold",
      confidence: 0.3,
      reasoning: "Unable to complete sentiment analysis",
      keyFactors: []
    };
  }
}
async function runRiskAgent(userId, symbol, marketData) {
  const messages = [
    {
      role: "system",
      content: "You are a risk management expert. Assess trading risks and provide risk-adjusted signals. Always respond with valid JSON."
    },
    {
      role: "user",
      content: `Assess the risk profile for trading ${symbol}.

Market Data:
${JSON.stringify(marketData?.chart?.result?.[0]?.meta || {}, null, 2)}

Consider: Volatility levels, liquidity risk, correlation with market, maximum drawdown potential, position sizing.

Respond in JSON format:
{
  "score": <number between -1 and 1, where negative means high risk>,
  "confidence": <number between 0 and 1>,
  "reasoning": "<brief explanation>",
  "keyFactors": ["<factor1>", "<factor2>", "<factor3>"]
}`
    }
  ];
  try {
    const response = await invokeUserLlm(userId, messages);
    const result = parseJsonResponse(response.content);
    if (!result) throw new Error("Failed to parse response");
    return {
      agent: "risk",
      score: Math.max(-1, Math.min(1, result.score || 0)),
      signal: scoreToSignal(result.score || 0),
      confidence: Math.max(0, Math.min(1, result.confidence || 0.5)),
      reasoning: result.reasoning || "Risk assessment completed",
      keyFactors: result.keyFactors || []
    };
  } catch (error) {
    console.error("Risk agent error:", error);
    return {
      agent: "risk",
      score: 0,
      signal: "hold",
      confidence: 0.3,
      reasoning: "Unable to complete risk assessment",
      keyFactors: []
    };
  }
}
async function runMicrostructureAgent(userId, symbol, marketData) {
  const messages = [
    {
      role: "system",
      content: "You are a market microstructure expert. Analyze order flow and market dynamics. Always respond with valid JSON."
    },
    {
      role: "user",
      content: `Analyze market microstructure for ${symbol}.

Market Data:
${JSON.stringify(marketData?.chart?.result?.[0]?.meta || {}, null, 2)}

Consider: Bid-ask spreads, order flow imbalances, market depth, trading volume patterns, price impact.

Respond in JSON format:
{
  "score": <number between -1 and 1>,
  "confidence": <number between 0 and 1>,
  "reasoning": "<brief explanation>",
  "keyFactors": ["<factor1>", "<factor2>", "<factor3>"]
}`
    }
  ];
  try {
    const response = await invokeUserLlm(userId, messages);
    const result = parseJsonResponse(response.content);
    if (!result) throw new Error("Failed to parse response");
    return {
      agent: "microstructure",
      score: Math.max(-1, Math.min(1, result.score || 0)),
      signal: scoreToSignal(result.score || 0),
      confidence: Math.max(0, Math.min(1, result.confidence || 0.5)),
      reasoning: result.reasoning || "Microstructure analysis completed",
      keyFactors: result.keyFactors || []
    };
  } catch (error) {
    console.error("Microstructure agent error:", error);
    return {
      agent: "microstructure",
      score: 0,
      signal: "hold",
      confidence: 0.3,
      reasoning: "Unable to complete microstructure analysis",
      keyFactors: []
    };
  }
}
async function runMacroAgent(userId, symbol, insights) {
  const messages = [
    {
      role: "system",
      content: "You are a macroeconomic analyst. Analyze macro factors affecting the stock. Always respond with valid JSON."
    },
    {
      role: "user",
      content: `Analyze macroeconomic factors for ${symbol}.

Stock Insights:
${JSON.stringify(insights || {}, null, 2).slice(0, 2e3)}

Consider: Interest rate environment, inflation trends, GDP growth, sector rotation, currency impacts, geopolitical factors.

Respond in JSON format:
{
  "score": <number between -1 and 1>,
  "confidence": <number between 0 and 1>,
  "reasoning": "<brief explanation>",
  "keyFactors": ["<factor1>", "<factor2>", "<factor3>"]
}`
    }
  ];
  try {
    const response = await invokeUserLlm(userId, messages);
    const result = parseJsonResponse(response.content);
    if (!result) throw new Error("Failed to parse response");
    return {
      agent: "macro",
      score: Math.max(-1, Math.min(1, result.score || 0)),
      signal: scoreToSignal(result.score || 0),
      confidence: Math.max(0, Math.min(1, result.confidence || 0.5)),
      reasoning: result.reasoning || "Macro analysis completed",
      keyFactors: result.keyFactors || []
    };
  } catch (error) {
    console.error("Macro agent error:", error);
    return {
      agent: "macro",
      score: 0,
      signal: "hold",
      confidence: 0.3,
      reasoning: "Unable to complete macro analysis",
      keyFactors: []
    };
  }
}
async function runQuantAgent(userId, symbol, marketData) {
  const messages = [
    {
      role: "system",
      content: "You are a quantitative analyst. Apply statistical and mathematical models. Always respond with valid JSON."
    },
    {
      role: "user",
      content: `Apply quantitative analysis for ${symbol}.

Market Data:
${JSON.stringify(marketData?.chart?.result?.[0]?.meta || {}, null, 2)}

Consider: Statistical arbitrage opportunities, mean reversion signals, momentum factors, volatility modeling, correlation analysis.

Respond in JSON format:
{
  "score": <number between -1 and 1>,
  "confidence": <number between 0 and 1>,
  "reasoning": "<brief explanation>",
  "keyFactors": ["<factor1>", "<factor2>", "<factor3>"]
}`
    }
  ];
  try {
    const response = await invokeUserLlm(userId, messages);
    const result = parseJsonResponse(response.content);
    if (!result) throw new Error("Failed to parse response");
    return {
      agent: "quant",
      score: Math.max(-1, Math.min(1, result.score || 0)),
      signal: scoreToSignal(result.score || 0),
      confidence: Math.max(0, Math.min(1, result.confidence || 0.5)),
      reasoning: result.reasoning || "Quantitative analysis completed",
      keyFactors: result.keyFactors || []
    };
  } catch (error) {
    console.error("Quant agent error:", error);
    return {
      agent: "quant",
      score: 0,
      signal: "hold",
      confidence: 0.3,
      reasoning: "Unable to complete quantitative analysis",
      keyFactors: []
    };
  }
}
function getAvailableAgents(tier) {
  const allAgents = ["technical", "fundamental", "sentiment", "risk", "microstructure", "macro", "quant"];
  switch (tier) {
    case "free":
      return ["technical", "sentiment"];
    case "starter":
      return ["technical", "fundamental", "sentiment", "risk"];
    case "pro":
    case "elite":
      return allAgents;
    default:
      return ["technical", "sentiment"];
  }
}
async function runAgentConsensus(userId, symbol, tier = "free") {
  console.log(`Running agent consensus for ${symbol} (user: ${userId}, tier: ${tier})`);
  const [marketData, insights, holders] = await Promise.all([
    getMarketData(symbol),
    getStockInsights(symbol),
    getStockHolders(symbol)
  ]);
  const availableAgents = getAvailableAgents(tier);
  const agentPromises = [];
  if (availableAgents.includes("technical")) {
    agentPromises.push(runTechnicalAgent(userId, symbol, marketData));
  }
  if (availableAgents.includes("fundamental")) {
    agentPromises.push(runFundamentalAgent(userId, symbol, insights, holders));
  }
  if (availableAgents.includes("sentiment")) {
    agentPromises.push(runSentimentAgent(userId, symbol, insights));
  }
  if (availableAgents.includes("risk")) {
    agentPromises.push(runRiskAgent(userId, symbol, marketData));
  }
  if (availableAgents.includes("microstructure")) {
    agentPromises.push(runMicrostructureAgent(userId, symbol, marketData));
  }
  if (availableAgents.includes("macro")) {
    agentPromises.push(runMacroAgent(userId, symbol, insights));
  }
  if (availableAgents.includes("quant")) {
    agentPromises.push(runQuantAgent(userId, symbol, marketData));
  }
  const agentResults = await Promise.all(agentPromises);
  const totalWeight = agentResults.reduce((sum2, r) => sum2 + r.confidence, 0);
  const weightedScore = agentResults.reduce((sum2, r) => sum2 + r.score * r.confidence, 0) / (totalWeight || 1);
  const avgConfidence = totalWeight / agentResults.length;
  const userConfig = await getUserLlmConfig(userId);
  const consensusSignal = scoreToSignal(weightedScore);
  let recommendation = "";
  let riskAssessment = "";
  switch (consensusSignal) {
    case "strong_buy":
      recommendation = `Strong bullish consensus on ${symbol}. Multiple agents indicate favorable conditions for entry.`;
      break;
    case "buy":
      recommendation = `Moderate bullish signal on ${symbol}. Consider gradual position building.`;
      break;
    case "hold":
      recommendation = `Neutral consensus on ${symbol}. Current conditions suggest maintaining existing positions.`;
      break;
    case "sell":
      recommendation = `Moderate bearish signal on ${symbol}. Consider reducing exposure.`;
      break;
    case "strong_sell":
      recommendation = `Strong bearish consensus on ${symbol}. Risk management suggests defensive positioning.`;
      break;
  }
  const riskAgent = agentResults.find((r) => r.agent === "risk");
  if (riskAgent) {
    riskAssessment = riskAgent.reasoning;
  } else {
    riskAssessment = "Risk assessment not available for current subscription tier.";
  }
  return {
    symbol,
    timestamp: /* @__PURE__ */ new Date(),
    agents: agentResults,
    consensusScore: weightedScore,
    consensusSignal,
    overallConfidence: avgConfidence,
    recommendation,
    riskAssessment,
    llmProvider: userConfig?.provider || "built-in",
    llmModel: userConfig?.model || "default"
  };
}

// server/services/commandcenter/CrossAgentSynthesis.ts
var CrossAgentSynthesisService = class {
  signals = /* @__PURE__ */ new Map();
  synthesisCache = null;
  lastSynthesisTime = null;
  CACHE_TTL_MS = 3e4;
  // 30 seconds
  // Agent weights for different market regimes
  agentWeights = {
    risk_on: {
      momentum: 0.25,
      technical: 0.2,
      sentiment: 0.2,
      fundamental: 0.15,
      macro: 0.1,
      risk: 0.1
    },
    risk_off: {
      risk: 0.3,
      macro: 0.25,
      fundamental: 0.2,
      technical: 0.15,
      sentiment: 0.05,
      momentum: 0.05
    },
    transition: {
      macro: 0.25,
      risk: 0.2,
      technical: 0.2,
      fundamental: 0.15,
      sentiment: 0.1,
      momentum: 0.1
    }
  };
  /**
   * Ingest a signal from any agent
   */
  ingestSignal(signal) {
    const key = `${signal.domain}_${signal.agentId}`;
    const existing = this.signals.get(key) || [];
    existing.unshift(signal);
    if (existing.length > 100) {
      existing.pop();
    }
    this.signals.set(key, existing);
    this.synthesisCache = null;
  }
  /**
   * Get all recent signals for an asset
   */
  getSignalsForAsset(asset) {
    const allSignals = [];
    for (const signals of Array.from(this.signals.values())) {
      for (const signal of signals) {
        const signalAsset = this.getAssetFromSignal(signal);
        if (signalAsset.toLowerCase() === asset.toLowerCase()) {
          allSignals.push(signal);
        }
      }
    }
    return allSignals.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
  }
  getAssetFromSignal(signal) {
    switch (signal.domain) {
      case "stock":
        return signal.symbol;
      case "crypto":
        return signal.token;
      case "sentiment":
        return signal.asset;
      case "options":
        return signal.underlying;
      case "macro":
        return "MACRO";
      default:
        return "UNKNOWN";
    }
  }
  /**
   * Synthesize all signals into unified intelligence
   */
  synthesize(forceRefresh = false) {
    if (!forceRefresh && this.synthesisCache && this.lastSynthesisTime) {
      const age = Date.now() - this.lastSynthesisTime.getTime();
      if (age < this.CACHE_TTL_MS) {
        return this.synthesisCache;
      }
    }
    const marketRegime = this.determineMarketRegime();
    const assetSignals = this.synthesizeAssetSignals(marketRegime.current);
    const correlations = this.calculateCorrelations();
    const riskAssessment = this.assessRisk(assetSignals, marketRegime);
    const opportunities = this.identifyOpportunities(assetSignals, correlations);
    const warnings = this.generateWarnings(assetSignals, riskAssessment);
    const recommendations = this.generateRecommendations(
      assetSignals,
      opportunities,
      warnings,
      marketRegime
    );
    const synthesis = {
      id: `synthesis_${Date.now()}`,
      timestamp: /* @__PURE__ */ new Date(),
      marketRegime,
      assetSignals,
      crossAssetCorrelations: correlations,
      riskAssessment,
      opportunities,
      warnings,
      recommendedActions: recommendations
    };
    this.synthesisCache = synthesis;
    this.lastSynthesisTime = /* @__PURE__ */ new Date();
    return synthesis;
  }
  /**
   * Determine current market regime from macro signals
   */
  determineMarketRegime() {
    const macroSignals = [];
    for (const signals of Array.from(this.signals.values())) {
      for (const signal of signals) {
        if (signal.domain === "macro") {
          macroSignals.push(signal);
        }
      }
    }
    if (macroSignals.length === 0) {
      return {
        current: "transition",
        confidence: 50,
        drivers: ["No macro data available"]
      };
    }
    const latest = macroSignals.sort(
      (a, b) => b.timestamp.getTime() - a.timestamp.getTime()
    )[0];
    const drivers = [];
    if (latest.vixLevel < 20) {
      drivers.push("Low VIX indicates calm markets");
    } else if (latest.vixLevel > 30) {
      drivers.push("Elevated VIX signals fear");
    }
    if (latest.fedSentiment > 0.3) {
      drivers.push("Hawkish Fed stance");
    } else if (latest.fedSentiment < -0.3) {
      drivers.push("Dovish Fed stance");
    }
    if (latest.yieldCurve === "inverted") {
      drivers.push("Inverted yield curve - recession signal");
    }
    return {
      current: latest.regime,
      confidence: 75,
      drivers
    };
  }
  /**
   * Synthesize signals for each asset
   */
  synthesizeAssetSignals(regime) {
    const assetMap = /* @__PURE__ */ new Map();
    for (const signals of Array.from(this.signals.values())) {
      for (const signal of signals) {
        const asset = this.getAssetFromSignal(signal);
        if (asset === "MACRO" || asset === "UNKNOWN") continue;
        const existing = assetMap.get(asset) || [];
        existing.push(signal);
        assetMap.set(asset, existing);
      }
    }
    const syntheses = [];
    const weights = this.agentWeights[regime] || this.agentWeights.transition;
    for (const [asset, signals] of Array.from(assetMap.entries())) {
      const latestByAgent = /* @__PURE__ */ new Map();
      for (const signal of signals) {
        const existing = latestByAgent.get(signal.agentId);
        if (!existing || signal.timestamp > existing.timestamp) {
          latestByAgent.set(signal.agentId, signal);
        }
      }
      const contributingAgents = [];
      let weightedScore = 0;
      let totalWeight = 0;
      for (const signal of Array.from(latestByAgent.values())) {
        const agentType = this.getAgentType(signal.agentName);
        const weight = weights[agentType] || 0.1;
        const score = this.signalToScore(signal);
        weightedScore += score * weight;
        totalWeight += weight;
        contributingAgents.push({
          agentName: signal.agentName,
          signal: this.getSignalLabel(signal),
          weight
        });
      }
      const avgScore = totalWeight > 0 ? weightedScore / totalWeight : 0;
      const aggregatedSignal = this.scoreToSignal(avgScore);
      const scores = Array.from(latestByAgent.values()).map((s) => this.signalToScore(s));
      const variance = this.calculateVariance(scores);
      const alignment = Math.max(0, 1 - variance / 2);
      syntheses.push({
        asset,
        assetClass: this.determineAssetClass(asset),
        aggregatedSignal,
        confidence: Math.round(alignment * 100),
        contributingAgents,
        sentimentAlignment: alignment,
        riskScore: this.calculateAssetRisk(signals),
        keyInsights: this.extractKeyInsights(signals)
      });
    }
    return syntheses.sort((a, b) => b.confidence - a.confidence);
  }
  getAgentType(agentName) {
    const name = agentName.toLowerCase();
    if (name.includes("momentum") || name.includes("alpha")) return "momentum";
    if (name.includes("technical") || name.includes("chart")) return "technical";
    if (name.includes("sentiment") || name.includes("social")) return "sentiment";
    if (name.includes("fundamental") || name.includes("value")) return "fundamental";
    if (name.includes("macro") || name.includes("global")) return "macro";
    if (name.includes("risk") || name.includes("volatility")) return "risk";
    return "other";
  }
  signalToScore(signal) {
    if (signal.domain === "stock") {
      const scores = {
        strong_buy: 1,
        buy: 0.5,
        hold: 0,
        sell: -0.5,
        strong_sell: -1
      };
      return scores[signal.signal] || 0;
    }
    if (signal.domain === "crypto") {
      const scores = {
        bullish: 0.75,
        neutral: 0,
        bearish: -0.75
      };
      return scores[signal.signal] || 0;
    }
    if (signal.domain === "sentiment") {
      return signal.overallSentiment;
    }
    return 0;
  }
  getSignalLabel(signal) {
    if (signal.domain === "stock") return signal.signal;
    if (signal.domain === "crypto") return signal.signal;
    if (signal.domain === "sentiment") {
      if (signal.overallSentiment > 0.3) return "bullish";
      if (signal.overallSentiment < -0.3) return "bearish";
      return "neutral";
    }
    return "unknown";
  }
  scoreToSignal(score) {
    if (score >= 0.6) return "strong_buy";
    if (score >= 0.2) return "buy";
    if (score >= -0.2) return "hold";
    if (score >= -0.6) return "sell";
    return "strong_sell";
  }
  calculateVariance(values) {
    if (values.length === 0) return 0;
    const mean5 = values.reduce((a, b) => a + b, 0) / values.length;
    const squaredDiffs = values.map((v) => Math.pow(v - mean5, 2));
    return squaredDiffs.reduce((a, b) => a + b, 0) / values.length;
  }
  determineAssetClass(asset) {
    const cryptoTokens = ["BTC", "ETH", "SOL", "AVAX", "MATIC", "ARB", "OP", "DOGE", "SHIB"];
    const commodities = ["GLD", "SLV", "USO", "UNG", "PAXG"];
    const forex = ["DXY", "EURUSD", "GBPUSD", "USDJPY"];
    if (cryptoTokens.includes(asset.toUpperCase())) return "crypto";
    if (commodities.includes(asset.toUpperCase())) return "commodity";
    if (forex.includes(asset.toUpperCase())) return "forex";
    return "stock";
  }
  calculateAssetRisk(signals) {
    let riskScore = 50;
    for (const signal of signals) {
      if (signal.domain === "options") {
        if (signal.ivPercentile > 80) riskScore += 15;
        if (signal.unusualActivity) riskScore += 10;
      }
      if (signal.domain === "sentiment") {
        if (signal.alertLevel === "extreme") riskScore += 20;
        if (signal.alertLevel === "elevated") riskScore += 10;
      }
    }
    return Math.min(100, riskScore);
  }
  extractKeyInsights(signals) {
    const insights = [];
    for (const signal of signals.slice(0, 5)) {
      if (signal.domain === "stock" && signal.reasoning) {
        insights.push(signal.reasoning);
      }
      if (signal.domain === "crypto") {
        if (signal.whaleActivity === "accumulating") {
          insights.push("Whale accumulation detected");
        }
        if (signal.narrativeStrength > 70) {
          insights.push("Strong narrative momentum");
        }
      }
    }
    return insights.slice(0, 3);
  }
  /**
   * Calculate cross-asset correlations
   */
  calculateCorrelations() {
    const pairs = [
      { asset1: "BTC", asset2: "NASDAQ", correlation: 0.72, lagDays: 0, isAnomalous: false },
      { asset1: "BTC", asset2: "SPY", correlation: 0.65, lagDays: 1, isAnomalous: false },
      { asset1: "BTC", asset2: "GLD", correlation: -0.12, lagDays: 0, isAnomalous: false },
      { asset1: "ETH", asset2: "BTC", correlation: 0.92, lagDays: 0, isAnomalous: false },
      { asset1: "SPY", asset2: "VIX", correlation: -0.85, lagDays: 0, isAnomalous: false }
    ];
    return {
      pairs,
      regimeCorrelations: [
        { regime: "risk_on", avgCorrelation: 0.65 },
        { regime: "risk_off", avgCorrelation: 0.82 },
        { regime: "transition", avgCorrelation: 0.55 }
      ]
    };
  }
  /**
   * Assess overall portfolio risk
   */
  assessRisk(assetSignals, marketRegime) {
    let riskScore = 30;
    const factors = [];
    if (marketRegime.current === "risk_off") {
      riskScore += 25;
      factors.push({ factor: "Risk-off market regime", contribution: 25, trend: "stable" });
    } else if (marketRegime.current === "transition") {
      riskScore += 15;
      factors.push({ factor: "Market regime transition", contribution: 15, trend: "increasing" });
    }
    const highRiskAssets = assetSignals.filter((a) => a.riskScore > 70);
    if (highRiskAssets.length > 0) {
      const contribution = highRiskAssets.length * 5;
      riskScore += contribution;
      factors.push({
        factor: `${highRiskAssets.length} high-risk assets`,
        contribution,
        trend: "stable"
      });
    }
    const lowAlignmentAssets = assetSignals.filter((a) => a.sentimentAlignment < 0.5);
    if (lowAlignmentAssets.length > 2) {
      riskScore += 10;
      factors.push({
        factor: "Agent disagreement on multiple assets",
        contribution: 10,
        trend: "increasing"
      });
    }
    const level = this.riskScoreToLevel(riskScore);
    const hedgeRecommendations = this.generateHedgeRecommendations(level, marketRegime);
    return {
      overallRiskLevel: level,
      riskScore: Math.min(100, riskScore),
      factors,
      hedgeRecommendations
    };
  }
  riskScoreToLevel(score) {
    if (score < 25) return "low";
    if (score < 45) return "moderate";
    if (score < 65) return "elevated";
    if (score < 85) return "high";
    return "extreme";
  }
  generateHedgeRecommendations(level, regime) {
    const recommendations = [];
    if (level === "elevated" || level === "high" || level === "extreme") {
      recommendations.push("Consider increasing cash allocation");
      recommendations.push("Add VIX calls for tail risk protection");
    }
    if (regime.current === "risk_off") {
      recommendations.push("Rotate to defensive sectors (utilities, healthcare)");
      recommendations.push("Consider gold allocation for safe haven");
    }
    if (level === "extreme") {
      recommendations.push("URGENT: Reduce overall exposure by 50%");
    }
    return recommendations;
  }
  /**
   * Identify trading opportunities
   */
  identifyOpportunities(assetSignals, correlations) {
    const opportunities = [];
    const strongBuys = assetSignals.filter(
      (a) => a.aggregatedSignal === "strong_buy" && a.confidence > 70
    );
    for (const asset of strongBuys) {
      opportunities.push({
        id: `opp_momentum_${asset.asset}`,
        type: "momentum",
        asset: asset.asset,
        expectedReturn: 0.05 + asset.confidence / 1e3,
        timeHorizon: "1-2 weeks",
        confidence: asset.confidence,
        supportingAgents: asset.contributingAgents.map((a) => a.agentName),
        riskRewardRatio: 2.5
      });
    }
    const strongSells = assetSignals.filter(
      (a) => a.aggregatedSignal === "strong_sell" && a.sentimentAlignment < 0.4
    );
    for (const asset of strongSells) {
      opportunities.push({
        id: `opp_reversion_${asset.asset}`,
        type: "mean_reversion",
        asset: asset.asset,
        expectedReturn: 0.03,
        timeHorizon: "3-5 days",
        confidence: 60,
        supportingAgents: ["Contrarian Agent"],
        riskRewardRatio: 1.5
      });
    }
    const anomalousCorrelations = correlations.pairs.filter((p) => p.isAnomalous);
    for (const pair of anomalousCorrelations) {
      opportunities.push({
        id: `opp_arb_${pair.asset1}_${pair.asset2}`,
        type: "arbitrage",
        asset: `${pair.asset1}/${pair.asset2}`,
        expectedReturn: 0.02,
        timeHorizon: "1-3 days",
        confidence: 65,
        supportingAgents: ["Correlation Agent"],
        riskRewardRatio: 3
      });
    }
    return opportunities.sort((a, b) => b.riskRewardRatio - a.riskRewardRatio);
  }
  /**
   * Generate warning signals
   */
  generateWarnings(assetSignals, riskAssessment) {
    const warnings = [];
    if (riskAssessment.overallRiskLevel === "high" || riskAssessment.overallRiskLevel === "extreme") {
      warnings.push({
        id: "warn_risk_level",
        severity: riskAssessment.overallRiskLevel === "extreme" ? "critical" : "warning",
        message: `Portfolio risk is ${riskAssessment.overallRiskLevel}. Consider reducing exposure.`,
        affectedAssets: assetSignals.filter((a) => a.riskScore > 70).map((a) => a.asset),
        source: "Risk Synthesis Engine",
        actionRequired: riskAssessment.overallRiskLevel === "extreme"
      });
    }
    const lowAlignment = assetSignals.filter((a) => a.sentimentAlignment < 0.3);
    for (const asset of lowAlignment) {
      warnings.push({
        id: `warn_disagreement_${asset.asset}`,
        severity: "warning",
        message: `Significant agent disagreement on ${asset.asset}. Exercise caution.`,
        affectedAssets: [asset.asset],
        source: "Consensus Engine",
        actionRequired: false
      });
    }
    return warnings;
  }
  /**
   * Generate action recommendations
   */
  generateRecommendations(assetSignals, opportunities, warnings, marketRegime) {
    const recommendations = [];
    const buySignals = assetSignals.filter(
      (a) => (a.aggregatedSignal === "strong_buy" || a.aggregatedSignal === "buy") && a.confidence > 65 && a.riskScore < 70
    );
    for (const signal of buySignals.slice(0, 5)) {
      recommendations.push({
        id: `rec_buy_${signal.asset}`,
        action: "buy",
        asset: signal.asset,
        urgency: signal.aggregatedSignal === "strong_buy" ? "today" : "this_week",
        size: signal.confidence > 80 ? "medium" : "small",
        rationale: signal.keyInsights.join(". ") || "Strong consensus signal",
        consensusScore: signal.confidence,
        requiresApproval: signal.confidence < 75
      });
    }
    const sellSignals = assetSignals.filter(
      (a) => (a.aggregatedSignal === "strong_sell" || a.aggregatedSignal === "sell") && a.confidence > 65
    );
    for (const signal of sellSignals.slice(0, 3)) {
      recommendations.push({
        id: `rec_sell_${signal.asset}`,
        action: "sell",
        asset: signal.asset,
        urgency: signal.aggregatedSignal === "strong_sell" ? "immediate" : "today",
        size: "medium",
        rationale: "Bearish consensus from multiple agents",
        consensusScore: signal.confidence,
        requiresApproval: false
      });
    }
    const criticalWarnings = warnings.filter((w) => w.severity === "critical");
    if (criticalWarnings.length > 0) {
      recommendations.push({
        id: "rec_hedge_portfolio",
        action: "hedge",
        asset: "PORTFOLIO",
        urgency: "immediate",
        size: "large",
        rationale: "Critical risk warnings detected",
        consensusScore: 90,
        requiresApproval: true
      });
    }
    return recommendations.sort((a, b) => {
      const urgencyOrder = { immediate: 0, today: 1, this_week: 2, opportunistic: 3 };
      return urgencyOrder[a.urgency] - urgencyOrder[b.urgency];
    });
  }
  /**
   * Process voice command and return response
   */
  processVoiceCommand(command) {
    const synthesis = this.synthesize();
    const lowerCommand = command.command.toLowerCase();
    if (lowerCommand.includes("market") && lowerCommand.includes("status")) {
      return {
        text: `The market is currently in a ${synthesis.marketRegime.current.replace("_", " ")} regime with ${synthesis.marketRegime.confidence}% confidence. ${synthesis.marketRegime.drivers[0] || ""}`,
        data: synthesis.marketRegime,
        suggestedActions: ["Show opportunities", "Check risk level"]
      };
    }
    if (lowerCommand.includes("risk")) {
      return {
        text: `Overall portfolio risk is ${synthesis.riskAssessment.overallRiskLevel} with a score of ${synthesis.riskAssessment.riskScore}. ${synthesis.riskAssessment.hedgeRecommendations[0] || ""}`,
        data: synthesis.riskAssessment,
        suggestedActions: ["Show hedge recommendations", "View risk factors"]
      };
    }
    if (lowerCommand.includes("opportunit")) {
      const topOpp = synthesis.opportunities[0];
      if (topOpp) {
        return {
          text: `Top opportunity: ${topOpp.type} trade on ${topOpp.asset} with ${Math.round(topOpp.expectedReturn * 100)}% expected return over ${topOpp.timeHorizon}.`,
          data: synthesis.opportunities.slice(0, 3),
          suggestedActions: ["Execute trade", "Show more opportunities"]
        };
      }
      return {
        text: "No significant opportunities detected at this time.",
        suggestedActions: ["Check later", "Adjust parameters"]
      };
    }
    if (lowerCommand.includes("recommend") || lowerCommand.includes("what should")) {
      const topRec = synthesis.recommendedActions[0];
      if (topRec) {
        return {
          text: `Top recommendation: ${topRec.action.toUpperCase()} ${topRec.asset} with ${topRec.urgency} urgency. ${topRec.rationale}`,
          data: synthesis.recommendedActions.slice(0, 3),
          suggestedActions: ["Execute recommendation", "Show alternatives"]
        };
      }
      return {
        text: "No specific recommendations at this time. Consider holding current positions.",
        suggestedActions: ["Review portfolio", "Check opportunities"]
      };
    }
    const assetMatch = lowerCommand.match(/(?:what about|analyze|check)\s+(\w+)/i);
    if (assetMatch) {
      const asset = assetMatch[1].toUpperCase();
      const assetSignal = synthesis.assetSignals.find(
        (a) => a.asset.toUpperCase() === asset
      );
      if (assetSignal) {
        return {
          text: `${asset}: ${assetSignal.aggregatedSignal.replace("_", " ").toUpperCase()} signal with ${assetSignal.confidence}% confidence. Risk score: ${assetSignal.riskScore}. ${assetSignal.keyInsights[0] || ""}`,
          data: assetSignal,
          suggestedActions: [`Trade ${asset}`, "Show contributing agents"]
        };
      }
      return {
        text: `No data available for ${asset}. Would you like me to run an analysis?`,
        suggestedActions: [`Analyze ${asset}`, "Search for similar assets"]
      };
    }
    return {
      text: "I can help you with market status, risk assessment, opportunities, recommendations, or specific asset analysis. What would you like to know?",
      suggestedActions: ["Market status", "Show opportunities", "Check risk"]
    };
  }
  /**
   * Get summary statistics
   */
  getSummaryStats() {
    let totalSignals = 0;
    let lastUpdate = null;
    for (const signals of Array.from(this.signals.values())) {
      totalSignals += signals.length;
      for (const signal of signals) {
        if (!lastUpdate || signal.timestamp > lastUpdate) {
          lastUpdate = signal.timestamp;
        }
      }
    }
    const synthesis = this.synthesize();
    return {
      totalSignals,
      activeAgents: this.signals.size,
      lastUpdate,
      marketRegime: synthesis.marketRegime.current,
      topOpportunity: synthesis.opportunities[0]?.asset || null,
      riskLevel: synthesis.riskAssessment.overallRiskLevel
    };
  }
};
var crossAgentSynthesis = new CrossAgentSynthesisService();

// server/services/swarm/orchestrator/AlphaOrchestrator.ts
var AlphaOrchestrator = class {
  STALE_DATA_THRESHOLD_MS = 15 * 60 * 1e3;
  // 15 minutes
  MAX_SINGLE_TRADE_RISK = 0.02;
  // 2%
  MAX_PORTFOLIO_RISK = 0.025;
  // 2.5%
  EXECUTION_CONFIDENCE_THRESHOLD = 85;
  DEVILS_ADVOCATE_VETO_THRESHOLD = 7;
  marketRegime;
  portfolioState;
  pendingTasks;
  agentResponses;
  decisionHistory;
  constructor() {
    this.marketRegime = this.initializeMarketRegime();
    this.portfolioState = this.initializePortfolioState();
    this.pendingTasks = /* @__PURE__ */ new Map();
    this.agentResponses = /* @__PURE__ */ new Map();
    this.decisionHistory = [];
  }
  initializeMarketRegime() {
    return {
      type: "balanced",
      confidence: 50,
      indicators: {
        vix: 20,
        goldUsdCorrelation: -0.3,
        btcNasdaqCorrelation: 0.6,
        yieldCurve: 0.5,
        creditSpreads: 1.5
      },
      recommendedStrategy: "balanced"
    };
  }
  initializePortfolioState() {
    return {
      totalValue: 1e6,
      cashAvailable: 5e5,
      positions: [],
      riskMetrics: {
        totalExposure: 0.5,
        maxDrawdown: 0.05,
        sharpeRatio: 1.5,
        correlationMatrix: {}
      }
    };
  }
  /**
   * Strategic Decomposition
   * Breaks down a trading goal into sub-tasks for specialized agents
   */
  decomposeTask(goal, asset, assetClass) {
    const baseId = `task_${Date.now()}`;
    const deadline = Date.now() + 3e4;
    const tasks = [];
    tasks.push({
      id: `${baseId}_technical`,
      type: "analysis",
      asset,
      assetClass,
      priority: "high",
      deadline,
      data: { analysisType: "technical", indicators: ["RSI", "MACD", "BB", "EMA"] }
    });
    tasks.push({
      id: `${baseId}_fundamental`,
      type: "analysis",
      asset,
      assetClass,
      priority: "high",
      deadline,
      data: { analysisType: "fundamental" }
    });
    if (assetClass === "crypto") {
      tasks.push({
        id: `${baseId}_onchain`,
        type: "analysis",
        asset,
        assetClass,
        priority: "high",
        deadline,
        data: { analysisType: "onchain", metrics: ["whale_flow", "exchange_balance", "nvt"] }
      });
    }
    if (assetClass === "stocks") {
      tasks.push({
        id: `${baseId}_earnings`,
        type: "analysis",
        asset,
        assetClass,
        priority: "medium",
        deadline,
        data: { analysisType: "earnings", includeGuidance: true }
      });
    }
    tasks.push({
      id: `${baseId}_macro`,
      type: "analysis",
      asset,
      assetClass,
      priority: "medium",
      deadline,
      data: { analysisType: "macro", factors: ["fed_policy", "geopolitical", "economic_data"] }
    });
    tasks.push({
      id: `${baseId}_sentiment`,
      type: "analysis",
      asset,
      assetClass,
      priority: "medium",
      deadline,
      data: { analysisType: "sentiment", sources: ["social", "news", "institutional"] }
    });
    tasks.push({
      id: `${baseId}_volatility`,
      type: "analysis",
      asset,
      assetClass,
      priority: "high",
      deadline,
      data: { analysisType: "volatility", greeks: ["vanna", "charm", "vomma"] }
    });
    tasks.push({
      id: `${baseId}_critique`,
      type: "critique",
      asset,
      assetClass,
      priority: "high",
      deadline,
      data: { critiqueType: "adversarial" }
    });
    tasks.push({
      id: `${baseId}_validation`,
      type: "validation",
      asset,
      assetClass,
      priority: "high",
      deadline,
      data: { validationType: "cross_asset" }
    });
    for (const task of tasks) {
      this.pendingTasks.set(task.id, task);
    }
    return tasks;
  }
  /**
   * Receive and validate agent response
   */
  receiveAgentResponse(response) {
    const dataAge = Date.now() - response.timestamp;
    if (dataAge > this.STALE_DATA_THRESHOLD_MS) {
      response.isStale = true;
      console.warn(`[Orchestrator] Rejecting stale data from ${response.agentName} (${dataAge}ms old)`);
      return false;
    }
    const taskResponses = this.agentResponses.get(response.taskId) || [];
    taskResponses.push(response);
    this.agentResponses.set(response.taskId, taskResponses);
    return true;
  }
  /**
   * Adversarial Synthesis
   * Forces Devil's Advocate critique and validates trade recommendations
   */
  performAdversarialSynthesis(bullishResponses, bearishResponse) {
    const critiqueScore = bearishResponse.confidence / 10;
    const reasoning = [];
    if (critiqueScore > this.DEVILS_ADVOCATE_VETO_THRESHOLD) {
      reasoning.push(`Devil's Advocate critique score (${critiqueScore.toFixed(1)}/10) exceeds veto threshold (${this.DEVILS_ADVOCATE_VETO_THRESHOLD}/10)`);
      reasoning.push(...bearishResponse.risks);
      return { approved: false, critiqueScore, reasoning };
    }
    const avgBullishConfidence = bullishResponses.reduce((sum2, r) => sum2 + r.confidence, 0) / bullishResponses.length;
    if (avgBullishConfidence < 60) {
      reasoning.push(`Average bullish confidence (${avgBullishConfidence.toFixed(1)}%) is below threshold`);
      return { approved: false, critiqueScore, reasoning };
    }
    reasoning.push(`Trade approved with critique score ${critiqueScore.toFixed(1)}/10`);
    reasoning.push(`Average bullish confidence: ${avgBullishConfidence.toFixed(1)}%`);
    return { approved: true, critiqueScore, reasoning };
  }
  /**
   * Cross-Asset Validation
   * Validates trade against correlated assets
   */
  performCrossAssetValidation(asset, assetClass, recommendation) {
    const checks = [];
    if (assetClass === "stocks") {
      const vixCheck = this.marketRegime.indicators.vix < 30;
      checks.push({
        name: "VIX Level",
        passed: recommendation === "buy" ? vixCheck : true,
        value: this.marketRegime.indicators.vix
      });
    }
    if (assetClass === "crypto") {
      const goldCorrelation = Math.abs(this.marketRegime.indicators.goldUsdCorrelation);
      const correlationCheck = goldCorrelation < 0.8;
      checks.push({
        name: "Gold/USD Correlation",
        passed: correlationCheck,
        value: this.marketRegime.indicators.goldUsdCorrelation
      });
    }
    if (assetClass === "crypto" || assetClass === "stocks") {
      const btcNasdaqCorrelation = this.marketRegime.indicators.btcNasdaqCorrelation;
      checks.push({
        name: "BTC/Nasdaq Correlation",
        passed: true,
        // Informational
        value: btcNasdaqCorrelation
      });
    }
    const yieldCurveCheck = this.marketRegime.indicators.yieldCurve > -0.5;
    checks.push({
      name: "Yield Curve",
      passed: yieldCurveCheck,
      value: this.marketRegime.indicators.yieldCurve
    });
    const creditSpreadsCheck = this.marketRegime.indicators.creditSpreads < 3;
    checks.push({
      name: "Credit Spreads",
      passed: creditSpreadsCheck,
      value: this.marketRegime.indicators.creditSpreads
    });
    const allPassed = checks.every((c) => c.passed);
    return { passed: allPassed, checks };
  }
  /**
   * Calculate final confidence score from all agent responses
   */
  calculateConfidenceScore(responses) {
    if (responses.length === 0) return 0;
    const weights = {
      technical: 0.2,
      fundamental: 0.15,
      onchain: 0.15,
      macro: 0.15,
      sentiment: 0.1,
      volatility: 0.15,
      momentum: 0.1
    };
    let weightedSum = 0;
    let totalWeight = 0;
    for (const response of responses) {
      const agentType = response.agentId.split("_")[0];
      const weight = weights[agentType] || 0.1;
      weightedSum += response.confidence * weight;
      totalWeight += weight;
    }
    return totalWeight > 0 ? weightedSum / totalWeight : 0;
  }
  /**
   * Assess risk for proposed trade
   */
  assessRisk(asset, proposedSize, direction) {
    const warnings = [];
    const singleTradeRisk = proposedSize / this.portfolioState.totalValue;
    if (singleTradeRisk > this.MAX_SINGLE_TRADE_RISK) {
      warnings.push(`Single trade risk (${(singleTradeRisk * 100).toFixed(2)}%) exceeds 2% limit`);
    }
    const currentExposure = this.portfolioState.riskMetrics.totalExposure;
    const additionalExposure = proposedSize / this.portfolioState.totalValue;
    const totalRisk = currentExposure + additionalExposure;
    if (totalRisk > this.MAX_PORTFOLIO_RISK) {
      warnings.push(`Total portfolio risk (${(totalRisk * 100).toFixed(2)}%) would exceed 2.5% limit`);
    }
    const existingPosition = this.portfolioState.positions.find((p) => p.asset === asset);
    if (existingPosition) {
      warnings.push(`Already have position in ${asset} (${existingPosition.size} units)`);
    }
    const withinLimits = singleTradeRisk <= this.MAX_SINGLE_TRADE_RISK && totalRisk <= this.MAX_PORTFOLIO_RISK;
    return { totalRisk, withinLimits, warnings };
  }
  /**
   * Detect current market regime
   */
  detectMarketRegime() {
    const { vix, goldUsdCorrelation, btcNasdaqCorrelation, yieldCurve, creditSpreads } = this.marketRegime.indicators;
    let riskScore = 0;
    if (vix < 15) riskScore += 2;
    else if (vix < 20) riskScore += 1;
    else if (vix < 25) riskScore += 0;
    else if (vix < 30) riskScore -= 1;
    else riskScore -= 2;
    if (yieldCurve > 1) riskScore += 1;
    else if (yieldCurve > 0) riskScore += 0;
    else riskScore -= 1;
    if (creditSpreads < 1.5) riskScore += 1;
    else if (creditSpreads < 2.5) riskScore += 0;
    else riskScore -= 1;
    let type;
    let recommendedStrategy;
    if (riskScore >= 2) {
      type = "risk-on";
      recommendedStrategy = "momentum";
    } else if (riskScore <= -2) {
      type = "risk-off";
      recommendedStrategy = "preservation";
    } else {
      type = "transition";
      recommendedStrategy = "balanced";
    }
    const confidence = Math.min(100, Math.abs(riskScore) * 25 + 50);
    this.marketRegime = {
      type,
      confidence,
      indicators: this.marketRegime.indicators,
      recommendedStrategy
    };
    return this.marketRegime;
  }
  /**
   * Create execution plan for approved trade
   */
  createExecutionPlan(asset, size, urgency) {
    let orderType;
    let fragments;
    if (size > 1e5) {
      orderType = "stealth";
      fragments = Math.ceil(size / 1e4);
    } else if (urgency === "immediate") {
      orderType = "market";
      fragments = 1;
    } else {
      orderType = "limit";
      fragments = urgency === "patient" ? Math.ceil(size / 25e3) : 1;
    }
    return {
      orderType,
      fragments,
      totalSize: size,
      urgency
    };
  }
  /**
   * Make final orchestrator decision
   */
  makeDecision(asset, assetClass, agentResponses, devilsAdvocateResponse, proposedSize) {
    const decisionId = `decision_${Date.now()}`;
    const bullishResponses = agentResponses.filter((r) => r.recommendation === "buy");
    const bearishResponses = agentResponses.filter((r) => r.recommendation === "sell" || r.recommendation === "avoid");
    const adversarialResult = this.performAdversarialSynthesis(bullishResponses, devilsAdvocateResponse);
    const crossAssetResult = this.performCrossAssetValidation(
      asset,
      assetClass,
      bullishResponses.length > bearishResponses.length ? "buy" : "sell"
    );
    const riskAssessment = this.assessRisk(asset, proposedSize, "long");
    const confidenceScore = this.calculateConfidenceScore(agentResponses);
    let finalRecommendation;
    let consensusReached = false;
    const reasoning = [];
    if (!adversarialResult.approved) {
      finalRecommendation = "avoid";
      reasoning.push("Trade vetoed by Devil's Advocate");
      reasoning.push(...adversarialResult.reasoning);
    } else if (!crossAssetResult.passed) {
      finalRecommendation = "hold";
      reasoning.push("Cross-asset validation failed");
      const failedChecks = crossAssetResult.checks.filter((c) => !c.passed);
      reasoning.push(...failedChecks.map((c) => `${c.name}: ${c.value}`));
    } else if (!riskAssessment.withinLimits) {
      finalRecommendation = "hold";
      reasoning.push("Risk limits exceeded");
      reasoning.push(...riskAssessment.warnings);
    } else if (confidenceScore >= this.EXECUTION_CONFIDENCE_THRESHOLD) {
      const buyVotes = agentResponses.filter((r) => r.recommendation === "buy").length;
      const sellVotes = agentResponses.filter((r) => r.recommendation === "sell").length;
      if (buyVotes > sellVotes) {
        finalRecommendation = "buy";
        consensusReached = true;
        reasoning.push(`Consensus reached: ${buyVotes} buy vs ${sellVotes} sell`);
      } else if (sellVotes > buyVotes) {
        finalRecommendation = "sell";
        consensusReached = true;
        reasoning.push(`Consensus reached: ${sellVotes} sell vs ${buyVotes} buy`);
      } else {
        finalRecommendation = "hold";
        reasoning.push("No clear consensus between agents");
      }
    } else {
      finalRecommendation = "hold";
      reasoning.push(`Confidence score (${confidenceScore.toFixed(1)}%) below threshold (${this.EXECUTION_CONFIDENCE_THRESHOLD}%)`);
    }
    let executionPlan;
    if (finalRecommendation === "buy" || finalRecommendation === "sell") {
      executionPlan = this.createExecutionPlan(
        asset,
        proposedSize,
        confidenceScore > 95 ? "immediate" : confidenceScore > 90 ? "gradual" : "patient"
      );
    }
    const requiresHumanApproval = proposedSize > 5e4 || confidenceScore < 90;
    const decision = {
      id: decisionId,
      timestamp: Date.now(),
      asset,
      assetClass,
      finalRecommendation,
      confidenceScore,
      consensusReached,
      agentVotes: agentResponses.map((r) => ({
        agentId: r.agentId,
        vote: r.recommendation,
        confidence: r.confidence
      })),
      devilsAdvocateScore: adversarialResult.critiqueScore,
      crossAssetValidation: crossAssetResult,
      riskAssessment,
      executionPlan,
      requiresHumanApproval,
      reasoning
    };
    this.decisionHistory.push(decision);
    return decision;
  }
  /**
   * Update market regime indicators
   */
  updateMarketIndicators(indicators) {
    this.marketRegime.indicators = {
      ...this.marketRegime.indicators,
      ...indicators
    };
    this.detectMarketRegime();
  }
  /**
   * Update portfolio state
   */
  updatePortfolioState(state) {
    this.portfolioState = {
      ...this.portfolioState,
      ...state
    };
  }
  /**
   * Get current market regime
   */
  getMarketRegime() {
    return this.marketRegime;
  }
  /**
   * Get portfolio state
   */
  getPortfolioState() {
    return this.portfolioState;
  }
  /**
   * Get decision history
   */
  getDecisionHistory() {
    return this.decisionHistory;
  }
  /**
   * Generate orchestrator status report
   */
  generateStatusReport() {
    const recentDecisions = this.decisionHistory.slice(-10);
    let systemHealth = "healthy";
    const recentLosses = recentDecisions.filter(
      (d) => d.finalRecommendation === "avoid" || !d.consensusReached
    ).length;
    if (recentLosses > 7) {
      systemHealth = "critical";
    } else if (recentLosses > 4) {
      systemHealth = "degraded";
    }
    return {
      marketRegime: this.marketRegime,
      portfolioState: this.portfolioState,
      pendingTasks: this.pendingTasks.size,
      recentDecisions,
      systemHealth
    };
  }
};

// server/services/commandcenter/CommandCenterDataService.ts
var CommandCenterDataService = class {
  alphaOrchestrator;
  signalCache = /* @__PURE__ */ new Map();
  pendingActionsCache = [];
  lastRefresh = null;
  CACHE_TTL_MS = 1e4;
  // 10 seconds
  constructor() {
    this.alphaOrchestrator = new AlphaOrchestrator();
  }
  /**
   * Get all agent statuses
   */
  async getAgentStatuses() {
    const agents = [];
    const stockAgents = [
      { id: "fundamental_analyst", name: "Fundamental Analyst", type: "stock" },
      { id: "technical_analyst", name: "Technical Analyst", type: "stock" },
      { id: "sentiment_harvester", name: "Sentiment Harvester", type: "stock" },
      { id: "macro_linker", name: "Macro Linker", type: "stock" },
      { id: "portfolio_manager", name: "Portfolio Manager", type: "stock" },
      { id: "devils_advocate", name: "Devil's Advocate", type: "stock" }
    ];
    const cryptoAgents = [
      { id: "whale_agent", name: "Whale Tracker", type: "crypto" },
      { id: "hype_agent", name: "Hype Detector", type: "crypto" },
      { id: "macro_crypto", name: "Crypto Macro", type: "crypto" },
      { id: "defi_analyst", name: "DeFi Analyst", type: "crypto" }
    ];
    const sentimentAgents = [
      { id: "twitter_sentiment", name: "Twitter Sentiment", type: "sentiment" },
      { id: "reddit_sentiment", name: "Reddit Sentiment", type: "sentiment" },
      { id: "news_sentiment", name: "News Sentiment", type: "sentiment" }
    ];
    const macroAgents = [
      { id: "fed_watcher", name: "Fed Watcher", type: "macro" },
      { id: "regime_detector", name: "Regime Detector", type: "macro" },
      { id: "correlation_tracker", name: "Correlation Tracker", type: "macro" }
    ];
    const optionsAgents = [
      { id: "greeks_analyzer", name: "Greeks Analyzer", type: "options" },
      { id: "iv_surface", name: "IV Surface Analyzer", type: "options" },
      { id: "flow_detector", name: "Options Flow Detector", type: "options" }
    ];
    const swarmAgents = [
      { id: "alpha_orchestrator", name: "Alpha Orchestrator", type: "swarm" },
      { id: "consensus_engine", name: "Consensus Engine", type: "swarm" },
      { id: "debate_system", name: "Debate System", type: "swarm" }
    ];
    const allAgentDefs = [
      ...stockAgents,
      ...cryptoAgents,
      ...sentimentAgents,
      ...macroAgents,
      ...optionsAgents,
      ...swarmAgents
    ];
    for (const agentDef of allAgentDefs) {
      const isActive = Math.random() > 0.1;
      const hasRecentSignal = Math.random() > 0.3;
      agents.push({
        id: agentDef.id,
        name: agentDef.name,
        type: agentDef.type,
        status: isActive ? hasRecentSignal ? "active" : "idle" : "error",
        lastSignal: hasRecentSignal ? new Date(Date.now() - Math.random() * 36e5) : null,
        signalCount: Math.floor(Math.random() * 100) + 10,
        accuracy: 60 + Math.random() * 35,
        confidence: 50 + Math.random() * 45
      });
    }
    return agents;
  }
  /**
   * Get aggregated signals from all sources
   */
  async getAggregatedSignals(filters) {
    const synthesis = crossAgentSynthesis.synthesize();
    const signals = [];
    for (const assetSignal of synthesis.assetSignals) {
      const direction = this.mapSignalToDirection(assetSignal.aggregatedSignal);
      const strength = this.mapConfidenceToStrength(assetSignal.confidence);
      signals.push({
        id: `signal_${assetSignal.asset}_${Date.now()}`,
        source: assetSignal.contributingAgents[0]?.agentName || "Multi-Agent Consensus",
        sourceType: this.determineSourceType(assetSignal.assetClass),
        asset: assetSignal.asset,
        assetClass: assetSignal.assetClass,
        direction,
        strength,
        confidence: assetSignal.confidence,
        reasoning: assetSignal.keyInsights,
        timestamp: /* @__PURE__ */ new Date(),
        expiresAt: new Date(Date.now() + 36e5),
        // 1 hour expiry
        actionable: assetSignal.confidence > 70,
        suggestedAction: assetSignal.confidence > 70 ? {
          type: direction === "bullish" ? "buy" : direction === "bearish" ? "sell" : "hold",
          size: strength === "strong" ? "large" : strength === "moderate" ? "medium" : "small",
          urgency: assetSignal.confidence > 85 ? "immediate" : "today"
        } : void 0
      });
    }
    for (const opp of synthesis.opportunities) {
      signals.push({
        id: opp.id,
        source: opp.supportingAgents.join(", "),
        sourceType: "swarm_consensus",
        asset: opp.asset,
        assetClass: this.inferAssetClass(opp.asset),
        direction: "bullish",
        strength: this.mapConfidenceToStrength(opp.confidence),
        confidence: opp.confidence,
        reasoning: [`${opp.type} opportunity`, `Expected return: ${(opp.expectedReturn * 100).toFixed(1)}%`, `Time horizon: ${opp.timeHorizon}`],
        timestamp: /* @__PURE__ */ new Date(),
        expiresAt: new Date(Date.now() + 864e5),
        // 24 hour expiry
        actionable: true,
        suggestedAction: {
          type: "buy",
          size: opp.riskRewardRatio > 2 ? "medium" : "small",
          urgency: "this_week"
        }
      });
    }
    let filtered = signals;
    if (filters) {
      if (filters.assetClass) {
        filtered = filtered.filter((s) => s.assetClass === filters.assetClass);
      }
      if (filters.direction) {
        filtered = filtered.filter((s) => s.direction === filters.direction);
      }
      if (filters.minConfidence !== void 0) {
        const minConf = filters.minConfidence;
        filtered = filtered.filter((s) => s.confidence >= minConf);
      }
      if (filters.source) {
        const sourceFilter = filters.source.toLowerCase();
        filtered = filtered.filter((s) => s.source.toLowerCase().includes(sourceFilter));
      }
    }
    return filtered.sort((a, b) => b.confidence - a.confidence);
  }
  /**
   * Get portfolio metrics
   */
  async getPortfolioMetrics() {
    const positions = [
      {
        symbol: "AAPL",
        assetClass: "stock",
        quantity: 100,
        avgCost: 175.5,
        currentPrice: 182.3,
        marketValue: 18230,
        unrealizedPnL: 680,
        unrealizedPnLPercent: 3.88,
        dayChange: 2.15,
        dayChangePercent: 1.19,
        weight: 0.15
      },
      {
        symbol: "BTC",
        assetClass: "crypto",
        quantity: 0.5,
        avgCost: 42e3,
        currentPrice: 43500,
        marketValue: 21750,
        unrealizedPnL: 750,
        unrealizedPnLPercent: 3.57,
        dayChange: -500,
        dayChangePercent: -1.14,
        weight: 0.18
      },
      {
        symbol: "MSFT",
        assetClass: "stock",
        quantity: 50,
        avgCost: 380,
        currentPrice: 395.2,
        marketValue: 19760,
        unrealizedPnL: 760,
        unrealizedPnLPercent: 4,
        dayChange: 3.5,
        dayChangePercent: 0.89,
        weight: 0.16
      },
      {
        symbol: "ETH",
        assetClass: "crypto",
        quantity: 5,
        avgCost: 2200,
        currentPrice: 2350,
        marketValue: 11750,
        unrealizedPnL: 750,
        unrealizedPnLPercent: 6.82,
        dayChange: 50,
        dayChangePercent: 2.17,
        weight: 0.1
      },
      {
        symbol: "NVDA",
        assetClass: "stock",
        quantity: 25,
        avgCost: 450,
        currentPrice: 485.6,
        marketValue: 12140,
        unrealizedPnL: 890,
        unrealizedPnLPercent: 7.91,
        dayChange: 8.2,
        dayChangePercent: 1.72,
        weight: 0.1
      }
    ];
    const totalValue = positions.reduce((sum2, p) => sum2 + p.marketValue, 0) + 5e4;
    const dayPnL = positions.reduce((sum2, p) => sum2 + p.dayChange * p.quantity, 0);
    const weekPnL = dayPnL * 3.5;
    return {
      totalValue,
      dayPnL,
      dayPnLPercent: dayPnL / totalValue * 100,
      weekPnL,
      weekPnLPercent: weekPnL / totalValue * 100,
      cashAvailable: 5e4,
      buyingPower: 1e5,
      marginUsed: 0,
      positions,
      riskMetrics: {
        sharpeRatio: 1.85,
        maxDrawdown: 8.5,
        volatility: 15.2,
        beta: 1.12,
        var95: 3500
      }
    };
  }
  /**
   * Get pending actions requiring approval
   */
  async getPendingActions() {
    const synthesis = crossAgentSynthesis.synthesize();
    const actions = [];
    for (const rec of synthesis.recommendedActions) {
      if (rec.requiresApproval) {
        actions.push({
          id: rec.id,
          type: "trade",
          priority: rec.urgency === "immediate" ? "high" : rec.urgency === "today" ? "medium" : "low",
          asset: rec.asset,
          action: rec.action.toUpperCase(),
          description: rec.rationale,
          confidence: rec.consensusScore,
          source: "Multi-Agent Consensus",
          createdAt: /* @__PURE__ */ new Date(),
          expiresAt: new Date(Date.now() + (rec.urgency === "immediate" ? 36e5 : 864e5)),
          requiresApproval: true,
          estimatedImpact: {
            expectedReturn: 5 + Math.random() * 10,
            riskLevel: rec.size === "large" ? "high" : rec.size === "medium" ? "moderate" : "low",
            timeHorizon: rec.urgency === "immediate" ? "1-2 days" : "1-2 weeks"
          }
        });
      }
    }
    for (const warning of synthesis.warnings) {
      if (warning.actionRequired) {
        actions.push({
          id: warning.id,
          type: "alert",
          priority: warning.severity === "critical" ? "high" : warning.severity === "warning" ? "medium" : "low",
          asset: warning.affectedAssets.join(", "),
          action: "REVIEW",
          description: warning.message,
          confidence: 90,
          source: warning.source,
          createdAt: /* @__PURE__ */ new Date(),
          expiresAt: new Date(Date.now() + 36e5),
          requiresApproval: true,
          estimatedImpact: {
            expectedReturn: 0,
            riskLevel: warning.severity,
            timeHorizon: "Immediate"
          }
        });
      }
    }
    return actions.sort((a, b) => {
      const priorityOrder = { high: 0, medium: 1, low: 2 };
      return priorityOrder[a.priority] - priorityOrder[b.priority];
    });
  }
  /**
   * Get command center summary
   */
  async getSummary() {
    const synthesis = crossAgentSynthesis.synthesize();
    const signals = await this.getAggregatedSignals();
    const agents = await this.getAgentStatuses();
    const portfolio = await this.getPortfolioMetrics();
    const pendingActions = await this.getPendingActions();
    const activeAgents = agents.filter((a) => a.status === "active");
    const topPerformer = agents.reduce(
      (best, current) => current.accuracy > best.accuracy ? current : best,
      agents[0]
    );
    return {
      marketRegime: {
        current: synthesis.marketRegime.current,
        confidence: synthesis.marketRegime.confidence,
        trend: "stable"
        // Would be calculated from historical data
      },
      signalSummary: {
        total: signals.length,
        bullish: signals.filter((s) => s.direction === "bullish").length,
        bearish: signals.filter((s) => s.direction === "bearish").length,
        neutral: signals.filter((s) => s.direction === "neutral").length,
        highConviction: signals.filter((s) => s.confidence > 80).length
      },
      agentSummary: {
        total: agents.length,
        active: activeAgents.length,
        topPerformer: topPerformer?.name || "N/A",
        avgAccuracy: agents.reduce((sum2, a) => sum2 + a.accuracy, 0) / agents.length
      },
      portfolioSummary: {
        totalValue: portfolio.totalValue,
        dayPnL: portfolio.dayPnL,
        riskLevel: synthesis.riskAssessment.overallRiskLevel
      },
      alertCount: synthesis.warnings.length,
      pendingActions: pendingActions.length,
      lastUpdate: /* @__PURE__ */ new Date()
    };
  }
  /**
   * Execute a signal/action
   */
  async executeSignal(signalId, options) {
    return {
      success: true,
      orderId: `order_${Date.now()}`,
      message: `Signal ${signalId} executed successfully with ${options?.orderType || "market"} order`
    };
  }
  /**
   * Process voice command
   */
  async processVoiceCommand(command) {
    const voiceCmd = {
      command,
      intent: "query",
      parameters: {},
      timestamp: /* @__PURE__ */ new Date()
    };
    const response = crossAgentSynthesis.processVoiceCommand(voiceCmd);
    const lowerCommand = command.toLowerCase();
    let executedAction;
    if (lowerCommand.includes("execute") || lowerCommand.includes("buy") || lowerCommand.includes("sell")) {
      const assetMatch = lowerCommand.match(/(?:buy|sell|execute)\s+(\w+)/i);
      if (assetMatch) {
        const asset = assetMatch[1].toUpperCase();
        const action = lowerCommand.includes("buy") ? "BUY" : lowerCommand.includes("sell") ? "SELL" : "EXECUTE";
        executedAction = `${action} order queued for ${asset}`;
      }
    }
    return {
      success: true,
      response: response.text,
      data: response.data,
      suggestedActions: response.suggestedActions,
      executedAction
    };
  }
  /**
   * Approve a pending action
   */
  async approveAction(actionId) {
    return {
      success: true,
      message: `Action ${actionId} approved and queued for execution`
    };
  }
  /**
   * Reject a pending action
   */
  async rejectAction(actionId, reason) {
    return {
      success: true,
      message: `Action ${actionId} rejected${reason ? `: ${reason}` : ""}`
    };
  }
  // Helper methods
  mapSignalToDirection(signal) {
    if (signal.includes("buy")) return "bullish";
    if (signal.includes("sell")) return "bearish";
    return "neutral";
  }
  mapConfidenceToStrength(confidence) {
    if (confidence >= 80) return "strong";
    if (confidence >= 60) return "moderate";
    return "weak";
  }
  determineSourceType(assetClass) {
    switch (assetClass) {
      case "crypto":
        return "crypto_agent";
      case "stock":
        return "stock_agent";
      default:
        return "swarm_consensus";
    }
  }
  inferAssetClass(asset) {
    const cryptoSymbols = ["BTC", "ETH", "SOL", "DOGE", "ADA", "XRP", "DOT", "AVAX", "MATIC"];
    const forexPairs = ["EUR", "GBP", "JPY", "CHF", "AUD", "CAD"];
    const commodities = ["GOLD", "SILVER", "OIL", "GAS", "WHEAT", "CORN"];
    const indices = ["SPY", "QQQ", "DIA", "IWM", "VIX"];
    const upperAsset = asset.toUpperCase();
    if (cryptoSymbols.some((c) => upperAsset.includes(c))) return "crypto";
    if (forexPairs.some((f) => upperAsset.includes(f))) return "forex";
    if (commodities.some((c) => upperAsset.includes(c))) return "commodity";
    if (indices.some((i) => upperAsset.includes(i))) return "index";
    return "stock";
  }
};
var commandCenterDataService = new CommandCenterDataService();

// server/routers.ts
init_enhancedAnalysis();

// server/services/backtesting.ts
init_dataApi();
async function fetchHistoricalData(symbol, startDate, endDate) {
  try {
    const daysDiff = Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
    let range = "max";
    if (daysDiff <= 30) range = "1mo";
    else if (daysDiff <= 90) range = "3mo";
    else if (daysDiff <= 180) range = "6mo";
    else if (daysDiff <= 365) range = "1y";
    else if (daysDiff <= 730) range = "2y";
    else if (daysDiff <= 1825) range = "5y";
    else if (daysDiff <= 3650) range = "10y";
    const response = await callDataApi("YahooFinance/get_stock_chart", {
      query: {
        symbol,
        region: "US",
        interval: "1d",
        range,
        includeAdjustedClose: true
      }
    });
    const chartResponse = response;
    if (!chartResponse?.chart?.result?.[0]) {
      return [];
    }
    const result = chartResponse.chart.result[0];
    const timestamps = result.timestamp || [];
    const quotes = result.indicators?.quote?.[0] || {};
    const adjClose = result.indicators?.adjclose?.[0]?.adjclose || [];
    const data = [];
    for (let i = 0; i < timestamps.length; i++) {
      const ts = timestamps[i] * 1e3;
      if (ts >= startDate.getTime() && ts <= endDate.getTime()) {
        data.push({
          timestamp: ts,
          open: quotes.open?.[i] || 0,
          high: quotes.high?.[i] || 0,
          low: quotes.low?.[i] || 0,
          close: adjClose[i] || quotes.close?.[i] || 0,
          volume: quotes.volume?.[i] || 0
        });
      }
    }
    return data;
  } catch (error) {
    console.error(`Failed to fetch historical data for ${symbol}:`, error);
    return [];
  }
}
function calculateSMA(data, period) {
  const sma = [];
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      sma.push(NaN);
    } else {
      const sum2 = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
      sma.push(sum2 / period);
    }
  }
  return sma;
}
function calculateEMA2(data, period) {
  const ema = [];
  const multiplier = 2 / (period + 1);
  for (let i = 0; i < data.length; i++) {
    if (i === 0) {
      ema.push(data[i]);
    } else if (i < period - 1) {
      ema.push(NaN);
    } else if (i === period - 1) {
      const sum2 = data.slice(0, period).reduce((a, b) => a + b, 0);
      ema.push(sum2 / period);
    } else {
      ema.push((data[i] - ema[i - 1]) * multiplier + ema[i - 1]);
    }
  }
  return ema;
}
function calculateRSI(data, period = 14) {
  const rsi = [];
  const gains = [];
  const losses = [];
  for (let i = 1; i < data.length; i++) {
    const change = data[i] - data[i - 1];
    gains.push(change > 0 ? change : 0);
    losses.push(change < 0 ? Math.abs(change) : 0);
  }
  for (let i = 0; i < data.length; i++) {
    if (i < period) {
      rsi.push(NaN);
    } else {
      const avgGain = gains.slice(i - period, i).reduce((a, b) => a + b, 0) / period;
      const avgLoss = losses.slice(i - period, i).reduce((a, b) => a + b, 0) / period;
      if (avgLoss === 0) {
        rsi.push(100);
      } else {
        const rs = avgGain / avgLoss;
        rsi.push(100 - 100 / (1 + rs));
      }
    }
  }
  return rsi;
}
function generateSignals(data, strategy) {
  const closes = data.map((d) => d.close);
  const signals = [];
  switch (strategy.type) {
    case "momentum": {
      const shortPeriod = strategy.parameters.shortPeriod || 10;
      const longPeriod = strategy.parameters.longPeriod || 20;
      const shortSMA = calculateSMA(closes, shortPeriod);
      const longSMA = calculateSMA(closes, longPeriod);
      for (let i = 0; i < data.length; i++) {
        if (isNaN(shortSMA[i]) || isNaN(longSMA[i])) {
          signals.push({ timestamp: data[i].timestamp, signal: "hold" });
        } else if (shortSMA[i] > longSMA[i] && shortSMA[i - 1] <= longSMA[i - 1]) {
          signals.push({ timestamp: data[i].timestamp, signal: "buy" });
        } else if (shortSMA[i] < longSMA[i] && shortSMA[i - 1] >= longSMA[i - 1]) {
          signals.push({ timestamp: data[i].timestamp, signal: "sell" });
        } else {
          signals.push({ timestamp: data[i].timestamp, signal: "hold" });
        }
      }
      break;
    }
    case "mean_reversion": {
      const period = strategy.parameters.period || 20;
      const stdMultiplier = strategy.parameters.stdMultiplier || 2;
      const sma = calculateSMA(closes, period);
      for (let i = 0; i < data.length; i++) {
        if (isNaN(sma[i]) || i < period) {
          signals.push({ timestamp: data[i].timestamp, signal: "hold" });
        } else {
          const slice = closes.slice(i - period + 1, i + 1);
          const std4 = Math.sqrt(slice.reduce((sum2, val) => sum2 + Math.pow(val - sma[i], 2), 0) / period);
          const upperBand = sma[i] + stdMultiplier * std4;
          const lowerBand = sma[i] - stdMultiplier * std4;
          if (closes[i] < lowerBand) {
            signals.push({ timestamp: data[i].timestamp, signal: "buy" });
          } else if (closes[i] > upperBand) {
            signals.push({ timestamp: data[i].timestamp, signal: "sell" });
          } else {
            signals.push({ timestamp: data[i].timestamp, signal: "hold" });
          }
        }
      }
      break;
    }
    case "trend_following": {
      const period = strategy.parameters.period || 14;
      const overbought = strategy.parameters.overbought || 70;
      const oversold = strategy.parameters.oversold || 30;
      const rsi = calculateRSI(closes, period);
      const ema = calculateEMA2(closes, 50);
      for (let i = 0; i < data.length; i++) {
        if (isNaN(rsi[i]) || isNaN(ema[i])) {
          signals.push({ timestamp: data[i].timestamp, signal: "hold" });
        } else if (closes[i] > ema[i] && rsi[i] < oversold) {
          signals.push({ timestamp: data[i].timestamp, signal: "buy" });
        } else if (closes[i] < ema[i] && rsi[i] > overbought) {
          signals.push({ timestamp: data[i].timestamp, signal: "sell" });
        } else {
          signals.push({ timestamp: data[i].timestamp, signal: "hold" });
        }
      }
      break;
    }
    default:
      for (const d of data) {
        signals.push({ timestamp: d.timestamp, signal: "hold" });
      }
  }
  return signals;
}
async function runBacktest(config) {
  const allTrades = [];
  const equityCurve = [];
  const drawdownCurve = [];
  let cash = config.initialCapital;
  let peakEquity = config.initialCapital;
  const positions = /* @__PURE__ */ new Map();
  const symbolData = /* @__PURE__ */ new Map();
  for (const symbol of config.symbols) {
    const data = await fetchHistoricalData(symbol, config.startDate, config.endDate);
    if (data.length > 0) {
      symbolData.set(symbol, data);
    }
  }
  if (symbolData.size === 0) {
    throw new Error("No historical data available for the specified symbols and date range");
  }
  const symbolSignals = /* @__PURE__ */ new Map();
  for (const [symbol, data] of Array.from(symbolData.entries())) {
    const signals = generateSignals(data, config.strategy);
    symbolSignals.set(symbol, signals);
  }
  const allTimestamps = /* @__PURE__ */ new Set();
  for (const [, data] of Array.from(symbolData.entries())) {
    for (const d of data) {
      allTimestamps.add(d.timestamp);
    }
  }
  const sortedTimestamps = Array.from(allTimestamps).sort((a, b) => a - b);
  for (const timestamp2 of sortedTimestamps) {
    const date2 = new Date(timestamp2);
    for (const [symbol, signals] of Array.from(symbolSignals.entries())) {
      const signalIndex = signals.findIndex((s) => s.timestamp === timestamp2);
      if (signalIndex === -1) continue;
      const signal = signals[signalIndex];
      const data = symbolData.get(symbol);
      const dataIndex = data.findIndex((d) => d.timestamp === timestamp2);
      if (dataIndex === -1) continue;
      const currentPrice = data[dataIndex].close;
      const position = positions.get(symbol);
      let positionSize = 0;
      if (config.strategy.positionSizing === "fixed") {
        positionSize = config.strategy.maxPositionSize;
      } else if (config.strategy.positionSizing === "percent") {
        positionSize = cash * config.strategy.maxPositionSize / 100;
      }
      if (position) {
        const pnlPercent = (currentPrice - position.entryPrice) / position.entryPrice;
        if (config.strategy.stopLoss && pnlPercent <= -config.strategy.stopLoss) {
          const exitPrice = currentPrice * (1 - config.slippage);
          const pnl = (exitPrice - position.entryPrice) * position.quantity - config.commission * 2;
          allTrades.push({
            symbol,
            entryDate: position.entryDate,
            entryPrice: position.entryPrice,
            exitDate: date2,
            exitPrice,
            side: "long",
            quantity: position.quantity,
            pnl,
            pnlPercent: pnl / (position.entryPrice * position.quantity),
            exitReason: "stop_loss"
          });
          cash += exitPrice * position.quantity;
          positions.delete(symbol);
          continue;
        }
        if (config.strategy.takeProfit && pnlPercent >= config.strategy.takeProfit) {
          const exitPrice = currentPrice * (1 - config.slippage);
          const pnl = (exitPrice - position.entryPrice) * position.quantity - config.commission * 2;
          allTrades.push({
            symbol,
            entryDate: position.entryDate,
            entryPrice: position.entryPrice,
            exitDate: date2,
            exitPrice,
            side: "long",
            quantity: position.quantity,
            pnl,
            pnlPercent: pnl / (position.entryPrice * position.quantity),
            exitReason: "take_profit"
          });
          cash += exitPrice * position.quantity;
          positions.delete(symbol);
          continue;
        }
      }
      if (signal.signal === "buy" && !position && positionSize > 0) {
        const entryPrice = currentPrice * (1 + config.slippage);
        const quantity = Math.floor(positionSize / entryPrice);
        if (quantity > 0 && cash >= entryPrice * quantity + config.commission) {
          cash -= entryPrice * quantity + config.commission;
          positions.set(symbol, { quantity, entryPrice, entryDate: date2 });
        }
      } else if (signal.signal === "sell" && position) {
        const exitPrice = currentPrice * (1 - config.slippage);
        const pnl = (exitPrice - position.entryPrice) * position.quantity - config.commission * 2;
        allTrades.push({
          symbol,
          entryDate: position.entryDate,
          entryPrice: position.entryPrice,
          exitDate: date2,
          exitPrice,
          side: "long",
          quantity: position.quantity,
          pnl,
          pnlPercent: pnl / (position.entryPrice * position.quantity),
          exitReason: "signal"
        });
        cash += exitPrice * position.quantity;
        positions.delete(symbol);
      }
    }
    let positionsValue = 0;
    for (const [symbol, position] of Array.from(positions.entries())) {
      const data = symbolData.get(symbol);
      const dataIndex = data?.findIndex((d) => d.timestamp === timestamp2);
      if (dataIndex !== void 0 && dataIndex !== -1 && data) {
        positionsValue += data[dataIndex].close * position.quantity;
      }
    }
    const currentEquity = cash + positionsValue;
    equityCurve.push({ date: date2, equity: currentEquity });
    if (currentEquity > peakEquity) {
      peakEquity = currentEquity;
    }
    const drawdown = (peakEquity - currentEquity) / peakEquity;
    drawdownCurve.push({ date: date2, drawdown });
  }
  const lastTimestamp = sortedTimestamps[sortedTimestamps.length - 1];
  for (const [symbol, position] of Array.from(positions.entries())) {
    const data = symbolData.get(symbol);
    const lastData = data?.[data.length - 1];
    if (lastData) {
      const exitPrice = lastData.close;
      const pnl = (exitPrice - position.entryPrice) * position.quantity - config.commission * 2;
      allTrades.push({
        symbol,
        entryDate: position.entryDate,
        entryPrice: position.entryPrice,
        exitDate: new Date(lastTimestamp),
        exitPrice,
        side: "long",
        quantity: position.quantity,
        pnl,
        pnlPercent: pnl / (position.entryPrice * position.quantity),
        exitReason: "end_of_test"
      });
      cash += exitPrice * position.quantity;
    }
  }
  const finalEquity = cash;
  const totalReturn = (finalEquity - config.initialCapital) / config.initialCapital;
  const tradingDays = sortedTimestamps.length;
  const years = tradingDays / 252;
  const annualizedReturn = Math.pow(1 + totalReturn, 1 / years) - 1;
  const winningTrades = allTrades.filter((t2) => (t2.pnl || 0) > 0);
  const losingTrades = allTrades.filter((t2) => (t2.pnl || 0) <= 0);
  const winRate = allTrades.length > 0 ? winningTrades.length / allTrades.length : 0;
  const totalWins = winningTrades.reduce((sum2, t2) => sum2 + (t2.pnl || 0), 0);
  const totalLosses = Math.abs(losingTrades.reduce((sum2, t2) => sum2 + (t2.pnl || 0), 0));
  const profitFactor = totalLosses > 0 ? totalWins / totalLosses : totalWins > 0 ? Infinity : 0;
  const averageWin = winningTrades.length > 0 ? totalWins / winningTrades.length : 0;
  const averageLoss = losingTrades.length > 0 ? totalLosses / losingTrades.length : 0;
  const returns = [];
  for (let i = 1; i < equityCurve.length; i++) {
    returns.push((equityCurve[i].equity - equityCurve[i - 1].equity) / equityCurve[i - 1].equity);
  }
  const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
  const stdReturn = Math.sqrt(returns.reduce((sum2, r) => sum2 + Math.pow(r - avgReturn, 2), 0) / returns.length);
  const sharpeRatio = stdReturn > 0 ? avgReturn * 252 / (stdReturn * Math.sqrt(252)) : 0;
  const negativeReturns = returns.filter((r) => r < 0);
  const downsideDeviation = negativeReturns.length > 0 ? Math.sqrt(negativeReturns.reduce((sum2, r) => sum2 + Math.pow(r, 2), 0) / negativeReturns.length) : 0;
  const sortinoRatio = downsideDeviation > 0 ? avgReturn * 252 / (downsideDeviation * Math.sqrt(252)) : 0;
  const maxDrawdown = Math.max(...drawdownCurve.map((d) => d.drawdown));
  let maxDrawdownDuration = 0;
  let currentDrawdownDuration = 0;
  for (const d of drawdownCurve) {
    if (d.drawdown > 0) {
      currentDrawdownDuration++;
      maxDrawdownDuration = Math.max(maxDrawdownDuration, currentDrawdownDuration);
    } else {
      currentDrawdownDuration = 0;
    }
  }
  const holdingPeriods = allTrades.filter((t2) => t2.exitDate).map((t2) => (t2.exitDate.getTime() - t2.entryDate.getTime()) / (1e3 * 60 * 60 * 24));
  const averageHoldingPeriod = holdingPeriods.length > 0 ? holdingPeriods.reduce((a, b) => a + b, 0) / holdingPeriods.length : 0;
  const calmarRatio = maxDrawdown > 0 ? annualizedReturn / maxDrawdown : 0;
  const metrics = {
    totalReturn,
    annualizedReturn,
    sharpeRatio,
    sortinoRatio,
    maxDrawdown,
    maxDrawdownDuration,
    winRate,
    profitFactor,
    averageWin,
    averageLoss,
    totalTrades: allTrades.length,
    winningTrades: winningTrades.length,
    losingTrades: losingTrades.length,
    averageHoldingPeriod,
    calmarRatio
  };
  return {
    config,
    trades: allTrades,
    metrics,
    equityCurve,
    drawdownCurve
  };
}

// server/services/backtestingValidation.ts
init_db();
init_schema();
init_dataApi();
import { eq as eq2, desc as desc2, and as and2 } from "drizzle-orm";
async function fetchHistoricalData2(symbol, startDate, endDate) {
  try {
    const daysDiff = Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
    let range = "max";
    if (daysDiff <= 30) range = "1mo";
    else if (daysDiff <= 90) range = "3mo";
    else if (daysDiff <= 180) range = "6mo";
    else if (daysDiff <= 365) range = "1y";
    else if (daysDiff <= 730) range = "2y";
    else if (daysDiff <= 1825) range = "5y";
    const response = await callDataApi("YahooFinance/get_stock_chart", {
      query: {
        symbol,
        region: "US",
        interval: "1d",
        range,
        includeAdjustedClose: true
      }
    });
    const chartResponse = response;
    if (!chartResponse?.chart?.result?.[0]) {
      return [];
    }
    const result = chartResponse.chart.result[0];
    const timestamps = result.timestamp || [];
    const quotes = result.indicators?.quote?.[0] || {};
    const adjClose = result.indicators?.adjclose?.[0]?.adjclose || [];
    const data = [];
    for (let i = 0; i < timestamps.length; i++) {
      const ts = timestamps[i] * 1e3;
      if (ts >= startDate.getTime() && ts <= endDate.getTime()) {
        data.push({
          timestamp: ts,
          open: quotes.open?.[i] || 0,
          high: quotes.high?.[i] || 0,
          low: quotes.low?.[i] || 0,
          close: adjClose[i] || quotes.close?.[i] || 0,
          volume: quotes.volume?.[i] || 0
        });
      }
    }
    return data;
  } catch (error) {
    console.error(`Failed to fetch historical data for ${symbol}:`, error);
    return [];
  }
}
function calculateMetrics(trades2, equityCurve, initialCapital, daysInTest) {
  const winningTrades = trades2.filter((t2) => t2.pnl > 0);
  const losingTrades = trades2.filter((t2) => t2.pnl <= 0);
  const totalReturn = equityCurve.length > 0 ? (equityCurve[equityCurve.length - 1].value - initialCapital) / initialCapital : 0;
  const annualizedReturn = Math.pow(1 + totalReturn, 365 / Math.max(daysInTest, 1)) - 1;
  const dailyReturns = [];
  for (let i = 1; i < equityCurve.length; i++) {
    dailyReturns.push((equityCurve[i].value - equityCurve[i - 1].value) / equityCurve[i - 1].value);
  }
  const avgDailyReturn = dailyReturns.length > 0 ? dailyReturns.reduce((a, b) => a + b, 0) / dailyReturns.length : 0;
  const stdDev = dailyReturns.length > 0 ? Math.sqrt(dailyReturns.reduce((sum2, r) => sum2 + Math.pow(r - avgDailyReturn, 2), 0) / dailyReturns.length) : 0;
  const downside = dailyReturns.filter((r) => r < 0);
  const downsideStdDev = downside.length > 0 ? Math.sqrt(downside.reduce((sum2, r) => sum2 + Math.pow(r, 2), 0) / downside.length) : 0;
  const sharpeRatio = stdDev > 0 ? avgDailyReturn * 252 / (stdDev * Math.sqrt(252)) : 0;
  const sortinoRatio = downsideStdDev > 0 ? avgDailyReturn * 252 / (downsideStdDev * Math.sqrt(252)) : 0;
  let maxDrawdown = 0;
  let peak = initialCapital;
  for (const point of equityCurve) {
    if (point.value > peak) peak = point.value;
    const drawdown = (peak - point.value) / peak;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
  }
  const winRate = trades2.length > 0 ? winningTrades.length / trades2.length : 0;
  const totalWins = winningTrades.reduce((sum2, t2) => sum2 + t2.pnl, 0);
  const totalLosses = Math.abs(losingTrades.reduce((sum2, t2) => sum2 + t2.pnl, 0));
  const profitFactor = totalLosses > 0 ? totalWins / totalLosses : totalWins > 0 ? Infinity : 0;
  const avgWin = winningTrades.length > 0 ? totalWins / winningTrades.length : 0;
  const avgLoss = losingTrades.length > 0 ? totalLosses / losingTrades.length : 0;
  const holdingPeriods = trades2.map(
    (t2) => (t2.exitDate.getTime() - t2.entryDate.getTime()) / (1e3 * 60 * 60 * 24)
  );
  const avgHoldingPeriod = holdingPeriods.length > 0 ? holdingPeriods.reduce((a, b) => a + b, 0) / holdingPeriods.length : 0;
  const calmarRatio = maxDrawdown > 0 ? annualizedReturn / maxDrawdown : 0;
  return {
    totalReturn,
    annualizedReturn,
    sharpeRatio,
    sortinoRatio,
    maxDrawdown,
    winRate,
    profitFactor,
    avgWin,
    avgLoss,
    totalTrades: trades2.length,
    winningTrades: winningTrades.length,
    losingTrades: losingTrades.length,
    avgHoldingPeriod,
    calmarRatio
  };
}
function generateStandardSignal(prices, index) {
  if (index < 50) {
    return { recommendation: "hold", confidence: 0.5 };
  }
  const sma20 = prices.slice(index - 19, index + 1).reduce((a, b) => a + b, 0) / 20;
  const sma50 = prices.slice(index - 49, index + 1).reduce((a, b) => a + b, 0) / 50;
  const prevSma20 = prices.slice(index - 20, index).reduce((a, b) => a + b, 0) / 20;
  const prevSma50 = prices.slice(index - 50, index - 1).reduce((a, b) => a + b, 0) / 50;
  let gains = 0, losses = 0;
  for (let i = index - 13; i <= index; i++) {
    const change = prices[i] - prices[i - 1];
    if (change > 0) gains += change;
    else losses -= change;
  }
  const rs = losses === 0 ? 100 : gains / losses;
  const rsi = 100 - 100 / (1 + rs);
  if (sma20 > sma50 && prevSma20 <= prevSma50) {
    return { recommendation: "strong_buy", confidence: 0.8 };
  } else if (sma20 > sma50 && rsi < 70) {
    return { recommendation: "buy", confidence: 0.65 };
  } else if (sma20 < sma50 && prevSma20 >= prevSma50) {
    return { recommendation: "strong_sell", confidence: 0.8 };
  } else if (sma20 < sma50 && rsi > 30) {
    return { recommendation: "sell", confidence: 0.65 };
  }
  return { recommendation: "hold", confidence: 0.5 };
}
async function generateEnhancedSignal(symbol, prices, volumes, highs, lows, index) {
  if (index < 50) {
    return { recommendation: "hold", confidence: 0.5, stopLoss: 0, takeProfit: 0 };
  }
  const currentPrice = prices[index];
  let gains = 0, losses = 0;
  for (let i = index - 13; i <= index; i++) {
    const change = prices[i] - prices[i - 1];
    if (change > 0) gains += change;
    else losses -= change;
  }
  const rs = losses === 0 ? 100 : gains / losses;
  const rsi = 100 - 100 / (1 + rs);
  const ema12 = calculateEMA3(prices.slice(0, index + 1), 12);
  const ema26 = calculateEMA3(prices.slice(0, index + 1), 26);
  const macd = ema12 - ema26;
  let atrSum = 0;
  for (let i = index - 13; i <= index; i++) {
    const tr = Math.max(
      highs[i] - lows[i],
      Math.abs(highs[i] - prices[i - 1]),
      Math.abs(lows[i] - prices[i - 1])
    );
    atrSum += tr;
  }
  const atr = atrSum / 14;
  const adx = calculateADX2(highs.slice(0, index + 1), lows.slice(0, index + 1), prices.slice(0, index + 1));
  const bbPeriod = 20;
  const bbPrices = prices.slice(index - bbPeriod + 1, index + 1);
  const bbMiddle = bbPrices.reduce((a, b) => a + b, 0) / bbPeriod;
  const bbStdDev = Math.sqrt(bbPrices.reduce((sum2, p) => sum2 + Math.pow(p - bbMiddle, 2), 0) / bbPeriod);
  const bbUpper = bbMiddle + 2 * bbStdDev;
  const bbLower = bbMiddle - 2 * bbStdDev;
  const percentB = (currentPrice - bbLower) / (bbUpper - bbLower);
  let score = 0;
  let confidence = 0.5;
  if (rsi < 30) score += 0.25;
  else if (rsi < 40) score += 0.125;
  else if (rsi > 70) score -= 0.25;
  else if (rsi > 60) score -= 0.125;
  if (macd > 0 && macd > prices[index] * 1e-3) score += 0.25;
  else if (macd > 0) score += 0.125;
  else if (macd < 0 && macd < -prices[index] * 1e-3) score -= 0.25;
  else if (macd < 0) score -= 0.125;
  if (percentB < 0.2) score += 0.2;
  else if (percentB < 0.4) score += 0.1;
  else if (percentB > 0.8) score -= 0.2;
  else if (percentB > 0.6) score -= 0.1;
  if (adx > 25) {
    score *= 1.2;
    confidence += 0.1;
  } else if (adx < 15) {
    score *= 0.8;
    confidence -= 0.1;
  }
  const avgVolume = volumes.slice(index - 19, index + 1).reduce((a, b) => a + b, 0) / 20;
  if (volumes[index] > avgVolume * 1.5) {
    confidence += 0.1;
  }
  let recommendation;
  if (score > 0.4) {
    recommendation = "strong_buy";
    confidence = Math.min(0.95, confidence + 0.2);
  } else if (score > 0.2) {
    recommendation = "buy";
    confidence = Math.min(0.85, confidence + 0.1);
  } else if (score < -0.4) {
    recommendation = "strong_sell";
    confidence = Math.min(0.95, confidence + 0.2);
  } else if (score < -0.2) {
    recommendation = "sell";
    confidence = Math.min(0.85, confidence + 0.1);
  } else {
    recommendation = "hold";
    confidence = 0.5;
  }
  const stopLoss = currentPrice - 2 * atr;
  const takeProfit = currentPrice + 3 * atr;
  return { recommendation, confidence, stopLoss, takeProfit };
}
function calculateEMA3(prices, period) {
  if (prices.length < period) return prices[prices.length - 1];
  const multiplier = 2 / (period + 1);
  let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
  for (let i = period; i < prices.length; i++) {
    ema = (prices[i] - ema) * multiplier + ema;
  }
  return ema;
}
function calculateADX2(highs, lows, closes) {
  const period = 14;
  const n = highs.length;
  if (n < period + 1) return 25;
  const plusDM = [];
  const minusDM = [];
  const tr = [];
  for (let i = 1; i < n; i++) {
    const upMove = highs[i] - highs[i - 1];
    const downMove = lows[i - 1] - lows[i];
    plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);
    minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);
    tr.push(Math.max(
      highs[i] - lows[i],
      Math.abs(highs[i] - closes[i - 1]),
      Math.abs(lows[i] - closes[i - 1])
    ));
  }
  const smoothedTR = tr.slice(-period).reduce((a, b) => a + b, 0);
  const smoothedPlusDM = plusDM.slice(-period).reduce((a, b) => a + b, 0);
  const smoothedMinusDM = minusDM.slice(-period).reduce((a, b) => a + b, 0);
  const plusDI = smoothedTR > 0 ? smoothedPlusDM / smoothedTR * 100 : 0;
  const minusDI = smoothedTR > 0 ? smoothedMinusDM / smoothedTR * 100 : 0;
  const dx = plusDI + minusDI > 0 ? Math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100 : 0;
  return dx;
}
async function runBacktestValidation(userId, config) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const [insertResult] = await db.insert(backtestResults).values({
    userId,
    name: `${config.strategyType} Backtest - ${config.symbol}`,
    symbol: config.symbol,
    startDate: config.startDate,
    endDate: config.endDate,
    initialCapital: config.initialCapital.toString(),
    strategyType: config.strategyType,
    strategyConfig: config.strategyConfig || {},
    status: "running"
  });
  const backtestId = insertResult.insertId;
  try {
    const historicalData = await fetchHistoricalData2(config.symbol, config.startDate, config.endDate);
    if (historicalData.length < 60) {
      throw new Error("Insufficient historical data for backtesting (need at least 60 days)");
    }
    const prices = historicalData.map((d) => d.close);
    const volumes = historicalData.map((d) => d.volume);
    const highs = historicalData.map((d) => d.high);
    const lows = historicalData.map((d) => d.low);
    const trades2 = [];
    const equityCurve = [];
    const drawdownCurve = [];
    let cash = config.initialCapital;
    let position = 0;
    let entryPrice = 0;
    let entryDate = null;
    let stopLoss = 0;
    let takeProfit = 0;
    let peak = config.initialCapital;
    const commission = config.commission || 1e-3;
    const slippage = config.slippage || 5e-4;
    const predictions = [];
    for (let i = 50; i < historicalData.length; i++) {
      const currentPrice = prices[i];
      const currentDate = new Date(historicalData[i].timestamp);
      const equity = cash + position * currentPrice;
      equityCurve.push({
        date: currentDate.toISOString().split("T")[0],
        value: equity
      });
      if (equity > peak) peak = equity;
      const drawdown = (peak - equity) / peak;
      drawdownCurve.push({
        date: currentDate.toISOString().split("T")[0],
        drawdown
      });
      let signal;
      if (config.strategyType === "enhanced") {
        signal = await generateEnhancedSignal(config.symbol, prices, volumes, highs, lows, i);
      } else {
        signal = generateStandardSignal(prices, i);
      }
      if (i < historicalData.length - 5) {
        const futureReturn = (prices[i + 5] - currentPrice) / currentPrice;
        predictions.push({
          recommendation: signal.recommendation,
          confidence: signal.confidence,
          actualReturn: futureReturn
        });
      }
      if (position > 0) {
        if (currentPrice <= stopLoss) {
          const exitPrice = currentPrice * (1 - slippage);
          const pnl = (exitPrice - entryPrice) * position - commission * exitPrice * position;
          trades2.push({
            entryDate,
            entryPrice,
            exitDate: currentDate,
            exitPrice,
            side: "long",
            quantity: position,
            pnl,
            pnlPercent: (exitPrice - entryPrice) / entryPrice,
            recommendation: signal.recommendation,
            confidence: signal.confidence,
            exitReason: "stop_loss"
          });
          cash += exitPrice * position - commission * exitPrice * position;
          position = 0;
          entryDate = null;
          continue;
        }
        if (currentPrice >= takeProfit) {
          const exitPrice = currentPrice * (1 - slippage);
          const pnl = (exitPrice - entryPrice) * position - commission * exitPrice * position;
          trades2.push({
            entryDate,
            entryPrice,
            exitDate: currentDate,
            exitPrice,
            side: "long",
            quantity: position,
            pnl,
            pnlPercent: (exitPrice - entryPrice) / entryPrice,
            recommendation: signal.recommendation,
            confidence: signal.confidence,
            exitReason: "take_profit"
          });
          cash += exitPrice * position - commission * exitPrice * position;
          position = 0;
          entryDate = null;
          continue;
        }
      }
      if (position === 0 && (signal.recommendation === "strong_buy" || signal.recommendation === "buy")) {
        const buyPrice = currentPrice * (1 + slippage);
        const positionSize = Math.floor(cash * 0.95 / buyPrice);
        if (positionSize > 0) {
          position = positionSize;
          entryPrice = buyPrice;
          entryDate = currentDate;
          cash -= buyPrice * positionSize + commission * buyPrice * positionSize;
          if (signal.stopLoss && signal.takeProfit) {
            stopLoss = signal.stopLoss;
            takeProfit = signal.takeProfit;
          } else {
            stopLoss = buyPrice * 0.98;
            takeProfit = buyPrice * 1.04;
          }
        }
      } else if (position > 0 && (signal.recommendation === "strong_sell" || signal.recommendation === "sell")) {
        const exitPrice = currentPrice * (1 - slippage);
        const pnl = (exitPrice - entryPrice) * position - commission * exitPrice * position;
        trades2.push({
          entryDate,
          entryPrice,
          exitDate: currentDate,
          exitPrice,
          side: "long",
          quantity: position,
          pnl,
          pnlPercent: (exitPrice - entryPrice) / entryPrice,
          recommendation: signal.recommendation,
          confidence: signal.confidence,
          exitReason: "signal"
        });
        cash += exitPrice * position - commission * exitPrice * position;
        position = 0;
        entryDate = null;
      }
    }
    if (position > 0) {
      const exitPrice = prices[prices.length - 1] * (1 - slippage);
      const pnl = (exitPrice - entryPrice) * position - commission * exitPrice * position;
      trades2.push({
        entryDate,
        entryPrice,
        exitDate: new Date(historicalData[historicalData.length - 1].timestamp),
        exitPrice,
        side: "long",
        quantity: position,
        pnl,
        pnlPercent: (exitPrice - entryPrice) / entryPrice,
        recommendation: "end",
        confidence: 0,
        exitReason: "end_of_test"
      });
      cash += exitPrice * position;
    }
    const daysInTest = Math.ceil((config.endDate.getTime() - config.startDate.getTime()) / (1e3 * 60 * 60 * 24));
    const metrics = calculateMetrics(trades2, equityCurve, config.initialCapital, daysInTest);
    const accuracyByRec = {};
    let totalCorrect = 0;
    for (const pred of predictions) {
      const isBullish = pred.recommendation === "strong_buy" || pred.recommendation === "buy";
      const isBearish = pred.recommendation === "strong_sell" || pred.recommendation === "sell";
      const isCorrect = isBullish && pred.actualReturn > 0 || isBearish && pred.actualReturn < 0 || pred.recommendation === "hold" && Math.abs(pred.actualReturn) < 0.02;
      if (isCorrect) totalCorrect++;
      if (!accuracyByRec[pred.recommendation]) {
        accuracyByRec[pred.recommendation] = { total: 0, correct: 0, accuracy: 0 };
      }
      accuracyByRec[pred.recommendation].total++;
      if (isCorrect) accuracyByRec[pred.recommendation].correct++;
    }
    for (const rec of Object.keys(accuracyByRec)) {
      accuracyByRec[rec].accuracy = accuracyByRec[rec].total > 0 ? accuracyByRec[rec].correct / accuracyByRec[rec].total : 0;
    }
    const analysisAccuracy = {
      totalPredictions: predictions.length,
      correctPredictions: totalCorrect,
      accuracyRate: predictions.length > 0 ? totalCorrect / predictions.length : 0,
      avgConfidence: predictions.length > 0 ? predictions.reduce((sum2, p) => sum2 + p.confidence, 0) / predictions.length : 0,
      byRecommendation: accuracyByRec
    };
    await db.update(backtestResults).set({
      finalCapital: (cash + position * prices[prices.length - 1]).toString(),
      totalReturn: metrics.totalReturn.toString(),
      annualizedReturn: metrics.annualizedReturn.toString(),
      sharpeRatio: metrics.sharpeRatio.toString(),
      sortinoRatio: metrics.sortinoRatio.toString(),
      maxDrawdown: metrics.maxDrawdown.toString(),
      winRate: metrics.winRate.toString(),
      profitFactor: metrics.profitFactor.toString(),
      totalTrades: metrics.totalTrades,
      winningTrades: metrics.winningTrades,
      losingTrades: metrics.losingTrades,
      avgWin: metrics.avgWin.toString(),
      avgLoss: metrics.avgLoss.toString(),
      equityCurve,
      trades: trades2.map((t2) => ({
        ...t2,
        entryDate: t2.entryDate.toISOString(),
        exitDate: t2.exitDate.toISOString()
      })),
      status: "completed",
      completedAt: /* @__PURE__ */ new Date()
    }).where(eq2(backtestResults.id, backtestId));
    return {
      id: backtestId,
      config,
      trades: trades2,
      metrics,
      equityCurve,
      drawdownCurve,
      analysisAccuracy,
      status: "completed"
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    await db.update(backtestResults).set({
      status: "failed",
      errorMessage
    }).where(eq2(backtestResults.id, backtestId));
    return {
      id: backtestId,
      config,
      trades: [],
      metrics: {
        totalReturn: 0,
        annualizedReturn: 0,
        sharpeRatio: 0,
        sortinoRatio: 0,
        maxDrawdown: 0,
        winRate: 0,
        profitFactor: 0,
        avgWin: 0,
        avgLoss: 0,
        totalTrades: 0,
        winningTrades: 0,
        losingTrades: 0,
        avgHoldingPeriod: 0,
        calmarRatio: 0
      },
      equityCurve: [],
      drawdownCurve: [],
      analysisAccuracy: {
        totalPredictions: 0,
        correctPredictions: 0,
        accuracyRate: 0,
        avgConfidence: 0,
        byRecommendation: {}
      },
      status: "failed",
      errorMessage
    };
  }
}
async function getUserBacktests2(userId, limit = 20) {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select().from(backtestResults).where(eq2(backtestResults.userId, userId)).orderBy(desc2(backtestResults.createdAt)).limit(limit);
  return results;
}
async function getBacktestById2(backtestId, userId) {
  const db = await getDb();
  if (!db) return null;
  const [result] = await db.select().from(backtestResults).where(and2(
    eq2(backtestResults.id, backtestId),
    eq2(backtestResults.userId, userId)
  ));
  return result;
}

// server/services/rlAgent.ts
init_db();
init_schema();
import { eq as eq3 } from "drizzle-orm";
var DEFAULT_CONFIG = {
  learningRate: 1e-4,
  gamma: 0.99,
  epsilon: 1,
  epsilonDecay: 0.995,
  epsilonMin: 0.01,
  batchSize: 64,
  memorySize: 1e5,
  targetUpdateFreq: 100,
  hiddenLayers: [128, 64, 32]
};
var STATE_DIM = 14;
var ACTION_DIM = 4;
function initializeNetwork(config) {
  const layers = [STATE_DIM, ...config.hiddenLayers, ACTION_DIM];
  const weights = [];
  const biases = [];
  for (let i = 0; i < layers.length - 1; i++) {
    const inputSize = layers[i];
    const outputSize = layers[i + 1];
    const scale = Math.sqrt(2 / (inputSize + outputSize));
    const layerWeights = [];
    for (let j = 0; j < outputSize; j++) {
      const neuronWeights = [];
      for (let k = 0; k < inputSize; k++) {
        neuronWeights.push((Math.random() * 2 - 1) * scale);
      }
      layerWeights.push(neuronWeights);
    }
    weights.push(layerWeights);
    const layerBiases = new Array(outputSize).fill(0);
    biases.push(layerBiases);
  }
  return { weights, biases };
}
function relu(x) {
  return Math.max(0, x);
}
function forward(network, state) {
  let current = state;
  for (let layer = 0; layer < network.weights.length; layer++) {
    const layerWeights = network.weights[layer];
    const layerBiases = network.biases[layer];
    const output = [];
    for (let j = 0; j < layerWeights.length; j++) {
      let sum2 = layerBiases[j];
      for (let k = 0; k < current.length; k++) {
        sum2 += layerWeights[j][k] * current[k];
      }
      output.push(layer < network.weights.length - 1 ? relu(sum2) : sum2);
    }
    current = output;
  }
  return current;
}
function stateToArray(state) {
  return [
    state.priceChange1d,
    state.priceChange5d,
    state.priceChange20d,
    state.volatility,
    state.rsi,
    state.macdHistogram,
    state.bollingerPosition,
    state.adx,
    state.atr,
    state.marketRegime,
    state.vixLevel,
    state.currentPosition,
    state.unrealizedPnl,
    state.daysInPosition
  ];
}
function selectAction(network, state, epsilon) {
  const qValues = forward(network, stateToArray(state));
  if (Math.random() < epsilon) {
    return { action: Math.floor(Math.random() * ACTION_DIM), qValues };
  }
  let maxQ = qValues[0];
  let maxAction = 0;
  for (let i = 1; i < qValues.length; i++) {
    if (qValues[i] > maxQ) {
      maxQ = qValues[i];
      maxAction = i;
    }
  }
  return { action: maxAction, qValues };
}
var RLTradingAgent = class {
  config;
  qNetwork;
  targetNetwork;
  replayBuffer = [];
  stepCount = 0;
  epsilon;
  modelId = null;
  constructor(config = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.qNetwork = initializeNetwork(this.config);
    this.targetNetwork = initializeNetwork(this.config);
    this.epsilon = this.config.epsilon;
    this.updateTargetNetwork();
  }
  /**
   * Update target network weights from Q-network
   */
  updateTargetNetwork() {
    this.targetNetwork = JSON.parse(JSON.stringify(this.qNetwork));
  }
  /**
   * Store experience in replay buffer
   */
  storeExperience(experience) {
    if (this.replayBuffer.length >= this.config.memorySize) {
      this.replayBuffer.shift();
    }
    this.replayBuffer.push(experience);
  }
  /**
   * Sample a batch from replay buffer
   */
  sampleBatch() {
    const batch = [];
    const indices = /* @__PURE__ */ new Set();
    while (indices.size < Math.min(this.config.batchSize, this.replayBuffer.length)) {
      indices.add(Math.floor(Math.random() * this.replayBuffer.length));
    }
    const indicesArray = Array.from(indices);
    for (const idx of indicesArray) {
      batch.push(this.replayBuffer[idx]);
    }
    return batch;
  }
  /**
   * Train the network on a batch of experiences
   */
  train() {
    if (this.replayBuffer.length < this.config.batchSize) {
      return { loss: 0 };
    }
    const batch = this.sampleBatch();
    let totalLoss = 0;
    for (const exp of batch) {
      const stateArray = stateToArray(exp.state);
      const nextStateArray = stateToArray(exp.nextState);
      const currentQ = forward(this.qNetwork, stateArray);
      const nextQMain = forward(this.qNetwork, nextStateArray);
      const nextQTarget = forward(this.targetNetwork, nextStateArray);
      let bestNextAction = 0;
      let maxNextQ = nextQMain[0];
      for (let i = 1; i < nextQMain.length; i++) {
        if (nextQMain[i] > maxNextQ) {
          maxNextQ = nextQMain[i];
          bestNextAction = i;
        }
      }
      const target = exp.done ? exp.reward : exp.reward + this.config.gamma * nextQTarget[bestNextAction];
      const tdError = target - currentQ[exp.action];
      totalLoss += tdError * tdError;
      this.updateWeights(stateArray, exp.action, tdError);
    }
    this.epsilon = Math.max(
      this.config.epsilonMin,
      this.epsilon * this.config.epsilonDecay
    );
    this.stepCount++;
    if (this.stepCount % this.config.targetUpdateFreq === 0) {
      this.updateTargetNetwork();
    }
    return { loss: totalLoss / batch.length };
  }
  /**
   * Update network weights using gradient descent
   */
  updateWeights(state, action, tdError) {
    const lr = this.config.learningRate;
    const activations = [state];
    let current = state;
    for (let layer = 0; layer < this.qNetwork.weights.length; layer++) {
      const layerWeights = this.qNetwork.weights[layer];
      const layerBiases = this.qNetwork.biases[layer];
      const output = [];
      for (let j = 0; j < layerWeights.length; j++) {
        let sum2 = layerBiases[j];
        for (let k = 0; k < current.length; k++) {
          sum2 += layerWeights[j][k] * current[k];
        }
        output.push(layer < this.qNetwork.weights.length - 1 ? relu(sum2) : sum2);
      }
      activations.push(output);
      current = output;
    }
    const lastLayer = this.qNetwork.weights.length - 1;
    const lastActivation = activations[lastLayer];
    for (let k = 0; k < lastActivation.length; k++) {
      this.qNetwork.weights[lastLayer][action][k] += lr * tdError * lastActivation[k];
    }
    this.qNetwork.biases[lastLayer][action] += lr * tdError;
    let gradient = tdError;
    for (let layer = lastLayer - 1; layer >= 0; layer--) {
      const activation = activations[layer];
      const nextActivation = activations[layer + 1];
      for (let j = 0; j < this.qNetwork.weights[layer].length; j++) {
        if (nextActivation[j] > 0) {
          for (let k = 0; k < activation.length; k++) {
            this.qNetwork.weights[layer][j][k] += lr * gradient * 0.1 * activation[k];
          }
          this.qNetwork.biases[layer][j] += lr * gradient * 0.1;
        }
      }
      gradient *= 0.5;
    }
  }
  /**
   * Get action recommendation for current state
   */
  getAction(state) {
    const { action, qValues } = selectAction(this.qNetwork, state, 0);
    const maxQ = Math.max(...qValues);
    const minQ = Math.min(...qValues);
    const range = maxQ - minQ;
    const confidence = range > 0 ? (qValues[action] - minQ) / range : 0.5;
    const actionTypes = ["hold", "buy", "sell", "close"];
    return {
      type: actionTypes[action],
      confidence: Math.min(Math.max(confidence, 0), 1)
    };
  }
  /**
   * Get Q-values for all actions
   */
  getQValues(state) {
    const qValues = forward(this.qNetwork, stateToArray(state));
    const actionTypes = ["hold", "buy", "sell", "close"];
    return actionTypes.map((action, i) => ({
      action,
      qValue: qValues[i]
    }));
  }
  /**
   * Save model to database
   */
  async saveModel(userId, name, symbol) {
    const db = await getDb();
    if (!db) throw new Error("Database not available");
    const modelData = {
      qNetwork: this.qNetwork,
      targetNetwork: this.targetNetwork,
      config: this.config,
      epsilon: this.epsilon,
      stepCount: this.stepCount,
      replayBufferSize: this.replayBuffer.length
    };
    const [result] = await db.insert(rlAgentModels).values({
      userId,
      name,
      symbol,
      modelData: JSON.stringify(modelData),
      config: JSON.stringify(this.config),
      totalEpisodes: this.stepCount
    });
    const insertId = result.insertId?.toString() || "";
    this.modelId = insertId;
    return insertId;
  }
  /**
   * Load model from database
   */
  async loadModel(modelId) {
    const db = await getDb();
    const [model] = await db.select().from(rlAgentModels).where(eq3(rlAgentModels.id, parseInt(modelId))).limit(1);
    if (!model) {
      return false;
    }
    const modelData = JSON.parse(model.modelData);
    this.qNetwork = modelData.qNetwork;
    this.targetNetwork = modelData.targetNetwork;
    this.config = modelData.config;
    this.epsilon = modelData.epsilon;
    this.stepCount = modelData.stepCount;
    this.modelId = modelId;
    return true;
  }
  /**
   * Log training history
   */
  async logTraining(episode, totalReward, avgLoss, portfolioValue) {
    if (!this.modelId) return;
    const db = await getDb();
    await db.insert(rlTrainingHistory).values({
      modelId: parseInt(this.modelId),
      episode,
      totalReward: totalReward.toString(),
      avgLoss: avgLoss.toString(),
      steps: 1,
      epsilon: this.epsilon.toString()
    });
  }
  /**
   * Get training statistics
   */
  getStats() {
    return {
      epsilon: this.epsilon,
      stepCount: this.stepCount,
      bufferSize: this.replayBuffer.length,
      config: this.config
    };
  }
};

// server/routers.ts
init_monteCarloSimulation();

// server/services/walkForwardOptimization.ts
init_dataApi();
async function fetchHistoricalData3(symbol) {
  try {
    const response = await callDataApi("YahooFinance/get_stock_chart", {
      query: {
        symbol,
        region: "US",
        interval: "1d",
        range: "5y",
        includeAdjustedClose: true
      }
    });
    if (!response?.chart?.result?.[0]) {
      throw new Error("No data returned from API");
    }
    const result = response.chart.result[0];
    const timestamps = result.timestamp;
    const quotes = result.indicators.quote[0];
    const data = [];
    for (let i = 0; i < timestamps.length; i++) {
      if (quotes.close[i] !== null) {
        data.push({
          date: new Date(timestamps[i] * 1e3),
          open: quotes.open[i] || quotes.close[i] || 0,
          high: quotes.high[i] || quotes.close[i] || 0,
          low: quotes.low[i] || quotes.close[i] || 0,
          close: quotes.close[i] || 0,
          volume: quotes.volume[i] || 0
        });
      }
    }
    return data;
  } catch (error) {
    console.error(`[WalkForward] Error fetching data for ${symbol}:`, error);
    return generateSyntheticData(252 * 5);
  }
}
function generateSyntheticData(days) {
  const data = [];
  let price = 100;
  const startDate = /* @__PURE__ */ new Date();
  startDate.setDate(startDate.getDate() - days);
  for (let i = 0; i < days; i++) {
    const date2 = new Date(startDate);
    date2.setDate(date2.getDate() + i);
    const dailyReturn = (Math.random() - 0.48) * 0.03;
    price *= 1 + dailyReturn;
    const volatility = price * 0.02;
    data.push({
      date: date2,
      open: price - volatility * Math.random(),
      high: price + volatility * Math.random(),
      low: price - volatility * Math.random(),
      close: price,
      volume: Math.floor(Math.random() * 1e7)
    });
  }
  return data;
}
function calculateIndicators(data, index) {
  const lookback = Math.min(index, 50);
  const prices = data.slice(Math.max(0, index - lookback), index + 1).map((d) => d.close);
  if (prices.length < 2) {
    return {
      priceChange1d: 0,
      priceChange5d: 0,
      priceChange20d: 0,
      volatility: 0.02,
      rsi: 50,
      macdHistogram: 0,
      bollingerPosition: 0.5,
      adx: 25,
      atr: 0.02,
      marketRegime: 0,
      vixLevel: 20,
      currentPosition: 0,
      unrealizedPnl: 0,
      daysInPosition: 0
    };
  }
  const currentPrice = prices[prices.length - 1];
  const priceChange1d = prices.length > 1 ? (currentPrice - prices[prices.length - 2]) / prices[prices.length - 2] : 0;
  const priceChange5d = prices.length > 5 ? (currentPrice - prices[prices.length - 6]) / prices[prices.length - 6] : 0;
  const priceChange20d = prices.length > 20 ? (currentPrice - prices[prices.length - 21]) / prices[prices.length - 21] : 0;
  const gains = [];
  const losses = [];
  for (let i = 1; i < Math.min(prices.length, 15); i++) {
    const change = prices[i] - prices[i - 1];
    if (change > 0) gains.push(change);
    else losses.push(Math.abs(change));
  }
  const avgGain = gains.length > 0 ? gains.reduce((a, b) => a + b, 0) / 14 : 0;
  const avgLoss = losses.length > 0 ? losses.reduce((a, b) => a + b, 0) / 14 : 1e-3;
  const rs = avgGain / avgLoss;
  const rsi = 100 - 100 / (1 + rs);
  const returns = [];
  for (let i = 1; i < prices.length; i++) {
    returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
  }
  const volatility = returns.length > 0 ? Math.sqrt(returns.map((r) => r * r).reduce((a, b) => a + b, 0) / returns.length) * Math.sqrt(252) : 0.2;
  const sma20 = prices.slice(-20).reduce((a, b) => a + b, 0) / Math.min(20, prices.length);
  const stdDev = Math.sqrt(prices.slice(-20).map((p) => Math.pow(p - sma20, 2)).reduce((a, b) => a + b, 0) / Math.min(20, prices.length));
  const upperBand = sma20 + 2 * stdDev;
  const lowerBand = sma20 - 2 * stdDev;
  const bollingerPosition = stdDev > 0 ? (currentPrice - lowerBand) / (upperBand - lowerBand) : 0.5;
  let marketRegime = 0;
  if (priceChange20d > 0.05) marketRegime = 1;
  else if (priceChange20d < -0.05) marketRegime = -1;
  return {
    priceChange1d,
    priceChange5d,
    priceChange20d,
    volatility,
    rsi,
    macdHistogram: priceChange5d * 100,
    bollingerPosition: Math.max(0, Math.min(1, bollingerPosition)),
    adx: 25 + Math.abs(priceChange20d) * 100,
    atr: volatility / Math.sqrt(252),
    marketRegime,
    vixLevel: 15 + volatility * 50,
    currentPosition: 0,
    unrealizedPnl: 0,
    daysInPosition: 0
  };
}
async function evaluateWindow(data, trainingStart, trainingEnd, testingStart, testingEnd, strategyType, initialCapital) {
  const trainingData = data.slice(trainingStart, trainingEnd);
  const testingData = data.slice(testingStart, testingEnd);
  if (strategyType === "rl") {
    const agent = new RLTradingAgent({
      learningRate: 1e-3,
      gamma: 0.95,
      epsilon: 1,
      epsilonDecay: 0.995,
      epsilonMin: 0.01,
      batchSize: 32,
      memorySize: 1e4
    });
    let trainingTrades = 0;
    let trainingWins = 0;
    let trainingReturns = [];
    let position = 0;
    let entryPrice = 0;
    for (let i = 20; i < trainingData.length; i++) {
      const state = calculateIndicators(trainingData, i);
      state.currentPosition = position;
      const actionResult = agent.getAction(state);
      const actionMap = { hold: 0, buy: 1, sell: 2, close: 3 };
      const action = actionMap[actionResult.type];
      const currentPrice = trainingData[i].close;
      let reward = 0;
      if (action === 1 && position === 0) {
        position = 1;
        entryPrice = currentPrice;
      } else if (action === 2 && position === 1) {
        const tradeReturn = (currentPrice - entryPrice) / entryPrice;
        reward = tradeReturn * 100;
        trainingReturns.push(tradeReturn);
        trainingTrades++;
        if (tradeReturn > 0) trainingWins++;
        position = 0;
      }
      if (i < trainingData.length - 1) {
        const nextState = calculateIndicators(trainingData, i + 1);
        nextState.currentPosition = position;
        const experience = {
          state,
          action,
          reward,
          nextState,
          done: false
        };
        agent.storeExperience(experience);
        agent.train();
      }
    }
    let testingTrades = 0;
    let testingWins = 0;
    let testingReturns = [];
    let equity = initialCapital;
    let peak = equity;
    let maxDrawdown = 0;
    position = 0;
    for (let i = 20; i < testingData.length; i++) {
      const state = calculateIndicators(testingData, i);
      state.currentPosition = position;
      const actionResult = agent.getAction(state);
      const actionMap = { hold: 0, buy: 1, sell: 2, close: 3 };
      const action = actionMap[actionResult.type];
      const currentPrice = testingData[i].close;
      if (action === 1 && position === 0) {
        position = 1;
        entryPrice = currentPrice;
      } else if (action === 2 && position === 1) {
        const tradeReturn = (currentPrice - entryPrice) / entryPrice;
        testingReturns.push(tradeReturn);
        equity *= 1 + tradeReturn;
        testingTrades++;
        if (tradeReturn > 0) testingWins++;
        position = 0;
      }
      if (equity > peak) peak = equity;
      const drawdown = (peak - equity) / peak;
      if (drawdown > maxDrawdown) maxDrawdown = drawdown;
    }
    const trainingReturn = trainingReturns.reduce((a, b) => a + b, 0);
    const testingReturn = testingReturns.reduce((a, b) => a + b, 0);
    const trainingSharpe = trainingReturns.length > 1 ? mean2(trainingReturns) / std2(trainingReturns) * Math.sqrt(252) : 0;
    const testingSharpe = testingReturns.length > 1 ? mean2(testingReturns) / std2(testingReturns) * Math.sqrt(252) : 0;
    return {
      trainingReturn,
      trainingSharpe,
      trainingWinRate: trainingTrades > 0 ? trainingWins / trainingTrades : 0,
      testingReturn,
      testingSharpe,
      testingWinRate: testingTrades > 0 ? testingWins / testingTrades : 0,
      testingMaxDrawdown: maxDrawdown,
      modelParameters: {
        trainingTrades,
        testingTrades
      }
    };
  }
  return evaluateSimpleStrategy(trainingData, testingData, strategyType, initialCapital);
}
function evaluateSimpleStrategy(trainingData, testingData, strategyType, initialCapital) {
  const evaluateData = (data) => {
    let position = 0;
    let entryPrice = 0;
    let trades2 = 0;
    let wins = 0;
    const returns = [];
    let equity = initialCapital;
    let peak = equity;
    let maxDrawdown = 0;
    for (let i = 20; i < data.length; i++) {
      const prices = data.slice(i - 20, i + 1).map((d) => d.close);
      const currentPrice = data[i].close;
      let signal = 0;
      if (strategyType === "momentum") {
        const momentum = (currentPrice - prices[0]) / prices[0];
        signal = momentum > 0.02 ? 1 : momentum < -0.02 ? -1 : 0;
      } else if (strategyType === "mean_reversion") {
        const sma = prices.reduce((a, b) => a + b, 0) / prices.length;
        const deviation = (currentPrice - sma) / sma;
        signal = deviation < -0.03 ? 1 : deviation > 0.03 ? -1 : 0;
      } else if (strategyType === "enhanced") {
        const gains = [];
        const losses = [];
        for (let j = 1; j < prices.length; j++) {
          const change = prices[j] - prices[j - 1];
          if (change > 0) gains.push(change);
          else losses.push(Math.abs(change));
        }
        const avgGain = gains.length > 0 ? gains.reduce((a, b) => a + b, 0) / 14 : 0;
        const avgLoss = losses.length > 0 ? losses.reduce((a, b) => a + b, 0) / 14 : 1e-3;
        const rsi = 100 - 100 / (1 + avgGain / avgLoss);
        signal = rsi < 30 ? 1 : rsi > 70 ? -1 : 0;
      }
      if (signal === 1 && position === 0) {
        position = 1;
        entryPrice = currentPrice;
      } else if (signal === -1 && position === 1) {
        const tradeReturn = (currentPrice - entryPrice) / entryPrice;
        returns.push(tradeReturn);
        equity *= 1 + tradeReturn;
        trades2++;
        if (tradeReturn > 0) wins++;
        position = 0;
      }
      if (equity > peak) peak = equity;
      const drawdown = (peak - equity) / peak;
      if (drawdown > maxDrawdown) maxDrawdown = drawdown;
    }
    const totalReturn = returns.reduce((a, b) => a + b, 0);
    const sharpe = returns.length > 1 ? mean2(returns) / std2(returns) * Math.sqrt(252) : 0;
    const winRate = trades2 > 0 ? wins / trades2 : 0;
    return { totalReturn, sharpe, winRate, maxDrawdown };
  };
  const trainingResult = evaluateData(trainingData);
  const testingResult = evaluateData(testingData);
  return {
    trainingReturn: trainingResult.totalReturn,
    trainingSharpe: trainingResult.sharpe,
    trainingWinRate: trainingResult.winRate,
    testingReturn: testingResult.totalReturn,
    testingSharpe: testingResult.sharpe,
    testingWinRate: testingResult.winRate,
    testingMaxDrawdown: testingResult.maxDrawdown,
    modelParameters: {}
  };
}
function mean2(arr) {
  return arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
}
function std2(arr) {
  if (arr.length < 2) return 0;
  const avg = mean2(arr);
  return Math.sqrt(arr.map((x) => Math.pow(x - avg, 2)).reduce((a, b) => a + b, 0) / arr.length);
}
async function runWalkForwardOptimization(config) {
  const {
    symbol,
    totalPeriodDays,
    trainingWindowDays,
    testingWindowDays,
    stepSizeDays,
    optimizationType,
    strategyType,
    initialCapital
  } = config;
  const allData = await fetchHistoricalData3(symbol);
  const data = allData.slice(-Math.min(totalPeriodDays, allData.length));
  if (data.length < trainingWindowDays + testingWindowDays) {
    throw new Error("Insufficient data for walk-forward optimization");
  }
  const windows = [];
  const combinedEquityCurve = [];
  const performanceTimeline = [];
  let windowIndex = 0;
  let trainingStart = 0;
  let cumulativeReturn = 0;
  let currentEquity = initialCapital;
  while (trainingStart + trainingWindowDays + testingWindowDays <= data.length) {
    const trainingEnd = optimizationType === "anchored" ? trainingStart + trainingWindowDays + windowIndex * stepSizeDays : trainingStart + trainingWindowDays;
    const testingStart = trainingEnd;
    const testingEnd = Math.min(testingStart + testingWindowDays, data.length);
    if (testingEnd > data.length) break;
    const result = await evaluateWindow(
      data,
      trainingStart,
      trainingEnd,
      testingStart,
      testingEnd,
      strategyType,
      initialCapital
    );
    const returnDegradation = result.trainingReturn !== 0 ? (result.trainingReturn - result.testingReturn) / Math.abs(result.trainingReturn) : 0;
    const isOverfit = returnDegradation > 0.5 || result.trainingSharpe > 1 && result.testingSharpe < 0;
    windows.push({
      windowIndex,
      trainingStart: data[trainingStart].date,
      trainingEnd: data[trainingEnd - 1].date,
      testingStart: data[testingStart].date,
      testingEnd: data[testingEnd - 1].date,
      trainingReturn: result.trainingReturn,
      trainingSharpe: result.trainingSharpe,
      trainingWinRate: result.trainingWinRate,
      testingReturn: result.testingReturn,
      testingSharpe: result.testingSharpe,
      testingWinRate: result.testingWinRate,
      testingMaxDrawdown: result.testingMaxDrawdown,
      returnDegradation,
      sharpeRatio: result.testingSharpe,
      isOverfit,
      modelParameters: result.modelParameters
    });
    cumulativeReturn = (1 + cumulativeReturn) * (1 + result.testingReturn) - 1;
    currentEquity *= 1 + result.testingReturn;
    combinedEquityCurve.push({
      date: data[testingEnd - 1].date.toISOString().split("T")[0],
      value: currentEquity
    });
    performanceTimeline.push({
      date: data[testingEnd - 1].date.toISOString().split("T")[0],
      cumulativeReturn,
      windowReturn: result.testingReturn,
      isTraining: false
    });
    if (optimizationType === "rolling") {
      trainingStart += stepSizeDays;
    }
    windowIndex++;
    if (windowIndex > 100) break;
  }
  const testingReturns = windows.map((w) => w.testingReturn);
  const testingSharpes = windows.map((w) => w.testingSharpe);
  const testingWinRates = windows.map((w) => w.testingWinRate);
  const testingDrawdowns = windows.map((w) => w.testingMaxDrawdown);
  const degradations = windows.map((w) => w.returnDegradation);
  const aggregateMetrics = {
    totalReturn: cumulativeReturn,
    avgTestingReturn: mean2(testingReturns),
    avgReturnDegradation: mean2(degradations),
    avgSharpe: mean2(testingSharpes),
    avgWinRate: mean2(testingWinRates),
    avgMaxDrawdown: mean2(testingDrawdowns),
    consistencyRatio: testingReturns.filter((r) => r > 0).length / testingReturns.length,
    overfitRatio: windows.filter((w) => w.isOverfit).length / windows.length
  };
  const stabilityMetrics = {
    returnStability: std2(testingReturns),
    sharpeStability: std2(testingSharpes),
    parameterStability: 0
    // Would need to track parameter changes
  };
  const stabilityScore = Math.max(0, Math.min(
    100,
    100 - stabilityMetrics.returnStability * 200 - aggregateMetrics.overfitRatio * 50
  ));
  const recommendations = {
    isStrategyRobust: aggregateMetrics.consistencyRatio > 0.6 && aggregateMetrics.overfitRatio < 0.3,
    suggestedTrainingWindow: trainingWindowDays,
    suggestedTestingWindow: testingWindowDays,
    overfitWarning: aggregateMetrics.overfitRatio > 0.3,
    stabilityScore
  };
  return {
    config,
    windows,
    aggregateMetrics,
    stabilityMetrics,
    combinedEquityCurve,
    performanceTimeline,
    recommendations
  };
}
async function runQuickWalkForward(symbol, strategyType) {
  const result = await runWalkForwardOptimization({
    symbol,
    totalPeriodDays: 504,
    // 2 years
    trainingWindowDays: 126,
    // 6 months
    testingWindowDays: 63,
    // 3 months
    stepSizeDays: 63,
    optimizationType: "rolling",
    strategyType,
    initialCapital: 1e5
  });
  return {
    isRobust: result.recommendations.isStrategyRobust,
    stabilityScore: result.recommendations.stabilityScore,
    avgReturn: result.aggregateMetrics.avgTestingReturn,
    overfitRatio: result.aggregateMetrics.overfitRatio
  };
}

// server/services/portfolioBacktesting.ts
init_dataApi();
async function fetchAssetData(symbol) {
  try {
    const response = await callDataApi("YahooFinance/get_stock_chart", {
      query: {
        symbol,
        region: "US",
        interval: "1d",
        range: "5y",
        includeAdjustedClose: true
      }
    });
    if (!response?.chart?.result?.[0]) {
      throw new Error(`No data for ${symbol}`);
    }
    const result = response.chart.result[0];
    const timestamps = result.timestamp;
    const closes = result.indicators.quote[0].close;
    const dates = [];
    const prices = [];
    const returns = [];
    for (let i = 0; i < timestamps.length; i++) {
      if (closes[i] !== null) {
        dates.push(new Date(timestamps[i] * 1e3));
        prices.push(closes[i]);
        if (prices.length > 1) {
          returns.push((prices[prices.length - 1] - prices[prices.length - 2]) / prices[prices.length - 2]);
        }
      }
    }
    return { symbol, dates, prices, returns };
  } catch (error) {
    console.error(`[PortfolioBacktest] Error fetching ${symbol}:`, error);
    return generateSyntheticAssetData(symbol);
  }
}
function generateSyntheticAssetData(symbol) {
  const days = 252 * 5;
  const dates = [];
  const prices = [];
  const returns = [];
  let price = 100;
  const startDate = /* @__PURE__ */ new Date();
  startDate.setDate(startDate.getDate() - days);
  const symbolHash = symbol.split("").reduce((a, b) => a + b.charCodeAt(0), 0);
  const meanReturn = 3e-4 + symbolHash % 10 * 5e-5;
  const volatility = 0.015 + symbolHash % 5 * 3e-3;
  for (let i = 0; i < days; i++) {
    const date2 = new Date(startDate);
    date2.setDate(date2.getDate() + i);
    dates.push(date2);
    if (i > 0) {
      const u1 = Math.random();
      const u2 = Math.random();
      const z3 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      const dailyReturn = meanReturn + volatility * z3;
      returns.push(dailyReturn);
      price *= 1 + dailyReturn;
    }
    prices.push(price);
  }
  return { symbol, dates, prices, returns };
}
function alignAssetData(assetsData) {
  const allDates = /* @__PURE__ */ new Set();
  for (const asset of assetsData) {
    for (const date2 of asset.dates) {
      allDates.add(date2.toISOString().split("T")[0]);
    }
  }
  const sortedDates = Array.from(allDates).sort();
  const commonDates = [];
  const alignedReturns = assetsData.map(() => []);
  for (const dateStr of sortedDates) {
    let allHaveData = true;
    const dayReturns = [];
    for (let i = 0; i < assetsData.length; i++) {
      const asset = assetsData[i];
      const dateIdx = asset.dates.findIndex((d) => d.toISOString().split("T")[0] === dateStr);
      if (dateIdx > 0 && dateIdx < asset.returns.length + 1) {
        dayReturns.push(asset.returns[dateIdx - 1]);
      } else {
        allHaveData = false;
        break;
      }
    }
    if (allHaveData) {
      commonDates.push(dateStr);
      for (let i = 0; i < dayReturns.length; i++) {
        alignedReturns[i].push(dayReturns[i]);
      }
    }
  }
  return {
    dates: commonDates.map((d) => new Date(d)),
    alignedReturns
  };
}
function calculateCorrelationMatrix(returns, symbols) {
  const n = returns.length;
  const matrix = Array(n).fill(null).map(() => Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      if (i === j) {
        matrix[i][j] = 1;
      } else if (j > i) {
        const corr = correlation(returns[i], returns[j]);
        matrix[i][j] = corr;
        matrix[j][i] = corr;
      }
    }
  }
  return { symbols, matrix };
}
function correlation(x, y) {
  const n = Math.min(x.length, y.length);
  if (n < 2) return 0;
  const meanX = mean3(x.slice(0, n));
  const meanY = mean3(y.slice(0, n));
  let sumXY = 0;
  let sumX2 = 0;
  let sumY2 = 0;
  for (let i = 0; i < n; i++) {
    const dx = x[i] - meanX;
    const dy = y[i] - meanY;
    sumXY += dx * dy;
    sumX2 += dx * dx;
    sumY2 += dy * dy;
  }
  const denom = Math.sqrt(sumX2 * sumY2);
  return denom > 0 ? sumXY / denom : 0;
}
function calculateCovarianceMatrix(returns) {
  const n = returns.length;
  const matrix = Array(n).fill(null).map(() => Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      if (j >= i) {
        const cov = covariance(returns[i], returns[j]);
        matrix[i][j] = cov;
        matrix[j][i] = cov;
      }
    }
  }
  return matrix;
}
function covariance(x, y) {
  const n = Math.min(x.length, y.length);
  if (n < 2) return 0;
  const meanX = mean3(x.slice(0, n));
  const meanY = mean3(y.slice(0, n));
  let sum2 = 0;
  for (let i = 0; i < n; i++) {
    sum2 += (x[i] - meanX) * (y[i] - meanY);
  }
  return sum2 / (n - 1);
}
function calculatePortfolioMetrics(weights, returns, covMatrix) {
  const assetReturns = returns.map((r) => mean3(r) * 252);
  let portfolioReturn = 0;
  for (let i = 0; i < weights.length; i++) {
    portfolioReturn += weights[i] * assetReturns[i];
  }
  let portfolioVariance = 0;
  for (let i = 0; i < weights.length; i++) {
    for (let j = 0; j < weights.length; j++) {
      portfolioVariance += weights[i] * weights[j] * covMatrix[i][j] * 252;
    }
  }
  return {
    return: portfolioReturn,
    volatility: Math.sqrt(portfolioVariance)
  };
}
function generateEfficientFrontier(returns, symbols, numPoints = 50) {
  const covMatrix = calculateCovarianceMatrix(returns);
  const assetReturns = returns.map((r) => mean3(r) * 252);
  const minReturn = Math.min(...assetReturns);
  const maxReturn = Math.max(...assetReturns);
  const frontier = [];
  for (let i = 0; i < numPoints; i++) {
    const targetReturn = minReturn + (maxReturn - minReturn) * (i / (numPoints - 1));
    const weights = optimizeForTargetReturn(returns, covMatrix, targetReturn);
    const metrics = calculatePortfolioMetrics(weights, returns, covMatrix);
    const weightsMap = {};
    for (let j = 0; j < symbols.length; j++) {
      weightsMap[symbols[j]] = weights[j];
    }
    frontier.push({
      return: metrics.return,
      volatility: metrics.volatility,
      sharpe: metrics.volatility > 0 ? metrics.return / metrics.volatility : 0,
      weights: weightsMap
    });
  }
  return frontier;
}
function optimizeForTargetReturn(returns, covMatrix, targetReturn) {
  const n = returns.length;
  const assetReturns = returns.map((r) => mean3(r) * 252);
  let weights = Array(n).fill(1 / n);
  const learningRate = 0.01;
  const iterations = 1e3;
  for (let iter = 0; iter < iterations; iter++) {
    let portfolioReturn = 0;
    let portfolioVariance = 0;
    for (let i = 0; i < n; i++) {
      portfolioReturn += weights[i] * assetReturns[i];
      for (let j = 0; j < n; j++) {
        portfolioVariance += weights[i] * weights[j] * covMatrix[i][j] * 252;
      }
    }
    const returnPenalty = Math.abs(portfolioReturn - targetReturn) * 100;
    const gradient = [];
    for (let i = 0; i < n; i++) {
      let dVar = 0;
      for (let j = 0; j < n; j++) {
        dVar += 2 * weights[j] * covMatrix[i][j] * 252;
      }
      const dReturn = assetReturns[i];
      gradient.push(dVar + returnPenalty * (portfolioReturn > targetReturn ? dReturn : -dReturn));
    }
    for (let i = 0; i < n; i++) {
      weights[i] -= learningRate * gradient[i];
    }
    weights = weights.map((w) => Math.max(0, w));
    const sum2 = weights.reduce((a, b) => a + b, 0);
    if (sum2 > 0) {
      weights = weights.map((w) => w / sum2);
    }
  }
  return weights;
}
function calculateDiversificationMetrics(weights, returns, correlationMatrix) {
  const volatilities = returns.map((r) => std3(r) * Math.sqrt(252));
  const covMatrix = calculateCovarianceMatrix(returns);
  let weightedAvgVol = 0;
  for (let i = 0; i < weights.length; i++) {
    weightedAvgVol += weights[i] * volatilities[i];
  }
  let portfolioVariance = 0;
  for (let i = 0; i < weights.length; i++) {
    for (let j = 0; j < weights.length; j++) {
      portfolioVariance += weights[i] * weights[j] * covMatrix[i][j] * 252;
    }
  }
  const portfolioVol = Math.sqrt(portfolioVariance);
  const diversificationRatio = portfolioVol > 0 ? weightedAvgVol / portfolioVol : 1;
  const diversificationBenefit = 1 - portfolioVol / weightedAvgVol;
  const herfindahl = weights.reduce((sum2, w) => sum2 + w * w, 0);
  const effectiveAssets = 1 / herfindahl;
  const correlations = [];
  for (let i = 0; i < correlationMatrix.matrix.length; i++) {
    for (let j = i + 1; j < correlationMatrix.matrix.length; j++) {
      correlations.push(correlationMatrix.matrix[i][j]);
    }
  }
  return {
    diversificationRatio,
    diversificationBenefit,
    effectiveAssets,
    concentrationRisk: herfindahl,
    correlationAverage: correlations.length > 0 ? mean3(correlations) : 0,
    correlationMax: correlations.length > 0 ? Math.max(...correlations) : 0,
    correlationMin: correlations.length > 0 ? Math.min(...correlations) : 0
  };
}
function mean3(arr) {
  return arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
}
function std3(arr) {
  if (arr.length < 2) return 0;
  const avg = mean3(arr);
  return Math.sqrt(arr.map((x) => Math.pow(x - avg, 2)).reduce((a, b) => a + b, 0) / arr.length);
}
async function runPortfolioBacktest(config) {
  const {
    assets,
    initialCapital,
    rebalanceFrequency,
    riskFreeRate = 0.05,
    benchmarkSymbol = "SPY"
  } = config;
  const assetsData = await Promise.all(
    assets.map((asset) => fetchAssetData(asset.symbol))
  );
  const benchmarkData = await fetchAssetData(benchmarkSymbol);
  const { dates, alignedReturns } = alignAssetData(assetsData);
  if (dates.length < 20) {
    throw new Error("Insufficient aligned data for backtesting");
  }
  const correlationMatrix = calculateCorrelationMatrix(
    alignedReturns,
    assets.map((a) => a.symbol)
  );
  const covMatrix = calculateCovarianceMatrix(alignedReturns);
  const weights = assets.map((a) => a.weight);
  const normalizedWeights = weights.map((w) => w / weights.reduce((a, b) => a + b, 0));
  const equityCurve = [];
  const allocationHistory = [];
  let portfolioValue = initialCapital;
  let peak = initialCapital;
  const portfolioReturns = [];
  const negativeReturns = [];
  const rebalanceDays = /* @__PURE__ */ new Set();
  for (let i = 0; i < dates.length; i++) {
    const date2 = dates[i];
    if (rebalanceFrequency === "daily") {
      rebalanceDays.add(i);
    } else if (rebalanceFrequency === "weekly" && date2.getDay() === 1) {
      rebalanceDays.add(i);
    } else if (rebalanceFrequency === "monthly" && date2.getDate() === 1) {
      rebalanceDays.add(i);
    } else if (rebalanceFrequency === "quarterly" && date2.getDate() === 1 && date2.getMonth() % 3 === 0) {
      rebalanceDays.add(i);
    }
  }
  let currentWeights = [...normalizedWeights];
  for (let i = 0; i < alignedReturns[0].length; i++) {
    let dayReturn = 0;
    for (let j = 0; j < currentWeights.length; j++) {
      dayReturn += currentWeights[j] * alignedReturns[j][i];
    }
    portfolioReturns.push(dayReturn);
    if (dayReturn < 0) negativeReturns.push(dayReturn);
    portfolioValue *= 1 + dayReturn;
    if (portfolioValue > peak) peak = portfolioValue;
    const drawdown = (peak - portfolioValue) / peak;
    equityCurve.push({
      date: dates[i].toISOString().split("T")[0],
      value: portfolioValue,
      drawdown
    });
    if (!rebalanceDays.has(i)) {
      const newWeights = [];
      let totalValue = 0;
      for (let j = 0; j < currentWeights.length; j++) {
        const assetValue = currentWeights[j] * (1 + alignedReturns[j][i]);
        newWeights.push(assetValue);
        totalValue += assetValue;
      }
      currentWeights = newWeights.map((w) => w / totalValue);
    } else {
      currentWeights = [...normalizedWeights];
    }
    if (i % 20 === 0) {
      const allocations = {};
      for (let j = 0; j < assets.length; j++) {
        allocations[assets[j].symbol] = currentWeights[j];
      }
      allocationHistory.push({
        date: dates[i].toISOString().split("T")[0],
        allocations
      });
    }
  }
  const totalReturn = (portfolioValue - initialCapital) / initialCapital;
  const annualizedReturn = Math.pow(1 + totalReturn, 252 / portfolioReturns.length) - 1;
  const volatility = std3(portfolioReturns) * Math.sqrt(252);
  const sharpeRatio = volatility > 0 ? (annualizedReturn - riskFreeRate) / volatility : 0;
  const downsideVol = negativeReturns.length > 0 ? std3(negativeReturns) * Math.sqrt(252) : volatility;
  const sortinoRatio = downsideVol > 0 ? (annualizedReturn - riskFreeRate) / downsideVol : 0;
  const maxDrawdown = Math.max(...equityCurve.map((e) => e.drawdown));
  const calmarRatio = maxDrawdown > 0 ? annualizedReturn / maxDrawdown : 0;
  let maxDrawdownDuration = 0;
  let currentDrawdownDuration = 0;
  for (const point of equityCurve) {
    if (point.drawdown > 0) {
      currentDrawdownDuration++;
      maxDrawdownDuration = Math.max(maxDrawdownDuration, currentDrawdownDuration);
    } else {
      currentDrawdownDuration = 0;
    }
  }
  const winningDays = portfolioReturns.filter((r) => r > 0);
  const losingDays = portfolioReturns.filter((r) => r < 0);
  const winRate = winningDays.length / portfolioReturns.length;
  const grossProfit = winningDays.reduce((a, b) => a + b, 0);
  const grossLoss = Math.abs(losingDays.reduce((a, b) => a + b, 0));
  const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? 999 : 0;
  const assetMetrics = [];
  for (let i = 0; i < assets.length; i++) {
    const assetReturns = alignedReturns[i];
    const assetReturn = assetReturns.reduce((a, b) => (1 + a) * (1 + b) - 1, 0);
    const assetVol = std3(assetReturns) * Math.sqrt(252);
    const assetSharpe = assetVol > 0 ? (mean3(assetReturns) * 252 - riskFreeRate) / assetVol : 0;
    let assetPeak = 1;
    let assetMaxDD = 0;
    let assetValue = 1;
    for (const ret of assetReturns) {
      assetValue *= 1 + ret;
      if (assetValue > assetPeak) assetPeak = assetValue;
      const dd = (assetPeak - assetValue) / assetPeak;
      if (dd > assetMaxDD) assetMaxDD = dd;
    }
    const benchmarkReturns2 = benchmarkData.returns.slice(0, assetReturns.length);
    const beta = covariance(assetReturns, benchmarkReturns2) / (std3(benchmarkReturns2) * std3(benchmarkReturns2) || 1);
    const benchmarkReturn = mean3(benchmarkReturns2) * 252;
    const alpha = mean3(assetReturns) * 252 - (riskFreeRate + beta * (benchmarkReturn - riskFreeRate));
    let riskContrib = 0;
    for (let j = 0; j < assets.length; j++) {
      riskContrib += normalizedWeights[j] * covMatrix[i][j];
    }
    riskContrib = normalizedWeights[i] * riskContrib / (volatility * volatility / 252 || 1);
    assetMetrics.push({
      symbol: assets[i].symbol,
      weight: normalizedWeights[i],
      return: assetReturn,
      volatility: assetVol,
      sharpe: assetSharpe,
      maxDrawdown: assetMaxDD,
      beta,
      alpha,
      contribution: normalizedWeights[i] * assetReturn,
      riskContribution: riskContrib
    });
  }
  const benchmarkReturns = benchmarkData.returns.slice(0, portfolioReturns.length);
  const benchmarkTotalReturn = benchmarkReturns.reduce((a, b) => (1 + a) * (1 + b) - 1, 0);
  const benchmarkVol = std3(benchmarkReturns) * Math.sqrt(252);
  const benchmarkSharpe = benchmarkVol > 0 ? (mean3(benchmarkReturns) * 252 - riskFreeRate) / benchmarkVol : 0;
  const portfolioBenchmarkCorr = correlation(portfolioReturns, benchmarkReturns);
  const portfolioBeta = covariance(portfolioReturns, benchmarkReturns) / (std3(benchmarkReturns) * std3(benchmarkReturns) || 1);
  const portfolioAlpha = annualizedReturn - (riskFreeRate + portfolioBeta * (mean3(benchmarkReturns) * 252 - riskFreeRate));
  const trackingDiff = portfolioReturns.map((r, i) => r - benchmarkReturns[i]);
  const trackingError = std3(trackingDiff) * Math.sqrt(252);
  const informationRatio = trackingError > 0 ? (annualizedReturn - mean3(benchmarkReturns) * 252) / trackingError : 0;
  const diversificationMetrics = calculateDiversificationMetrics(
    normalizedWeights,
    alignedReturns,
    correlationMatrix
  );
  const efficientFrontier = generateEfficientFrontier(
    alignedReturns,
    assets.map((a) => a.symbol)
  );
  const currentPortfolioPosition = {
    return: annualizedReturn,
    volatility,
    sharpe: sharpeRatio,
    weights: Object.fromEntries(assets.map((a, i) => [a.symbol, normalizedWeights[i]]))
  };
  const systematicRisk = portfolioBeta * portfolioBeta * benchmarkVol * benchmarkVol;
  const totalRisk = volatility * volatility;
  const idiosyncraticRisk = totalRisk - systematicRisk;
  const maxSharpePoint = efficientFrontier.reduce(
    (best, point) => point.sharpe > best.sharpe ? point : best
  );
  const rebalanceNeeded = assets.some(
    (a, i) => Math.abs(currentWeights[i] - normalizedWeights[i]) > 0.05
  );
  const riskWarnings = [];
  if (maxDrawdown > 0.2) riskWarnings.push("High maximum drawdown (>20%)");
  if (diversificationMetrics.concentrationRisk > 0.5) riskWarnings.push("High concentration risk");
  if (diversificationMetrics.correlationAverage > 0.7) riskWarnings.push("High average correlation between assets");
  if (volatility > 0.3) riskWarnings.push("High portfolio volatility (>30%)");
  const improvementPotential = maxSharpePoint.sharpe > sharpeRatio ? (maxSharpePoint.sharpe - sharpeRatio) / sharpeRatio : 0;
  return {
    config,
    portfolioMetrics: {
      totalReturn,
      annualizedReturn,
      volatility,
      sharpeRatio,
      sortinoRatio,
      calmarRatio,
      maxDrawdown,
      maxDrawdownDuration,
      winRate,
      profitFactor
    },
    benchmarkMetrics: {
      totalReturn: benchmarkTotalReturn,
      volatility: benchmarkVol,
      sharpe: benchmarkSharpe,
      correlation: portfolioBenchmarkCorr,
      beta: portfolioBeta,
      alpha: portfolioAlpha,
      trackingError,
      informationRatio
    },
    assetMetrics,
    correlationMatrix,
    diversificationMetrics,
    efficientFrontier,
    currentPortfolioPosition,
    equityCurve,
    allocationHistory,
    riskDecomposition: {
      systematic: systematicRisk / totalRisk,
      idiosyncratic: idiosyncraticRisk / totalRisk,
      factorExposures: {
        market: portfolioBeta
      }
    },
    recommendations: {
      suggestedWeights: maxSharpePoint.weights,
      rebalanceNeeded,
      riskWarnings,
      improvementPotential
    }
  };
}
async function runQuickPortfolioAnalysis(symbols, weights) {
  const assets = symbols.map((symbol, i) => ({
    symbol,
    weight: weights[i] || 1 / symbols.length
  }));
  const result = await runPortfolioBacktest({
    assets,
    initialCapital: 1e5,
    startDate: new Date(Date.now() - 365 * 24 * 60 * 60 * 1e3),
    endDate: /* @__PURE__ */ new Date(),
    rebalanceFrequency: "monthly"
  });
  let suggestedAction = "Portfolio looks well-balanced";
  if (result.diversificationMetrics.concentrationRisk > 0.5) {
    suggestedAction = "Consider diversifying - high concentration risk";
  } else if (result.diversificationMetrics.correlationAverage > 0.7) {
    suggestedAction = "Add uncorrelated assets to improve diversification";
  } else if (result.recommendations.improvementPotential > 0.2) {
    suggestedAction = "Rebalancing could improve risk-adjusted returns";
  }
  return {
    sharpe: result.portfolioMetrics.sharpeRatio,
    diversificationRatio: result.diversificationMetrics.diversificationRatio,
    correlationAvg: result.diversificationMetrics.correlationAverage,
    suggestedAction
  };
}

// server/services/regimeSwitching.ts
init_dataApi();
async function fetchHistoricalData4(symbol, days) {
  try {
    const response = await callDataApi("YahooFinance/get_stock_chart", {
      query: {
        symbol,
        interval: "1d",
        range: days <= 30 ? "1mo" : days <= 90 ? "3mo" : days <= 180 ? "6mo" : "1y"
      }
    });
    if (!response?.chart?.result?.[0]) {
      throw new Error("No data returned from API");
    }
    const result = response.chart.result[0];
    const timestamps = result.timestamp;
    const quotes = result.indicators.quote[0];
    const priceData = [];
    for (let i = 0; i < timestamps.length; i++) {
      if (quotes.close[i] !== null && quotes.open[i] !== null) {
        priceData.push({
          date: new Date(timestamps[i] * 1e3),
          open: quotes.open[i],
          high: quotes.high[i],
          low: quotes.low[i],
          close: quotes.close[i],
          volume: quotes.volume[i]
        });
      }
    }
    return priceData;
  } catch (error) {
    console.error("Error fetching historical data:", error);
    return generateSimulatedData(days);
  }
}
function generateSimulatedData(days) {
  const data = [];
  let price = 150;
  const now = /* @__PURE__ */ new Date();
  for (let i = days; i >= 0; i--) {
    const date2 = new Date(now);
    date2.setDate(date2.getDate() - i);
    const change = (Math.random() - 0.48) * 3;
    price = Math.max(50, price * (1 + change / 100));
    const high = price * (1 + Math.random() * 0.02);
    const low = price * (1 - Math.random() * 0.02);
    const open = low + Math.random() * (high - low);
    data.push({
      date: date2,
      open,
      high,
      low,
      close: price,
      volume: 1e6 + Math.random() * 5e6
    });
  }
  return data;
}
function calculateSMA2(prices, period) {
  if (prices.length < period) return prices[prices.length - 1] || 0;
  const slice = prices.slice(-period);
  return slice.reduce((a, b) => a + b, 0) / period;
}
function calculateEMA4(prices, period) {
  if (prices.length < period) return prices[prices.length - 1] || 0;
  const multiplier = 2 / (period + 1);
  let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
  for (let i = period; i < prices.length; i++) {
    ema = (prices[i] - ema) * multiplier + ema;
  }
  return ema;
}
function calculateRSI2(prices, period = 14) {
  if (prices.length < period + 1) return 50;
  const changes = prices.slice(-period - 1).map(
    (p, i, arr) => i === 0 ? 0 : p - arr[i - 1]
  ).slice(1);
  const gains = changes.filter((c) => c > 0);
  const losses = changes.filter((c) => c < 0).map((c) => Math.abs(c));
  const avgGain = gains.length > 0 ? gains.reduce((a, b) => a + b, 0) / period : 0;
  const avgLoss = losses.length > 0 ? losses.reduce((a, b) => a + b, 0) / period : 0;
  if (avgLoss === 0) return 100;
  const rs = avgGain / avgLoss;
  return 100 - 100 / (1 + rs);
}
function calculateMACD(prices) {
  const ema12 = calculateEMA4(prices, 12);
  const ema26 = calculateEMA4(prices, 26);
  const macdLine = ema12 - ema26;
  const macdValues = [];
  for (let i = 26; i <= prices.length; i++) {
    const slice = prices.slice(0, i);
    const e12 = calculateEMA4(slice, 12);
    const e26 = calculateEMA4(slice, 26);
    macdValues.push(e12 - e26);
  }
  const signal = macdValues.length >= 9 ? calculateEMA4(macdValues, 9) : macdLine;
  return {
    value: macdLine,
    signal,
    histogram: macdLine - signal
  };
}
function calculateATR(data, period = 14) {
  if (data.length < period + 1) return 0;
  const trueRanges = [];
  for (let i = 1; i < data.length; i++) {
    const high = data[i].high;
    const low = data[i].low;
    const prevClose = data[i - 1].close;
    const tr = Math.max(
      high - low,
      Math.abs(high - prevClose),
      Math.abs(low - prevClose)
    );
    trueRanges.push(tr);
  }
  return trueRanges.slice(-period).reduce((a, b) => a + b, 0) / period;
}
function calculateADX3(data, period = 14) {
  if (data.length < period * 2) {
    return { adx: 25, plusDI: 25, minusDI: 25 };
  }
  const plusDMs = [];
  const minusDMs = [];
  const trueRanges = [];
  for (let i = 1; i < data.length; i++) {
    const high = data[i].high;
    const low = data[i].low;
    const prevHigh = data[i - 1].high;
    const prevLow = data[i - 1].low;
    const prevClose = data[i - 1].close;
    const plusDM = high - prevHigh > prevLow - low ? Math.max(high - prevHigh, 0) : 0;
    const minusDM = prevLow - low > high - prevHigh ? Math.max(prevLow - low, 0) : 0;
    plusDMs.push(plusDM);
    minusDMs.push(minusDM);
    const tr = Math.max(
      high - low,
      Math.abs(high - prevClose),
      Math.abs(low - prevClose)
    );
    trueRanges.push(tr);
  }
  const smoothedPlusDM = plusDMs.slice(-period).reduce((a, b) => a + b, 0);
  const smoothedMinusDM = minusDMs.slice(-period).reduce((a, b) => a + b, 0);
  const smoothedTR = trueRanges.slice(-period).reduce((a, b) => a + b, 0);
  const plusDI = smoothedTR > 0 ? smoothedPlusDM / smoothedTR * 100 : 0;
  const minusDI = smoothedTR > 0 ? smoothedMinusDM / smoothedTR * 100 : 0;
  const dx = plusDI + minusDI > 0 ? Math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100 : 0;
  return { adx: dx, plusDI, minusDI };
}
function calculateHistoricalVolatility(prices, period = 20) {
  if (prices.length < period + 1) return 0.2;
  const returns = [];
  for (let i = 1; i < prices.length; i++) {
    returns.push(Math.log(prices[i] / prices[i - 1]));
  }
  const recentReturns = returns.slice(-period);
  const mean5 = recentReturns.reduce((a, b) => a + b, 0) / period;
  const variance = recentReturns.reduce((sum2, r) => sum2 + (r - mean5) ** 2, 0) / period;
  return Math.sqrt(variance * 252);
}
function calculateBollingerWidth(prices, period = 20) {
  const sma = calculateSMA2(prices, period);
  const slice = prices.slice(-period);
  const variance = slice.reduce((sum2, p) => sum2 + (p - sma) ** 2, 0) / period;
  const stdDev = Math.sqrt(variance);
  return 4 * stdDev / sma;
}
function detectRegime(indicators, thresholds) {
  const scores = {
    bull: 0,
    bear: 0,
    sideways: 0,
    volatile: 0
  };
  if (indicators.priceVsSma200 > 0) scores.bull += 2;
  else scores.bear += 2;
  if (indicators.priceVsSma50 > 0) scores.bull += 1;
  else scores.bear += 1;
  if (indicators.sma50 > indicators.sma200) scores.bull += 2;
  else scores.bear += 2;
  if (indicators.macdHistogram > 0) scores.bull += 1;
  else scores.bear += 1;
  if (indicators.rsi > 60) scores.bull += 1;
  else if (indicators.rsi < 40) scores.bear += 1;
  else scores.sideways += 1;
  if (indicators.adx < thresholds.trendStrengthThreshold) {
    scores.sideways += 3;
  } else {
    if (indicators.plusDI > indicators.minusDI) scores.bull += 1;
    else scores.bear += 1;
  }
  if (indicators.historicalVolatility > thresholds.volatilityThreshold) {
    scores.volatile += 3;
  }
  if (indicators.bollingerWidth > 0.1) {
    scores.volatile += 1;
  }
  const total = scores.bull + scores.bear + scores.sideways + scores.volatile;
  const probabilities = {
    bull: scores.bull / total,
    bear: scores.bear / total,
    sideways: scores.sideways / total,
    volatile: scores.volatile / total
  };
  let regime = "sideways";
  let maxScore = scores.sideways;
  if (scores.bull > maxScore) {
    regime = "bull";
    maxScore = scores.bull;
  }
  if (scores.bear > maxScore) {
    regime = "bear";
    maxScore = scores.bear;
  }
  if (scores.volatile > maxScore) {
    regime = "volatile";
    maxScore = scores.volatile;
  }
  const confidence = maxScore / total;
  return { regime, probabilities, confidence };
}
function getStrategyAdjustments(regime) {
  const adjustments = {
    bull: {
      regime: "bull",
      positionSizeMultiplier: 1.2,
      stopLossMultiplier: 1.5,
      takeProfitMultiplier: 2,
      preferredStrategies: ["momentum", "trend_following", "breakout"],
      riskLevel: "aggressive",
      description: "Bull market detected. Increase position sizes, use wider stops, and focus on momentum strategies."
    },
    bear: {
      regime: "bear",
      positionSizeMultiplier: 0.5,
      stopLossMultiplier: 0.8,
      takeProfitMultiplier: 1,
      preferredStrategies: ["short_selling", "defensive", "hedging"],
      riskLevel: "conservative",
      description: "Bear market detected. Reduce position sizes, use tighter stops, and consider defensive strategies."
    },
    sideways: {
      regime: "sideways",
      positionSizeMultiplier: 0.8,
      stopLossMultiplier: 1,
      takeProfitMultiplier: 1.2,
      preferredStrategies: ["mean_reversion", "range_trading", "options_selling"],
      riskLevel: "moderate",
      description: "Sideways market detected. Use mean reversion strategies and range trading approaches."
    },
    volatile: {
      regime: "volatile",
      positionSizeMultiplier: 0.3,
      stopLossMultiplier: 2,
      takeProfitMultiplier: 3,
      preferredStrategies: ["volatility_trading", "straddles", "iron_condors"],
      riskLevel: "conservative",
      description: "High volatility detected. Significantly reduce position sizes and use volatility-based strategies."
    }
  };
  return adjustments[regime];
}
function calculateTransitionMatrix(regimeHistory2) {
  const transitions = {};
  const regimes = ["bull", "bear", "sideways", "volatile"];
  for (const from of regimes) {
    for (const to of regimes) {
      transitions[`${from}-${to}`] = { count: 0, durations: [] };
    }
  }
  let currentRegime = regimeHistory2[0]?.regime;
  let duration = 1;
  for (let i = 1; i < regimeHistory2.length; i++) {
    if (regimeHistory2[i].regime === currentRegime) {
      duration++;
    } else {
      const key = `${currentRegime}-${regimeHistory2[i].regime}`;
      transitions[key].count++;
      transitions[key].durations.push(duration);
      currentRegime = regimeHistory2[i].regime;
      duration = 1;
    }
  }
  const result = [];
  for (const from of regimes) {
    const totalFromRegime = regimes.reduce(
      (sum2, to) => sum2 + transitions[`${from}-${to}`].count,
      0
    ) || 1;
    for (const to of regimes) {
      const key = `${from}-${to}`;
      const data = transitions[key];
      result.push({
        fromRegime: from,
        toRegime: to,
        probability: data.count / totalFromRegime,
        avgDuration: data.durations.length > 0 ? data.durations.reduce((a, b) => a + b, 0) / data.durations.length : 0
      });
    }
  }
  return result;
}
async function analyzeMarketRegime(config) {
  const thresholds = config.regimeThresholds || {
    bullThreshold: 0.1,
    bearThreshold: -0.1,
    volatilityThreshold: 0.3,
    trendStrengthThreshold: 25
  };
  const data = await fetchHistoricalData4(config.symbol, config.lookbackDays);
  const closes = data.map((d) => d.close);
  const currentPrice = closes[closes.length - 1];
  const sma20 = calculateSMA2(closes, 20);
  const sma50 = calculateSMA2(closes, 50);
  const sma200 = calculateSMA2(closes, 200);
  const ema12 = calculateEMA4(closes, 12);
  const ema26 = calculateEMA4(closes, 26);
  const rsi = calculateRSI2(closes);
  const macd = calculateMACD(closes);
  const atr = calculateATR(data);
  const { adx, plusDI, minusDI } = calculateADX3(data);
  const historicalVolatility = calculateHistoricalVolatility(closes);
  const bollingerWidth = calculateBollingerWidth(closes);
  const indicators = {
    sma20,
    sma50,
    sma200,
    ema12,
    ema26,
    rsi,
    macdHistogram: macd.histogram,
    atr,
    atrPercent: atr / currentPrice * 100,
    historicalVolatility,
    bollingerWidth,
    adx,
    plusDI,
    minusDI,
    priceVsSma200: (currentPrice - sma200) / sma200 * 100,
    priceVsSma50: (currentPrice - sma50) / sma50 * 100
  };
  const { regime, probabilities, confidence } = detectRegime(indicators, thresholds);
  const regimeHistory2 = [];
  const windowSize = 20;
  for (let i = windowSize; i < data.length; i++) {
    const windowData = data.slice(i - windowSize, i);
    const windowCloses = windowData.map((d) => d.close);
    const windowIndicators = {
      sma20: calculateSMA2(windowCloses, 20),
      sma50: calculateSMA2(closes.slice(0, i), 50),
      sma200: calculateSMA2(closes.slice(0, i), 200),
      ema12: calculateEMA4(windowCloses, 12),
      ema26: calculateEMA4(closes.slice(0, i), 26),
      rsi: calculateRSI2(windowCloses),
      macdHistogram: calculateMACD(closes.slice(0, i)).histogram,
      atr: calculateATR(windowData),
      atrPercent: 0,
      historicalVolatility: calculateHistoricalVolatility(windowCloses),
      bollingerWidth: calculateBollingerWidth(windowCloses),
      adx: calculateADX3(windowData).adx,
      plusDI: calculateADX3(windowData).plusDI,
      minusDI: calculateADX3(windowData).minusDI,
      priceVsSma200: 0,
      priceVsSma50: 0
    };
    const windowRegime = detectRegime(windowIndicators, thresholds);
    regimeHistory2.push({
      date: data[i].date.toISOString().split("T")[0],
      regime: windowRegime.regime,
      probability: windowRegime.confidence
    });
  }
  const transitionMatrix = calculateTransitionMatrix(regimeHistory2);
  const strategyAdjustments = getStrategyAdjustments(regime);
  const signals = {
    trendDirection: indicators.priceVsSma50 > 2 ? "up" : indicators.priceVsSma50 < -2 ? "down" : "neutral",
    trendStrength: adx > 40 ? "strong" : adx > 25 ? "moderate" : "weak",
    volatilityLevel: historicalVolatility > 0.4 ? "high" : historicalVolatility < 0.15 ? "low" : "normal",
    momentum: rsi > 60 && macd.histogram > 0 ? "bullish" : rsi < 40 && macd.histogram < 0 ? "bearish" : "neutral"
  };
  const recommendations = [];
  if (regime === "bull") {
    recommendations.push("Consider increasing equity exposure");
    recommendations.push("Focus on momentum and trend-following strategies");
    if (rsi > 70) recommendations.push("RSI overbought - consider taking partial profits");
  } else if (regime === "bear") {
    recommendations.push("Consider reducing equity exposure");
    recommendations.push("Focus on defensive positions and hedging");
    if (rsi < 30) recommendations.push("RSI oversold - watch for potential bounce");
  } else if (regime === "sideways") {
    recommendations.push("Consider range-trading strategies");
    recommendations.push("Mean reversion strategies may be effective");
    recommendations.push("Avoid trend-following strategies");
  } else {
    recommendations.push("Reduce position sizes due to high volatility");
    recommendations.push("Consider volatility-based strategies");
    recommendations.push("Use wider stops to avoid being stopped out");
  }
  return {
    symbol: config.symbol,
    currentRegime: regime,
    regimeProbabilities: probabilities,
    regimeConfidence: confidence,
    indicators,
    transitionMatrix,
    regimeHistory: regimeHistory2,
    strategyAdjustments,
    signals,
    recommendations
  };
}
async function getQuickRegime(symbol) {
  const result = await analyzeMarketRegime({
    symbol,
    lookbackDays: 60
  });
  return {
    regime: result.currentRegime,
    confidence: result.regimeConfidence,
    adjustments: result.strategyAdjustments
  };
}

// server/services/optionsGreeks.ts
init_dataApi();
function normalCDF(x) {
  const a1 = 0.254829592;
  const a2 = -0.284496736;
  const a3 = 1.421413741;
  const a4 = -1.453152027;
  const a5 = 1.061405429;
  const p = 0.3275911;
  const sign = x < 0 ? -1 : 1;
  x = Math.abs(x) / Math.sqrt(2);
  const t2 = 1 / (1 + p * x);
  const y = 1 - ((((a5 * t2 + a4) * t2 + a3) * t2 + a2) * t2 + a1) * t2 * Math.exp(-x * x);
  return 0.5 * (1 + sign * y);
}
function normalPDF(x) {
  return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
}
function calculateD1(S, K, T, r, sigma, q = 0) {
  return (Math.log(S / K) + (r - q + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
}
function calculateD2(d1, sigma, T) {
  return d1 - sigma * Math.sqrt(T);
}
function calculateOptionPrice(input) {
  const { underlyingPrice: S, strikePrice: K, timeToExpiry: T, riskFreeRate: r, volatility: sigma, optionType, dividendYield: q = 0 } = input;
  if (T <= 0) {
    if (optionType === "call") {
      return Math.max(0, S - K);
    } else {
      return Math.max(0, K - S);
    }
  }
  const d1 = calculateD1(S, K, T, r, sigma, q);
  const d2 = calculateD2(d1, sigma, T);
  if (optionType === "call") {
    return S * Math.exp(-q * T) * normalCDF(d1) - K * Math.exp(-r * T) * normalCDF(d2);
  } else {
    return K * Math.exp(-r * T) * normalCDF(-d2) - S * Math.exp(-q * T) * normalCDF(-d1);
  }
}
function calculateGreeks(input) {
  const { underlyingPrice: S, strikePrice: K, timeToExpiry: T, riskFreeRate: r, volatility: sigma, optionType, dividendYield: q = 0 } = input;
  if (T <= 0) {
    const intrinsicValue2 = optionType === "call" ? Math.max(0, S - K) : Math.max(0, K - S);
    return {
      price: intrinsicValue2,
      intrinsicValue: intrinsicValue2,
      timeValue: 0,
      delta: optionType === "call" ? S > K ? 1 : 0 : S < K ? -1 : 0,
      gamma: 0,
      theta: 0,
      vega: 0,
      rho: 0,
      lambda: 0,
      probability: {
        itm: optionType === "call" ? S > K ? 1 : 0 : S < K ? 1 : 0,
        otm: optionType === "call" ? S <= K ? 1 : 0 : S >= K ? 1 : 0
      },
      breakeven: optionType === "call" ? K + intrinsicValue2 : K - intrinsicValue2,
      deltaPerDollar: 0,
      gammaPerDollar: 0
    };
  }
  const d1 = calculateD1(S, K, T, r, sigma, q);
  const d2 = calculateD2(d1, sigma, T);
  const sqrtT = Math.sqrt(T);
  const price = calculateOptionPrice(input);
  const intrinsicValue = optionType === "call" ? Math.max(0, S - K) : Math.max(0, K - S);
  const timeValue = price - intrinsicValue;
  let delta;
  if (optionType === "call") {
    delta = Math.exp(-q * T) * normalCDF(d1);
  } else {
    delta = Math.exp(-q * T) * (normalCDF(d1) - 1);
  }
  const gamma = Math.exp(-q * T) * normalPDF(d1) / (S * sigma * sqrtT);
  let theta;
  const term1 = -S * normalPDF(d1) * sigma * Math.exp(-q * T) / (2 * sqrtT);
  if (optionType === "call") {
    theta = term1 - r * K * Math.exp(-r * T) * normalCDF(d2) + q * S * Math.exp(-q * T) * normalCDF(d1);
  } else {
    theta = term1 + r * K * Math.exp(-r * T) * normalCDF(-d2) - q * S * Math.exp(-q * T) * normalCDF(-d1);
  }
  theta = theta / 365;
  const vega = S * Math.exp(-q * T) * normalPDF(d1) * sqrtT / 100;
  let rho;
  if (optionType === "call") {
    rho = K * T * Math.exp(-r * T) * normalCDF(d2) / 100;
  } else {
    rho = -K * T * Math.exp(-r * T) * normalCDF(-d2) / 100;
  }
  const lambda = price > 0 ? delta * S / price : 0;
  const probITM = optionType === "call" ? normalCDF(d2) : normalCDF(-d2);
  const breakeven = optionType === "call" ? K + price : K - price;
  return {
    price,
    intrinsicValue,
    timeValue,
    delta,
    gamma,
    theta,
    vega,
    rho,
    lambda,
    probability: {
      itm: probITM,
      otm: 1 - probITM
    },
    breakeven,
    deltaPerDollar: price > 0 ? delta / price : 0,
    gammaPerDollar: price > 0 ? gamma / price : 0
  };
}
function calculateImpliedVolatility(marketPrice, underlyingPrice, strikePrice, timeToExpiry, riskFreeRate, optionType, dividendYield = 0) {
  const maxIterations = 100;
  const tolerance = 1e-4;
  let sigma = Math.sqrt(2 * Math.PI / timeToExpiry) * marketPrice / underlyingPrice;
  sigma = Math.max(0.01, Math.min(sigma, 5));
  for (let i = 0; i < maxIterations; i++) {
    const input = {
      underlyingPrice,
      strikePrice,
      timeToExpiry,
      riskFreeRate,
      volatility: sigma,
      optionType,
      dividendYield
    };
    const price = calculateOptionPrice(input);
    const vega = calculateGreeks(input).vega * 100;
    const diff = price - marketPrice;
    if (Math.abs(diff) < tolerance) {
      return sigma;
    }
    if (vega < 1e-4) {
      break;
    }
    sigma = sigma - diff / vega;
    sigma = Math.max(0.01, Math.min(sigma, 5));
  }
  return sigma;
}
function generateGreeksVisualization(input) {
  const { underlyingPrice: S, strikePrice: K, timeToExpiry: T, riskFreeRate: r, volatility: sigma, optionType, dividendYield: q = 0 } = input;
  const priceRange = Array.from({ length: 51 }, (_, i) => S * (0.5 + i * 0.02));
  const deltaVsPrice = priceRange.map((price) => ({
    price,
    delta: calculateGreeks({ ...input, underlyingPrice: price }).delta
  }));
  const gammaVsPrice = priceRange.map((price) => ({
    price,
    gamma: calculateGreeks({ ...input, underlyingPrice: price }).gamma
  }));
  const daysToExpiry = Math.ceil(T * 365);
  const thetaVsTime = Array.from({ length: Math.min(daysToExpiry, 90) + 1 }, (_, i) => {
    const remainingDays = daysToExpiry - i;
    const remainingT = remainingDays / 365;
    return {
      daysToExpiry: remainingDays,
      theta: remainingT > 0 ? calculateGreeks({ ...input, timeToExpiry: remainingT }).theta : 0
    };
  });
  const priceVsUnderlying = priceRange.map((price) => ({
    underlyingPrice: price,
    optionPrice: calculateOptionPrice({ ...input, underlyingPrice: price })
  }));
  const premium = calculateOptionPrice(input);
  const profitLossAtExpiry = priceRange.map((price) => {
    let payoff;
    if (optionType === "call") {
      payoff = Math.max(0, price - K);
    } else {
      payoff = Math.max(0, K - price);
    }
    return {
      underlyingPrice: price,
      profitLoss: payoff - premium
    };
  });
  return {
    deltaVsPrice,
    gammaVsPrice,
    thetaVsTime,
    priceVsUnderlying,
    profitLossAtExpiry
  };
}
async function generateOptionChain(symbol, expirationDays, numStrikes = 11) {
  let underlyingPrice = 150;
  try {
    const response = await callDataApi("YahooFinance/get_stock_chart", {
      query: {
        symbol,
        interval: "1d",
        range: "5d"
      }
    });
    if (response?.chart?.result?.[0]?.meta?.regularMarketPrice) {
      underlyingPrice = response.chart.result[0].meta.regularMarketPrice;
    }
  } catch (error) {
    console.error("Error fetching price:", error);
  }
  const timeToExpiry = expirationDays / 365;
  const riskFreeRate = 0.05;
  const volatility = 0.25;
  const strikeInterval = underlyingPrice * 0.025;
  const strikes = [];
  const halfStrikes = Math.floor(numStrikes / 2);
  for (let i = -halfStrikes; i <= halfStrikes; i++) {
    const strike = Math.round((underlyingPrice + i * strikeInterval) * 100) / 100;
    const callInput = {
      underlyingPrice,
      strikePrice: strike,
      timeToExpiry,
      riskFreeRate,
      volatility,
      optionType: "call"
    };
    const putInput = {
      ...callInput,
      optionType: "put"
    };
    strikes.push({
      strike,
      call: calculateGreeks(callInput),
      put: calculateGreeks(putInput)
    });
  }
  const expirationDate = /* @__PURE__ */ new Date();
  expirationDate.setDate(expirationDate.getDate() + expirationDays);
  return {
    symbol,
    underlyingPrice,
    expirationDate: expirationDate.toISOString().split("T")[0],
    strikes
  };
}
function analyzeStrategy(legs, underlyingPrice, timeToExpiry, riskFreeRate = 0.05, volatility = 0.25) {
  let netDelta = 0;
  let netGamma = 0;
  let netTheta = 0;
  let netVega = 0;
  let totalPremium = 0;
  for (const leg of legs) {
    const greeks = calculateGreeks({
      underlyingPrice,
      strikePrice: leg.strikePrice,
      timeToExpiry,
      riskFreeRate,
      volatility,
      optionType: leg.optionType
    });
    netDelta += greeks.delta * leg.quantity;
    netGamma += greeks.gamma * leg.quantity;
    netTheta += greeks.theta * leg.quantity;
    netVega += greeks.vega * leg.quantity;
    totalPremium += leg.premium * leg.quantity;
  }
  const priceRange = Array.from({ length: 51 }, (_, i) => underlyingPrice * (0.5 + i * 0.02));
  const profitLossCurve = priceRange.map((price) => {
    let payoff = 0;
    for (const leg of legs) {
      let legPayoff;
      if (leg.optionType === "call") {
        legPayoff = Math.max(0, price - leg.strikePrice);
      } else {
        legPayoff = Math.max(0, leg.strikePrice - price);
      }
      payoff += legPayoff * leg.quantity;
    }
    return {
      price,
      profitLoss: payoff - totalPremium
    };
  });
  const profits = profitLossCurve.map((p) => p.profitLoss);
  const maxProfit = Math.max(...profits);
  const minProfit = Math.min(...profits);
  const breakevens = [];
  for (let i = 1; i < profitLossCurve.length; i++) {
    const prev = profitLossCurve[i - 1];
    const curr = profitLossCurve[i];
    if (prev.profitLoss < 0 && curr.profitLoss >= 0 || prev.profitLoss >= 0 && curr.profitLoss < 0) {
      const breakeven = prev.price + (curr.price - prev.price) * Math.abs(prev.profitLoss) / (Math.abs(prev.profitLoss) + Math.abs(curr.profitLoss));
      breakevens.push(Math.round(breakeven * 100) / 100);
    }
  }
  let name = "Custom Strategy";
  let description = "Custom options strategy";
  if (legs.length === 1) {
    const leg = legs[0];
    if (leg.quantity > 0) {
      name = leg.optionType === "call" ? "Long Call" : "Long Put";
      description = leg.optionType === "call" ? "Bullish strategy with unlimited upside potential" : "Bearish strategy with significant downside potential";
    } else {
      name = leg.optionType === "call" ? "Short Call" : "Short Put";
      description = leg.optionType === "call" ? "Neutral to bearish strategy with limited profit" : "Neutral to bullish strategy with limited profit";
    }
  } else if (legs.length === 2) {
    const [leg1, leg2] = legs;
    if (leg1.optionType === "call" && leg2.optionType === "put" && leg1.quantity > 0 && leg2.quantity > 0 && leg1.strikePrice === leg2.strikePrice) {
      name = "Long Straddle";
      description = "Volatility strategy profiting from large price moves in either direction";
    } else if (leg1.optionType === leg2.optionType && leg1.quantity > 0 && leg2.quantity < 0) {
      name = leg1.optionType === "call" ? "Bull Call Spread" : "Bear Put Spread";
      description = leg1.optionType === "call" ? "Moderately bullish strategy with limited risk and reward" : "Moderately bearish strategy with limited risk and reward";
    }
  }
  return {
    name,
    description,
    maxProfit: maxProfit === profits[profits.length - 1] ? "unlimited" : maxProfit,
    maxLoss: minProfit === profits[0] ? "unlimited" : Math.abs(minProfit),
    breakevens,
    greeks: {
      netDelta,
      netGamma,
      netTheta,
      netVega
    },
    profitLossCurve
  };
}

// server/services/alpacaOptions.ts
var ALPACA_DATA_URL = "https://data.alpaca.markets";
var ALPACA_API_KEY2 = process.env.ALPACA_API_KEY || "";
var ALPACA_API_SECRET2 = process.env.ALPACA_API_SECRET || "";
function parseOptionSymbol(symbol) {
  try {
    const match = symbol.match(/^([A-Z]{1,6})(\d{6})([CP])(\d{8})$/);
    if (!match) return null;
    const [, underlying, dateStr, typeChar, strikeStr] = match;
    const year = 2e3 + parseInt(dateStr.substring(0, 2));
    const month = parseInt(dateStr.substring(2, 4)) - 1;
    const day = parseInt(dateStr.substring(4, 6));
    const expiration = new Date(year, month, day);
    const now = /* @__PURE__ */ new Date();
    const daysToExpiry = Math.ceil((expiration.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24));
    const strike = parseInt(strikeStr) / 1e3;
    return {
      symbol,
      underlying,
      expiration,
      type: typeChar === "C" ? "call" : "put",
      strike,
      daysToExpiry
    };
  } catch (error) {
    console.error(`[AlpacaOptions] Failed to parse symbol ${symbol}:`, error);
    return null;
  }
}
async function fetchOptionsChain(underlying, filter) {
  if (!ALPACA_API_KEY2 || !ALPACA_API_SECRET2) {
    console.error("[AlpacaOptions] API credentials not configured");
    return [];
  }
  try {
    const params = new URLSearchParams();
    params.set("feed", "indicative");
    params.set("limit", (filter?.limit || 1e3).toString());
    if (filter?.type) {
      params.set("type", filter.type);
    }
    if (filter?.minStrike !== void 0) {
      params.set("strike_price_gte", filter.minStrike.toString());
    }
    if (filter?.maxStrike !== void 0) {
      params.set("strike_price_lte", filter.maxStrike.toString());
    }
    if (filter?.expirationDate) {
      params.set("expiration_date", filter.expirationDate);
    }
    if (filter?.minExpiration) {
      params.set("expiration_date_gte", filter.minExpiration);
    }
    if (filter?.maxExpiration) {
      params.set("expiration_date_lte", filter.maxExpiration);
    }
    const url = `${ALPACA_DATA_URL}/v1beta1/options/snapshots/${underlying}?${params.toString()}`;
    console.log(`[AlpacaOptions] Fetching options chain for ${underlying}`);
    const response = await fetch(url, {
      headers: {
        "APCA-API-KEY-ID": ALPACA_API_KEY2,
        "APCA-API-SECRET-KEY": ALPACA_API_SECRET2,
        "Accept": "application/json"
      }
    });
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[AlpacaOptions] API error: ${response.status} - ${errorText}`);
      return [];
    }
    const data = await response.json();
    const enhancedOptions = [];
    for (const [symbol, snapshot] of Object.entries(data.snapshots)) {
      const parsed = parseOptionSymbol(symbol);
      if (!parsed) continue;
      if (filter?.minDaysToExpiry !== void 0 && parsed.daysToExpiry < filter.minDaysToExpiry) continue;
      if (filter?.maxDaysToExpiry !== void 0 && parsed.daysToExpiry > filter.maxDaysToExpiry) continue;
      if (filter?.minDelta !== void 0 && Math.abs(snapshot.greeks.delta) < filter.minDelta) continue;
      if (filter?.maxDelta !== void 0 && Math.abs(snapshot.greeks.delta) > filter.maxDelta) continue;
      if (filter?.minIV !== void 0 && snapshot.impliedVolatility < filter.minIV) continue;
      if (filter?.maxIV !== void 0 && snapshot.impliedVolatility > filter.maxIV) continue;
      const bidPrice = snapshot.latestQuote.bp || 0;
      const askPrice = snapshot.latestQuote.ap || 0;
      const midPrice = (bidPrice + askPrice) / 2;
      const spread = askPrice - bidPrice;
      const spreadPercent = midPrice > 0 ? spread / midPrice * 100 : 0;
      enhancedOptions.push({
        ...parsed,
        greeks: snapshot.greeks,
        iv: snapshot.impliedVolatility,
        bidPrice,
        askPrice,
        bidSize: snapshot.latestQuote.bs || 0,
        askSize: snapshot.latestQuote.as || 0,
        lastPrice: snapshot.latestTrade?.p || midPrice,
        lastSize: snapshot.latestTrade?.s || 0,
        spread,
        spreadPercent,
        midPrice,
        volume: 0,
        // Not provided in snapshot, would need separate call
        openInterest: 0,
        // Not provided in snapshot
        timestamp: new Date(snapshot.latestQuote.t)
      });
    }
    let pageToken = data.next_page_token;
    while (pageToken && enhancedOptions.length < (filter?.limit || 1e3)) {
      params.set("page_token", pageToken);
      const nextUrl = `${ALPACA_DATA_URL}/v1beta1/options/snapshots/${underlying}?${params.toString()}`;
      const nextResponse = await fetch(nextUrl, {
        headers: {
          "APCA-API-KEY-ID": ALPACA_API_KEY2,
          "APCA-API-SECRET-KEY": ALPACA_API_SECRET2,
          "Accept": "application/json"
        }
      });
      if (!nextResponse.ok) break;
      const nextData = await nextResponse.json();
      for (const [symbol, snapshot] of Object.entries(nextData.snapshots)) {
        const parsed = parseOptionSymbol(symbol);
        if (!parsed) continue;
        const bidPrice = snapshot.latestQuote.bp || 0;
        const askPrice = snapshot.latestQuote.ap || 0;
        const midPrice = (bidPrice + askPrice) / 2;
        const spread = askPrice - bidPrice;
        const spreadPercent = midPrice > 0 ? spread / midPrice * 100 : 0;
        enhancedOptions.push({
          ...parsed,
          greeks: snapshot.greeks,
          iv: snapshot.impliedVolatility,
          bidPrice,
          askPrice,
          bidSize: snapshot.latestQuote.bs || 0,
          askSize: snapshot.latestQuote.as || 0,
          lastPrice: snapshot.latestTrade?.p || midPrice,
          lastSize: snapshot.latestTrade?.s || 0,
          spread,
          spreadPercent,
          midPrice,
          volume: 0,
          openInterest: 0,
          timestamp: new Date(snapshot.latestQuote.t)
        });
      }
      pageToken = nextData.next_page_token;
    }
    console.log(`[AlpacaOptions] Fetched ${enhancedOptions.length} options for ${underlying}`);
    return enhancedOptions;
  } catch (error) {
    console.error("[AlpacaOptions] Error fetching options chain:", error);
    return [];
  }
}
function buildIVSurface(options) {
  return options.map((opt) => ({
    strike: opt.strike,
    daysToExpiry: opt.daysToExpiry,
    iv: opt.iv,
    type: opt.type
  }));
}
function calculateGreeksSummary(options, positions, underlyingPrice) {
  let totalDelta = 0;
  let totalGamma = 0;
  let totalTheta = 0;
  let totalVega = 0;
  let totalRho = 0;
  for (const opt of options) {
    const quantity = positions.get(opt.symbol) || 0;
    if (quantity === 0) continue;
    const multiplier = quantity * 100;
    totalDelta += opt.greeks.delta * multiplier;
    totalGamma += opt.greeks.gamma * multiplier;
    totalTheta += opt.greeks.theta * multiplier;
    totalVega += opt.greeks.vega * multiplier;
    totalRho += opt.greeks.rho * multiplier;
  }
  return {
    totalDelta,
    totalGamma,
    totalTheta,
    totalVega,
    totalRho,
    deltaExposure: totalDelta * underlyingPrice,
    gammaExposure: totalGamma * underlyingPrice * underlyingPrice * 0.01,
    vegaExposure: totalVega * 100,
    thetaExposure: totalTheta * 100
  };
}
function detectUnusualActivity(options, historicalIV) {
  const unusual = [];
  for (const opt of options) {
    const ivHistory = historicalIV.get(opt.underlying) || [];
    const ivPercentile = ivHistory.length > 0 ? ivHistory.filter((iv) => iv < opt.iv).length / ivHistory.length * 100 : 50;
    let sentiment = "neutral";
    if (opt.type === "call" && opt.greeks.delta > 0.3) {
      sentiment = "bullish";
    } else if (opt.type === "put" && Math.abs(opt.greeks.delta) > 0.3) {
      sentiment = "bearish";
    }
    if (ivPercentile > 80) {
      unusual.push({
        symbol: opt.symbol,
        type: opt.type,
        strike: opt.strike,
        expiration: opt.expiration,
        volume: opt.volume,
        avgVolume: 0,
        // Would need historical data
        volumeRatio: 0,
        iv: opt.iv,
        ivPercentile,
        sentiment,
        significance: ivPercentile > 95 ? "high" : ivPercentile > 85 ? "medium" : "low"
      });
    }
  }
  return unusual;
}
async function getATMStraddle(underlying, spotPrice, targetDTE = 30) {
  const options = await fetchOptionsChain(underlying, {
    minStrike: spotPrice * 0.95,
    maxStrike: spotPrice * 1.05,
    minDaysToExpiry: targetDTE - 7,
    maxDaysToExpiry: targetDTE + 7
  });
  if (options.length === 0) return null;
  const strikes = Array.from(new Set(options.map((o) => o.strike)));
  const atmStrike = strikes.reduce(
    (closest, strike) => Math.abs(strike - spotPrice) < Math.abs(closest - spotPrice) ? strike : closest
  );
  const atmOptions = options.filter((o) => o.strike === atmStrike);
  const call = atmOptions.find((o) => o.type === "call") || null;
  const put = atmOptions.find((o) => o.type === "put") || null;
  if (!call || !put) return null;
  const totalPremium = call.midPrice + put.midPrice;
  const breakEvenUp = atmStrike + totalPremium;
  const breakEvenDown = atmStrike - totalPremium;
  const impliedMove = totalPremium;
  const impliedMovePercent = totalPremium / spotPrice * 100;
  return {
    call,
    put,
    totalPremium,
    breakEvenUp,
    breakEvenDown,
    impliedMove,
    impliedMovePercent
  };
}
function getTermStructure(options) {
  const byDTE = /* @__PURE__ */ new Map();
  for (const opt of options) {
    const existing = byDTE.get(opt.daysToExpiry) || [];
    existing.push(opt);
    byDTE.set(opt.daysToExpiry, existing);
  }
  const termStructure = [];
  for (const [dte, opts] of Array.from(byDTE.entries())) {
    const avgIV = opts.reduce((sum2, o) => sum2 + o.iv, 0) / opts.length;
    const atmOpt = opts.filter((o) => o.type === "call").sort((a, b) => Math.abs(a.greeks.delta - 0.5) - Math.abs(b.greeks.delta - 0.5))[0];
    termStructure.push({
      daysToExpiry: dte,
      avgIV,
      atmIV: atmOpt?.iv || avgIV
    });
  }
  return termStructure.sort((a, b) => a.daysToExpiry - b.daysToExpiry);
}
function getSkew(options, spotPrice) {
  const byStrike = /* @__PURE__ */ new Map();
  for (const opt of options) {
    const existing = byStrike.get(opt.strike) || {};
    if (opt.type === "call") {
      existing.call = opt;
    } else {
      existing.put = opt;
    }
    byStrike.set(opt.strike, existing);
  }
  const skew = [];
  for (const [strike, opts] of Array.from(byStrike.entries())) {
    skew.push({
      strike,
      moneyness: strike / spotPrice,
      callIV: opts.call?.iv || 0,
      putIV: opts.put?.iv || 0
    });
  }
  return skew.sort((a, b) => a.strike - b.strike);
}
function getAlpacaOptionsStatus() {
  return {
    configured: !!(ALPACA_API_KEY2 && ALPACA_API_SECRET2),
    apiKey: ALPACA_API_KEY2 ? `${ALPACA_API_KEY2.substring(0, 4)}...` : "Not configured"
  };
}

// server/services/liveOptionsAnalyzer.ts
var optionsCache = /* @__PURE__ */ new Map();
var CACHE_TTL = 3e4;
async function analyzeLiveOptions(underlying, spotPrice, filter) {
  const startTime = Date.now();
  const cached = optionsCache.get(underlying);
  if (cached && Date.now() - cached.timestamp.getTime() < CACHE_TTL && cached.analysis) {
    console.log(`[LiveOptionsAnalyzer] Using cached data for ${underlying}`);
    return cached.analysis;
  }
  console.log(`[LiveOptionsAnalyzer] Fetching fresh options data for ${underlying}`);
  const options = await fetchOptionsChain(underlying, {
    ...filter,
    minDaysToExpiry: 1,
    maxDaysToExpiry: filter?.maxDaysToExpiry || 90,
    limit: 1e3
  });
  if (options.length === 0) {
    throw new Error(`No options data available for ${underlying}`);
  }
  const calls = options.filter((o) => o.type === "call");
  const puts = options.filter((o) => o.type === "put");
  const avgCallIV = calls.length > 0 ? calls.reduce((sum2, o) => sum2 + o.iv, 0) / calls.length : 0;
  const avgPutIV = puts.length > 0 ? puts.reduce((sum2, o) => sum2 + o.iv, 0) / puts.length : 0;
  const atmCalls = calls.filter((c) => Math.abs(c.greeks.delta - 0.5) < 0.1);
  const atmPuts = puts.filter((p) => Math.abs(p.greeks.delta + 0.5) < 0.1);
  const atmCallIV = atmCalls.length > 0 ? atmCalls.reduce((sum2, o) => sum2 + o.iv, 0) / atmCalls.length : avgCallIV;
  const atmPutIV = atmPuts.length > 0 ? atmPuts.reduce((sum2, o) => sum2 + o.iv, 0) / atmPuts.length : avgPutIV;
  const atmIV = (atmCallIV + atmPutIV) / 2;
  const ivSkew = atmPutIV - atmCallIV;
  const termStructure = getTermStructure(options);
  let ivTermStructure = "flat";
  if (termStructure.length >= 2) {
    const shortTermIV = termStructure[0].atmIV;
    const longTermIV = termStructure[termStructure.length - 1].atmIV;
    const diff = longTermIV - shortTermIV;
    if (diff > 0.02) {
      ivTermStructure = "contango";
    } else if (diff < -0.02) {
      ivTermStructure = "backwardation";
    }
  }
  const greeksSummary = calculateGreeksSummary(options, /* @__PURE__ */ new Map(), spotPrice);
  const straddle = await getATMStraddle(underlying, spotPrice, 30);
  const expectedMove = straddle?.impliedMove || spotPrice * atmIV * Math.sqrt(30 / 365);
  const expectedMovePercent = straddle?.impliedMovePercent || atmIV * Math.sqrt(30 / 365) * 100;
  const unusualActivity = detectUnusualActivity(options, /* @__PURE__ */ new Map());
  const ivSurface = buildIVSurface(options);
  const recommendations = generateRecommendations(
    options,
    spotPrice,
    atmIV,
    ivSkew,
    ivTermStructure,
    unusualActivity
  );
  const analysis = {
    underlying,
    spotPrice,
    timestamp: /* @__PURE__ */ new Date(),
    totalContracts: options.length,
    callCount: calls.length,
    putCount: puts.length,
    atmIV,
    avgCallIV,
    avgPutIV,
    ivSkew,
    ivTermStructure,
    greeksSummary,
    expectedMove,
    expectedMovePercent,
    unusualActivity,
    ivSurface,
    recommendations
  };
  optionsCache.set(underlying, {
    data: options,
    timestamp: /* @__PURE__ */ new Date(),
    analysis
  });
  console.log(`[LiveOptionsAnalyzer] Analysis complete for ${underlying} in ${Date.now() - startTime}ms`);
  return analysis;
}
function generateRecommendations(options, spotPrice, atmIV, ivSkew, termStructure, unusualActivity) {
  const recommendations = [];
  if (atmIV > 0.4) {
    recommendations.push({
      type: "strategy",
      title: "High IV Environment - Consider Selling Premium",
      description: `ATM IV is ${(atmIV * 100).toFixed(1)}%, which is elevated. Consider selling options strategies like Iron Condors or Credit Spreads to collect premium.`,
      confidence: 0.75,
      details: {
        atmIV,
        suggestedStrategies: ["Iron Condor", "Credit Spread", "Short Strangle"]
      }
    });
  } else if (atmIV < 0.15) {
    recommendations.push({
      type: "strategy",
      title: "Low IV Environment - Consider Buying Premium",
      description: `ATM IV is ${(atmIV * 100).toFixed(1)}%, which is low. Consider buying options strategies like Straddles or Strangles before volatility expansion.`,
      confidence: 0.7,
      details: {
        atmIV,
        suggestedStrategies: ["Long Straddle", "Long Strangle", "Calendar Spread"]
      }
    });
  }
  if (ivSkew > 0.05) {
    recommendations.push({
      type: "opportunity",
      title: "Put Skew Elevated - Bearish Sentiment",
      description: `Put IV is ${(ivSkew * 100).toFixed(1)}% higher than call IV, indicating elevated demand for downside protection. Consider put spreads or risk reversals.`,
      confidence: 0.65,
      details: {
        ivSkew,
        sentiment: "bearish",
        suggestedStrategies: ["Put Spread", "Risk Reversal", "Collar"]
      }
    });
  } else if (ivSkew < -0.03) {
    recommendations.push({
      type: "opportunity",
      title: "Call Skew Elevated - Bullish Sentiment",
      description: `Call IV is ${(Math.abs(ivSkew) * 100).toFixed(1)}% higher than put IV, indicating elevated demand for upside exposure. Consider call spreads.`,
      confidence: 0.65,
      details: {
        ivSkew,
        sentiment: "bullish",
        suggestedStrategies: ["Call Spread", "Bull Call Spread"]
      }
    });
  }
  if (termStructure === "backwardation") {
    recommendations.push({
      type: "warning",
      title: "IV Term Structure in Backwardation",
      description: "Short-term IV is higher than long-term IV, often indicating near-term event risk (earnings, news). Be cautious with short-dated positions.",
      confidence: 0.8,
      details: {
        termStructure,
        suggestedAction: "Avoid selling short-dated options"
      }
    });
  }
  const highSignificanceActivity = unusualActivity.filter((a) => a.significance === "high");
  if (highSignificanceActivity.length > 0) {
    const activity = highSignificanceActivity[0];
    recommendations.push({
      type: "opportunity",
      title: `Unusual Options Activity Detected`,
      description: `High significance ${activity.type} activity at $${activity.strike} strike with IV at ${(activity.iv * 100).toFixed(1)}% (${activity.ivPercentile.toFixed(0)}th percentile).`,
      confidence: 0.6,
      details: {
        activity,
        sentiment: activity.sentiment
      }
    });
  }
  const goodRiskReward = options.filter(
    (o) => o.spreadPercent < 5 && // Tight spread
    Math.abs(o.greeks.delta) > 0.2 && Math.abs(o.greeks.delta) < 0.4 && // OTM but not too far
    o.daysToExpiry >= 14 && o.daysToExpiry <= 45
    // Sweet spot for theta
  );
  if (goodRiskReward.length > 0) {
    const bestOption = goodRiskReward.sort((a, b) => a.spreadPercent - b.spreadPercent)[0];
    recommendations.push({
      type: "opportunity",
      title: "Favorable Risk/Reward Option Found",
      description: `${bestOption.type.toUpperCase()} at $${bestOption.strike} strike expiring in ${bestOption.daysToExpiry} days has tight spread (${bestOption.spreadPercent.toFixed(1)}%) and delta of ${bestOption.greeks.delta.toFixed(2)}.`,
      confidence: 0.55,
      details: {
        option: bestOption
      }
    });
  }
  return recommendations;
}
async function getOptionsChainWithGreeks(underlying, filter) {
  const cached = optionsCache.get(underlying);
  if (cached && Date.now() - cached.timestamp.getTime() < CACHE_TTL) {
    let data = cached.data;
    if (filter?.type) {
      data = data.filter((o) => o.type === filter.type);
    }
    if (filter?.minStrike !== void 0) {
      data = data.filter((o) => o.strike >= filter.minStrike);
    }
    if (filter?.maxStrike !== void 0) {
      data = data.filter((o) => o.strike <= filter.maxStrike);
    }
    if (filter?.minDaysToExpiry !== void 0) {
      data = data.filter((o) => o.daysToExpiry >= filter.minDaysToExpiry);
    }
    if (filter?.maxDaysToExpiry !== void 0) {
      data = data.filter((o) => o.daysToExpiry <= filter.maxDaysToExpiry);
    }
    return data;
  }
  return fetchOptionsChain(underlying, filter);
}
async function getLiveIVSurface(underlying, spotPrice) {
  const options = await getOptionsChainWithGreeks(underlying, {
    minDaysToExpiry: 1,
    maxDaysToExpiry: 90
  });
  return {
    surface: buildIVSurface(options),
    skew: getSkew(options, spotPrice),
    termStructure: getTermStructure(options)
  };
}
var activeAlerts = /* @__PURE__ */ new Map();
function createOptionsAlert(underlying, condition, threshold) {
  const alert = {
    id: `${underlying}-${condition}-${Date.now()}`,
    underlying,
    condition,
    threshold,
    triggered: false
  };
  activeAlerts.set(alert.id, alert);
  return alert;
}
function removeAlert(alertId) {
  return activeAlerts.delete(alertId);
}
function getActiveAlerts() {
  return Array.from(activeAlerts.values());
}
function clearOptionsCache(underlying) {
  if (underlying) {
    optionsCache.delete(underlying);
  } else {
    optionsCache.clear();
  }
}
function getCacheStatus() {
  const underlyings = Array.from(optionsCache.keys());
  let oldestEntry = null;
  for (const cached of Array.from(optionsCache.values())) {
    if (!oldestEntry || cached.timestamp < oldestEntry) {
      oldestEntry = cached.timestamp;
    }
  }
  return {
    entries: optionsCache.size,
    underlyings,
    oldestEntry
  };
}

// server/services/liveVolatilitySurface.ts
var historicalIVCache = /* @__PURE__ */ new Map();
async function analyzeLiveVolatilitySurface(underlying, spotPrice) {
  console.log(`[LiveVolSurface] Analyzing volatility surface for ${underlying}`);
  const { surface, skew, termStructure } = await getLiveIVSurface(underlying, spotPrice);
  const analysis = await analyzeLiveOptions(underlying, spotPrice);
  const { ivRank, ivPercentile } = calculateIVRankPercentile(underlying, analysis.atmIV);
  const skewAnalysis = analyzeSkew(skew, spotPrice);
  const termAnalysis = analyzeTermStructure(termStructure);
  const interpolatedSurface = buildInterpolatedSurface(surface, spotPrice);
  const anomalies = detectSurfaceAnomalies(surface, interpolatedSurface, spotPrice);
  const arbitrageOpportunities = findArbitrageOpportunities(surface, spotPrice);
  const predictions = generateVolatilityPredictions(
    analysis.atmIV,
    ivRank,
    skewAnalysis,
    termAnalysis
  );
  return {
    underlying,
    spotPrice,
    timestamp: /* @__PURE__ */ new Date(),
    atmIV: analysis.atmIV,
    ivRank,
    ivPercentile,
    skewType: skewAnalysis.type,
    skewSteepness: skewAnalysis.steepness,
    putSkew25Delta: skewAnalysis.put25Delta,
    callSkew25Delta: skewAnalysis.call25Delta,
    termStructureType: termAnalysis.type,
    frontMonthIV: termAnalysis.frontMonth,
    backMonthIV: termAnalysis.backMonth,
    termSpread: termAnalysis.spread,
    surfacePoints: surface,
    interpolatedSurface,
    anomalies,
    arbitrageOpportunities,
    predictions
  };
}
function calculateIVRankPercentile(underlying, currentIV) {
  const historical = historicalIVCache.get(underlying) || [];
  if (historical.length === 0) {
    return { ivRank: 50, ivPercentile: 50 };
  }
  const last52Weeks = historical.filter(
    (h) => h.date.getTime() > Date.now() - 365 * 24 * 60 * 60 * 1e3
  );
  if (last52Weeks.length === 0) {
    return { ivRank: 50, ivPercentile: 50 };
  }
  const highIV = Math.max(...last52Weeks.map((h) => h.highIV));
  const lowIV = Math.min(...last52Weeks.map((h) => h.lowIV));
  const ivRank = highIV !== lowIV ? (currentIV - lowIV) / (highIV - lowIV) * 100 : 50;
  const daysLower = last52Weeks.filter((h) => h.atmIV < currentIV).length;
  const ivPercentile = daysLower / last52Weeks.length * 100;
  return {
    ivRank: Math.max(0, Math.min(100, ivRank)),
    ivPercentile: Math.max(0, Math.min(100, ivPercentile))
  };
}
function analyzeSkew(skew, spotPrice) {
  if (skew.length < 3) {
    return { type: "normal", steepness: 0, put25Delta: 0, call25Delta: 0 };
  }
  const atmPoint = skew.reduce(
    (closest, point) => Math.abs(point.moneyness - 1) < Math.abs(closest.moneyness - 1) ? point : closest
  );
  const atmIV = (atmPoint.callIV + atmPoint.putIV) / 2;
  const put25Delta = skew.find((s) => s.moneyness >= 0.9 && s.moneyness <= 0.95);
  const call25Delta = skew.find((s) => s.moneyness >= 1.05 && s.moneyness <= 1.1);
  const put25DeltaSkew = put25Delta ? put25Delta.putIV - atmIV : 0;
  const call25DeltaSkew = call25Delta ? call25Delta.callIV - atmIV : 0;
  let type = "normal";
  if (put25DeltaSkew > 0.02 && call25DeltaSkew > 0.02) {
    type = "smile";
  } else if (put25DeltaSkew > 0.02 && call25DeltaSkew < 0.01) {
    type = "smirk";
  } else if (put25DeltaSkew < -0.01 && call25DeltaSkew > 0.02) {
    type = "inverted";
  }
  const otmPuts = skew.filter((s) => s.moneyness < 1);
  let steepness = 0;
  if (otmPuts.length >= 2) {
    const sorted = otmPuts.sort((a, b) => a.moneyness - b.moneyness);
    const first = sorted[0];
    const last = sorted[sorted.length - 1];
    steepness = (first.putIV - last.putIV) / (last.moneyness - first.moneyness);
  }
  return {
    type,
    steepness,
    put25Delta: put25DeltaSkew,
    call25Delta: call25DeltaSkew
  };
}
function analyzeTermStructure(termStructure) {
  if (termStructure.length < 2) {
    return { type: "flat", frontMonth: 0, backMonth: 0, spread: 0 };
  }
  const sorted = termStructure.sort((a, b) => a.daysToExpiry - b.daysToExpiry);
  const frontMonth = sorted[0].atmIV;
  const backMonth = sorted[sorted.length - 1].atmIV;
  const spread = backMonth - frontMonth;
  let type = "flat";
  if (sorted.length >= 3) {
    const middleIdx = Math.floor(sorted.length / 2);
    const middleIV = sorted[middleIdx].atmIV;
    if (middleIV > frontMonth && middleIV > backMonth) {
      type = "humped";
    } else if (spread > 0.02) {
      type = "contango";
    } else if (spread < -0.02) {
      type = "backwardation";
    }
  } else {
    if (spread > 0.02) {
      type = "contango";
    } else if (spread < -0.02) {
      type = "backwardation";
    }
  }
  return { type, frontMonth, backMonth, spread };
}
function buildInterpolatedSurface(points, spotPrice) {
  const strikes = Array.from(new Set(points.map((p) => p.strike))).sort((a, b) => a - b);
  const expirations = Array.from(new Set(points.map((p) => p.daysToExpiry))).sort((a, b) => a - b);
  const ivMatrix = [];
  for (let i = 0; i < strikes.length; i++) {
    ivMatrix[i] = [];
    for (let j = 0; j < expirations.length; j++) {
      const point = points.find(
        (p) => p.strike === strikes[i] && p.daysToExpiry === expirations[j]
      );
      if (point) {
        ivMatrix[i][j] = point.iv;
      } else {
        ivMatrix[i][j] = interpolateIV(points, strikes[i], expirations[j]);
      }
    }
  }
  return { strikes, expirations, ivMatrix };
}
function interpolateIV(points, targetStrike, targetExpiry) {
  const nearby = points.map((p) => ({
    ...p,
    distance: Math.sqrt(
      Math.pow((p.strike - targetStrike) / targetStrike, 2) + Math.pow((p.daysToExpiry - targetExpiry) / Math.max(targetExpiry, 1), 2)
    )
  })).sort((a, b) => a.distance - b.distance).slice(0, 4);
  if (nearby.length === 0) return 0.3;
  let totalWeight = 0;
  let weightedIV = 0;
  for (const point of nearby) {
    const weight = 1 / (point.distance + 1e-4);
    totalWeight += weight;
    weightedIV += point.iv * weight;
  }
  return weightedIV / totalWeight;
}
function detectSurfaceAnomalies(points, interpolated, spotPrice) {
  const anomalies = [];
  for (const point of points) {
    const expectedIV = interpolateIV(
      points.filter((p) => p !== point),
      point.strike,
      point.daysToExpiry
    );
    const deviation = (point.iv - expectedIV) / expectedIV;
    if (Math.abs(deviation) > 0.15) {
      anomalies.push({
        type: deviation > 0 ? "iv_spike" : "iv_dip",
        strike: point.strike,
        daysToExpiry: point.daysToExpiry,
        severity: Math.abs(deviation) > 0.3 ? "high" : Math.abs(deviation) > 0.2 ? "medium" : "low",
        description: `IV at $${point.strike} strike (${point.daysToExpiry}d) is ${(deviation * 100).toFixed(1)}% ${deviation > 0 ? "above" : "below"} expected`,
        expectedIV,
        actualIV: point.iv,
        deviation
      });
    }
  }
  const byExpiry = /* @__PURE__ */ new Map();
  for (const point of points) {
    const existing = byExpiry.get(point.daysToExpiry) || [];
    existing.push(point);
    byExpiry.set(point.daysToExpiry, existing);
  }
  for (const [expiry, expiryPoints] of Array.from(byExpiry.entries())) {
    const sorted = expiryPoints.sort((a, b) => a.strike - b.strike);
    for (let i = 1; i < sorted.length - 1; i++) {
      const lower = sorted[i - 1];
      const middle = sorted[i];
      const upper = sorted[i + 1];
      const butterflyValue = (lower.iv + upper.iv) / 2 - middle.iv;
      if (butterflyValue < -0.02) {
        anomalies.push({
          type: "butterfly_spread",
          strike: middle.strike,
          daysToExpiry: expiry,
          severity: butterflyValue < -0.05 ? "high" : "medium",
          description: `Negative butterfly at $${middle.strike} strike suggests arbitrage opportunity`,
          expectedIV: (lower.iv + upper.iv) / 2,
          actualIV: middle.iv,
          deviation: butterflyValue
        });
      }
    }
  }
  return anomalies;
}
function findArbitrageOpportunities(points, spotPrice) {
  const opportunities = [];
  const byExpiry = /* @__PURE__ */ new Map();
  for (const point of points) {
    const existing = byExpiry.get(point.daysToExpiry) || [];
    existing.push(point);
    byExpiry.set(point.daysToExpiry, existing);
  }
  const expiries = Array.from(byExpiry.keys()).sort((a, b) => a - b);
  for (let i = 0; i < expiries.length - 1; i++) {
    const frontExpiry = expiries[i];
    const backExpiry = expiries[i + 1];
    const frontPoints = byExpiry.get(frontExpiry) || [];
    const backPoints = byExpiry.get(backExpiry) || [];
    const frontATM = frontPoints.find(
      (p) => Math.abs(p.strike - spotPrice) / spotPrice < 0.05
    );
    const backATM = backPoints.find(
      (p) => Math.abs(p.strike - spotPrice) / spotPrice < 0.05
    );
    if (frontATM && backATM) {
      const ivDiff = frontATM.iv - backATM.iv;
      if (ivDiff > 0.05) {
        opportunities.push({
          type: "calendar_spread",
          legs: [
            { strike: frontATM.strike, expiry: frontExpiry, type: "call", action: "sell", iv: frontATM.iv },
            { strike: backATM.strike, expiry: backExpiry, type: "call", action: "buy", iv: backATM.iv }
          ],
          expectedProfit: ivDiff * 100,
          // Simplified profit estimate
          riskLevel: "medium",
          description: `Sell front month (${frontExpiry}d) at ${(frontATM.iv * 100).toFixed(1)}% IV, buy back month (${backExpiry}d) at ${(backATM.iv * 100).toFixed(1)}% IV`
        });
      }
    }
  }
  for (const [expiry, expiryPoints] of Array.from(byExpiry.entries())) {
    const sorted = expiryPoints.sort((a, b) => a.strike - b.strike);
    for (let i = 1; i < sorted.length - 1; i++) {
      const lower = sorted[i - 1];
      const middle = sorted[i];
      const upper = sorted[i + 1];
      const butterflyValue = (lower.iv + upper.iv) / 2 - middle.iv;
      if (butterflyValue < -0.03) {
        opportunities.push({
          type: "butterfly",
          legs: [
            { strike: lower.strike, expiry, type: "call", action: "buy", iv: lower.iv },
            { strike: middle.strike, expiry, type: "call", action: "sell", iv: middle.iv },
            { strike: middle.strike, expiry, type: "call", action: "sell", iv: middle.iv },
            { strike: upper.strike, expiry, type: "call", action: "buy", iv: upper.iv }
          ],
          expectedProfit: Math.abs(butterflyValue) * 100,
          riskLevel: "low",
          description: `Butterfly spread at $${middle.strike} with ${expiry}d expiry shows IV convexity violation`
        });
      }
    }
  }
  return opportunities;
}
function generateVolatilityPredictions(currentIV, ivRank, skewAnalysis, termAnalysis) {
  const predictions = [];
  let direction1d = "stable";
  let predicted1d = currentIV;
  if (ivRank > 80) {
    direction1d = "down";
    predicted1d = currentIV * 0.98;
  } else if (ivRank < 20) {
    direction1d = "up";
    predicted1d = currentIV * 1.02;
  }
  predictions.push({
    horizon: "1d",
    predictedIV: predicted1d,
    confidence: 0.6,
    direction: direction1d
  });
  let direction1w = "stable";
  let predicted1w = currentIV;
  if (termAnalysis.type === "backwardation") {
    direction1w = "down";
    predicted1w = currentIV * 0.95;
    predictions.push({
      horizon: "1w",
      predictedIV: predicted1w,
      confidence: 0.55,
      direction: direction1w,
      catalyst: "Term structure in backwardation suggests near-term event resolution"
    });
  } else if (ivRank > 70) {
    direction1w = "down";
    predicted1w = currentIV * 0.92;
    predictions.push({
      horizon: "1w",
      predictedIV: predicted1w,
      confidence: 0.5,
      direction: direction1w
    });
  } else {
    predictions.push({
      horizon: "1w",
      predictedIV: currentIV,
      confidence: 0.45,
      direction: "stable"
    });
  }
  let direction1m = "stable";
  let predicted1m = currentIV;
  if (ivRank > 85) {
    direction1m = "down";
    predicted1m = currentIV * 0.85;
  } else if (ivRank < 15) {
    direction1m = "up";
    predicted1m = currentIV * 1.15;
  }
  predictions.push({
    horizon: "1m",
    predictedIV: predicted1m,
    confidence: 0.4,
    direction: direction1m
  });
  return predictions;
}
async function getIVRank(underlying, spotPrice) {
  const analysis = await analyzeLiveOptions(underlying, spotPrice);
  const { ivRank, ivPercentile } = calculateIVRankPercentile(underlying, analysis.atmIV);
  return {
    ivRank,
    ivPercentile,
    currentIV: analysis.atmIV
  };
}
async function getVolatilitySurfaceSummary(underlying, spotPrice) {
  const analysis = await analyzeLiveVolatilitySurface(underlying, spotPrice);
  return {
    atmIV: analysis.atmIV,
    ivRank: analysis.ivRank,
    skewType: analysis.skewType,
    termStructure: analysis.termStructureType,
    anomalyCount: analysis.anomalies.length,
    opportunityCount: analysis.arbitrageOpportunities.length
  };
}

// server/services/sentimentAnalysis.ts
init_llm();
function generateSimulatedNews(symbol) {
  const headlines = [
    { headline: `${symbol} Reports Strong Q4 Earnings, Beats Expectations`, sentiment: "bullish", score: 0.7 },
    { headline: `Analysts Upgrade ${symbol} to Buy Rating`, sentiment: "very_bullish", score: 0.85 },
    { headline: `${symbol} Announces New Product Launch`, sentiment: "bullish", score: 0.6 },
    { headline: `Market Volatility Impacts ${symbol} Stock`, sentiment: "neutral", score: 0.1 },
    { headline: `${symbol} Faces Regulatory Scrutiny`, sentiment: "bearish", score: -0.5 },
    { headline: `Institutional Investors Increase ${symbol} Holdings`, sentiment: "bullish", score: 0.55 },
    { headline: `${symbol} CEO Discusses Growth Strategy`, sentiment: "bullish", score: 0.45 },
    { headline: `Supply Chain Concerns Affect ${symbol}`, sentiment: "bearish", score: -0.35 }
  ];
  const sources = ["Reuters", "Bloomberg", "CNBC", "WSJ", "Financial Times", "MarketWatch"];
  const now = /* @__PURE__ */ new Date();
  return headlines.slice(0, 5 + Math.floor(Math.random() * 3)).map((item, i) => ({
    ...item,
    source: sources[i % sources.length],
    publishedAt: new Date(now.getTime() - i * 36e5 * (1 + Math.random() * 5)).toISOString(),
    relevance: 0.7 + Math.random() * 0.3,
    summary: `Analysis of ${symbol} based on recent market developments and company performance.`
  }));
}
function generateSimulatedSocial(symbol) {
  return [
    {
      platform: "Twitter/X",
      mentions: 15e3 + Math.floor(Math.random() * 1e4),
      sentimentScore: 0.3 + (Math.random() - 0.5) * 0.4,
      volumeChange: (Math.random() - 0.3) * 50,
      topTopics: ["earnings", "growth", "innovation", "market"],
      influencerSentiment: 0.4 + (Math.random() - 0.5) * 0.3
    },
    {
      platform: "Reddit",
      mentions: 5e3 + Math.floor(Math.random() * 5e3),
      sentimentScore: 0.2 + (Math.random() - 0.5) * 0.5,
      volumeChange: (Math.random() - 0.3) * 40,
      topTopics: ["DD", "analysis", "hold", "buy"],
      influencerSentiment: 0.35 + (Math.random() - 0.5) * 0.4
    },
    {
      platform: "StockTwits",
      mentions: 3e3 + Math.floor(Math.random() * 3e3),
      sentimentScore: 0.25 + (Math.random() - 0.5) * 0.4,
      volumeChange: (Math.random() - 0.3) * 30,
      topTopics: ["bullish", "technical", "support", "breakout"],
      influencerSentiment: 0.3 + (Math.random() - 0.5) * 0.35
    }
  ];
}
function calculateFearGreedIndex() {
  const components = {
    marketMomentum: 40 + Math.random() * 40,
    stockPriceStrength: 35 + Math.random() * 45,
    stockPriceBreadth: 45 + Math.random() * 35,
    putCallRatio: 30 + Math.random() * 50,
    marketVolatility: 40 + Math.random() * 40,
    safehavenDemand: 35 + Math.random() * 45,
    junkBondDemand: 40 + Math.random() * 40
  };
  const value = Math.round(
    components.marketMomentum * 0.2 + components.stockPriceStrength * 0.15 + components.stockPriceBreadth * 0.15 + components.putCallRatio * 0.15 + components.marketVolatility * 0.15 + components.safehavenDemand * 0.1 + components.junkBondDemand * 0.1
  );
  let level;
  if (value < 20) level = "extreme_fear";
  else if (value < 40) level = "fear";
  else if (value < 60) level = "neutral";
  else if (value < 80) level = "greed";
  else level = "extreme_greed";
  const history = [];
  const now = /* @__PURE__ */ new Date();
  let histValue = value;
  for (let i = 30; i >= 0; i--) {
    const date2 = new Date(now);
    date2.setDate(date2.getDate() - i);
    histValue = Math.max(0, Math.min(100, histValue + (Math.random() - 0.5) * 10));
    history.push({
      date: date2.toISOString().split("T")[0],
      value: Math.round(histValue)
    });
  }
  return { value, level, components, history };
}
function scoreToLevel(score) {
  if (score < -0.6) return "very_bearish";
  if (score < -0.2) return "bearish";
  if (score < 0.2) return "neutral";
  if (score < 0.6) return "bullish";
  return "very_bullish";
}
async function getAIInterpretation(symbol, overallScore, news, social, fearGreed) {
  const newsHeadlines = news.slice(0, 5).map((n) => `- ${n.headline} (${n.sentiment})`).join("\n");
  const socialSummary = social.map((s) => `${s.platform}: ${s.sentimentScore.toFixed(2)} score, ${s.mentions} mentions`).join(", ");
  const prompt = `Analyze the sentiment data for ${symbol} stock and provide a brief interpretation:

Overall Sentiment Score: ${overallScore.toFixed(2)} (scale: -1 to 1)
Fear & Greed Index: ${fearGreed.value} (${fearGreed.level})

Recent News Headlines:
${newsHeadlines}

Social Media Summary: ${socialSummary}

Provide a 2-3 sentence interpretation of the current sentiment landscape and what it might mean for the stock. Be specific and actionable.`;
  try {
    const response = await invokeLLM({
      messages: [
        { role: "system", content: "You are a financial sentiment analyst. Provide concise, actionable interpretations." },
        { role: "user", content: prompt }
      ]
    });
    const content = response.choices[0]?.message?.content;
    return typeof content === "string" ? content : "Unable to generate interpretation.";
  } catch (error) {
    console.error("LLM interpretation error:", error);
    return `Sentiment for ${symbol} is ${scoreToLevel(overallScore)} with a score of ${overallScore.toFixed(2)}. The Fear & Greed Index at ${fearGreed.value} suggests ${fearGreed.level.replace("_", " ")} in the market.`;
  }
}
async function analyzeSentiment(symbol) {
  const news = generateSimulatedNews(symbol);
  const social = generateSimulatedSocial(symbol);
  const fearGreedIndex = calculateFearGreedIndex();
  const sources = [
    {
      name: "News Articles",
      type: "news",
      score: news.reduce((sum2, n) => sum2 + n.score * n.relevance, 0) / news.length,
      confidence: 0.8,
      sampleSize: news.length,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    {
      name: "Social Media",
      type: "social",
      score: social.reduce((sum2, s) => sum2 + s.sentimentScore, 0) / social.length,
      confidence: 0.6,
      sampleSize: social.reduce((sum2, s) => sum2 + s.mentions, 0),
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    {
      name: "Analyst Ratings",
      type: "analyst",
      score: 0.3 + (Math.random() - 0.5) * 0.4,
      confidence: 0.85,
      sampleSize: 15 + Math.floor(Math.random() * 10),
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    {
      name: "Insider Activity",
      type: "insider",
      score: 0.1 + (Math.random() - 0.5) * 0.3,
      confidence: 0.9,
      sampleSize: 5 + Math.floor(Math.random() * 5),
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    }
  ];
  const weights = { news: 0.35, social: 0.25, analyst: 0.25, insider: 0.15 };
  const overallScore = sources.reduce((sum2, s) => {
    const weight = weights[s.type] || 0.25;
    return sum2 + s.score * weight * s.confidence;
  }, 0);
  const overallSentiment = scoreToLevel(overallScore);
  const confidence = sources.reduce((sum2, s) => sum2 + s.confidence, 0) / sources.length;
  const previousScore = overallScore + (Math.random() - 0.5) * 0.2;
  const momentum = {
    current: overallScore,
    previous: previousScore,
    change: overallScore - previousScore,
    trend: overallScore > previousScore + 0.05 ? "improving" : overallScore < previousScore - 0.05 ? "deteriorating" : "stable",
    velocity: (overallScore - previousScore) / 7
    // Weekly velocity
  };
  const indicators = [
    {
      name: "News Sentiment",
      value: sources[0].score,
      interpretation: sources[0].score > 0.3 ? "Positive news coverage" : sources[0].score < -0.3 ? "Negative news coverage" : "Mixed news coverage",
      weight: 0.35
    },
    {
      name: "Social Buzz",
      value: sources[1].score,
      interpretation: social[0].volumeChange > 20 ? "High social media activity" : social[0].volumeChange < -20 ? "Declining social interest" : "Normal social activity",
      weight: 0.25
    },
    {
      name: "Analyst Consensus",
      value: sources[2].score,
      interpretation: sources[2].score > 0.4 ? "Bullish analyst consensus" : sources[2].score < -0.2 ? "Bearish analyst consensus" : "Mixed analyst views",
      weight: 0.25
    },
    {
      name: "Insider Sentiment",
      value: sources[3].score,
      interpretation: sources[3].score > 0.2 ? "Net insider buying" : sources[3].score < -0.2 ? "Net insider selling" : "Balanced insider activity",
      weight: 0.15
    },
    {
      name: "Fear & Greed",
      value: (fearGreedIndex.value - 50) / 50,
      // Normalize to -1 to 1
      interpretation: fearGreedIndex.level.replace("_", " ").replace(/\b\w/g, (l) => l.toUpperCase()),
      weight: 0.2
    }
  ];
  const aiInterpretation = await getAIInterpretation(symbol, overallScore, news, social, fearGreedIndex);
  let signal;
  let strength;
  if (overallScore > 0.5 && momentum.trend === "improving") {
    signal = "buy";
    strength = "strong";
  } else if (overallScore > 0.2) {
    signal = "buy";
    strength = "moderate";
  } else if (overallScore < -0.5 && momentum.trend === "deteriorating") {
    signal = "sell";
    strength = "strong";
  } else if (overallScore < -0.2) {
    signal = "sell";
    strength = "moderate";
  } else {
    signal = "hold";
    strength = "weak";
  }
  const risks = [];
  if (fearGreedIndex.level === "extreme_greed") risks.push("Market may be overheated - potential correction risk");
  if (fearGreedIndex.level === "extreme_fear") risks.push("High fear may indicate capitulation or further downside");
  if (Math.abs(social[0].volumeChange) > 50) risks.push("Unusual social media activity - potential volatility");
  if (confidence < 0.6) risks.push("Low confidence in sentiment data - use with caution");
  const historicalSentiment = [];
  const now = /* @__PURE__ */ new Date();
  let histScore = overallScore;
  for (let i = 30; i >= 0; i--) {
    const date2 = new Date(now);
    date2.setDate(date2.getDate() - i);
    histScore = Math.max(-1, Math.min(1, histScore + (Math.random() - 0.5) * 0.15));
    historicalSentiment.push({
      date: date2.toISOString().split("T")[0],
      score: histScore,
      level: scoreToLevel(histScore)
    });
  }
  return {
    symbol,
    overallSentiment,
    overallScore,
    confidence,
    sources,
    news,
    social,
    momentum,
    fearGreedIndex,
    indicators,
    aiInterpretation,
    tradingImplications: {
      signal,
      strength,
      reasoning: `Based on ${overallSentiment} sentiment (${overallScore.toFixed(2)}) with ${momentum.trend} momentum.`,
      risks
    },
    historicalSentiment
  };
}
async function getQuickSentiment(symbol) {
  const result = await analyzeSentiment(symbol);
  return {
    sentiment: result.overallSentiment,
    score: result.overallScore,
    signal: result.tradingImplications.signal
  };
}
async function analyzeBatchSentiment(symbols) {
  const results = await Promise.all(
    symbols.map(async (symbol) => {
      const result = await analyzeSentiment(symbol);
      return {
        symbol,
        sentiment: result.overallSentiment,
        score: result.overallScore
      };
    })
  );
  return results;
}

// server/services/cryptoTrading.ts
var SUPPORTED_CRYPTOS = [
  { symbol: "BTC", name: "Bitcoin", coingeckoId: "bitcoin" },
  { symbol: "ETH", name: "Ethereum", coingeckoId: "ethereum" },
  { symbol: "BNB", name: "BNB", coingeckoId: "binancecoin" },
  { symbol: "XRP", name: "XRP", coingeckoId: "ripple" },
  { symbol: "ADA", name: "Cardano", coingeckoId: "cardano" },
  { symbol: "SOL", name: "Solana", coingeckoId: "solana" },
  { symbol: "DOGE", name: "Dogecoin", coingeckoId: "dogecoin" },
  { symbol: "DOT", name: "Polkadot", coingeckoId: "polkadot" },
  { symbol: "MATIC", name: "Polygon", coingeckoId: "matic-network" },
  { symbol: "AVAX", name: "Avalanche", coingeckoId: "avalanche-2" },
  { symbol: "LINK", name: "Chainlink", coingeckoId: "chainlink" },
  { symbol: "UNI", name: "Uniswap", coingeckoId: "uniswap" },
  { symbol: "ATOM", name: "Cosmos", coingeckoId: "cosmos" },
  { symbol: "LTC", name: "Litecoin", coingeckoId: "litecoin" },
  { symbol: "NEAR", name: "NEAR Protocol", coingeckoId: "near" }
];
var priceCache = /* @__PURE__ */ new Map();
var CACHE_TTL2 = 60 * 1e3;
async function getCryptoPrice(symbol) {
  const crypto6 = SUPPORTED_CRYPTOS.find((c) => c.symbol === symbol.toUpperCase());
  if (!crypto6) return null;
  const cached = priceCache.get(symbol);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL2) {
    return cached.data;
  }
  try {
    const basePrice = getBaseCryptoPrice(symbol);
    const volatility = getCryptoVolatility(symbol);
    const randomChange = (Math.random() - 0.5) * volatility * basePrice;
    const price = basePrice + randomChange;
    const priceData = {
      symbol: crypto6.symbol,
      name: crypto6.name,
      price,
      priceChange24h: randomChange,
      priceChangePercent24h: randomChange / basePrice * 100,
      volume24h: basePrice * (1e6 + Math.random() * 1e7),
      marketCap: price * getCirculatingSupply(symbol),
      high24h: price * (1 + volatility / 2),
      low24h: price * (1 - volatility / 2),
      circulatingSupply: getCirculatingSupply(symbol),
      totalSupply: getTotalSupply(symbol),
      maxSupply: getMaxSupply(symbol),
      lastUpdated: /* @__PURE__ */ new Date()
    };
    priceCache.set(symbol, { data: priceData, timestamp: Date.now() });
    return priceData;
  } catch (error) {
    console.error(`Error fetching crypto price for ${symbol}:`, error);
    return null;
  }
}
async function getCryptoPrices(symbols) {
  const targetSymbols = symbols || SUPPORTED_CRYPTOS.map((c) => c.symbol);
  const prices = await Promise.all(targetSymbols.map(getCryptoPrice));
  return prices.filter((p) => p !== null);
}
async function getCryptoOHLCV(symbol, interval = "1d", days = 30) {
  const basePrice = getBaseCryptoPrice(symbol);
  const volatility = getCryptoVolatility(symbol);
  const data = [];
  const intervalMs = {
    "1h": 60 * 60 * 1e3,
    "4h": 4 * 60 * 60 * 1e3,
    "1d": 24 * 60 * 60 * 1e3,
    "1w": 7 * 24 * 60 * 60 * 1e3
  };
  const periods = Math.floor(days * 24 * 60 * 60 * 1e3 / intervalMs[interval]);
  let currentPrice = basePrice * (0.8 + Math.random() * 0.4);
  const now = Date.now();
  for (let i = periods - 1; i >= 0; i--) {
    const timestamp2 = now - i * intervalMs[interval];
    const change = (Math.random() - 0.48) * volatility * currentPrice;
    const open = currentPrice;
    const close = currentPrice + change;
    const high = Math.max(open, close) * (1 + Math.random() * volatility * 0.5);
    const low = Math.min(open, close) * (1 - Math.random() * volatility * 0.5);
    const volume = basePrice * (1e5 + Math.random() * 1e6);
    data.push({ timestamp: timestamp2, open, high, low, close, volume });
    currentPrice = close;
  }
  return data;
}
async function getCryptoIndicators(symbol) {
  const ohlcv = await getCryptoOHLCV(symbol, "1d", 200);
  const closes = ohlcv.map((d) => d.close);
  const volumes = ohlcv.map((d) => d.volume);
  const rsi = calculateRSI3(closes, 14);
  const macd = calculateMACD2(closes);
  const bollingerBands = calculateBollingerBands(closes, 20, 2);
  const ema20 = calculateEMA5(closes, 20);
  const ema50 = calculateEMA5(closes, 50);
  const ema200 = calculateEMA5(closes, 200);
  const currentPrice = closes[closes.length - 1];
  const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;
  const nvtRatio = 50 + Math.random() * 100;
  const mvrvRatio = 1 + Math.random() * 3;
  const sopr = 0.95 + Math.random() * 0.15;
  const fearGreedIndex = Math.floor(20 + Math.random() * 60);
  const hashRate = symbol === "BTC" ? 400 + Math.random() * 200 : void 0;
  const activeAddresses = Math.floor(5e5 + Math.random() * 5e5);
  const exchangeNetFlow = (Math.random() - 0.5) * 1e4;
  const fundingRate = (Math.random() - 0.5) * 0.1;
  const openInterest = currentPrice * (1e7 + Math.random() * 5e7);
  const longShortRatio = 0.8 + Math.random() * 0.8;
  return {
    rsi,
    macd,
    bollingerBands,
    ema20,
    ema50,
    ema200,
    nvtRatio,
    mvrvRatio,
    sopr,
    fearGreedIndex,
    hashRate,
    activeAddresses,
    exchangeNetFlow,
    fundingRate,
    openInterest,
    longShortRatio
  };
}
async function getDeFiProtocols() {
  return [
    {
      name: "Aave",
      chain: "Ethereum",
      tvl: 105e8 + Math.random() * 1e9,
      tvlChange24h: (Math.random() - 0.5) * 5,
      apy: 2 + Math.random() * 8,
      category: "lending",
      token: "AAVE",
      tokenPrice: 80 + Math.random() * 20
    },
    {
      name: "Uniswap",
      chain: "Ethereum",
      tvl: 5e9 + Math.random() * 5e8,
      tvlChange24h: (Math.random() - 0.5) * 5,
      apy: 5 + Math.random() * 30,
      category: "dex",
      token: "UNI",
      tokenPrice: 6 + Math.random() * 2
    },
    {
      name: "Lido",
      chain: "Ethereum",
      tvl: 15e9 + Math.random() * 2e9,
      tvlChange24h: (Math.random() - 0.5) * 3,
      apy: 3.5 + Math.random() * 1,
      category: "staking",
      token: "LDO",
      tokenPrice: 2 + Math.random() * 1
    },
    {
      name: "Compound",
      chain: "Ethereum",
      tvl: 2e9 + Math.random() * 3e8,
      tvlChange24h: (Math.random() - 0.5) * 4,
      apy: 1.5 + Math.random() * 6,
      category: "lending",
      token: "COMP",
      tokenPrice: 50 + Math.random() * 15
    },
    {
      name: "Curve",
      chain: "Ethereum",
      tvl: 35e8 + Math.random() * 5e8,
      tvlChange24h: (Math.random() - 0.5) * 4,
      apy: 2 + Math.random() * 15,
      category: "dex",
      token: "CRV",
      tokenPrice: 0.5 + Math.random() * 0.3
    },
    {
      name: "MakerDAO",
      chain: "Ethereum",
      tvl: 7e9 + Math.random() * 1e9,
      tvlChange24h: (Math.random() - 0.5) * 3,
      apy: 5 + Math.random() * 3,
      category: "lending",
      token: "MKR",
      tokenPrice: 1500 + Math.random() * 300
    },
    {
      name: "PancakeSwap",
      chain: "BSC",
      tvl: 15e8 + Math.random() * 3e8,
      tvlChange24h: (Math.random() - 0.5) * 6,
      apy: 10 + Math.random() * 50,
      category: "dex",
      token: "CAKE",
      tokenPrice: 2 + Math.random() * 1
    },
    {
      name: "GMX",
      chain: "Arbitrum",
      tvl: 5e8 + Math.random() * 1e8,
      tvlChange24h: (Math.random() - 0.5) * 5,
      apy: 15 + Math.random() * 20,
      category: "derivatives",
      token: "GMX",
      tokenPrice: 30 + Math.random() * 10
    },
    {
      name: "Stargate",
      chain: "Multi-chain",
      tvl: 4e8 + Math.random() * 1e8,
      tvlChange24h: (Math.random() - 0.5) * 5,
      apy: 5 + Math.random() * 10,
      category: "bridge",
      token: "STG",
      tokenPrice: 0.4 + Math.random() * 0.2
    },
    {
      name: "Yearn Finance",
      chain: "Ethereum",
      tvl: 3e8 + Math.random() * 5e7,
      tvlChange24h: (Math.random() - 0.5) * 4,
      apy: 5 + Math.random() * 15,
      category: "yield",
      token: "YFI",
      tokenPrice: 7e3 + Math.random() * 1e3
    }
  ];
}
async function analyzeCrypto(symbol) {
  const price = await getCryptoPrice(symbol);
  if (!price) return null;
  const indicators = await getCryptoIndicators(symbol);
  const sentimentSignals = [];
  let sentimentScore = 0;
  if (indicators.rsi < 30) {
    sentimentSignals.push("RSI indicates oversold conditions");
    sentimentScore += 2;
  } else if (indicators.rsi > 70) {
    sentimentSignals.push("RSI indicates overbought conditions");
    sentimentScore -= 2;
  }
  if (indicators.macd.histogram > 0 && indicators.macd.value > indicators.macd.signal) {
    sentimentSignals.push("MACD shows bullish momentum");
    sentimentScore += 1;
  } else if (indicators.macd.histogram < 0) {
    sentimentSignals.push("MACD shows bearish momentum");
    sentimentScore -= 1;
  }
  if (indicators.fearGreedIndex < 25) {
    sentimentSignals.push("Extreme fear in market - potential buying opportunity");
    sentimentScore += 2;
  } else if (indicators.fearGreedIndex > 75) {
    sentimentSignals.push("Extreme greed in market - potential selling opportunity");
    sentimentScore -= 2;
  }
  if (indicators.exchangeNetFlow < -5e3) {
    sentimentSignals.push("Large exchange outflows - bullish accumulation");
    sentimentScore += 1;
  } else if (indicators.exchangeNetFlow > 5e3) {
    sentimentSignals.push("Large exchange inflows - potential selling pressure");
    sentimentScore -= 1;
  }
  if (indicators.fundingRate > 0.05) {
    sentimentSignals.push("High positive funding rate - overleveraged longs");
    sentimentScore -= 1;
  } else if (indicators.fundingRate < -0.05) {
    sentimentSignals.push("Negative funding rate - overleveraged shorts");
    sentimentScore += 1;
  }
  if (indicators.mvrvRatio > 3) {
    sentimentSignals.push("MVRV suggests overvaluation");
    sentimentScore -= 1;
  } else if (indicators.mvrvRatio < 1) {
    sentimentSignals.push("MVRV suggests undervaluation");
    sentimentScore += 1;
  }
  let overallSentiment;
  if (sentimentScore >= 4) overallSentiment = "very_bullish";
  else if (sentimentScore >= 2) overallSentiment = "bullish";
  else if (sentimentScore <= -4) overallSentiment = "very_bearish";
  else if (sentimentScore <= -2) overallSentiment = "bearish";
  else overallSentiment = "neutral";
  const reasoning = [];
  let action;
  let confidence;
  if (sentimentScore >= 4) {
    action = "strong_buy";
    confidence = 0.8 + Math.random() * 0.15;
    reasoning.push("Multiple bullish signals aligned");
  } else if (sentimentScore >= 2) {
    action = "buy";
    confidence = 0.65 + Math.random() * 0.15;
    reasoning.push("Moderately bullish conditions");
  } else if (sentimentScore <= -4) {
    action = "strong_sell";
    confidence = 0.8 + Math.random() * 0.15;
    reasoning.push("Multiple bearish signals aligned");
  } else if (sentimentScore <= -2) {
    action = "sell";
    confidence = 0.65 + Math.random() * 0.15;
    reasoning.push("Moderately bearish conditions");
  } else {
    action = "hold";
    confidence = 0.5 + Math.random() * 0.2;
    reasoning.push("Mixed signals - wait for clearer direction");
  }
  const currentPrice = price.price;
  const support = [
    currentPrice * 0.95,
    currentPrice * 0.9,
    currentPrice * 0.85
  ];
  const resistance = [
    currentPrice * 1.05,
    currentPrice * 1.1,
    currentPrice * 1.15
  ];
  return {
    symbol,
    price,
    indicators,
    sentiment: {
      overall: overallSentiment,
      score: sentimentScore,
      signals: sentimentSignals
    },
    recommendation: {
      action,
      confidence,
      reasoning,
      priceTargets: { support, resistance }
    }
  };
}
function getBaseCryptoPrice(symbol) {
  const prices = {
    BTC: 43e3,
    ETH: 2300,
    BNB: 310,
    XRP: 0.55,
    ADA: 0.45,
    SOL: 100,
    DOGE: 0.08,
    DOT: 7,
    MATIC: 0.85,
    AVAX: 35,
    LINK: 14,
    UNI: 6.5,
    ATOM: 9,
    LTC: 70,
    NEAR: 5
  };
  return prices[symbol.toUpperCase()] || 1;
}
function getCryptoVolatility(symbol) {
  const volatility = {
    BTC: 0.03,
    ETH: 0.04,
    BNB: 0.04,
    XRP: 0.05,
    ADA: 0.05,
    SOL: 0.06,
    DOGE: 0.08,
    DOT: 0.05,
    MATIC: 0.06,
    AVAX: 0.06,
    LINK: 0.05,
    UNI: 0.05,
    ATOM: 0.05,
    LTC: 0.04,
    NEAR: 0.06
  };
  return volatility[symbol.toUpperCase()] || 0.05;
}
function getCirculatingSupply(symbol) {
  const supply = {
    BTC: 195e5,
    ETH: 12e7,
    BNB: 15e7,
    XRP: 53e9,
    ADA: 35e9,
    SOL: 43e7,
    DOGE: 142e9,
    DOT: 13e8,
    MATIC: 93e8,
    AVAX: 37e7,
    LINK: 56e7,
    UNI: 75e7,
    ATOM: 29e7,
    LTC: 73e6,
    NEAR: 1e9
  };
  return supply[symbol.toUpperCase()] || 1e9;
}
function getTotalSupply(symbol) {
  const supply = {
    BTC: 21e6,
    ETH: 12e7,
    BNB: 2e8,
    XRP: 1e11,
    ADA: 45e9,
    SOL: 55e7,
    DOGE: 142e9,
    DOT: 14e8,
    MATIC: 1e10,
    AVAX: 72e7,
    LINK: 1e9,
    UNI: 1e9,
    ATOM: 29e7,
    LTC: 84e6,
    NEAR: 1e9
  };
  return supply[symbol.toUpperCase()] || 1e9;
}
function getMaxSupply(symbol) {
  const supply = {
    BTC: 21e6,
    ETH: null,
    BNB: 2e8,
    XRP: 1e11,
    ADA: 45e9,
    SOL: null,
    DOGE: null,
    DOT: null,
    MATIC: 1e10,
    AVAX: 72e7,
    LINK: 1e9,
    UNI: 1e9,
    ATOM: null,
    LTC: 84e6,
    NEAR: 1e9
  };
  return supply[symbol.toUpperCase()] ?? null;
}
function calculateRSI3(prices, period = 14) {
  if (prices.length < period + 1) return 50;
  let gains = 0;
  let losses = 0;
  for (let i = prices.length - period; i < prices.length; i++) {
    const change = prices[i] - prices[i - 1];
    if (change > 0) gains += change;
    else losses -= change;
  }
  const avgGain = gains / period;
  const avgLoss = losses / period;
  if (avgLoss === 0) return 100;
  const rs = avgGain / avgLoss;
  return 100 - 100 / (1 + rs);
}
function calculateMACD2(prices) {
  const ema12 = calculateEMA5(prices, 12);
  const ema26 = calculateEMA5(prices, 26);
  const macdLine = ema12 - ema26;
  const signal = macdLine * 0.9;
  const histogram = macdLine - signal;
  return { value: macdLine, signal, histogram };
}
function calculateBollingerBands(prices, period = 20, stdDev = 2) {
  const slice = prices.slice(-period);
  const middle = slice.reduce((a, b) => a + b, 0) / slice.length;
  const variance = slice.reduce((sum2, price) => sum2 + Math.pow(price - middle, 2), 0) / slice.length;
  const std4 = Math.sqrt(variance);
  return {
    upper: middle + stdDev * std4,
    middle,
    lower: middle - stdDev * std4
  };
}
function calculateEMA5(prices, period) {
  if (prices.length < period) return prices[prices.length - 1] || 0;
  const multiplier = 2 / (period + 1);
  let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
  for (let i = period; i < prices.length; i++) {
    ema = (prices[i] - ema) * multiplier + ema;
  }
  return ema;
}

// server/services/paperTrading.ts
init_db();
init_schema();
import { eq as eq4, and as and4, desc as desc4 } from "drizzle-orm";
var COMMISSION_RATES = { stock: 1e-3, crypto: 2e-3 };
var SLIPPAGE_RANGE = { stock: 1e-3, crypto: 2e-3 };
var toNum = (v) => {
  if (v === null || v === void 0) return 0;
  return typeof v === "number" ? v : parseFloat(v) || 0;
};
async function createPaperAccount(userId, name, initialBalance = 1e5) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const id = `pta_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const now = /* @__PURE__ */ new Date();
  await db.insert(paperTradingAccounts).values({
    id,
    userId,
    name,
    initialBalance: String(initialBalance),
    currentBalance: String(initialBalance),
    totalEquity: String(initialBalance),
    totalPnL: "0",
    totalPnLPercent: "0",
    totalTrades: 0,
    winningTrades: 0,
    losingTrades: 0,
    winRate: "0",
    createdAt: now,
    updatedAt: now
  });
  return {
    id,
    userId,
    name,
    initialBalance,
    currentBalance: initialBalance,
    totalEquity: initialBalance,
    totalPnL: 0,
    totalPnLPercent: 0,
    totalTrades: 0,
    winningTrades: 0,
    losingTrades: 0,
    winRate: 0,
    createdAt: now,
    updatedAt: now
  };
}
async function getPaperAccount(accountId) {
  const db = await getDb();
  if (!db) return null;
  const results = await db.select().from(paperTradingAccounts).where(eq4(paperTradingAccounts.id, accountId));
  if (results.length === 0) return null;
  const r = results[0];
  return {
    id: r.id,
    userId: r.userId,
    name: r.name,
    initialBalance: toNum(r.initialBalance),
    currentBalance: toNum(r.currentBalance),
    totalEquity: toNum(r.totalEquity),
    totalPnL: toNum(r.totalPnL),
    totalPnLPercent: toNum(r.totalPnLPercent),
    totalTrades: r.totalTrades,
    winningTrades: r.winningTrades,
    losingTrades: r.losingTrades,
    winRate: toNum(r.winRate),
    createdAt: new Date(r.createdAt),
    updatedAt: new Date(r.updatedAt)
  };
}
async function getUserPaperAccounts(userId) {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select().from(paperTradingAccounts).where(eq4(paperTradingAccounts.userId, userId)).orderBy(desc4(paperTradingAccounts.createdAt));
  return results.map((r) => ({
    id: r.id,
    userId: r.userId,
    name: r.name,
    initialBalance: toNum(r.initialBalance),
    currentBalance: toNum(r.currentBalance),
    totalEquity: toNum(r.totalEquity),
    totalPnL: toNum(r.totalPnL),
    totalPnLPercent: toNum(r.totalPnLPercent),
    totalTrades: r.totalTrades,
    winningTrades: r.winningTrades,
    losingTrades: r.losingTrades,
    winRate: toNum(r.winRate),
    createdAt: new Date(r.createdAt),
    updatedAt: new Date(r.updatedAt)
  }));
}
async function getCurrentPrice(symbol, assetType) {
  const cryptoPrices = {
    BTC: 43e3,
    ETH: 2300,
    SOL: 100,
    BNB: 310,
    XRP: 0.55,
    ADA: 0.45,
    DOGE: 0.08,
    DOT: 7,
    MATIC: 0.85,
    AVAX: 35
  };
  const stockPrices = {
    AAPL: 185,
    GOOGL: 140,
    MSFT: 375,
    AMZN: 155,
    NVDA: 480,
    META: 350,
    TSLA: 250
  };
  const base = assetType === "crypto" ? cryptoPrices[symbol] || 100 : stockPrices[symbol] || 100;
  return base * (1 + (Math.random() - 0.5) * 0.02);
}
async function placePaperOrder(accountId, symbol, assetType, side, type, quantity, options) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const account = await getPaperAccount(accountId);
  if (!account) throw new Error("Account not found");
  const id = `pto_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const currentPrice = await getCurrentPrice(symbol, assetType);
  const now = /* @__PURE__ */ new Date();
  const estimatedCost = quantity * (options?.price || currentPrice);
  if (side === "buy" && estimatedCost > account.currentBalance) {
    throw new Error("Insufficient balance");
  }
  let status = "pending";
  let filledQuantity = 0;
  let filledPrice;
  let commission = 0;
  if (type === "market") {
    const slippage = (Math.random() - 0.5) * 2 * SLIPPAGE_RANGE[assetType];
    filledPrice = currentPrice * (1 + (side === "buy" ? slippage : -slippage));
    commission = quantity * filledPrice * COMMISSION_RATES[assetType];
    filledQuantity = quantity;
    status = "filled";
    await executeMarketOrder(db, account, symbol, assetType, side, quantity, filledPrice, commission);
  }
  await db.insert(paperTradingOrders).values({
    id,
    accountId,
    symbol,
    assetType,
    side,
    type,
    quantity: String(quantity),
    price: options?.price ? String(options.price) : null,
    stopPrice: options?.stopPrice ? String(options.stopPrice) : null,
    takeProfitPrice: options?.takeProfitPrice ? String(options.takeProfitPrice) : null,
    stopLossPrice: options?.stopLossPrice ? String(options.stopLossPrice) : null,
    status,
    filledQuantity: String(filledQuantity),
    filledPrice: filledPrice ? String(filledPrice) : null,
    commission: String(commission),
    createdAt: now,
    updatedAt: now,
    expiresAt: options?.expiresAt || null
  });
  return {
    id,
    accountId,
    symbol,
    assetType,
    side,
    type,
    quantity,
    price: options?.price,
    stopPrice: options?.stopPrice,
    takeProfitPrice: options?.takeProfitPrice,
    stopLossPrice: options?.stopLossPrice,
    status,
    filledQuantity,
    filledPrice,
    commission,
    createdAt: now,
    updatedAt: now,
    expiresAt: options?.expiresAt
  };
}
async function executeMarketOrder(db, account, symbol, assetType, side, quantity, price, commission) {
  const orderId = `pto_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  let pnl = 0;
  if (side === "buy") {
    const totalCost = quantity * price + commission;
    const newBalance = account.currentBalance - totalCost;
    await db.update(paperTradingAccounts).set({
      currentBalance: String(newBalance),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq4(paperTradingAccounts.id, account.id));
    const existingPos = await db.select().from(paperTradingPositions).where(and4(eq4(paperTradingPositions.accountId, account.id), eq4(paperTradingPositions.symbol, symbol)));
    if (existingPos.length > 0) {
      const pos = existingPos[0];
      const oldQty = toNum(pos.quantity);
      const oldAvg = toNum(pos.averagePrice);
      const newQty = oldQty + quantity;
      const newAvg = (oldQty * oldAvg + quantity * price) / newQty;
      await db.update(paperTradingPositions).set({
        quantity: String(newQty),
        averagePrice: String(newAvg),
        currentPrice: String(price),
        marketValue: String(newQty * price),
        unrealizedPnL: String((price - newAvg) * newQty),
        unrealizedPnLPercent: String((price - newAvg) / newAvg * 100),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq4(paperTradingPositions.id, pos.id));
    } else {
      await db.insert(paperTradingPositions).values({
        id: `ptp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        accountId: account.id,
        symbol,
        assetType,
        quantity: String(quantity),
        averagePrice: String(price),
        currentPrice: String(price),
        marketValue: String(quantity * price),
        unrealizedPnL: "0",
        unrealizedPnLPercent: "0",
        realizedPnL: "0",
        openedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      });
    }
  } else {
    const existingPos = await db.select().from(paperTradingPositions).where(and4(eq4(paperTradingPositions.accountId, account.id), eq4(paperTradingPositions.symbol, symbol)));
    if (existingPos.length === 0) throw new Error("No position to sell");
    const pos = existingPos[0];
    const posQty = toNum(pos.quantity);
    const avgPrice = toNum(pos.averagePrice);
    if (quantity > posQty) throw new Error("Insufficient position");
    pnl = (price - avgPrice) * quantity - commission;
    const proceeds = quantity * price - commission;
    const newBalance = account.currentBalance + proceeds;
    const isWin = pnl > 0;
    await db.update(paperTradingAccounts).set({
      currentBalance: String(newBalance),
      totalPnL: String(account.totalPnL + pnl),
      totalTrades: account.totalTrades + 1,
      winningTrades: isWin ? account.winningTrades + 1 : account.winningTrades,
      losingTrades: !isWin ? account.losingTrades + 1 : account.losingTrades,
      winRate: String((isWin ? account.winningTrades + 1 : account.winningTrades) / (account.totalTrades + 1) * 100),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq4(paperTradingAccounts.id, account.id));
    const newQty = posQty - quantity;
    if (newQty <= 0) {
      await db.delete(paperTradingPositions).where(eq4(paperTradingPositions.id, pos.id));
    } else {
      await db.update(paperTradingPositions).set({
        quantity: String(newQty),
        currentPrice: String(price),
        marketValue: String(newQty * price),
        unrealizedPnL: String((price - avgPrice) * newQty),
        realizedPnL: String(toNum(pos.realizedPnL) + pnl),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq4(paperTradingPositions.id, pos.id));
    }
  }
  await db.insert(paperTradingHistory).values({
    id: `pth_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    accountId: account.id,
    orderId,
    symbol,
    assetType,
    side,
    quantity: String(quantity),
    price: String(price),
    commission: String(commission),
    pnl: String(pnl),
    createdAt: /* @__PURE__ */ new Date()
  });
}
async function getAccountPositions(accountId) {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select().from(paperTradingPositions).where(eq4(paperTradingPositions.accountId, accountId));
  const positions = [];
  for (const r of results) {
    const currentPrice = await getCurrentPrice(r.symbol, r.assetType);
    const qty = toNum(r.quantity);
    const avgPrice = toNum(r.averagePrice);
    const unrealizedPnL = (currentPrice - avgPrice) * qty;
    const unrealizedPnLPercent = avgPrice > 0 ? (currentPrice - avgPrice) / avgPrice * 100 : 0;
    positions.push({
      id: r.id,
      accountId: r.accountId,
      symbol: r.symbol,
      assetType: r.assetType,
      quantity: qty,
      averagePrice: avgPrice,
      currentPrice,
      marketValue: qty * currentPrice,
      unrealizedPnL,
      unrealizedPnLPercent,
      realizedPnL: toNum(r.realizedPnL),
      openedAt: new Date(r.openedAt),
      updatedAt: new Date(r.updatedAt)
    });
  }
  return positions;
}
async function getAccountOrders(accountId, status) {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select().from(paperTradingOrders).where(eq4(paperTradingOrders.accountId, accountId)).orderBy(desc4(paperTradingOrders.createdAt));
  return results.filter((r) => !status || r.status === status).map((r) => ({
    id: r.id,
    accountId: r.accountId,
    symbol: r.symbol,
    assetType: r.assetType,
    side: r.side,
    type: r.type,
    quantity: toNum(r.quantity),
    price: r.price ? toNum(r.price) : void 0,
    stopPrice: r.stopPrice ? toNum(r.stopPrice) : void 0,
    takeProfitPrice: r.takeProfitPrice ? toNum(r.takeProfitPrice) : void 0,
    stopLossPrice: r.stopLossPrice ? toNum(r.stopLossPrice) : void 0,
    status: r.status,
    filledQuantity: toNum(r.filledQuantity),
    filledPrice: r.filledPrice ? toNum(r.filledPrice) : void 0,
    commission: toNum(r.commission),
    createdAt: new Date(r.createdAt),
    updatedAt: new Date(r.updatedAt),
    expiresAt: r.expiresAt ? new Date(r.expiresAt) : void 0
  }));
}
async function getTradeHistory(accountId) {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select().from(paperTradingHistory).where(eq4(paperTradingHistory.accountId, accountId)).orderBy(desc4(paperTradingHistory.createdAt));
  return results.map((r) => ({
    orderId: r.orderId,
    symbol: r.symbol,
    side: r.side,
    quantity: toNum(r.quantity),
    price: toNum(r.price),
    commission: toNum(r.commission),
    timestamp: new Date(r.createdAt),
    pnl: toNum(r.pnl)
  }));
}
async function cancelOrder(orderId) {
  const db = await getDb();
  if (!db) return false;
  await db.update(paperTradingOrders).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(and4(eq4(paperTradingOrders.id, orderId), eq4(paperTradingOrders.status, "pending")));
  return true;
}
async function calculatePerformanceMetrics(accountId) {
  const account = await getPaperAccount(accountId);
  if (!account) throw new Error("Account not found");
  const trades2 = await getTradeHistory(accountId);
  const positions = await getAccountPositions(accountId);
  const positionValue = positions.reduce((sum2, p) => sum2 + p.marketValue, 0);
  const totalEquity = account.currentBalance + positionValue;
  const totalReturn = totalEquity - account.initialBalance;
  const totalReturnPercent = totalReturn / account.initialBalance * 100;
  const wins = trades2.filter((t2) => (t2.pnl || 0) > 0);
  const losses = trades2.filter((t2) => (t2.pnl || 0) < 0);
  const averageWin = wins.length > 0 ? wins.reduce((s, t2) => s + (t2.pnl || 0), 0) / wins.length : 0;
  const averageLoss = losses.length > 0 ? Math.abs(losses.reduce((s, t2) => s + (t2.pnl || 0), 0) / losses.length) : 0;
  const largestWin = wins.length > 0 ? Math.max(...wins.map((t2) => t2.pnl || 0)) : 0;
  const largestLoss = losses.length > 0 ? Math.abs(Math.min(...losses.map((t2) => t2.pnl || 0))) : 0;
  const grossProfit = wins.reduce((s, t2) => s + (t2.pnl || 0), 0);
  const grossLoss = Math.abs(losses.reduce((s, t2) => s + (t2.pnl || 0), 0));
  const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? Infinity : 0;
  const returns = trades2.map((t2) => (t2.pnl || 0) / account.initialBalance);
  const avgReturn = returns.length > 0 ? returns.reduce((a, b) => a + b, 0) / returns.length : 0;
  const variance = returns.length > 1 ? returns.reduce((s, r) => s + Math.pow(r - avgReturn, 2), 0) / (returns.length - 1) : 0;
  const stdDev = Math.sqrt(variance);
  const sharpeRatio = stdDev > 0 ? avgReturn * Math.sqrt(252) / stdDev : 0;
  let peak = account.initialBalance;
  let maxDrawdown = 0;
  let runningBalance = account.initialBalance;
  for (const trade of trades2) {
    runningBalance += trade.pnl || 0;
    if (runningBalance > peak) peak = runningBalance;
    const drawdown = peak - runningBalance;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
  }
  const maxDrawdownPercent = peak > 0 ? maxDrawdown / peak * 100 : 0;
  const tradeDates = new Set(trades2.map((t2) => t2.timestamp.toDateString()));
  return {
    totalReturn,
    totalReturnPercent,
    sharpeRatio,
    maxDrawdown,
    maxDrawdownPercent,
    winRate: account.winRate,
    profitFactor,
    averageWin,
    averageLoss,
    largestWin,
    largestLoss,
    totalTrades: account.totalTrades,
    tradingDays: tradeDates.size,
    averageHoldingPeriod: 24
  };
}
async function resetPaperAccount(accountId) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const account = await getPaperAccount(accountId);
  if (!account) throw new Error("Account not found");
  await db.delete(paperTradingPositions).where(eq4(paperTradingPositions.accountId, accountId));
  await db.delete(paperTradingOrders).where(eq4(paperTradingOrders.accountId, accountId));
  await db.delete(paperTradingHistory).where(eq4(paperTradingHistory.accountId, accountId));
  await db.update(paperTradingAccounts).set({
    currentBalance: String(account.initialBalance),
    totalEquity: String(account.initialBalance),
    totalPnL: "0",
    totalPnLPercent: "0",
    totalTrades: 0,
    winningTrades: 0,
    losingTrades: 0,
    winRate: "0",
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq4(paperTradingAccounts.id, accountId));
  return getPaperAccount(accountId);
}

// server/services/sec-edgar/SECEdgarService.ts
init_dataApi();
var SECEdgarService = class {
  baseUrl = "https://data.sec.gov";
  userAgent = "TradoVerse/1.0 (contact@tradoverse.com)";
  cikCache = /* @__PURE__ */ new Map();
  constructor() {
    console.log("[SEC EDGAR] Service initialized");
  }
  /**
   * Look up CIK by ticker symbol
   */
  async getCIKByTicker(ticker) {
    const cached = this.cikCache.get(ticker.toUpperCase());
    if (cached) return cached;
    try {
      const response = await fetch(
        "https://www.sec.gov/files/company_tickers.json",
        {
          headers: {
            "User-Agent": this.userAgent,
            "Accept": "application/json"
          }
        }
      );
      if (!response.ok) {
        console.error(`[SEC EDGAR] Failed to fetch company tickers: ${response.status}`);
        return null;
      }
      const data = await response.json();
      for (const key of Object.keys(data)) {
        const company = data[key];
        if (company.ticker?.toUpperCase() === ticker.toUpperCase()) {
          const cik = String(company.cik_str).padStart(10, "0");
          this.cikCache.set(ticker.toUpperCase(), cik);
          return cik;
        }
      }
      return null;
    } catch (error) {
      console.error("[SEC EDGAR] Error looking up CIK:", error);
      return null;
    }
  }
  /**
   * Get company submissions (filing history)
   */
  async getCompanySubmissions(cik) {
    try {
      const paddedCik = cik.padStart(10, "0");
      const url = `${this.baseUrl}/submissions/CIK${paddedCik}.json`;
      const response = await fetch(url, {
        headers: {
          "User-Agent": this.userAgent,
          "Accept": "application/json"
        }
      });
      if (!response.ok) {
        console.error(`[SEC EDGAR] Failed to fetch submissions: ${response.status}`);
        return null;
      }
      const data = await response.json();
      const companyInfo = {
        cik: data.cik,
        entityType: data.entityType,
        sic: data.sic,
        sicDescription: data.sicDescription,
        name: data.name,
        tickers: data.tickers || [],
        exchanges: data.exchanges || [],
        ein: data.ein,
        description: data.description || "",
        website: data.website || "",
        fiscalYearEnd: data.fiscalYearEnd,
        stateOfIncorporation: data.stateOfIncorporation,
        stateOfIncorporationDescription: data.stateOfIncorporationDescription,
        addresses: data.addresses
      };
      const recentFilings = data.filings?.recent || {};
      const filings = [];
      const accessionNumbers = recentFilings.accessionNumber || [];
      const filingDates = recentFilings.filingDate || [];
      const reportDates = recentFilings.reportDate || [];
      const forms = recentFilings.form || [];
      const primaryDocuments = recentFilings.primaryDocument || [];
      const primaryDocDescriptions = recentFilings.primaryDocDescription || [];
      const fileNumbers = recentFilings.fileNumber || [];
      const filmNumbers = recentFilings.filmNumber || [];
      const items = recentFilings.items || [];
      const sizes = recentFilings.size || [];
      const isXBRLs = recentFilings.isXBRL || [];
      const isInlineXBRLs = recentFilings.isInlineXBRL || [];
      for (let i = 0; i < accessionNumbers.length; i++) {
        const accessionNumber = accessionNumbers[i];
        const accessionFormatted = accessionNumber.replace(/-/g, "");
        filings.push({
          accessionNumber,
          filingDate: filingDates[i] || "",
          reportDate: reportDates[i] || "",
          form: forms[i] || "",
          primaryDocument: primaryDocuments[i] || "",
          primaryDocDescription: primaryDocDescriptions[i] || "",
          fileNumber: fileNumbers[i] || "",
          filmNumber: filmNumbers[i] || "",
          items: items[i] || "",
          size: sizes[i] || 0,
          isXBRL: isXBRLs[i] || false,
          isInlineXBRL: isInlineXBRLs[i] || false,
          edgarUrl: `https://www.sec.gov/Archives/edgar/data/${paddedCik}/${accessionFormatted}/${primaryDocuments[i]}`
        });
      }
      return { companyInfo, filings };
    } catch (error) {
      console.error("[SEC EDGAR] Error fetching submissions:", error);
      return null;
    }
  }
  /**
   * Get company XBRL facts (financial data)
   */
  async getCompanyFacts(cik) {
    try {
      const paddedCik = cik.padStart(10, "0");
      const url = `${this.baseUrl}/api/xbrl/companyfacts/CIK${paddedCik}.json`;
      const response = await fetch(url, {
        headers: {
          "User-Agent": this.userAgent,
          "Accept": "application/json"
        }
      });
      if (!response.ok) {
        console.error(`[SEC EDGAR] Failed to fetch company facts: ${response.status}`);
        return null;
      }
      const data = await response.json();
      return data;
    } catch (error) {
      console.error("[SEC EDGAR] Error fetching company facts:", error);
      return null;
    }
  }
  /**
   * Get specific XBRL concept for a company
   */
  async getCompanyConcept(cik, taxonomy, concept) {
    try {
      const paddedCik = cik.padStart(10, "0");
      const url = `${this.baseUrl}/api/xbrl/companyconcept/CIK${paddedCik}/${taxonomy}/${concept}.json`;
      const response = await fetch(url, {
        headers: {
          "User-Agent": this.userAgent,
          "Accept": "application/json"
        }
      });
      if (!response.ok) {
        console.error(`[SEC EDGAR] Failed to fetch concept: ${response.status}`);
        return null;
      }
      const data = await response.json();
      const facts = [];
      for (const unit of Object.keys(data.units || {})) {
        for (const fact of data.units[unit]) {
          facts.push({
            taxonomy,
            tag: concept,
            label: data.label,
            description: data.description,
            units: unit,
            value: fact.val,
            startDate: fact.start,
            endDate: fact.end,
            instant: fact.instant,
            form: fact.form,
            filed: fact.filed,
            accn: fact.accn
          });
        }
      }
      return facts;
    } catch (error) {
      console.error("[SEC EDGAR] Error fetching concept:", error);
      return null;
    }
  }
  /**
   * Get 10-K filings for a company
   */
  async get10KFilings(ticker, limit = 5) {
    const cik = await this.getCIKByTicker(ticker);
    if (!cik) return [];
    const submissions = await this.getCompanySubmissions(cik);
    if (!submissions) return [];
    return submissions.filings.filter((f) => f.form === "10-K" || f.form === "10-K/A").slice(0, limit);
  }
  /**
   * Get 10-Q filings for a company
   */
  async get10QFilings(ticker, limit = 10) {
    const cik = await this.getCIKByTicker(ticker);
    if (!cik) return [];
    const submissions = await this.getCompanySubmissions(cik);
    if (!submissions) return [];
    return submissions.filings.filter((f) => f.form === "10-Q" || f.form === "10-Q/A").slice(0, limit);
  }
  /**
   * Get 8-K filings for a company
   */
  async get8KFilings(ticker, limit = 20) {
    const cik = await this.getCIKByTicker(ticker);
    if (!cik) return [];
    const submissions = await this.getCompanySubmissions(cik);
    if (!submissions) return [];
    return submissions.filings.filter((f) => f.form === "8-K" || f.form === "8-K/A").slice(0, limit);
  }
  /**
   * Get filing content (HTML)
   */
  async getFilingContent(filing) {
    try {
      const response = await fetch(filing.edgarUrl, {
        headers: {
          "User-Agent": this.userAgent,
          "Accept": "text/html"
        }
      });
      if (!response.ok) {
        console.error(`[SEC EDGAR] Failed to fetch filing content: ${response.status}`);
        return null;
      }
      return await response.text();
    } catch (error) {
      console.error("[SEC EDGAR] Error fetching filing content:", error);
      return null;
    }
  }
  /**
   * Get SEC filings via Yahoo Finance API (for metadata)
   */
  async getYahooSECFilings(ticker) {
    try {
      const result = await callDataApi("YahooFinance/get_stock_sec_filing", {
        query: {
          symbol: ticker,
          region: "US",
          lang: "en-US"
        }
      });
      if (!result || !result.quoteSummary?.result?.[0]?.secFilings?.filings) {
        return [];
      }
      return result.quoteSummary.result[0].secFilings.filings.map((f) => ({
        date: f.date,
        epochDate: f.epochDate,
        type: f.type,
        title: f.title,
        edgarUrl: f.edgarUrl,
        maxAge: f.maxAge
      }));
    } catch (error) {
      console.error("[SEC EDGAR] Error fetching Yahoo SEC filings:", error);
      return [];
    }
  }
  /**
   * Extract key financial metrics from XBRL data
   */
  async extractKeyMetrics(ticker) {
    const cik = await this.getCIKByTicker(ticker);
    if (!cik) return null;
    const facts = await this.getCompanyFacts(cik);
    if (!facts) return null;
    const metrics = {};
    const keyConcepts = [
      "Revenues",
      "RevenueFromContractWithCustomerExcludingAssessedTax",
      "NetIncomeLoss",
      "EarningsPerShareBasic",
      "EarningsPerShareDiluted",
      "Assets",
      "Liabilities",
      "StockholdersEquity",
      "CashAndCashEquivalentsAtCarryingValue",
      "LongTermDebt",
      "OperatingIncomeLoss",
      "GrossProfit",
      "ResearchAndDevelopmentExpense",
      "CommonStockSharesOutstanding"
    ];
    const usGaap = facts.facts?.["us-gaap"];
    if (usGaap) {
      for (const concept of keyConcepts) {
        if (usGaap[concept]) {
          const units = usGaap[concept].units;
          const unitKey = Object.keys(units)[0];
          if (unitKey && units[unitKey].length > 0) {
            const sortedFacts = units[unitKey].filter((f) => f.form === "10-K" || f.form === "10-Q").sort((a, b) => new Date(b.filed).getTime() - new Date(a.filed).getTime());
            if (sortedFacts.length > 0) {
              metrics[concept] = {
                value: sortedFacts[0].val,
                unit: unitKey,
                filed: sortedFacts[0].filed,
                form: sortedFacts[0].form,
                period: sortedFacts[0].end || sortedFacts[0].instant
              };
            }
          }
        }
      }
    }
    return metrics;
  }
};
var secEdgarService = new SECEdgarService();

// server/services/stock-intelligence/EnhancedFundamentalAnalyst.ts
init_llm();
init_dataApi();

// server/services/sec-edgar/SECFilingRAG.ts
init_llm();
var SECFilingRAG = class {
  chunkSize = 2e3;
  chunkOverlap = 200;
  filingCache = /* @__PURE__ */ new Map();
  // Standard 10-K section patterns
  sectionPatterns = [
    { pattern: /ITEM\s*1[.\s]*BUSINESS/i, title: "Business", itemNumber: "1" },
    { pattern: /ITEM\s*1A[.\s]*RISK\s*FACTORS/i, title: "Risk Factors", itemNumber: "1A" },
    { pattern: /ITEM\s*1B[.\s]*UNRESOLVED\s*STAFF\s*COMMENTS/i, title: "Unresolved Staff Comments", itemNumber: "1B" },
    { pattern: /ITEM\s*1C[.\s]*CYBERSECURITY/i, title: "Cybersecurity", itemNumber: "1C" },
    { pattern: /ITEM\s*2[.\s]*PROPERTIES/i, title: "Properties", itemNumber: "2" },
    { pattern: /ITEM\s*3[.\s]*LEGAL\s*PROCEEDINGS/i, title: "Legal Proceedings", itemNumber: "3" },
    { pattern: /ITEM\s*4[.\s]*MINE\s*SAFETY/i, title: "Mine Safety Disclosures", itemNumber: "4" },
    { pattern: /ITEM\s*5[.\s]*MARKET/i, title: "Market for Common Equity", itemNumber: "5" },
    { pattern: /ITEM\s*6[.\s]*SELECTED\s*FINANCIAL/i, title: "Selected Financial Data", itemNumber: "6" },
    { pattern: /ITEM\s*7[.\s]*MANAGEMENT.*DISCUSSION/i, title: "Management's Discussion and Analysis (MD&A)", itemNumber: "7" },
    { pattern: /ITEM\s*7A[.\s]*QUANTITATIVE.*QUALITATIVE/i, title: "Market Risk Disclosures", itemNumber: "7A" },
    { pattern: /ITEM\s*8[.\s]*FINANCIAL\s*STATEMENTS/i, title: "Financial Statements", itemNumber: "8" },
    { pattern: /ITEM\s*9[.\s]*CHANGES.*DISAGREEMENTS/i, title: "Changes in Accountants", itemNumber: "9" },
    { pattern: /ITEM\s*9A[.\s]*CONTROLS/i, title: "Controls and Procedures", itemNumber: "9A" },
    { pattern: /ITEM\s*9B[.\s]*OTHER\s*INFORMATION/i, title: "Other Information", itemNumber: "9B" },
    { pattern: /ITEM\s*10[.\s]*DIRECTORS/i, title: "Directors and Executive Officers", itemNumber: "10" },
    { pattern: /ITEM\s*11[.\s]*EXECUTIVE\s*COMPENSATION/i, title: "Executive Compensation", itemNumber: "11" },
    { pattern: /ITEM\s*12[.\s]*SECURITY\s*OWNERSHIP/i, title: "Security Ownership", itemNumber: "12" },
    { pattern: /ITEM\s*13[.\s]*CERTAIN\s*RELATIONSHIPS/i, title: "Related Party Transactions", itemNumber: "13" },
    { pattern: /ITEM\s*14[.\s]*PRINCIPAL\s*ACCOUNT/i, title: "Principal Accountant Fees", itemNumber: "14" },
    { pattern: /ITEM\s*15[.\s]*EXHIBITS/i, title: "Exhibits and Financial Schedules", itemNumber: "15" }
  ];
  constructor() {
    console.log("[SEC RAG] Filing RAG system initialized");
  }
  /**
   * Parse and process a SEC filing
   */
  async parseFiling(ticker, filing) {
    const cacheKey = `${ticker}-${filing.accessionNumber}`;
    if (this.filingCache.has(cacheKey)) {
      return this.filingCache.get(cacheKey);
    }
    try {
      const htmlContent = await secEdgarService.getFilingContent(filing);
      if (!htmlContent) return null;
      const plainText = this.htmlToText(htmlContent);
      const sections = this.extractSections(plainText);
      const chunks = this.createChunks(plainText, ticker, filing);
      const parsedFiling = {
        accessionNumber: filing.accessionNumber,
        form: filing.form,
        filingDate: filing.filingDate,
        companyName: filing.primaryDocDescription || ticker,
        ticker,
        sections,
        chunks,
        rawText: plainText
      };
      this.filingCache.set(cacheKey, parsedFiling);
      return parsedFiling;
    } catch (error) {
      console.error("[SEC RAG] Error parsing filing:", error);
      return null;
    }
  }
  /**
   * Convert HTML to plain text
   */
  htmlToText(html) {
    let text2 = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "");
    text2 = text2.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "");
    text2 = text2.replace(/&nbsp;/g, " ");
    text2 = text2.replace(/&amp;/g, "&");
    text2 = text2.replace(/&lt;/g, "<");
    text2 = text2.replace(/&gt;/g, ">");
    text2 = text2.replace(/&quot;/g, '"');
    text2 = text2.replace(/&#39;/g, "'");
    text2 = text2.replace(/<\/?(p|div|br|h[1-6]|tr|li)[^>]*>/gi, "\n");
    text2 = text2.replace(/<[^>]+>/g, "");
    text2 = text2.replace(/\s+/g, " ");
    text2 = text2.replace(/\n\s+/g, "\n");
    text2 = text2.replace(/\n{3,}/g, "\n\n");
    return text2.trim();
  }
  /**
   * Extract sections from filing text
   */
  extractSections(text2) {
    const sections = [];
    for (let i = 0; i < this.sectionPatterns.length; i++) {
      const { pattern, title, itemNumber } = this.sectionPatterns[i];
      const match = text2.match(pattern);
      if (match) {
        const startIndex = match.index;
        let endIndex = text2.length;
        for (let j = i + 1; j < this.sectionPatterns.length; j++) {
          const nextMatch = text2.match(this.sectionPatterns[j].pattern);
          if (nextMatch && nextMatch.index > startIndex) {
            endIndex = nextMatch.index;
            break;
          }
        }
        const content = text2.substring(startIndex, endIndex).trim();
        sections.push({
          title,
          itemNumber,
          content: content.substring(0, 5e4)
          // Limit content size
        });
      }
    }
    return sections;
  }
  /**
   * Create chunks from filing text
   */
  createChunks(text2, ticker, filing) {
    const chunks = [];
    let currentIndex = 0;
    let chunkIndex = 0;
    while (currentIndex < text2.length) {
      const endIndex = Math.min(currentIndex + this.chunkSize, text2.length);
      let chunkText = text2.substring(currentIndex, endIndex);
      if (endIndex < text2.length) {
        const lastPeriod = chunkText.lastIndexOf(".");
        const lastNewline = chunkText.lastIndexOf("\n");
        const breakPoint = Math.max(lastPeriod, lastNewline);
        if (breakPoint > this.chunkSize * 0.5) {
          chunkText = chunkText.substring(0, breakPoint + 1);
        }
      }
      let sectionTitle = "General";
      for (const { pattern, title } of this.sectionPatterns) {
        const textBefore = text2.substring(0, currentIndex + 500);
        if (pattern.test(textBefore)) {
          sectionTitle = title;
        }
      }
      chunks.push({
        id: `${filing.accessionNumber}-chunk-${chunkIndex}`,
        filingAccession: filing.accessionNumber,
        sectionTitle,
        content: chunkText.trim(),
        startIndex: currentIndex,
        endIndex: currentIndex + chunkText.length,
        metadata: {
          ticker,
          form: filing.form,
          filingDate: filing.filingDate,
          chunkIndex,
          totalChunks: 0
          // Will be updated after all chunks created
        }
      });
      currentIndex += chunkText.length - this.chunkOverlap;
      chunkIndex++;
    }
    for (const chunk of chunks) {
      chunk.metadata.totalChunks = chunks.length;
    }
    return chunks;
  }
  /**
   * Search filing content using semantic similarity
   */
  async searchFiling(parsedFiling, query, topK = 5) {
    const queryTerms = query.toLowerCase().split(/\s+/);
    const scoredChunks = parsedFiling.chunks.map((chunk) => {
      const contentLower = chunk.content.toLowerCase();
      let score = 0;
      for (const term of queryTerms) {
        const regex = new RegExp(term, "gi");
        const matches = contentLower.match(regex);
        if (matches) {
          score += matches.length;
        }
      }
      if (query.toLowerCase().includes("risk") && chunk.sectionTitle.includes("Risk")) {
        score *= 2;
      }
      if (query.toLowerCase().includes("business") && chunk.sectionTitle.includes("Business")) {
        score *= 2;
      }
      if (query.toLowerCase().includes("financial") && chunk.sectionTitle.includes("Financial")) {
        score *= 2;
      }
      return { chunk, score };
    });
    const topChunks = scoredChunks.filter((c) => c.score > 0).sort((a, b) => b.score - a.score).slice(0, topK);
    return topChunks.map(({ chunk, score }) => ({
      chunk,
      relevanceScore: score,
      highlightedContent: this.highlightTerms(chunk.content, queryTerms)
    }));
  }
  /**
   * Highlight search terms in content
   */
  highlightTerms(content, terms) {
    let highlighted = content;
    for (const term of terms) {
      const regex = new RegExp(`(${term})`, "gi");
      highlighted = highlighted.replace(regex, "**$1**");
    }
    return highlighted;
  }
  /**
   * Answer questions about a filing using RAG
   */
  async askQuestion(parsedFiling, question) {
    const searchResults = await this.searchFiling(parsedFiling, question, 5);
    const context = searchResults.map((r) => `[${r.chunk.sectionTitle}]
${r.chunk.content}`).join("\n\n---\n\n");
    const response = await invokeLLM({
      messages: [
        {
          role: "system",
          content: `You are a financial analyst expert at analyzing SEC filings. 
Answer questions based ONLY on the provided filing excerpts.
If the information is not in the excerpts, say "This information is not found in the filing."
Be specific and cite the relevant section when possible.
Format numbers clearly and provide context for financial figures.`
        },
        {
          role: "user",
          content: `Based on the following excerpts from ${parsedFiling.ticker}'s ${parsedFiling.form} filing dated ${parsedFiling.filingDate}:

${context}

Question: ${question}

Please provide a detailed answer based on the filing content.`
        }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "filing_qa_response",
          strict: true,
          schema: {
            type: "object",
            properties: {
              answer: { type: "string", description: "The answer to the question" },
              confidence: { type: "number", description: "Confidence score 0-100" },
              citedSections: {
                type: "array",
                items: { type: "string" },
                description: "Sections cited in the answer"
              }
            },
            required: ["answer", "confidence", "citedSections"],
            additionalProperties: false
          }
        }
      }
    });
    const content = response.choices[0]?.message?.content;
    let parsed = { answer: "Unable to generate answer", confidence: 0, citedSections: [] };
    if (content) {
      try {
        parsed = JSON.parse(typeof content === "string" ? content : JSON.stringify(content));
      } catch {
        parsed.answer = typeof content === "string" ? content : "Unable to parse response";
      }
    }
    return {
      question,
      answer: parsed.answer,
      sources: searchResults.slice(0, 3).map((r) => ({
        section: r.chunk.sectionTitle,
        excerpt: r.chunk.content.substring(0, 300) + "...",
        filingDate: parsedFiling.filingDate
      })),
      confidence: parsed.confidence
    };
  }
  /**
   * Generate a summary of the filing
   */
  async generateSummary(parsedFiling) {
    const businessSection = parsedFiling.sections.find((s) => s.itemNumber === "1");
    const riskSection = parsedFiling.sections.find((s) => s.itemNumber === "1A");
    const mdaSection = parsedFiling.sections.find((s) => s.itemNumber === "7");
    const context = [
      businessSection ? `BUSINESS:
${businessSection.content.substring(0, 5e3)}` : "",
      riskSection ? `RISK FACTORS:
${riskSection.content.substring(0, 5e3)}` : "",
      mdaSection ? `MD&A:
${mdaSection.content.substring(0, 5e3)}` : ""
    ].filter(Boolean).join("\n\n---\n\n");
    const response = await invokeLLM({
      messages: [
        {
          role: "system",
          content: `You are a senior financial analyst creating executive summaries of SEC filings.
Generate a comprehensive but concise summary highlighting key business information, risks, and financial outlook.
Focus on actionable insights for investors.`
        },
        {
          role: "user",
          content: `Summarize this ${parsedFiling.form} filing for ${parsedFiling.ticker}:

${context}

Generate a structured summary with:
1. Executive summary (2-3 sentences)
2. Key highlights (3-5 bullet points)
3. Top risk factors (3-5 items)
4. Management outlook`
        }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "filing_summary",
          strict: true,
          schema: {
            type: "object",
            properties: {
              executiveSummary: { type: "string" },
              keyHighlights: { type: "array", items: { type: "string" } },
              riskFactors: { type: "array", items: { type: "string" } },
              managementOutlook: { type: "string" }
            },
            required: ["executiveSummary", "keyHighlights", "riskFactors", "managementOutlook"],
            additionalProperties: false
          }
        }
      }
    });
    const content = response.choices[0]?.message?.content;
    let parsed = {
      executiveSummary: "Summary not available",
      keyHighlights: [],
      riskFactors: [],
      managementOutlook: "Outlook not available"
    };
    if (content) {
      try {
        parsed = JSON.parse(typeof content === "string" ? content : JSON.stringify(content));
      } catch {
      }
    }
    return {
      ticker: parsedFiling.ticker,
      form: parsedFiling.form,
      filingDate: parsedFiling.filingDate,
      executiveSummary: parsed.executiveSummary,
      keyHighlights: parsed.keyHighlights,
      riskFactors: parsed.riskFactors,
      financialHighlights: [],
      // Would need XBRL data
      managementOutlook: parsed.managementOutlook
    };
  }
  /**
   * Compare two filings (e.g., YoY comparison)
   */
  async compareFilings(filing1, filing2, focusArea = "risk factors") {
    const section1 = filing1.sections.find(
      (s) => s.title.toLowerCase().includes(focusArea.toLowerCase())
    );
    const section2 = filing2.sections.find(
      (s) => s.title.toLowerCase().includes(focusArea.toLowerCase())
    );
    if (!section1 || !section2) {
      return {
        comparison: `Unable to compare ${focusArea} - section not found in one or both filings`,
        changes: []
      };
    }
    const response = await invokeLLM({
      messages: [
        {
          role: "system",
          content: `You are a financial analyst comparing SEC filings year-over-year.
Identify key changes, new disclosures, and removed items.
Focus on material changes that could affect investment decisions.`
        },
        {
          role: "user",
          content: `Compare the ${focusArea} section between these two filings:

OLDER FILING (${filing1.filingDate}):
${section1.content.substring(0, 8e3)}

NEWER FILING (${filing2.filingDate}):
${section2.content.substring(0, 8e3)}

Identify:
1. New risks/items added
2. Risks/items removed
3. Significant changes in language or emphasis
4. Overall assessment of changes`
        }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "filing_comparison",
          strict: true,
          schema: {
            type: "object",
            properties: {
              comparison: { type: "string", description: "Overall comparison summary" },
              changes: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    area: { type: "string" },
                    change: { type: "string" },
                    significance: { type: "string", enum: ["high", "medium", "low"] }
                  },
                  required: ["area", "change", "significance"],
                  additionalProperties: false
                }
              }
            },
            required: ["comparison", "changes"],
            additionalProperties: false
          }
        }
      }
    });
    const content = response.choices[0]?.message?.content;
    let parsed = { comparison: "Comparison not available", changes: [] };
    if (content) {
      try {
        parsed = JSON.parse(typeof content === "string" ? content : JSON.stringify(content));
      } catch {
      }
    }
    return parsed;
  }
  /**
   * Get specific section from filing
   */
  getSection(parsedFiling, sectionName) {
    return parsedFiling.sections.find(
      (s) => s.title.toLowerCase().includes(sectionName.toLowerCase()) || s.itemNumber === sectionName
    ) || null;
  }
  /**
   * Clear cache
   */
  clearCache() {
    this.filingCache.clear();
  }
};
var secFilingRAG = new SECFilingRAG();

// server/services/stock-intelligence/EnhancedFundamentalAnalyst.ts
var EnhancedFundamentalAnalyst = class {
  name = "Enhanced Fundamental Analyst";
  systemPrompt;
  constructor() {
    this.systemPrompt = `You are an elite Fundamental Analyst with expertise in SEC filings analysis.
You have access to actual 10-K, 10-Q, and 8-K filings from SEC EDGAR.
Your analysis goes beyond surface-level metrics to uncover:

1. **Hidden Risks in Footnotes**: Identify off-balance-sheet liabilities, contingent obligations, 
   and accounting policy changes that could materially impact the company.

2. **Revenue Quality Assessment**: Evaluate revenue recognition policies, customer concentration,
   contract terms, and deferred revenue trends.

3. **Cash Flow Analysis**: Distinguish between operating cash flow quality, capex requirements,
   working capital trends, and free cash flow sustainability.

4. **Debt & Liquidity**: Analyze debt maturities, covenant compliance, credit facility availability,
   and refinancing risks.

5. **Management Signals**: Decode MD&A language changes, guidance tone shifts, and executive
   compensation alignment with shareholder interests.

6. **Competitive Position**: Assess market share trends, pricing power, and competitive moats
   from business description changes.

Always cite specific sections and provide page references when possible.
Be skeptical and look for what management is NOT saying.`;
  }
  /**
   * Perform enhanced fundamental analysis with live SEC filings
   */
  async analyze(ticker) {
    console.log(`[${this.name}] Starting enhanced analysis for ${ticker}`);
    const [cik, yahooData, xbrlMetrics] = await Promise.all([
      secEdgarService.getCIKByTicker(ticker),
      this.fetchYahooData(ticker),
      secEdgarService.extractKeyMetrics(ticker)
    ]);
    if (!cik) {
      console.warn(`[${this.name}] Could not find CIK for ${ticker}`);
      return this.createDefaultSignal(ticker, "Unable to find SEC filings");
    }
    const [filings10K, filings10Q] = await Promise.all([
      secEdgarService.get10KFilings(ticker, 2),
      secEdgarService.get10QFilings(ticker, 4)
    ]);
    const latestFiling = filings10K[0] || filings10Q[0];
    if (!latestFiling) {
      return this.createDefaultSignal(ticker, "No recent SEC filings found");
    }
    const parsedFiling = await secFilingRAG.parseFiling(ticker, latestFiling);
    if (!parsedFiling) {
      return this.createDefaultSignal(ticker, "Failed to parse SEC filing");
    }
    const filingSummary = await secFilingRAG.generateSummary(parsedFiling);
    const riskSection = secFilingRAG.getSection(parsedFiling, "Risk Factors");
    const mdaSection = secFilingRAG.getSection(parsedFiling, "MD&A");
    const businessSection = secFilingRAG.getSection(parsedFiling, "Business");
    const analysisPrompt = this.buildAnalysisPrompt(
      ticker,
      filingSummary,
      riskSection?.content.substring(0, 5e3),
      mdaSection?.content.substring(0, 5e3),
      businessSection?.content.substring(0, 3e3),
      xbrlMetrics,
      yahooData
    );
    const response = await invokeLLM({
      messages: [
        { role: "system", content: this.systemPrompt },
        { role: "user", content: analysisPrompt }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "fundamental_analysis",
          strict: true,
          schema: {
            type: "object",
            properties: {
              signal: { type: "string", enum: ["bullish", "bearish", "neutral"] },
              confidence: { type: "number" },
              rationale: { type: "string" },
              keyFindings: { type: "array", items: { type: "string" } },
              risks: { type: "array", items: { type: "string" } },
              riskFactorHighlights: { type: "array", items: { type: "string" } },
              mdaHighlights: { type: "array", items: { type: "string" } }
            },
            required: ["signal", "confidence", "rationale", "keyFindings", "risks", "riskFactorHighlights", "mdaHighlights"],
            additionalProperties: false
          }
        }
      }
    });
    const content = response.choices[0]?.message?.content;
    let analysis = {
      signal: "neutral",
      confidence: 50,
      rationale: "Analysis not available",
      keyFindings: [],
      risks: [],
      riskFactorHighlights: [],
      mdaHighlights: []
    };
    if (content) {
      try {
        analysis = JSON.parse(typeof content === "string" ? content : JSON.stringify(content));
      } catch {
      }
    }
    return {
      agent: this.name,
      ticker,
      signal: analysis.signal,
      confidence: analysis.confidence,
      rationale: analysis.rationale,
      keyFindings: analysis.keyFindings,
      risks: analysis.risks,
      timestamp: /* @__PURE__ */ new Date(),
      dataPoints: xbrlMetrics || {},
      secAnalysis: {
        latestFilingDate: latestFiling.filingDate,
        latestFilingType: latestFiling.form,
        filingSummary,
        riskFactorChanges: analysis.riskFactorHighlights,
        mdaHighlights: analysis.mdaHighlights,
        financialMetrics: xbrlMetrics || {}
      }
    };
  }
  /**
   * Perform deep dive analysis on specific areas
   */
  async deepDive(request) {
    const { ticker, focusAreas = ["risk_factors", "mda"], compareYoY = false, specificQuestions = [] } = request;
    const filings10K = await secEdgarService.get10KFilings(ticker, 2);
    const latestFiling = filings10K[0];
    if (!latestFiling) {
      throw new Error(`No 10-K filings found for ${ticker}`);
    }
    const parsedFiling = await secFilingRAG.parseFiling(ticker, latestFiling);
    if (!parsedFiling) {
      throw new Error(`Failed to parse filing for ${ticker}`);
    }
    const summary = await secFilingRAG.generateSummary(parsedFiling);
    const sectionAnalysis = [];
    for (const area of focusAreas) {
      const sectionName = this.mapAreaToSection(area);
      const section = secFilingRAG.getSection(parsedFiling, sectionName);
      if (section) {
        const analysis = await this.analyzeSectionDeep(ticker, section.title, section.content);
        sectionAnalysis.push(analysis);
      }
    }
    let yoyComparison;
    if (compareYoY && filings10K.length >= 2) {
      const previousFiling = await secFilingRAG.parseFiling(ticker, filings10K[1]);
      if (previousFiling) {
        const comparison = await secFilingRAG.compareFilings(
          previousFiling,
          parsedFiling,
          "risk factors"
        );
        yoyComparison = comparison.changes.map((c) => ({
          area: c.area,
          changes: [c.change],
          significance: c.significance
        }));
      }
    }
    let questionAnswers;
    if (specificQuestions.length > 0) {
      questionAnswers = await Promise.all(
        specificQuestions.map((q) => secFilingRAG.askQuestion(parsedFiling, q))
      );
    }
    const overallAssessment = await this.generateOverallAssessment(
      ticker,
      summary,
      sectionAnalysis,
      yoyComparison
    );
    return {
      ticker,
      filingDate: latestFiling.filingDate,
      filingType: latestFiling.form,
      summary,
      sectionAnalysis,
      yoyComparison,
      questionAnswers,
      overallAssessment
    };
  }
  /**
   * Ask a specific question about a company's filings
   */
  async askQuestion(ticker, question) {
    const filings10K = await secEdgarService.get10KFilings(ticker, 1);
    const filings10Q = await secEdgarService.get10QFilings(ticker, 1);
    const latestFiling = filings10K[0] || filings10Q[0];
    if (!latestFiling) {
      return {
        question,
        answer: `No SEC filings found for ${ticker}`,
        sources: [],
        confidence: 0
      };
    }
    const parsedFiling = await secFilingRAG.parseFiling(ticker, latestFiling);
    if (!parsedFiling) {
      return {
        question,
        answer: `Failed to parse SEC filing for ${ticker}`,
        sources: [],
        confidence: 0
      };
    }
    return secFilingRAG.askQuestion(parsedFiling, question);
  }
  /**
   * Get filing summary for a ticker
   */
  async getFilingSummary(ticker, filingType = "10-K") {
    const filings = filingType === "10-K" ? await secEdgarService.get10KFilings(ticker, 1) : await secEdgarService.get10QFilings(ticker, 1);
    if (filings.length === 0) return null;
    const parsedFiling = await secFilingRAG.parseFiling(ticker, filings[0]);
    if (!parsedFiling) return null;
    return secFilingRAG.generateSummary(parsedFiling);
  }
  /**
   * Get key financial metrics from XBRL
   */
  async getFinancialMetrics(ticker) {
    return secEdgarService.extractKeyMetrics(ticker);
  }
  /**
   * List available SEC filings for a ticker
   */
  async listFilings(ticker, limit = 20) {
    const cik = await secEdgarService.getCIKByTicker(ticker);
    if (!cik) return [];
    const submissions = await secEdgarService.getCompanySubmissions(cik);
    if (!submissions) return [];
    return submissions.filings.filter((f) => ["10-K", "10-Q", "8-K", "10-K/A", "10-Q/A"].includes(f.form)).slice(0, limit);
  }
  // ============================================================================
  // Private Helper Methods
  // ============================================================================
  buildAnalysisPrompt(ticker, summary, riskFactors, mda, business, xbrlMetrics, yahooData) {
    return `Analyze ${ticker} based on the following SEC filing data:

## FILING SUMMARY
- Form: ${summary.form}
- Filing Date: ${summary.filingDate}
- Executive Summary: ${summary.executiveSummary}

## KEY HIGHLIGHTS
${summary.keyHighlights.map((h) => `- ${h}`).join("\n")}

## RISK FACTORS (from filing)
${summary.riskFactors.map((r) => `- ${r}`).join("\n")}

## MANAGEMENT OUTLOOK
${summary.managementOutlook}

${riskFactors ? `## RISK FACTORS SECTION (excerpt)
${riskFactors.substring(0, 3e3)}...` : ""}

${mda ? `## MD&A SECTION (excerpt)
${mda.substring(0, 3e3)}...` : ""}

${business ? `## BUSINESS SECTION (excerpt)
${business.substring(0, 2e3)}...` : ""}

${xbrlMetrics ? `## XBRL FINANCIAL METRICS
${Object.entries(xbrlMetrics).map(
      ([k, v]) => `- ${k}: ${v.value?.toLocaleString() || "N/A"} (${v.period || "N/A"})`
    ).join("\n")}` : ""}

${yahooData ? `## MARKET DATA
- Current Price: $${yahooData.currentPrice || "N/A"}
- Market Cap: $${yahooData.marketCap?.toLocaleString() || "N/A"}
- P/E Ratio: ${yahooData.peRatio || "N/A"}
- 52-Week Range: $${yahooData.fiftyTwoWeekLow || "N/A"} - $${yahooData.fiftyTwoWeekHigh || "N/A"}` : ""}

Based on this comprehensive analysis of actual SEC filings:
1. What is your investment signal (bullish/bearish/neutral)?
2. What is your confidence level (0-100)?
3. What are the key findings that support your thesis?
4. What are the main risks investors should be aware of?
5. What specific risk factors from the filing are most concerning?
6. What are the key highlights from the MD&A section?`;
  }
  async fetchYahooData(ticker) {
    try {
      const result = await callDataApi("YahooFinance/get_stock_chart", {
        query: { symbol: ticker, range: "1d", interval: "1d" }
      });
      const meta = result?.chart?.result?.[0]?.meta;
      if (meta) {
        return {
          currentPrice: meta.regularMarketPrice,
          marketCap: meta.marketCap,
          fiftyTwoWeekHigh: meta.fiftyTwoWeekHigh,
          fiftyTwoWeekLow: meta.fiftyTwoWeekLow
        };
      }
    } catch (error) {
      console.error(`[${this.name}] Failed to fetch Yahoo data:`, error);
    }
    return null;
  }
  mapAreaToSection(area) {
    const mapping = {
      "risk_factors": "Risk Factors",
      "mda": "MD&A",
      "business": "Business",
      "financials": "Financial Statements",
      "compensation": "Executive Compensation"
    };
    return mapping[area] || area;
  }
  async analyzeSectionDeep(ticker, sectionTitle, content) {
    const response = await invokeLLM({
      messages: [
        {
          role: "system",
          content: `You are analyzing the ${sectionTitle} section of a SEC filing for ${ticker}.
Provide a detailed analysis focusing on material information for investors.`
        },
        {
          role: "user",
          content: `Analyze this ${sectionTitle} section:

${content.substring(0, 8e3)}

Provide:
1. A summary analysis
2. Key points investors should know
3. Any concerns or red flags`
        }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "section_analysis",
          strict: true,
          schema: {
            type: "object",
            properties: {
              analysis: { type: "string" },
              keyPoints: { type: "array", items: { type: "string" } },
              concerns: { type: "array", items: { type: "string" } }
            },
            required: ["analysis", "keyPoints", "concerns"],
            additionalProperties: false
          }
        }
      }
    });
    const responseContent = response.choices[0]?.message?.content;
    let parsed = { analysis: "Analysis not available", keyPoints: [], concerns: [] };
    if (responseContent) {
      try {
        parsed = JSON.parse(typeof responseContent === "string" ? responseContent : JSON.stringify(responseContent));
      } catch {
      }
    }
    return {
      section: sectionTitle,
      ...parsed
    };
  }
  async generateOverallAssessment(ticker, summary, sectionAnalysis, yoyComparison) {
    const response = await invokeLLM({
      messages: [
        {
          role: "system",
          content: `You are generating an overall investment assessment for ${ticker} based on SEC filing analysis.`
        },
        {
          role: "user",
          content: `Based on the following analysis:

SUMMARY:
${summary.executiveSummary}

SECTION ANALYSES:
${sectionAnalysis.map((s) => `${s.section}: ${s.analysis}`).join("\n\n")}

${yoyComparison ? `YOY CHANGES:
${yoyComparison.map((c) => `- ${c.area}: ${c.changes.join(", ")} (${c.significance})`).join("\n")}` : ""}

Provide an overall investment assessment with signal, confidence, and thesis.`
        }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "overall_assessment",
          strict: true,
          schema: {
            type: "object",
            properties: {
              signal: { type: "string", enum: ["bullish", "bearish", "neutral"] },
              confidence: { type: "number" },
              investmentThesis: { type: "string" }
            },
            required: ["signal", "confidence", "investmentThesis"],
            additionalProperties: false
          }
        }
      }
    });
    const content = response.choices[0]?.message?.content;
    let parsed = {
      signal: "neutral",
      confidence: 50,
      investmentThesis: "Assessment not available"
    };
    if (content) {
      try {
        parsed = JSON.parse(typeof content === "string" ? content : JSON.stringify(content));
      } catch {
      }
    }
    return parsed;
  }
  createDefaultSignal(ticker, reason) {
    return {
      agent: this.name,
      ticker,
      signal: "neutral",
      confidence: 0,
      rationale: reason,
      keyFindings: [],
      risks: [reason],
      timestamp: /* @__PURE__ */ new Date(),
      dataPoints: {},
      secAnalysis: {
        latestFilingDate: "",
        latestFilingType: "",
        financialMetrics: {}
      }
    };
  }
};
var enhancedFundamentalAnalyst = new EnhancedFundamentalAnalyst();

// server/services/alertSystem.ts
init_db();
init_schema();
import { eq as eq5, and as and5, desc as desc5 } from "drizzle-orm";
var toNum2 = (v) => {
  if (v === null || v === void 0) return 0;
  return typeof v === "number" ? v : parseFloat(v) || 0;
};
async function createPriceAlert(userId, symbol, assetType, alertType, targetValue, options) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const id = `pa_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const now = /* @__PURE__ */ new Date();
  await db.insert(priceAlerts).values({
    id,
    userId,
    symbol,
    assetType,
    alertType,
    targetValue: String(targetValue),
    message: options?.message || null,
    isActive: true,
    isTriggered: false,
    notifyEmail: options?.notifyEmail ?? true,
    notifyPush: options?.notifyPush ?? true,
    createdAt: now,
    updatedAt: now
  });
  return {
    id,
    userId,
    symbol,
    assetType,
    alertType,
    targetValue,
    message: options?.message,
    isActive: true,
    isTriggered: false,
    notifyEmail: options?.notifyEmail ?? true,
    notifyPush: options?.notifyPush ?? true,
    createdAt: now,
    updatedAt: now
  };
}
async function createRegimeAlert(userId, symbol, toRegime, options) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const id = `ra_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const now = /* @__PURE__ */ new Date();
  await db.insert(regimeAlerts).values({
    id,
    userId,
    symbol,
    toRegime,
    fromRegime: options?.fromRegime || null,
    isActive: true,
    isTriggered: false,
    notifyEmail: options?.notifyEmail ?? true,
    notifyPush: options?.notifyPush ?? true,
    createdAt: now,
    updatedAt: now
  });
  return {
    id,
    userId,
    symbol,
    toRegime,
    fromRegime: options?.fromRegime,
    isActive: true,
    isTriggered: false,
    notifyEmail: options?.notifyEmail ?? true,
    notifyPush: options?.notifyPush ?? true,
    createdAt: now,
    updatedAt: now
  };
}
async function createSentimentAlert(userId, symbol, alertType, options) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const id = `sa_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const now = /* @__PURE__ */ new Date();
  await db.insert(sentimentAlerts).values({
    id,
    userId,
    symbol,
    alertType,
    threshold: options?.threshold ? String(options.threshold) : null,
    isActive: true,
    isTriggered: false,
    notifyEmail: options?.notifyEmail ?? true,
    notifyPush: options?.notifyPush ?? true,
    createdAt: now,
    updatedAt: now
  });
  return {
    id,
    userId,
    symbol,
    alertType,
    threshold: options?.threshold,
    isActive: true,
    isTriggered: false,
    notifyEmail: options?.notifyEmail ?? true,
    notifyPush: options?.notifyPush ?? true,
    createdAt: now,
    updatedAt: now
  };
}
async function getUserPriceAlerts(userId) {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select().from(priceAlerts).where(eq5(priceAlerts.userId, userId)).orderBy(desc5(priceAlerts.createdAt));
  return results.map((r) => ({
    id: r.id,
    userId: r.userId,
    symbol: r.symbol,
    assetType: r.assetType,
    alertType: r.alertType,
    targetValue: toNum2(r.targetValue),
    currentValue: r.currentValue ? toNum2(r.currentValue) : void 0,
    message: r.message || void 0,
    isActive: r.isActive,
    isTriggered: r.isTriggered,
    triggeredAt: r.triggeredAt ? new Date(r.triggeredAt) : void 0,
    notifyEmail: r.notifyEmail,
    notifyPush: r.notifyPush,
    createdAt: new Date(r.createdAt),
    updatedAt: new Date(r.updatedAt)
  }));
}
async function getUserRegimeAlerts(userId) {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select().from(regimeAlerts).where(eq5(regimeAlerts.userId, userId)).orderBy(desc5(regimeAlerts.createdAt));
  return results.map((r) => ({
    id: r.id,
    userId: r.userId,
    symbol: r.symbol,
    fromRegime: r.fromRegime,
    toRegime: r.toRegime,
    isActive: r.isActive,
    isTriggered: r.isTriggered,
    triggeredAt: r.triggeredAt ? new Date(r.triggeredAt) : void 0,
    notifyEmail: r.notifyEmail,
    notifyPush: r.notifyPush,
    createdAt: new Date(r.createdAt),
    updatedAt: new Date(r.updatedAt)
  }));
}
async function getUserSentimentAlerts(userId) {
  const db = await getDb();
  if (!db) return [];
  const results = await db.select().from(sentimentAlerts).where(eq5(sentimentAlerts.userId, userId)).orderBy(desc5(sentimentAlerts.createdAt));
  return results.map((r) => ({
    id: r.id,
    userId: r.userId,
    symbol: r.symbol,
    alertType: r.alertType,
    threshold: r.threshold ? toNum2(r.threshold) : void 0,
    isActive: r.isActive,
    isTriggered: r.isTriggered,
    triggeredAt: r.triggeredAt ? new Date(r.triggeredAt) : void 0,
    notifyEmail: r.notifyEmail,
    notifyPush: r.notifyPush,
    createdAt: new Date(r.createdAt),
    updatedAt: new Date(r.updatedAt)
  }));
}
async function getAlertHistory(userId, limit = 50) {
  const db = await getDb();
  if (!db) return [];
  const numericUserId = parseInt(userId) || 0;
  const results = await db.select().from(alertHistory).where(eq5(alertHistory.userId, numericUserId)).orderBy(desc5(alertHistory.createdAt)).limit(limit);
  return results.map((r) => ({
    id: r.id,
    uniqueId: r.uniqueId || void 0,
    userId: r.userId,
    alertId: r.alertId,
    alertIdStr: r.alertIdStr || void 0,
    alertType: r.alertType,
    symbol: r.symbol,
    title: r.title || void 0,
    message: r.message,
    details: r.details,
    isRead: r.isRead,
    emailSent: r.emailSent,
    pushSent: r.pushSent,
    createdAt: new Date(r.createdAt)
  }));
}
async function togglePriceAlert(alertId, isActive) {
  const db = await getDb();
  if (!db) return false;
  await db.update(priceAlerts).set({ isActive, updatedAt: /* @__PURE__ */ new Date() }).where(eq5(priceAlerts.id, alertId));
  return true;
}
async function toggleRegimeAlert(alertId, isActive) {
  const db = await getDb();
  if (!db) return false;
  await db.update(regimeAlerts).set({ isActive, updatedAt: /* @__PURE__ */ new Date() }).where(eq5(regimeAlerts.id, alertId));
  return true;
}
async function toggleSentimentAlert(alertId, isActive) {
  const db = await getDb();
  if (!db) return false;
  await db.update(sentimentAlerts).set({ isActive, updatedAt: /* @__PURE__ */ new Date() }).where(eq5(sentimentAlerts.id, alertId));
  return true;
}
async function deletePriceAlert(alertId) {
  const db = await getDb();
  if (!db) return false;
  await db.delete(priceAlerts).where(eq5(priceAlerts.id, alertId));
  return true;
}
async function deleteRegimeAlert(alertId) {
  const db = await getDb();
  if (!db) return false;
  await db.delete(regimeAlerts).where(eq5(regimeAlerts.id, alertId));
  return true;
}
async function deleteSentimentAlert(alertId) {
  const db = await getDb();
  if (!db) return false;
  await db.delete(sentimentAlerts).where(eq5(sentimentAlerts.id, alertId));
  return true;
}
async function markAlertAsRead(alertHistoryId) {
  const db = await getDb();
  if (!db) return false;
  const numericId = parseInt(alertHistoryId) || 0;
  await db.update(alertHistory).set({ isRead: true }).where(eq5(alertHistory.id, numericId));
  return true;
}
async function getAlertSummary(userId) {
  const priceAlertsList = await getUserPriceAlerts(userId);
  const regimeAlertsList = await getUserRegimeAlerts(userId);
  const sentimentAlertsList = await getUserSentimentAlerts(userId);
  const today = /* @__PURE__ */ new Date();
  today.setHours(0, 0, 0, 0);
  const allAlerts = [
    ...priceAlertsList.map((a) => ({ ...a, type: "price" })),
    ...regimeAlertsList.map((a) => ({ ...a, type: "regime" })),
    ...sentimentAlertsList.map((a) => ({ ...a, type: "sentiment" }))
  ];
  const triggeredToday = allAlerts.filter(
    (a) => a.triggeredAt && new Date(a.triggeredAt) >= today
  ).length;
  return {
    totalAlerts: allAlerts.length,
    activeAlerts: allAlerts.filter((a) => a.isActive).length,
    triggeredToday,
    priceAlerts: priceAlertsList.length,
    regimeAlerts: regimeAlertsList.length,
    sentimentAlerts: sentimentAlertsList.length
  };
}

// server/services/copyTrading.ts
var SIMULATED_TRADERS = [
  {
    id: "trader_1",
    name: "AlphaTrader",
    avatar: void 0,
    totalReturn: 156.8,
    winRate: 72.5,
    totalTrades: 1247,
    followers: 892,
    riskScore: 6,
    sharpeRatio: 2.34,
    maxDrawdown: 12.5,
    avgTradeSize: 5e3,
    tradingStyle: "swing_trader",
    preferredAssets: ["AAPL", "MSFT", "GOOGL", "NVDA"],
    monthlyReturn: 8.5,
    isVerified: true,
    joinedAt: /* @__PURE__ */ new Date("2023-01-15")
  },
  {
    id: "trader_2",
    name: "CryptoKing",
    avatar: void 0,
    totalReturn: 234.2,
    winRate: 65.8,
    totalTrades: 2156,
    followers: 1543,
    riskScore: 8,
    sharpeRatio: 1.89,
    maxDrawdown: 25.3,
    avgTradeSize: 8e3,
    tradingStyle: "day_trader",
    preferredAssets: ["BTC", "ETH", "SOL", "AVAX"],
    monthlyReturn: 12.3,
    isVerified: true,
    joinedAt: /* @__PURE__ */ new Date("2022-08-20")
  },
  {
    id: "trader_3",
    name: "ValueHunter",
    avatar: void 0,
    totalReturn: 89.4,
    winRate: 78.2,
    totalTrades: 456,
    followers: 567,
    riskScore: 3,
    sharpeRatio: 2.78,
    maxDrawdown: 8.2,
    avgTradeSize: 15e3,
    tradingStyle: "position_trader",
    preferredAssets: ["AAPL", "JNJ", "PG", "KO"],
    monthlyReturn: 4.2,
    isVerified: true,
    joinedAt: /* @__PURE__ */ new Date("2023-03-10")
  },
  {
    id: "trader_4",
    name: "MomentumMaster",
    avatar: void 0,
    totalReturn: 178.9,
    winRate: 68.4,
    totalTrades: 3421,
    followers: 1234,
    riskScore: 7,
    sharpeRatio: 2.12,
    maxDrawdown: 18.7,
    avgTradeSize: 3e3,
    tradingStyle: "scalper",
    preferredAssets: ["SPY", "QQQ", "TSLA", "AMD"],
    monthlyReturn: 9.8,
    isVerified: true,
    joinedAt: /* @__PURE__ */ new Date("2022-11-05")
  },
  {
    id: "trader_5",
    name: "TechGuru",
    avatar: void 0,
    totalReturn: 145.6,
    winRate: 71.2,
    totalTrades: 987,
    followers: 789,
    riskScore: 5,
    sharpeRatio: 2.45,
    maxDrawdown: 14.3,
    avgTradeSize: 6500,
    tradingStyle: "swing_trader",
    preferredAssets: ["NVDA", "AMD", "INTC", "QCOM"],
    monthlyReturn: 7.6,
    isVerified: true,
    joinedAt: /* @__PURE__ */ new Date("2023-02-28")
  },
  {
    id: "trader_6",
    name: "DeFiWhale",
    avatar: void 0,
    totalReturn: 312.5,
    winRate: 62.1,
    totalTrades: 1876,
    followers: 2134,
    riskScore: 9,
    sharpeRatio: 1.67,
    maxDrawdown: 32.1,
    avgTradeSize: 12e3,
    tradingStyle: "day_trader",
    preferredAssets: ["ETH", "UNI", "AAVE", "LINK"],
    monthlyReturn: 15.8,
    isVerified: true,
    joinedAt: /* @__PURE__ */ new Date("2022-06-15")
  },
  {
    id: "trader_7",
    name: "SafeHaven",
    avatar: void 0,
    totalReturn: 45.8,
    winRate: 82.3,
    totalTrades: 234,
    followers: 345,
    riskScore: 2,
    sharpeRatio: 3.12,
    maxDrawdown: 5.4,
    avgTradeSize: 2e4,
    tradingStyle: "position_trader",
    preferredAssets: ["GLD", "TLT", "VTI", "BND"],
    monthlyReturn: 2.8,
    isVerified: true,
    joinedAt: /* @__PURE__ */ new Date("2023-05-01")
  },
  {
    id: "trader_8",
    name: "OptionsWizard",
    avatar: void 0,
    totalReturn: 198.3,
    winRate: 69.7,
    totalTrades: 1543,
    followers: 987,
    riskScore: 7,
    sharpeRatio: 2.01,
    maxDrawdown: 21.5,
    avgTradeSize: 4500,
    tradingStyle: "swing_trader",
    preferredAssets: ["SPY", "AAPL", "TSLA", "AMZN"],
    monthlyReturn: 10.2,
    isVerified: true,
    joinedAt: /* @__PURE__ */ new Date("2022-09-12")
  }
];
var copySettingsStore = /* @__PURE__ */ new Map();
var copyTradesStore = /* @__PURE__ */ new Map();
async function getTopTraders2(sortBy = "return", limit = 10) {
  let sorted = [...SIMULATED_TRADERS];
  switch (sortBy) {
    case "return":
      sorted.sort((a, b) => b.totalReturn - a.totalReturn);
      break;
    case "winRate":
      sorted.sort((a, b) => b.winRate - a.winRate);
      break;
    case "followers":
      sorted.sort((a, b) => b.followers - a.followers);
      break;
    case "sharpe":
      sorted.sort((a, b) => b.sharpeRatio - a.sharpeRatio);
      break;
  }
  return sorted.slice(0, limit);
}
async function getTraderById(traderId) {
  return SIMULATED_TRADERS.find((t2) => t2.id === traderId) || null;
}
async function startCopyTrading(followerId, traderId, settings) {
  const id = `copy_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const copySettings2 = {
    id,
    followerId,
    traderId,
    allocationMode: settings.allocationMode,
    allocationAmount: settings.allocationAmount,
    maxPositionSize: settings.maxPositionSize || 1e4,
    maxDailyLoss: settings.maxDailyLoss || 500,
    copyStopLoss: settings.copyStopLoss ?? true,
    copyTakeProfit: settings.copyTakeProfit ?? true,
    excludeSymbols: settings.excludeSymbols || [],
    status: "active",
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  };
  copySettingsStore.set(id, copySettings2);
  const trader = SIMULATED_TRADERS.find((t2) => t2.id === traderId);
  if (trader) {
    trader.followers += 1;
  }
  return copySettings2;
}
async function stopCopyTrading(copySettingsId) {
  const settings = copySettingsStore.get(copySettingsId);
  if (!settings) return false;
  settings.status = "stopped";
  settings.updatedAt = /* @__PURE__ */ new Date();
  const trader = SIMULATED_TRADERS.find((t2) => t2.id === settings.traderId);
  if (trader && trader.followers > 0) {
    trader.followers -= 1;
  }
  return true;
}
async function pauseCopyTrading(copySettingsId) {
  const settings = copySettingsStore.get(copySettingsId);
  if (!settings) return false;
  settings.status = "paused";
  settings.updatedAt = /* @__PURE__ */ new Date();
  return true;
}
async function resumeCopyTrading(copySettingsId) {
  const settings = copySettingsStore.get(copySettingsId);
  if (!settings) return false;
  settings.status = "active";
  settings.updatedAt = /* @__PURE__ */ new Date();
  return true;
}
async function updateCopySettings(copySettingsId, updates) {
  const settings = copySettingsStore.get(copySettingsId);
  if (!settings) return null;
  Object.assign(settings, updates, { updatedAt: /* @__PURE__ */ new Date() });
  return settings;
}
async function getUserCopySettings(userId) {
  const results = [];
  copySettingsStore.forEach((settings) => {
    if (settings.followerId === userId) {
      results.push(settings);
    }
  });
  return results;
}
async function getCopySettingsById(id) {
  return copySettingsStore.get(id) || null;
}
async function getUserCopyTrades(userId, limit = 50) {
  const trades2 = copyTradesStore.get(userId) || [];
  return trades2.slice(-limit).reverse();
}
async function getCopyPerformance(userId) {
  const trades2 = copyTradesStore.get(userId) || [];
  if (trades2.length === 0) {
    return {
      totalCopiedTrades: 0,
      successfulTrades: 0,
      failedTrades: 0,
      totalPnL: 0,
      totalReturn: 0,
      avgSlippage: 0,
      bestTrade: 0,
      worstTrade: 0,
      winRate: 0
    };
  }
  const executedTrades = trades2.filter((t2) => t2.status === "executed");
  const failedTrades = trades2.filter((t2) => t2.status === "failed");
  const tradesWithPnL = executedTrades.map((t2) => {
    const pnlPercent = (Math.random() - 0.45) * 10;
    const pnl = t2.copiedQuantity * t2.copiedPrice * (pnlPercent / 100);
    return { ...t2, pnl };
  });
  const totalPnL = tradesWithPnL.reduce((sum2, t2) => sum2 + (t2.pnl || 0), 0);
  const wins = tradesWithPnL.filter((t2) => (t2.pnl || 0) > 0);
  const avgSlippage = executedTrades.reduce((sum2, t2) => sum2 + t2.slippage, 0) / executedTrades.length;
  const pnls = tradesWithPnL.map((t2) => t2.pnl || 0);
  return {
    totalCopiedTrades: trades2.length,
    successfulTrades: executedTrades.length,
    failedTrades: failedTrades.length,
    totalPnL,
    totalReturn: totalPnL / 1e4 * 100,
    // Assuming $10k base
    avgSlippage,
    bestTrade: Math.max(...pnls, 0),
    worstTrade: Math.min(...pnls, 0),
    winRate: executedTrades.length > 0 ? wins.length / executedTrades.length * 100 : 0
  };
}

// server/services/tradingJournal.ts
var journalStore = /* @__PURE__ */ new Map();
async function createJournalEntry(userId, entry) {
  const id = `journal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const journalEntry = {
    id,
    userId,
    ...entry,
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  };
  if (entry.entryDate && entry.exitDate) {
    journalEntry.holdingPeriod = Math.floor(
      (new Date(entry.exitDate).getTime() - new Date(entry.entryDate).getTime()) / 6e4
    );
  }
  if (entry.entryPrice && entry.exitPrice) {
    const multiplier = entry.side === "long" ? 1 : -1;
    journalEntry.pnl = (entry.exitPrice - entry.entryPrice) * entry.quantity * multiplier;
    journalEntry.pnlPercent = (entry.exitPrice - entry.entryPrice) / entry.entryPrice * 100 * multiplier;
    if (journalEntry.pnl > 0) {
      journalEntry.outcome = "win";
    } else if (journalEntry.pnl < 0) {
      journalEntry.outcome = "loss";
    } else {
      journalEntry.outcome = "breakeven";
    }
  } else {
    journalEntry.outcome = "open";
  }
  const userEntries = journalStore.get(userId) || [];
  userEntries.push(journalEntry);
  journalStore.set(userId, userEntries);
  return journalEntry;
}
async function updateJournalEntry(userId, entryId, updates) {
  const userEntries = journalStore.get(userId) || [];
  const index = userEntries.findIndex((e) => e.id === entryId);
  if (index === -1) return null;
  const entry = userEntries[index];
  Object.assign(entry, updates, { updatedAt: /* @__PURE__ */ new Date() });
  if (entry.entryPrice && entry.exitPrice) {
    const multiplier = entry.side === "long" ? 1 : -1;
    entry.pnl = (entry.exitPrice - entry.entryPrice) * entry.quantity * multiplier;
    entry.pnlPercent = (entry.exitPrice - entry.entryPrice) / entry.entryPrice * 100 * multiplier;
    if (entry.pnl > 0) {
      entry.outcome = "win";
    } else if (entry.pnl < 0) {
      entry.outcome = "loss";
    } else {
      entry.outcome = "breakeven";
    }
  }
  if (entry.entryDate && entry.exitDate) {
    entry.holdingPeriod = Math.floor(
      (new Date(entry.exitDate).getTime() - new Date(entry.entryDate).getTime()) / 6e4
    );
  }
  return entry;
}
async function deleteJournalEntry(userId, entryId) {
  const userEntries = journalStore.get(userId) || [];
  const index = userEntries.findIndex((e) => e.id === entryId);
  if (index === -1) return false;
  userEntries.splice(index, 1);
  return true;
}
async function getJournalEntryById(userId, entryId) {
  const userEntries = journalStore.get(userId) || [];
  return userEntries.find((e) => e.id === entryId) || null;
}
async function getUserJournalEntries(userId, filters, limit = 50, offset = 0) {
  let entries = journalStore.get(userId) || [];
  if (filters) {
    if (filters.symbol) {
      entries = entries.filter((e) => e.symbol.toLowerCase().includes(filters.symbol.toLowerCase()));
    }
    if (filters.setup) {
      entries = entries.filter((e) => e.setup === filters.setup);
    }
    if (filters.emotion) {
      entries = entries.filter(
        (e) => e.emotionBefore === filters.emotion || e.emotionDuring === filters.emotion || e.emotionAfter === filters.emotion
      );
    }
    if (filters.outcome) {
      entries = entries.filter((e) => e.outcome === filters.outcome);
    }
    if (filters.tags && filters.tags.length > 0) {
      entries = entries.filter(
        (e) => filters.tags.some((tag) => e.tags.includes(tag))
      );
    }
    if (filters.startDate) {
      entries = entries.filter((e) => new Date(e.entryDate) >= filters.startDate);
    }
    if (filters.endDate) {
      entries = entries.filter((e) => new Date(e.entryDate) <= filters.endDate);
    }
    if (filters.minPnL !== void 0) {
      entries = entries.filter((e) => (e.pnl || 0) >= filters.minPnL);
    }
    if (filters.maxPnL !== void 0) {
      entries = entries.filter((e) => (e.pnl || 0) <= filters.maxPnL);
    }
  }
  entries.sort((a, b) => new Date(b.entryDate).getTime() - new Date(a.entryDate).getTime());
  const total = entries.length;
  const paginatedEntries = entries.slice(offset, offset + limit);
  return { entries: paginatedEntries, total };
}
async function getJournalEntriesByDate(userId, year, month) {
  const entries = journalStore.get(userId) || [];
  const result = {};
  entries.forEach((entry) => {
    const date2 = new Date(entry.entryDate);
    if (date2.getFullYear() === year && date2.getMonth() === month - 1) {
      const dateKey = date2.toISOString().split("T")[0];
      if (!result[dateKey]) {
        result[dateKey] = [];
      }
      result[dateKey].push(entry);
    }
  });
  return result;
}
async function getJournalStats(userId, timeframe) {
  let entries = journalStore.get(userId) || [];
  if (timeframe) {
    entries = entries.filter((e) => {
      const date2 = new Date(e.entryDate);
      return date2 >= timeframe.startDate && date2 <= timeframe.endDate;
    });
  }
  const closedTrades = entries.filter((e) => e.outcome && e.outcome !== "open");
  const wins = closedTrades.filter((e) => e.outcome === "win");
  const emotionBreakdown = {
    confident: 0,
    anxious: 0,
    greedy: 0,
    fearful: 0,
    neutral: 0,
    excited: 0,
    frustrated: 0,
    calm: 0
  };
  entries.forEach((e) => {
    emotionBreakdown[e.emotionBefore]++;
  });
  const setupBreakdown = {
    breakout: { count: 0, winRate: 0, avgPnL: 0 },
    pullback: { count: 0, winRate: 0, avgPnL: 0 },
    reversal: { count: 0, winRate: 0, avgPnL: 0 },
    trend_following: { count: 0, winRate: 0, avgPnL: 0 },
    range_bound: { count: 0, winRate: 0, avgPnL: 0 },
    news_based: { count: 0, winRate: 0, avgPnL: 0 },
    technical: { count: 0, winRate: 0, avgPnL: 0 },
    fundamental: { count: 0, winRate: 0, avgPnL: 0 },
    other: { count: 0, winRate: 0, avgPnL: 0 }
  };
  closedTrades.forEach((e) => {
    const setup = setupBreakdown[e.setup];
    setup.count++;
    setup.avgPnL = (setup.avgPnL * (setup.count - 1) + (e.pnl || 0)) / setup.count;
  });
  Object.keys(setupBreakdown).forEach((setup) => {
    const setupTrades = closedTrades.filter((e) => e.setup === setup);
    const setupWins = setupTrades.filter((e) => e.outcome === "win");
    setupBreakdown[setup].winRate = setupTrades.length > 0 ? setupWins.length / setupTrades.length * 100 : 0;
  });
  const tagBreakdown = {};
  entries.forEach((e) => {
    e.tags.forEach((tag) => {
      if (!tagBreakdown[tag]) {
        tagBreakdown[tag] = { count: 0, winRate: 0 };
      }
      tagBreakdown[tag].count++;
    });
  });
  Object.keys(tagBreakdown).forEach((tag) => {
    const tagTrades = closedTrades.filter((e) => e.tags.includes(tag));
    const tagWins = tagTrades.filter((e) => e.outcome === "win");
    tagBreakdown[tag].winRate = tagTrades.length > 0 ? tagWins.length / tagTrades.length * 100 : 0;
  });
  const monthlyPnL = [];
  const monthlyData = {};
  closedTrades.forEach((e) => {
    const date2 = new Date(e.entryDate);
    const monthKey = `${date2.getFullYear()}-${String(date2.getMonth() + 1).padStart(2, "0")}`;
    if (!monthlyData[monthKey]) {
      monthlyData[monthKey] = { pnl: 0, trades: 0 };
    }
    monthlyData[monthKey].pnl += e.pnl || 0;
    monthlyData[monthKey].trades++;
  });
  Object.entries(monthlyData).sort(([a], [b]) => a.localeCompare(b)).forEach(([month, data]) => {
    monthlyPnL.push({ month, ...data });
  });
  const pnls = closedTrades.map((e) => e.pnl || 0);
  const totalPnL = pnls.reduce((sum2, p) => sum2 + p, 0);
  const planFollowed = entries.filter((e) => e.planFollowed);
  return {
    totalEntries: entries.length,
    totalTrades: closedTrades.length,
    winRate: closedTrades.length > 0 ? wins.length / closedTrades.length * 100 : 0,
    avgPnL: closedTrades.length > 0 ? totalPnL / closedTrades.length : 0,
    totalPnL,
    avgHoldingPeriod: closedTrades.length > 0 ? closedTrades.reduce((sum2, e) => sum2 + (e.holdingPeriod || 0), 0) / closedTrades.length : 0,
    avgConfidence: entries.length > 0 ? entries.reduce((sum2, e) => sum2 + e.confidenceLevel, 0) / entries.length : 0,
    planFollowedRate: entries.length > 0 ? planFollowed.length / entries.length * 100 : 0,
    bestTrade: pnls.length > 0 ? Math.max(...pnls) : 0,
    worstTrade: pnls.length > 0 ? Math.min(...pnls) : 0,
    emotionBreakdown,
    setupBreakdown,
    tagBreakdown,
    monthlyPnL
  };
}
async function getEmotionCorrelations(userId) {
  const entries = journalStore.get(userId) || [];
  const closedTrades = entries.filter((e) => e.outcome && e.outcome !== "open");
  const emotions = ["confident", "anxious", "greedy", "fearful", "neutral", "excited", "frustrated", "calm"];
  return emotions.map((emotion) => {
    const emotionTrades = closedTrades.filter((e) => e.emotionBefore === emotion);
    const wins = emotionTrades.filter((e) => e.outcome === "win");
    const avgPnL = emotionTrades.length > 0 ? emotionTrades.reduce((sum2, e) => sum2 + (e.pnl || 0), 0) / emotionTrades.length : 0;
    const winRate = emotionTrades.length > 0 ? wins.length / emotionTrades.length * 100 : 0;
    let recommendation = "";
    if (emotion === "anxious" || emotion === "fearful") {
      recommendation = winRate < 50 ? "Consider reducing position size when feeling this emotion" : "Your performance is stable despite this emotion";
    } else if (emotion === "greedy" || emotion === "excited") {
      recommendation = winRate < 50 ? "Be cautious - this emotion may lead to overtrading" : "Channel this energy into disciplined execution";
    } else if (emotion === "confident" || emotion === "calm") {
      recommendation = winRate > 60 ? "This is your optimal trading state - aim to trade more in this mindset" : "Even in good states, stick to your trading plan";
    } else {
      recommendation = "Track more trades to identify patterns";
    }
    return {
      emotion,
      winRate,
      avgPnL,
      tradeCount: emotionTrades.length,
      recommendation
    };
  });
}
async function detectTradingPatterns(userId) {
  const entries = journalStore.get(userId) || [];
  const closedTrades = entries.filter((e) => e.outcome && e.outcome !== "open");
  const patterns = [];
  if (closedTrades.length < 5) {
    return [{
      pattern: "Insufficient Data",
      description: "Need at least 5 closed trades to detect patterns",
      frequency: 0,
      impact: "neutral",
      suggestion: "Continue journaling your trades to unlock pattern detection"
    }];
  }
  const losses = closedTrades.filter((e) => e.outcome === "loss");
  let revengeTradingCount = 0;
  for (let i = 1; i < closedTrades.length; i++) {
    if (closedTrades[i - 1].outcome === "loss" && closedTrades[i].outcome === "loss" && (closedTrades[i].emotionBefore === "frustrated" || closedTrades[i].emotionBefore === "anxious")) {
      revengeTradingCount++;
    }
  }
  if (revengeTradingCount > 0) {
    patterns.push({
      pattern: "Revenge Trading",
      description: `Detected ${revengeTradingCount} instances of trading while frustrated after a loss`,
      frequency: revengeTradingCount,
      impact: "negative",
      suggestion: "Take a break after losses. Set a rule to wait 30 minutes before the next trade."
    });
  }
  const dailyTrades = {};
  closedTrades.forEach((e) => {
    const dateKey = new Date(e.entryDate).toISOString().split("T")[0];
    dailyTrades[dateKey] = (dailyTrades[dateKey] || 0) + 1;
  });
  const highTradeDays = Object.values(dailyTrades).filter((count2) => count2 > 5).length;
  if (highTradeDays > 0) {
    patterns.push({
      pattern: "Overtrading",
      description: `${highTradeDays} days with more than 5 trades detected`,
      frequency: highTradeDays,
      impact: "negative",
      suggestion: "Quality over quantity. Set a daily trade limit and stick to your best setups."
    });
  }
  const planNotFollowed = entries.filter((e) => !e.planFollowed);
  const planDeviationRate = planNotFollowed.length / entries.length * 100;
  if (planDeviationRate > 30) {
    patterns.push({
      pattern: "Plan Deviation",
      description: `${planDeviationRate.toFixed(1)}% of trades deviated from the original plan`,
      frequency: planNotFollowed.length,
      impact: "negative",
      suggestion: "Review your trading plan. If deviations are profitable, update the plan."
    });
  }
  const setupPerformance = {};
  closedTrades.forEach((e) => {
    if (!setupPerformance[e.setup]) {
      setupPerformance[e.setup] = { wins: 0, total: 0 };
    }
    setupPerformance[e.setup].total++;
    if (e.outcome === "win") {
      setupPerformance[e.setup].wins++;
    }
  });
  let bestSetup = "";
  let bestWinRate = 0;
  Object.entries(setupPerformance).forEach(([setup, data]) => {
    if (data.total >= 3) {
      const winRate = data.wins / data.total * 100;
      if (winRate > bestWinRate) {
        bestWinRate = winRate;
        bestSetup = setup;
      }
    }
  });
  if (bestSetup && bestWinRate > 60) {
    patterns.push({
      pattern: "Winning Setup",
      description: `${bestSetup.replace("_", " ")} setup has ${bestWinRate.toFixed(1)}% win rate`,
      frequency: setupPerformance[bestSetup].total,
      impact: "positive",
      suggestion: `Focus more on ${bestSetup.replace("_", " ")} setups - this is your edge.`
    });
  }
  const emotionalTrades = closedTrades.filter(
    (e) => e.emotionBefore === "greedy" || e.emotionBefore === "fearful" || e.emotionBefore === "anxious"
  );
  const emotionalLosses = emotionalTrades.filter((e) => e.outcome === "loss");
  if (emotionalTrades.length > 3 && emotionalLosses.length / emotionalTrades.length > 0.6) {
    patterns.push({
      pattern: "Emotional Trading",
      description: `${(emotionalLosses.length / emotionalTrades.length * 100).toFixed(1)}% loss rate when trading emotionally`,
      frequency: emotionalTrades.length,
      impact: "negative",
      suggestion: "Develop a pre-trade checklist to assess your emotional state."
    });
  }
  const wins = closedTrades.filter((e) => e.outcome === "win");
  const overallWinRate = wins.length / closedTrades.length * 100;
  if (overallWinRate > 55 && closedTrades.length >= 10) {
    patterns.push({
      pattern: "Consistent Performance",
      description: `Maintaining ${overallWinRate.toFixed(1)}% win rate across ${closedTrades.length} trades`,
      frequency: closedTrades.length,
      impact: "positive",
      suggestion: "Great consistency! Consider gradually increasing position sizes."
    });
  }
  return patterns;
}
async function getUserTags(userId) {
  const entries = journalStore.get(userId) || [];
  const tags = /* @__PURE__ */ new Set();
  entries.forEach((e) => {
    e.tags.forEach((tag) => tags.add(tag));
  });
  return Array.from(tags).sort();
}
async function searchJournalEntries(userId, query) {
  const entries = journalStore.get(userId) || [];
  const lowerQuery = query.toLowerCase();
  return entries.filter(
    (e) => e.symbol.toLowerCase().includes(lowerQuery) || e.notes.toLowerCase().includes(lowerQuery) || e.lessonsLearned && e.lessonsLearned.toLowerCase().includes(lowerQuery) || e.tags.some((tag) => tag.toLowerCase().includes(lowerQuery))
  );
}

// server/services/exchangeIntegration.ts
var EXCHANGE_INFO = {
  binance: {
    name: "Binance",
    type: "binance",
    description: "World's largest cryptocurrency exchange by trading volume",
    supportedFeatures: ["spot", "futures", "margin", "staking"],
    authMethod: "api_key",
    apiDocsUrl: "https://binance-docs.github.io/apidocs/",
    tradingFees: { maker: 0.1, taker: 0.1 },
    minimumOrderSize: 10,
    supportedAssets: "crypto"
  },
  coinbase: {
    name: "Coinbase",
    type: "coinbase",
    description: "US-based cryptocurrency exchange with strong regulatory compliance",
    supportedFeatures: ["spot", "staking", "earn"],
    authMethod: "oauth",
    oauthUrl: "https://www.coinbase.com/oauth/authorize",
    apiDocsUrl: "https://docs.cloud.coinbase.com/",
    tradingFees: { maker: 0.4, taker: 0.6 },
    minimumOrderSize: 1,
    supportedAssets: "crypto"
  },
  alpaca: {
    name: "Alpaca",
    type: "alpaca",
    description: "Commission-free stock and crypto trading API",
    supportedFeatures: ["stocks", "crypto", "fractional", "paper_trading"],
    authMethod: "api_key",
    apiDocsUrl: "https://alpaca.markets/docs/api-documentation/",
    tradingFees: { maker: 0, taker: 0 },
    minimumOrderSize: 1,
    supportedAssets: "both"
  },
  interactive_brokers: {
    name: "Interactive Brokers",
    type: "interactive_brokers",
    description: "Professional-grade trading platform with global market access",
    supportedFeatures: ["stocks", "options", "futures", "forex", "bonds"],
    authMethod: "oauth",
    oauthUrl: "https://www.interactivebrokers.com/oauth",
    apiDocsUrl: "https://www.interactivebrokers.com/api",
    tradingFees: { maker: 5e-3, taker: 5e-3 },
    minimumOrderSize: 1,
    supportedAssets: "stocks"
  }
};
var connectionsStore = /* @__PURE__ */ new Map();
var credentialsStore = /* @__PURE__ */ new Map();
function getAvailableExchanges() {
  return Object.values(EXCHANGE_INFO);
}
function getExchangeInfo(exchange) {
  return EXCHANGE_INFO[exchange];
}
async function connectExchange(userId, exchange, credentials) {
  if (!credentials.apiKey || !credentials.apiSecret) {
    throw new Error("API key and secret are required");
  }
  if (exchange === "coinbase" && !credentials.passphrase) {
    throw new Error("Passphrase is required for Coinbase");
  }
  const id = `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const isValid = await validateCredentials(exchange, credentials);
  const connection = {
    id,
    userId,
    exchange,
    status: isValid ? "connected" : "error",
    error: isValid ? void 0 : "Invalid API credentials",
    permissions: isValid ? getDefaultPermissions(exchange) : [],
    lastSyncAt: isValid ? /* @__PURE__ */ new Date() : void 0,
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  };
  const userConnections = connectionsStore.get(userId) || [];
  userConnections.push(connection);
  connectionsStore.set(userId, userConnections);
  if (isValid) {
    credentialsStore.set(id, credentials);
  }
  return connection;
}
async function validateCredentials(exchange, credentials) {
  switch (exchange) {
    case "binance":
      return credentials.apiKey.length >= 32 && credentials.apiSecret.length >= 32;
    case "coinbase":
      return credentials.apiKey.length >= 16 && credentials.apiSecret.length >= 16 && !!credentials.passphrase;
    case "alpaca":
      return credentials.apiKey.length >= 16 && credentials.apiSecret.length >= 16;
    case "interactive_brokers":
      return credentials.apiKey.length >= 8 && !!credentials.accountId;
    default:
      return false;
  }
}
function getDefaultPermissions(exchange) {
  switch (exchange) {
    case "binance":
      return ["read", "spot_trade", "margin_trade", "futures_trade"];
    case "coinbase":
      return ["read", "trade", "transfer"];
    case "alpaca":
      return ["read", "trade", "data"];
    case "interactive_brokers":
      return ["read", "trade", "account_info"];
    default:
      return ["read"];
  }
}
async function disconnectExchange(userId, connectionId) {
  const userConnections = connectionsStore.get(userId) || [];
  const index = userConnections.findIndex((c) => c.id === connectionId);
  if (index === -1) return false;
  userConnections.splice(index, 1);
  credentialsStore.delete(connectionId);
  return true;
}
async function getUserConnections(userId) {
  return connectionsStore.get(userId) || [];
}
async function getConnectionById(userId, connectionId) {
  const userConnections = connectionsStore.get(userId) || [];
  return userConnections.find((c) => c.id === connectionId) || null;
}
async function getExchangeBalances(connectionId) {
  const credentials = credentialsStore.get(connectionId);
  if (!credentials) {
    throw new Error("Connection not found or not authenticated");
  }
  return [
    { asset: "USD", free: 1e4, locked: 0, total: 1e4, usdValue: 1e4 },
    { asset: "BTC", free: 0.5, locked: 0.1, total: 0.6, usdValue: 25e3 },
    { asset: "ETH", free: 5, locked: 0, total: 5, usdValue: 12500 },
    { asset: "AAPL", free: 50, locked: 0, total: 50, usdValue: 9500 }
  ];
}
async function getExchangePositions(connectionId) {
  const credentials = credentialsStore.get(connectionId);
  if (!credentials) {
    throw new Error("Connection not found or not authenticated");
  }
  return [
    {
      symbol: "AAPL",
      side: "long",
      quantity: 50,
      entryPrice: 175.5,
      currentPrice: 190.25,
      unrealizedPnL: 737.5,
      unrealizedPnLPercent: 8.4,
      marketValue: 9512.5
    },
    {
      symbol: "BTC",
      side: "long",
      quantity: 0.5,
      entryPrice: 42e3,
      currentPrice: 45e3,
      unrealizedPnL: 1500,
      unrealizedPnLPercent: 7.14,
      marketValue: 22500
    }
  ];
}
async function placeExchangeOrder(connectionId, order) {
  const credentials = credentialsStore.get(connectionId);
  if (!credentials) {
    throw new Error("Connection not found or not authenticated");
  }
  let exchange = "alpaca";
  connectionsStore.forEach((connections) => {
    const conn = connections.find((c) => c.id === connectionId);
    if (conn) exchange = conn.exchange;
  });
  const exchangeOrder = {
    id: `order_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    exchangeOrderId: `${exchange}_${Date.now()}`,
    exchange,
    symbol: order.symbol,
    side: order.side,
    type: order.type,
    quantity: order.quantity,
    price: order.price,
    stopPrice: order.stopPrice,
    filledQuantity: order.type === "market" ? order.quantity : 0,
    avgFillPrice: order.type === "market" ? order.price || 100 : void 0,
    status: order.type === "market" ? "filled" : "open",
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  };
  return exchangeOrder;
}
async function cancelExchangeOrder(connectionId, orderId) {
  const credentials = credentialsStore.get(connectionId);
  if (!credentials) {
    throw new Error("Connection not found or not authenticated");
  }
  return true;
}
async function getOrderHistory(connectionId, limit = 50) {
  const credentials = credentialsStore.get(connectionId);
  if (!credentials) {
    throw new Error("Connection not found or not authenticated");
  }
  let exchange = "alpaca";
  connectionsStore.forEach((connections) => {
    const conn = connections.find((c) => c.id === connectionId);
    if (conn) exchange = conn.exchange;
  });
  const orders = [];
  const symbols = ["AAPL", "GOOGL", "BTC", "ETH", "MSFT"];
  for (let i = 0; i < Math.min(limit, 10); i++) {
    orders.push({
      id: `order_${i}`,
      exchangeOrderId: `${exchange}_${Date.now() - i * 864e5}`,
      exchange,
      symbol: symbols[i % symbols.length],
      side: i % 2 === 0 ? "buy" : "sell",
      type: "market",
      quantity: Math.floor(Math.random() * 100) + 1,
      filledQuantity: Math.floor(Math.random() * 100) + 1,
      avgFillPrice: 100 + Math.random() * 100,
      status: "filled",
      createdAt: new Date(Date.now() - i * 864e5),
      updatedAt: new Date(Date.now() - i * 864e5)
    });
  }
  return orders;
}
async function syncExchangeData(userId, connectionId) {
  const connection = await getConnectionById(userId, connectionId);
  if (!connection) {
    throw new Error("Connection not found");
  }
  const balances = await getExchangeBalances(connectionId);
  const positions = await getExchangePositions(connectionId);
  const orders = await getOrderHistory(connectionId, 20);
  connection.lastSyncAt = /* @__PURE__ */ new Date();
  connection.updatedAt = /* @__PURE__ */ new Date();
  return { balances, positions, orders };
}
function getOAuthUrl(exchange, redirectUri, state) {
  const info = EXCHANGE_INFO[exchange];
  if (info.authMethod !== "oauth" || !info.oauthUrl) {
    return null;
  }
  const params = new URLSearchParams({
    client_id: `tradoverse_${exchange}`,
    // Would be actual client ID in production
    redirect_uri: redirectUri,
    response_type: "code",
    state,
    scope: "read,trade"
  });
  return `${info.oauthUrl}?${params.toString()}`;
}
async function handleOAuthCallback(userId, exchange, code) {
  const id = `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const connection = {
    id,
    userId,
    exchange,
    status: "connected",
    permissions: getDefaultPermissions(exchange),
    lastSyncAt: /* @__PURE__ */ new Date(),
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  };
  const userConnections = connectionsStore.get(userId) || [];
  userConnections.push(connection);
  connectionsStore.set(userId, userConnections);
  credentialsStore.set(id, {
    apiKey: `oauth_${code}`,
    apiSecret: `oauth_secret_${Date.now()}`
  });
  return connection;
}
async function testConnection(connectionId) {
  const credentials = credentialsStore.get(connectionId);
  if (!credentials) {
    return { healthy: false, latency: 0, error: "Connection not found" };
  }
  const startTime = Date.now();
  await new Promise((resolve) => setTimeout(resolve, 50 + Math.random() * 100));
  const latency = Date.now() - startTime;
  return {
    healthy: true,
    latency
  };
}

// server/routers.ts
init_types();
init_BrokerService();
init_AlpacaAdapter();
init_IBKRAdapter();
init_BrokerFactory();
init_dataApi();

// server/services/marketData.ts
init_dataApi();
init_websocket();
var CACHE_CONFIG = {
  ttl: 3e4,
  // 30 seconds - data is fresh
  staleTtl: 12e4,
  // 2 minutes - data is stale but usable
  maxAge: 3e5,
  // 5 minutes - data expires completely
  minFetchInterval: 15e3
  // 15 seconds minimum between fetches per symbol
};
var RATE_LIMIT_CONFIG = {
  maxRequestsPerMinute: 30,
  // Max API requests per minute
  burstLimit: 5,
  // Max concurrent requests
  cooldownPeriod: 6e4,
  // Cooldown after hitting rate limit
  backoffMultiplier: 2
  // Exponential backoff multiplier
};
var priceCache2 = /* @__PURE__ */ new Map();
var pendingFetches = /* @__PURE__ */ new Map();
var requestCount = 0;
var lastRequestReset = Date.now();
var rateLimitCooldown = false;
var cooldownEndTime = 0;
var consecutiveErrors = 0;
var currentBackoff = RATE_LIMIT_CONFIG.cooldownPeriod;
var marketDataInterval = null;
var isRunning = false;
var FETCH_INTERVAL = 3e4;
function checkRateLimit() {
  const now = Date.now();
  if (rateLimitCooldown && now < cooldownEndTime) {
    return false;
  }
  if (rateLimitCooldown && now >= cooldownEndTime) {
    rateLimitCooldown = false;
    consecutiveErrors = 0;
    currentBackoff = RATE_LIMIT_CONFIG.cooldownPeriod;
    console.log("[MarketData] Rate limit cooldown ended, resuming requests");
  }
  if (now - lastRequestReset >= 6e4) {
    requestCount = 0;
    lastRequestReset = now;
  }
  return requestCount < RATE_LIMIT_CONFIG.maxRequestsPerMinute;
}
function handleRateLimitError() {
  consecutiveErrors++;
  currentBackoff = Math.min(
    currentBackoff * RATE_LIMIT_CONFIG.backoffMultiplier,
    3e5
    // Max 5 minutes backoff
  );
  rateLimitCooldown = true;
  cooldownEndTime = Date.now() + currentBackoff;
  console.log(`[MarketData] Rate limit hit, backing off for ${currentBackoff / 1e3}s (consecutive errors: ${consecutiveErrors})`);
  FETCH_INTERVAL = Math.min(FETCH_INTERVAL * 1.5, 12e4);
  console.log(`[MarketData] Adjusted fetch interval to ${FETCH_INTERVAL / 1e3}s`);
}
function handleSuccessfulRequest() {
  if (consecutiveErrors > 0) {
    consecutiveErrors = Math.max(0, consecutiveErrors - 1);
    FETCH_INTERVAL = Math.max(FETCH_INTERVAL * 0.9, 3e4);
  }
}
function getCacheStatus2(symbol) {
  const cached = priceCache2.get(symbol.toUpperCase());
  if (!cached) return "missing";
  const age = Date.now() - cached.timestamp;
  if (age < CACHE_CONFIG.ttl) return "fresh";
  if (age < CACHE_CONFIG.staleTtl) return "stale";
  if (age < CACHE_CONFIG.maxAge) return "expired";
  return "missing";
}
function shouldFetch(symbol) {
  const upperSymbol = symbol.toUpperCase();
  const cached = priceCache2.get(upperSymbol);
  if (!cached) return true;
  const timeSinceLastFetch = Date.now() - cached.lastFetchAttempt;
  if (timeSinceLastFetch < CACHE_CONFIG.minFetchInterval) {
    return false;
  }
  const status = getCacheStatus2(symbol);
  return status !== "fresh";
}
async function fetchStockPrice(symbol) {
  const upperSymbol = symbol.toUpperCase();
  if (!checkRateLimit()) {
    const cached = priceCache2.get(upperSymbol);
    if (cached) {
      console.log(`[MarketData] Rate limited, returning cached data for ${upperSymbol}`);
      return cached.data;
    }
    return null;
  }
  const pendingFetch = pendingFetches.get(upperSymbol);
  if (pendingFetch) {
    return pendingFetch;
  }
  if (!shouldFetch(upperSymbol)) {
    const cached = priceCache2.get(upperSymbol);
    if (cached) {
      return cached.data;
    }
  }
  const fetchPromise = (async () => {
    try {
      requestCount++;
      const response = await callDataApi("YahooFinance/get_stock_chart", {
        query: {
          symbol: upperSymbol,
          region: "US",
          interval: "1d",
          range: "1d"
        }
      });
      if (!response?.chart?.result?.[0]) {
        console.log(`[MarketData] No data for ${upperSymbol}`);
        return priceCache2.get(upperSymbol)?.data || null;
      }
      const result = response.chart.result[0];
      const meta = result.meta;
      const currentPrice = meta.regularMarketPrice || 0;
      const previousClose = meta.previousClose || meta.chartPreviousClose || currentPrice;
      const change = currentPrice - previousClose;
      const changePercent = previousClose > 0 ? change / previousClose * 100 : 0;
      const priceUpdate = {
        symbol: upperSymbol,
        price: Math.round(currentPrice * 100) / 100,
        change: Math.round(change * 100) / 100,
        changePercent: Math.round(changePercent * 100) / 100,
        volume: meta.regularMarketVolume || 0,
        timestamp: Date.now()
      };
      const existingCache = priceCache2.get(upperSymbol);
      priceCache2.set(upperSymbol, {
        data: priceUpdate,
        timestamp: Date.now(),
        fetchCount: (existingCache?.fetchCount || 0) + 1,
        lastFetchAttempt: Date.now()
      });
      handleSuccessfulRequest();
      return priceUpdate;
    } catch (error) {
      if (error?.message?.includes("429") || error?.message?.includes("rate limit")) {
        handleRateLimitError();
      }
      console.error(`[MarketData] Error fetching ${upperSymbol}:`, error);
      const cached = priceCache2.get(upperSymbol);
      if (cached) {
        cached.lastFetchAttempt = Date.now();
        return cached.data;
      }
      return null;
    } finally {
      pendingFetches.delete(upperSymbol);
    }
  })();
  pendingFetches.set(upperSymbol, fetchPromise);
  return fetchPromise;
}
async function fetchMultipleStockPrices(symbols) {
  const updates = [];
  const symbolsToFetch = [];
  for (const symbol of symbols) {
    const upperSymbol = symbol.toUpperCase();
    const status = getCacheStatus2(upperSymbol);
    if (status === "fresh") {
      const cached = priceCache2.get(upperSymbol);
      if (cached) {
        updates.push(cached.data);
      }
    } else if (status === "stale") {
      const cached = priceCache2.get(upperSymbol);
      if (cached) {
        updates.push(cached.data);
      }
      if (shouldFetch(upperSymbol)) {
        symbolsToFetch.push(upperSymbol);
      }
    } else {
      if (shouldFetch(upperSymbol)) {
        symbolsToFetch.push(upperSymbol);
      }
    }
  }
  if (!checkRateLimit()) {
    console.log(`[MarketData] Rate limited, returning ${updates.length} cached prices`);
    return updates;
  }
  const batchSize = Math.min(RATE_LIMIT_CONFIG.burstLimit, 3);
  for (let i = 0; i < symbolsToFetch.length; i += batchSize) {
    if (!checkRateLimit()) {
      console.log(`[MarketData] Rate limit reached during batch fetch`);
      break;
    }
    const batch = symbolsToFetch.slice(i, i + batchSize);
    const results = await Promise.all(
      batch.map((symbol) => fetchStockPrice(symbol))
    );
    results.forEach((result, idx) => {
      if (result) {
        const existingIdx = updates.findIndex((u) => u.symbol === result.symbol);
        if (existingIdx >= 0) {
          updates[existingIdx] = result;
        } else {
          updates.push(result);
        }
      }
    });
    if (i + batchSize < symbolsToFetch.length) {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
    }
  }
  return updates;
}
function getCachedPrice(symbol) {
  const cached = priceCache2.get(symbol.toUpperCase());
  if (cached && Date.now() - cached.timestamp < CACHE_CONFIG.maxAge) {
    return cached.data;
  }
  return null;
}
function getAllCachedPrices() {
  const result = /* @__PURE__ */ new Map();
  const now = Date.now();
  priceCache2.forEach((cached, symbol) => {
    if (now - cached.timestamp < CACHE_CONFIG.maxAge) {
      result.set(symbol, cached.data);
    }
  });
  return result;
}
function getCacheStats() {
  let freshCount = 0;
  let staleCount = 0;
  let expiredCount = 0;
  priceCache2.forEach((_, symbol) => {
    const status = getCacheStatus2(symbol);
    if (status === "fresh") freshCount++;
    else if (status === "stale") staleCount++;
    else if (status === "expired") expiredCount++;
  });
  return {
    totalCached: priceCache2.size,
    freshCount,
    staleCount,
    expiredCount,
    rateLimited: rateLimitCooldown,
    cooldownRemaining: Math.max(0, cooldownEndTime - Date.now()),
    fetchInterval: FETCH_INTERVAL,
    requestsThisMinute: requestCount
  };
}
function startMarketDataService() {
  if (isRunning) {
    console.log("[MarketData] Service already running");
    return;
  }
  isRunning = true;
  console.log("[MarketData] Starting real-time market data service with enhanced caching");
  const defaultSymbols = ["AAPL", "GOOGL", "MSFT", "TSLA", "AMZN", "NVDA", "META"];
  setTimeout(async () => {
    const updates = await fetchMultipleStockPrices(defaultSymbols);
    if (updates.length > 0) {
      broadcastPriceUpdates(updates);
      console.log(`[MarketData] Initial fetch: ${updates.length} symbols`);
    }
  }, 2e3);
  const runUpdateCycle = async () => {
    const activeSymbols = getActiveSymbolSubscriptions();
    if (activeSymbols.length === 0) {
      return;
    }
    const stats = getCacheStats();
    if (stats.rateLimited) {
      console.log(`[MarketData] Rate limited, cooldown: ${Math.round(stats.cooldownRemaining / 1e3)}s`);
    }
    try {
      const updates = await fetchMultipleStockPrices(activeSymbols);
      if (updates.length > 0) {
        broadcastPriceUpdates(updates);
      }
    } catch (error) {
      console.error("[MarketData] Error in update cycle:", error);
    }
    marketDataInterval = setTimeout(runUpdateCycle, FETCH_INTERVAL);
  };
  marketDataInterval = setTimeout(runUpdateCycle, FETCH_INTERVAL);
}
async function getStockQuote(symbol) {
  const upperSymbol = symbol.toUpperCase();
  if (!checkRateLimit()) {
    const cached = priceCache2.get(upperSymbol);
    if (cached) {
      return {
        symbol: upperSymbol,
        name: upperSymbol,
        price: cached.data.price,
        change: cached.data.change,
        changePercent: cached.data.changePercent,
        volume: cached.data.volume,
        marketCap: 0,
        high52Week: 0,
        low52Week: 0,
        dayHigh: 0,
        dayLow: 0,
        exchange: "",
        currency: "USD",
        cached: true,
        cacheAge: Date.now() - cached.timestamp
      };
    }
    return null;
  }
  try {
    requestCount++;
    const response = await callDataApi("YahooFinance/get_stock_chart", {
      query: {
        symbol: upperSymbol,
        region: "US",
        interval: "1d",
        range: "1d"
      }
    });
    if (!response?.chart?.result?.[0]) {
      return null;
    }
    const meta = response.chart.result[0].meta;
    const currentPrice = meta.regularMarketPrice || 0;
    const previousClose = meta.previousClose || meta.chartPreviousClose || currentPrice;
    const change = currentPrice - previousClose;
    const changePercent = previousClose > 0 ? change / previousClose * 100 : 0;
    const priceUpdate = {
      symbol: upperSymbol,
      price: Math.round(currentPrice * 100) / 100,
      change: Math.round(change * 100) / 100,
      changePercent: Math.round(changePercent * 100) / 100,
      volume: meta.regularMarketVolume || 0,
      timestamp: Date.now()
    };
    const existingCache = priceCache2.get(upperSymbol);
    priceCache2.set(upperSymbol, {
      data: priceUpdate,
      timestamp: Date.now(),
      fetchCount: (existingCache?.fetchCount || 0) + 1,
      lastFetchAttempt: Date.now()
    });
    handleSuccessfulRequest();
    return {
      symbol: upperSymbol,
      name: meta.longName || meta.shortName || symbol,
      price: currentPrice,
      change: Math.round(change * 100) / 100,
      changePercent: Math.round(changePercent * 100) / 100,
      volume: meta.regularMarketVolume || 0,
      marketCap: meta.marketCap || 0,
      high52Week: meta.fiftyTwoWeekHigh || 0,
      low52Week: meta.fiftyTwoWeekLow || 0,
      dayHigh: meta.regularMarketDayHigh || 0,
      dayLow: meta.regularMarketDayLow || 0,
      exchange: meta.exchangeName || "",
      currency: meta.currency || "USD",
      cached: false,
      cacheAge: 0
    };
  } catch (error) {
    if (error?.message?.includes("429") || error?.message?.includes("rate limit")) {
      handleRateLimitError();
    }
    console.error(`[MarketData] Error fetching quote for ${symbol}:`, error);
    const cached = priceCache2.get(upperSymbol);
    if (cached) {
      return {
        symbol: upperSymbol,
        name: upperSymbol,
        price: cached.data.price,
        change: cached.data.change,
        changePercent: cached.data.changePercent,
        volume: cached.data.volume,
        marketCap: 0,
        high52Week: 0,
        low52Week: 0,
        dayHigh: 0,
        dayLow: 0,
        exchange: "",
        currency: "USD",
        cached: true,
        cacheAge: Date.now() - cached.timestamp
      };
    }
    return null;
  }
}
async function searchStocks(query) {
  const popularStocks = [
    { symbol: "AAPL", name: "Apple Inc.", exchange: "NASDAQ", type: "Equity" },
    { symbol: "GOOGL", name: "Alphabet Inc.", exchange: "NASDAQ", type: "Equity" },
    { symbol: "MSFT", name: "Microsoft Corporation", exchange: "NASDAQ", type: "Equity" },
    { symbol: "AMZN", name: "Amazon.com Inc.", exchange: "NASDAQ", type: "Equity" },
    { symbol: "TSLA", name: "Tesla Inc.", exchange: "NASDAQ", type: "Equity" },
    { symbol: "META", name: "Meta Platforms Inc.", exchange: "NASDAQ", type: "Equity" },
    { symbol: "NVDA", name: "NVIDIA Corporation", exchange: "NASDAQ", type: "Equity" },
    { symbol: "JPM", name: "JPMorgan Chase & Co.", exchange: "NYSE", type: "Equity" },
    { symbol: "V", name: "Visa Inc.", exchange: "NYSE", type: "Equity" },
    { symbol: "JNJ", name: "Johnson & Johnson", exchange: "NYSE", type: "Equity" },
    { symbol: "WMT", name: "Walmart Inc.", exchange: "NYSE", type: "Equity" },
    { symbol: "PG", name: "Procter & Gamble Co.", exchange: "NYSE", type: "Equity" },
    { symbol: "MA", name: "Mastercard Inc.", exchange: "NYSE", type: "Equity" },
    { symbol: "HD", name: "Home Depot Inc.", exchange: "NYSE", type: "Equity" },
    { symbol: "DIS", name: "Walt Disney Co.", exchange: "NYSE", type: "Equity" },
    { symbol: "NFLX", name: "Netflix Inc.", exchange: "NASDAQ", type: "Equity" },
    { symbol: "PYPL", name: "PayPal Holdings Inc.", exchange: "NASDAQ", type: "Equity" },
    { symbol: "INTC", name: "Intel Corporation", exchange: "NASDAQ", type: "Equity" },
    { symbol: "AMD", name: "Advanced Micro Devices Inc.", exchange: "NASDAQ", type: "Equity" },
    { symbol: "CRM", name: "Salesforce Inc.", exchange: "NYSE", type: "Equity" }
  ];
  const lowerQuery = query.toLowerCase();
  return popularStocks.filter(
    (stock) => stock.symbol.toLowerCase().includes(lowerQuery) || stock.name.toLowerCase().includes(lowerQuery)
  );
}

// server/services/twilioEmail.ts
init_db();
init_schema();
import { eq as eq7, and as and7 } from "drizzle-orm";
var SENDGRID_API_URL = "https://api.sendgrid.com/v3/mail/send";
async function getUserEmailPreferences(userId) {
  const db = await getDb();
  if (!db) return null;
  const [prefs] = await db.select().from(userEmailPreferences).where(eq7(userEmailPreferences.userId, userId)).limit(1);
  if (!prefs) return null;
  return {
    userId: prefs.userId,
    botExecutionComplete: prefs.botExecutionComplete,
    botExecutionError: prefs.botExecutionError,
    priceTargetAlert: prefs.priceTargetAlert,
    recommendationChange: prefs.recommendationChange,
    weeklyReport: prefs.weeklyReport,
    monthlyReport: prefs.monthlyReport,
    marketingEmails: prefs.marketingEmails,
    digestFrequency: prefs.digestFrequency,
    quietHoursStart: prefs.quietHoursStart ?? void 0,
    quietHoursEnd: prefs.quietHoursEnd ?? void 0,
    timezone: prefs.timezone,
    isUnsubscribed: prefs.isUnsubscribed
  };
}
async function updateUserEmailPreferences(userId, preferences) {
  const db = await getDb();
  if (!db) throw new Error("Database not available");
  const existing = await getUserEmailPreferences(userId);
  if (existing) {
    await db.update(userEmailPreferences).set({
      botExecutionComplete: preferences.botExecutionComplete,
      botExecutionError: preferences.botExecutionError,
      priceTargetAlert: preferences.priceTargetAlert,
      recommendationChange: preferences.recommendationChange,
      weeklyReport: preferences.weeklyReport,
      monthlyReport: preferences.monthlyReport,
      marketingEmails: preferences.marketingEmails,
      digestFrequency: preferences.digestFrequency,
      quietHoursStart: preferences.quietHoursStart,
      quietHoursEnd: preferences.quietHoursEnd,
      timezone: preferences.timezone,
      isUnsubscribed: preferences.isUnsubscribed
    }).where(eq7(userEmailPreferences.userId, userId));
  } else {
    await db.insert(userEmailPreferences).values({
      userId,
      botExecutionComplete: preferences.botExecutionComplete ?? true,
      botExecutionError: preferences.botExecutionError ?? true,
      priceTargetAlert: preferences.priceTargetAlert ?? true,
      recommendationChange: preferences.recommendationChange ?? true,
      weeklyReport: preferences.weeklyReport ?? true,
      monthlyReport: preferences.monthlyReport ?? true,
      marketingEmails: preferences.marketingEmails ?? false,
      digestFrequency: preferences.digestFrequency ?? "immediate",
      quietHoursStart: preferences.quietHoursStart,
      quietHoursEnd: preferences.quietHoursEnd,
      timezone: preferences.timezone ?? "UTC",
      isUnsubscribed: preferences.isUnsubscribed ?? false
    });
  }
  return await getUserEmailPreferences(userId);
}
async function testSendGridApiKey(apiKey, testEmail) {
  try {
    const response = await fetch("https://api.sendgrid.com/v3/scopes", {
      method: "GET",
      headers: {
        "Authorization": `Bearer ${apiKey}`
      }
    });
    if (!response.ok) {
      if (response.status === 401) {
        return { success: false, error: "Invalid API key" };
      }
      return { success: false, error: `API error: ${response.status}` };
    }
    if (testEmail) {
      const emailResponse = await fetch(SENDGRID_API_URL, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          personalizations: [{ to: [{ email: testEmail }] }],
          from: { email: "noreply@tradoverse.com", name: "TradoVerse" },
          subject: "TradoVerse - Email Configuration Test",
          content: [{
            type: "text/html",
            value: `
              <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                <h2 style="color: #10b981;">Email Configuration Successful!</h2>
                <p>This is a test email from TradoVerse to verify your SendGrid configuration.</p>
                <p>If you received this email, your email settings are working correctly.</p>
                <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 20px 0;" />
                <p style="color: #6b7280; font-size: 12px;">This is an automated test email from TradoVerse.</p>
              </div>
            `
          }]
        })
      });
      if (!emailResponse.ok) {
        const errorText = await emailResponse.text();
        return { success: false, error: `Failed to send test email: ${errorText}` };
      }
    }
    return { success: true };
  } catch (error) {
    return { success: false, error: error instanceof Error ? error.message : "Connection error" };
  }
}

// server/stripe/checkout.ts
import Stripe from "stripe";

// server/stripe/products.ts
var SUBSCRIPTION_TIERS = {
  free: {
    id: "free",
    name: "Free",
    description: "Perfect for learning and paper trading",
    price: 0,
    priceId: null,
    // Free tier doesn't need a Stripe price
    features: {
      maxBots: 1,
      maxAccounts: 1,
      aiAgents: 2,
      backtestMonths: 3,
      liveTradingEnabled: false,
      apiAccessEnabled: false,
      prioritySupport: false
    },
    featureList: [
      "Paper trading only",
      "2 AI agents",
      "1 trading bot",
      "1 trading account",
      "3-month backtest history"
    ]
  },
  starter: {
    id: "starter",
    name: "Starter",
    description: "For serious traders getting started",
    price: 29,
    priceId: process.env.STRIPE_STARTER_PRICE_ID || null,
    features: {
      maxBots: 3,
      maxAccounts: 2,
      aiAgents: 4,
      backtestMonths: 12,
      liveTradingEnabled: true,
      apiAccessEnabled: false,
      prioritySupport: false
    },
    featureList: [
      "Paper & live trading",
      "4 AI agents",
      "3 trading bots",
      "2 trading accounts",
      "1-year backtest history"
    ]
  },
  pro: {
    id: "pro",
    name: "Pro",
    description: "Full power for active traders",
    price: 79,
    priceId: process.env.STRIPE_PRO_PRICE_ID || null,
    features: {
      maxBots: 10,
      maxAccounts: 5,
      aiAgents: 7,
      backtestMonths: 60,
      liveTradingEnabled: true,
      apiAccessEnabled: true,
      prioritySupport: false
    },
    featureList: [
      "Paper & live trading",
      "All 7 AI agents",
      "10 trading bots",
      "5 trading accounts",
      "5-year backtest history",
      "API access"
    ]
  },
  elite: {
    id: "elite",
    name: "Elite",
    description: "Maximum power for professionals",
    price: 199,
    priceId: process.env.STRIPE_ELITE_PRICE_ID || null,
    features: {
      maxBots: -1,
      // Unlimited
      maxAccounts: -1,
      // Unlimited
      aiAgents: 7,
      backtestMonths: -1,
      // Full history (2010+)
      liveTradingEnabled: true,
      apiAccessEnabled: true,
      prioritySupport: true
    },
    featureList: [
      "Paper & live trading",
      "All 7 AI agents",
      "Unlimited trading bots",
      "Unlimited accounts",
      "Full backtest history (2010+)",
      "API access",
      "Priority support"
    ]
  }
};

// server/stripe/checkout.ts
var stripe = new Stripe(process.env.STRIPE_SECRET_KEY || "");
async function createCheckoutSession({
  userId,
  userEmail,
  userName,
  tier,
  origin
}) {
  const tierConfig = SUBSCRIPTION_TIERS[tier];
  if (tier === "free") {
    throw new Error("Cannot create checkout session for free tier");
  }
  const priceId = tierConfig.priceId;
  if (!priceId) {
    const product = await stripe.products.create({
      name: `TradoVerse ${tierConfig.name}`,
      description: tierConfig.description
    });
    const price = await stripe.prices.create({
      product: product.id,
      unit_amount: tierConfig.price * 100,
      // Convert to cents
      currency: "usd",
      recurring: {
        interval: "month"
      }
    });
    const session2 = await stripe.checkout.sessions.create({
      mode: "subscription",
      payment_method_types: ["card"],
      line_items: [
        {
          price: price.id,
          quantity: 1
        }
      ],
      customer_email: userEmail,
      client_reference_id: userId.toString(),
      metadata: {
        user_id: userId.toString(),
        customer_email: userEmail,
        customer_name: userName,
        tier
      },
      allow_promotion_codes: true,
      success_url: `${origin}/dashboard?subscription=success&tier=${tier}`,
      cancel_url: `${origin}/pricing?subscription=canceled`
    });
    return { url: session2.url };
  }
  const session = await stripe.checkout.sessions.create({
    mode: "subscription",
    payment_method_types: ["card"],
    line_items: [
      {
        price: priceId,
        quantity: 1
      }
    ],
    customer_email: userEmail,
    client_reference_id: userId.toString(),
    metadata: {
      user_id: userId.toString(),
      customer_email: userEmail,
      customer_name: userName,
      tier
    },
    allow_promotion_codes: true,
    success_url: `${origin}/dashboard?subscription=success&tier=${tier}`,
    cancel_url: `${origin}/pricing?subscription=canceled`
  });
  return { url: session.url };
}

// server/routers.ts
var adminProcedure2 = protectedProcedure.use(({ ctx, next }) => {
  if (ctx.user.role !== "admin") {
    throw new TRPCError3({ code: "FORBIDDEN", message: "Admin access required" });
  }
  return next({ ctx });
});
function checkTierAccess(userTier, requiredTier) {
  const tierOrder = ["free", "starter", "pro", "elite"];
  return tierOrder.indexOf(userTier) >= tierOrder.indexOf(requiredTier);
}
var appRouter = router({
  system: systemRouter,
  // ==================== AUTH ROUTES ====================
  auth: router({
    me: publicProcedure.query((opts) => opts.ctx.user),
    logout: publicProcedure.mutation(({ ctx }) => {
      const cookieOptions = getSessionCookieOptions(ctx.req);
      ctx.res.clearCookie(COOKIE_NAME, { ...cookieOptions, maxAge: -1 });
      return { success: true };
    })
  }),
  // ==================== USER ROUTES ====================
  user: router({
    getProfile: protectedProcedure.query(async ({ ctx }) => {
      return ctx.user;
    }),
    getTierLimits: protectedProcedure.query(async ({ ctx }) => {
      return getTierLimits(ctx.user.subscriptionTier);
    }),
    // Email Preferences
    getEmailPreferences: protectedProcedure.query(async ({ ctx }) => {
      const prefs = await getUserEmailPreferences(ctx.user.id);
      return prefs || {
        userId: ctx.user.id,
        botExecutionComplete: true,
        botExecutionError: true,
        priceTargetAlert: true,
        recommendationChange: true,
        weeklyReport: true,
        monthlyReport: true,
        marketingEmails: false,
        digestFrequency: "immediate",
        timezone: "UTC",
        isUnsubscribed: false
      };
    }),
    updateEmailPreferences: protectedProcedure.input(z2.object({
      botExecutionComplete: z2.boolean().optional(),
      botExecutionError: z2.boolean().optional(),
      priceTargetAlert: z2.boolean().optional(),
      recommendationChange: z2.boolean().optional(),
      weeklyReport: z2.boolean().optional(),
      monthlyReport: z2.boolean().optional(),
      marketingEmails: z2.boolean().optional(),
      digestFrequency: z2.enum(["immediate", "hourly", "daily", "weekly"]).optional(),
      quietHoursStart: z2.string().optional(),
      quietHoursEnd: z2.string().optional(),
      timezone: z2.string().optional(),
      isUnsubscribed: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      return updateUserEmailPreferences(ctx.user.id, input);
    }),
    testEmailConnection: protectedProcedure.input(z2.object({ apiKey: z2.string() })).mutation(async ({ input }) => {
      return testSendGridApiKey(input.apiKey);
    }),
    // Email Verification
    getVerificationStatus: protectedProcedure.query(async ({ ctx }) => {
      const verification = await getEmailVerificationByUserId(ctx.user.id);
      return {
        isVerified: ctx.user.isEmailVerified || false,
        email: ctx.user.email,
        verifiedAt: ctx.user.emailVerifiedAt,
        hasPendingVerification: verification && !verification.isVerified && new Date(verification.expiresAt) > /* @__PURE__ */ new Date(),
        canResend: !verification || (verification.resendCount || 0) < 5
      };
    }),
    sendVerificationEmail: protectedProcedure.input(z2.object({ email: z2.string().email() })).mutation(async ({ ctx, input }) => {
      if (ctx.user.isEmailVerified) {
        return { success: false, error: "Email already verified" };
      }
      const canSend = await canSendEmail();
      if (!canSend.allowed) {
        return { success: false, error: canSend.reason };
      }
      const existing = await getEmailVerificationByUserId(ctx.user.id);
      if (existing && (existing.resendCount || 0) >= 5) {
        return { success: false, error: "Too many verification emails sent. Please contact support." };
      }
      const token = crypto.randomUUID().replace(/-/g, "");
      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1e3);
      await createEmailVerification({
        userId: ctx.user.id,
        email: input.email,
        token,
        expiresAt
      });
      const config = await getEmailConfig();
      if (!config?.sendgridApiKey) {
        return { success: false, error: "Email service not configured" };
      }
      try {
        const verifyUrl = `${process.env.VITE_OAUTH_PORTAL_URL || ""}/verify-email?token=${token}`;
        const response = await fetch("https://api.sendgrid.com/v3/mail/send", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${config.sendgridApiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            personalizations: [{ to: [{ email: config.testMode ? config.testEmail : input.email }] }],
            from: { email: config.senderEmail || "noreply@tradoverse.com", name: config.senderName || "TradoVerse" },
            subject: "Verify your email - TradoVerse",
            content: [{
              type: "text/html",
              value: `
                  <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2 style="color: #10b981;">Verify Your Email</h2>
                    <p>Hi ${ctx.user.name || "there"},</p>
                    <p>Please verify your email address to enable notifications and unlock all features.</p>
                    <p style="margin: 30px 0;">
                      <a href="${verifyUrl}" style="background-color: #10b981; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">Verify Email</a>
                    </p>
                    <p>Or copy and paste this link in your browser:</p>
                    <p style="color: #6b7280; word-break: break-all;">${verifyUrl}</p>
                    <p>This link expires in 24 hours.</p>
                    <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 20px 0;" />
                    <p style="color: #6b7280; font-size: 12px;">If you didn't request this, please ignore this email.</p>
                  </div>
                `
            }]
          })
        });
        if (!response.ok) {
          return { success: false, error: "Failed to send verification email" };
        }
        await incrementEmailsSentToday();
        return { success: true };
      } catch (error) {
        return { success: false, error: error instanceof Error ? error.message : "Failed to send email" };
      }
    }),
    verifyEmail: publicProcedure.input(z2.object({ token: z2.string() })).mutation(async ({ input }) => {
      const verification = await getEmailVerificationByToken(input.token);
      if (!verification) {
        return { success: false, error: "Invalid verification token" };
      }
      if (verification.isVerified) {
        return { success: true, message: "Email already verified" };
      }
      if (new Date(verification.expiresAt) < /* @__PURE__ */ new Date()) {
        return { success: false, error: "Verification link has expired" };
      }
      const success = await markEmailVerified(input.token);
      if (!success) {
        return { success: false, error: "Failed to verify email" };
      }
      const dbInstance = await getDb();
      if (dbInstance) {
        const { users: users3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
        const { eq: eq18 } = await import("drizzle-orm");
        await dbInstance.update(users3).set({
          isEmailVerified: true,
          emailVerifiedAt: /* @__PURE__ */ new Date(),
          email: verification.email
        }).where(eq18(users3.id, verification.userId));
      }
      return { success: true, message: "Email verified successfully" };
    }),
    resendVerification: protectedProcedure.mutation(async ({ ctx }) => {
      const verification = await getEmailVerificationByUserId(ctx.user.id);
      if (!verification) {
        return { success: false, error: "No pending verification found" };
      }
      if (verification.isVerified) {
        return { success: false, error: "Email already verified" };
      }
      if ((verification.resendCount || 0) >= 5) {
        return { success: false, error: "Too many resend attempts" };
      }
      await incrementResendCount(ctx.user.id);
      const config = await getEmailConfig();
      if (!config?.sendgridApiKey) {
        return { success: false, error: "Email service not configured" };
      }
      try {
        const verifyUrl = `${process.env.VITE_OAUTH_PORTAL_URL || ""}/verify-email?token=${verification.token}`;
        const response = await fetch("https://api.sendgrid.com/v3/mail/send", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${config.sendgridApiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            personalizations: [{ to: [{ email: config.testMode ? config.testEmail : verification.email }] }],
            from: { email: config.senderEmail || "noreply@tradoverse.com", name: config.senderName || "TradoVerse" },
            subject: "Verify your email - TradoVerse",
            content: [{
              type: "text/html",
              value: `
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                  <h2 style="color: #10b981;">Verify Your Email</h2>
                  <p>Hi ${ctx.user.name || "there"},</p>
                  <p>Here's your verification link again:</p>
                  <p style="margin: 30px 0;">
                    <a href="${verifyUrl}" style="background-color: #10b981; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">Verify Email</a>
                  </p>
                  <p>This link expires in 24 hours.</p>
                  <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 20px 0;" />
                  <p style="color: #6b7280; font-size: 12px;">If you didn't request this, please ignore this email.</p>
                </div>
              `
            }]
          })
        });
        if (!response.ok) {
          return { success: false, error: "Failed to send verification email" };
        }
        await incrementEmailsSentToday();
        return { success: true };
      } catch (error) {
        return { success: false, error: error instanceof Error ? error.message : "Failed to send email" };
      }
    })
  }),
  // ==================== TRADING ACCOUNT ROUTES ====================
  account: router({
    list: protectedProcedure.query(async ({ ctx }) => {
      return getUserTradingAccounts(ctx.user.id);
    }),
    get: protectedProcedure.input(z2.object({ id: z2.number() })).query(async ({ ctx, input }) => {
      const account = await getTradingAccountById(input.id, ctx.user.id);
      if (!account) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Account not found" });
      }
      return account;
    }),
    create: protectedProcedure.input(z2.object({
      name: z2.string().min(1).max(255),
      type: z2.enum(["paper", "live"]),
      initialBalance: z2.number().min(0).default(1e5)
    })).mutation(async ({ ctx, input }) => {
      const limit = await checkTierLimit(ctx.user.id, "maxAccounts");
      if (!limit.allowed) {
        throw new TRPCError3({
          code: "FORBIDDEN",
          message: `Account limit reached (${limit.current}/${limit.limit}). Upgrade your plan for more accounts.`
        });
      }
      if (input.type === "live") {
        const tierLimits = getTierLimits(ctx.user.subscriptionTier);
        if (!tierLimits.liveTrading) {
          throw new TRPCError3({
            code: "FORBIDDEN",
            message: "Live trading requires Starter plan or higher"
          });
        }
      }
      const id = await createTradingAccount({
        userId: ctx.user.id,
        name: input.name,
        type: input.type,
        balance: input.initialBalance.toString(),
        initialBalance: input.initialBalance.toString()
      });
      return { id, success: true };
    })
  }),
  // ==================== TRADING BOT ROUTES ====================
  bot: router({
    list: protectedProcedure.query(async ({ ctx }) => {
      return getUserTradingBots(ctx.user.id);
    }),
    get: protectedProcedure.input(z2.object({ id: z2.number() })).query(async ({ ctx, input }) => {
      const bot = await getTradingBotById(input.id, ctx.user.id);
      if (!bot) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Bot not found" });
      }
      return bot;
    }),
    create: protectedProcedure.input(z2.object({
      accountId: z2.number(),
      name: z2.string().min(1).max(255),
      description: z2.string().optional(),
      strategy: z2.object({
        type: z2.enum(["momentum", "mean_reversion", "trend_following", "custom"]),
        parameters: z2.record(z2.string(), z2.union([z2.number(), z2.string(), z2.boolean()])),
        entryConditions: z2.array(z2.string()),
        exitConditions: z2.array(z2.string()),
        positionSizing: z2.enum(["fixed", "percent", "kelly"]),
        maxPositionSize: z2.number(),
        stopLoss: z2.number().optional(),
        takeProfit: z2.number().optional()
      }),
      symbols: z2.array(z2.string()),
      riskSettings: z2.object({
        maxDrawdown: z2.number(),
        maxPositionSize: z2.number(),
        maxDailyLoss: z2.number()
      })
    })).mutation(async ({ ctx, input }) => {
      const limit = await checkTierLimit(ctx.user.id, "maxBots");
      if (!limit.allowed) {
        throw new TRPCError3({
          code: "FORBIDDEN",
          message: `Bot limit reached (${limit.current}/${limit.limit}). Upgrade your plan for more bots.`
        });
      }
      const account = await getTradingAccountById(input.accountId, ctx.user.id);
      if (!account) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Trading account not found" });
      }
      const id = await createTradingBot({
        userId: ctx.user.id,
        accountId: input.accountId,
        name: input.name,
        description: input.description,
        strategy: input.strategy,
        symbols: input.symbols,
        riskSettings: input.riskSettings
      });
      return { id, success: true };
    }),
    update: protectedProcedure.input(z2.object({
      id: z2.number(),
      name: z2.string().min(1).max(255).optional(),
      description: z2.string().optional(),
      status: z2.enum(["active", "paused", "stopped"]).optional(),
      strategy: z2.any().optional(),
      symbols: z2.array(z2.string()).optional(),
      riskSettings: z2.any().optional(),
      isPublic: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      const { id, ...data } = input;
      await updateTradingBot(id, ctx.user.id, data);
      return { success: true };
    }),
    getTrades: protectedProcedure.input(z2.object({ botId: z2.number(), limit: z2.number().default(100) })).query(async ({ ctx, input }) => {
      const bot = await getTradingBotById(input.botId, ctx.user.id);
      if (!bot) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Bot not found" });
      }
      return getBotTrades(input.botId, input.limit);
    })
  }),
  // ==================== AI AGENT ROUTES ====================
  agent: router({
    analyze: protectedProcedure.input(z2.object({ symbol: z2.string() })).mutation(async ({ ctx, input }) => {
      const result = await runAgentConsensus(
        ctx.user.id,
        input.symbol,
        ctx.user.subscriptionTier
      );
      await createAgentAnalysis({
        userId: ctx.user.id,
        symbol: input.symbol,
        technicalScore: result.agents.find((a) => a.agent === "technical")?.score.toString(),
        fundamentalScore: result.agents.find((a) => a.agent === "fundamental")?.score.toString(),
        sentimentScore: result.agents.find((a) => a.agent === "sentiment")?.score.toString(),
        riskScore: result.agents.find((a) => a.agent === "risk")?.score.toString(),
        microstructureScore: result.agents.find((a) => a.agent === "microstructure")?.score.toString(),
        macroScore: result.agents.find((a) => a.agent === "macro")?.score.toString(),
        quantScore: result.agents.find((a) => a.agent === "quant")?.score.toString(),
        consensusScore: result.consensusScore.toString(),
        consensusAction: result.consensusSignal,
        confidence: result.overallConfidence.toString(),
        analysisDetails: result
      });
      return result;
    }),
    getHistory: protectedProcedure.input(z2.object({ symbol: z2.string(), limit: z2.number().default(10) })).query(async ({ ctx, input }) => {
      return getAgentAnalysisHistory(input.symbol, ctx.user.id, input.limit);
    }),
    getAvailableAgents: protectedProcedure.query(async ({ ctx }) => {
      return getAvailableAgents(ctx.user.subscriptionTier);
    }),
    // Enhanced analysis history with filtering
    getFilteredHistory: protectedProcedure.input(z2.object({
      symbol: z2.string().optional(),
      consensusAction: z2.enum(["strong_buy", "buy", "hold", "sell", "strong_sell"]).optional(),
      startDate: z2.string().optional(),
      // ISO date string
      endDate: z2.string().optional(),
      minConfidence: z2.number().min(0).max(1).optional(),
      limit: z2.number().min(1).max(100).default(20),
      offset: z2.number().min(0).default(0)
    })).query(async ({ ctx, input }) => {
      const filters = {
        userId: ctx.user.id,
        symbol: input.symbol,
        consensusAction: input.consensusAction,
        startDate: input.startDate ? new Date(input.startDate) : void 0,
        endDate: input.endDate ? new Date(input.endDate) : void 0,
        minConfidence: input.minConfidence,
        limit: input.limit,
        offset: input.offset
      };
      return getFilteredAnalysisHistory(filters);
    }),
    getById: protectedProcedure.input(z2.object({ id: z2.number() })).query(async ({ ctx, input }) => {
      const analysis = await getAnalysisById(input.id, ctx.user.id);
      if (!analysis) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Analysis not found" });
      }
      return analysis;
    }),
    getStats: protectedProcedure.query(async ({ ctx }) => {
      return getAnalysisStats(ctx.user.id);
    }),
    getUniqueSymbols: protectedProcedure.query(async ({ ctx }) => {
      return getUniqueSymbols(ctx.user.id);
    }),
    // Enhanced Analysis with research-backed strategies
    enhancedAnalysis: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      accountBalance: z2.number().optional().default(1e4)
    })).mutation(async ({ ctx, input }) => {
      if (!checkTierAccess(ctx.user.subscriptionTier, "starter")) {
        throw new TRPCError3({
          code: "FORBIDDEN",
          message: "Enhanced analysis requires Starter tier or higher"
        });
      }
      const result = await runEnhancedAnalysis(input.symbol, input.accountBalance);
      await createAgentAnalysis({
        userId: ctx.user.id,
        symbol: input.symbol,
        technicalScore: (result.agents.find((a) => a.agentType === "Technical Analysis")?.confidence ?? 0.5).toString(),
        fundamentalScore: (result.agents.find((a) => a.agentType === "Fundamental Analysis")?.confidence ?? 0.5).toString(),
        sentimentScore: (result.agents.find((a) => a.agentType === "Sentiment Analysis")?.confidence ?? 0.5).toString(),
        riskScore: (result.agents.find((a) => a.agentType === "Risk Management")?.confidence ?? 0.5).toString(),
        quantScore: (result.agents.find((a) => a.agentType === "Quantitative Analysis")?.confidence ?? 0.5).toString(),
        consensusScore: result.overallScore.toString(),
        consensusAction: result.consensusRecommendation,
        confidence: result.consensusConfidence.toString(),
        analysisDetails: result
      });
      return result;
    }),
    // Get market regime for a symbol
    getMarketRegime: protectedProcedure.input(z2.object({ symbol: z2.string() })).query(async ({ ctx, input }) => {
      const result = await runEnhancedAnalysis(input.symbol);
      return result.marketRegime;
    }),
    // Calculate position sizing
    calculatePositionSize: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      accountBalance: z2.number(),
      winRate: z2.number().min(0).max(1).optional().default(0.55),
      avgWinPercent: z2.number().optional().default(2),
      avgLossPercent: z2.number().optional().default(1),
      maxRiskPercent: z2.number().min(0.01).max(0.1).optional().default(0.02)
    })).query(async ({ ctx, input }) => {
      const { calculateKellyPosition: calculateKellyPosition2 } = await Promise.resolve().then(() => (init_enhancedAnalysis(), enhancedAnalysis_exports));
      return calculateKellyPosition2(
        input.winRate,
        input.avgWinPercent,
        input.avgLossPercent,
        input.accountBalance,
        input.maxRiskPercent
      );
    })
  }),
  // ==================== BACKTEST ROUTES ====================
  backtest: router({
    list: protectedProcedure.query(async ({ ctx }) => {
      return getUserBacktests(ctx.user.id);
    }),
    get: protectedProcedure.input(z2.object({ id: z2.number() })).query(async ({ ctx, input }) => {
      const backtest = await getBacktestById(input.id, ctx.user.id);
      if (!backtest) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Backtest not found" });
      }
      return backtest;
    }),
    run: protectedProcedure.input(z2.object({
      name: z2.string(),
      botId: z2.number().optional(),
      strategy: z2.object({
        type: z2.enum(["momentum", "mean_reversion", "trend_following", "custom"]),
        parameters: z2.record(z2.string(), z2.union([z2.number(), z2.string(), z2.boolean()])),
        entryConditions: z2.array(z2.string()),
        exitConditions: z2.array(z2.string()),
        positionSizing: z2.enum(["fixed", "percent", "kelly"]),
        maxPositionSize: z2.number(),
        stopLoss: z2.number().optional(),
        takeProfit: z2.number().optional()
      }),
      symbols: z2.array(z2.string()),
      startDate: z2.string(),
      endDate: z2.string(),
      initialCapital: z2.number().default(1e5)
    })).mutation(async ({ ctx, input }) => {
      const tierLimits = getTierLimits(ctx.user.subscriptionTier);
      const startDate = new Date(input.startDate);
      const endDate = new Date(input.endDate);
      const yearsBack = (Date.now() - startDate.getTime()) / (1e3 * 60 * 60 * 24 * 365);
      if (yearsBack > tierLimits.backtestYears) {
        throw new TRPCError3({
          code: "FORBIDDEN",
          message: `Your plan allows backtesting up to ${tierLimits.backtestYears} years. Upgrade for more historical data.`
        });
      }
      const backtestId = await createBacktest({
        userId: ctx.user.id,
        botId: input.botId,
        name: input.name,
        strategy: input.strategy,
        symbols: input.symbols,
        startDate,
        endDate,
        initialCapital: input.initialCapital.toString()
      });
      await updateBacktestResults(backtestId, { status: "running" });
      try {
        const config = {
          strategy: input.strategy,
          symbols: input.symbols,
          startDate,
          endDate,
          initialCapital: input.initialCapital,
          commission: 1e-3,
          // 0.1% commission
          slippage: 1e-3
          // 0.1% slippage
        };
        const result = await runBacktest(config);
        await updateBacktestResults(backtestId, {
          status: "completed",
          finalCapital: (input.initialCapital * (1 + result.metrics.totalReturn)).toString(),
          totalReturn: result.metrics.totalReturn.toString(),
          sharpeRatio: result.metrics.sharpeRatio.toString(),
          maxDrawdown: result.metrics.maxDrawdown.toString(),
          winRate: result.metrics.winRate.toString(),
          profitFactor: result.metrics.profitFactor.toString(),
          totalTrades: result.metrics.totalTrades,
          results: result,
          completedAt: /* @__PURE__ */ new Date()
        });
        return { id: backtestId, result };
      } catch (error) {
        await updateBacktestResults(backtestId, { status: "failed" });
        throw new TRPCError3({ code: "INTERNAL_SERVER_ERROR", message: "Backtest failed" });
      }
    })
  }),
  // ==================== MARKET DATA ROUTES ====================
  market: router({
    getChart: publicProcedure.input(z2.object({
      symbol: z2.string(),
      interval: z2.enum(["1m", "5m", "15m", "30m", "1h", "1d", "1wk", "1mo"]).default("1d"),
      range: z2.enum(["1d", "5d", "1mo", "3mo", "6mo", "1y", "2y", "5y", "10y", "max"]).default("3mo")
    })).query(async ({ input }) => {
      const response = await callDataApi("YahooFinance/get_stock_chart", {
        query: {
          symbol: input.symbol,
          region: "US",
          interval: input.interval,
          range: input.range,
          includeAdjustedClose: true
        }
      });
      return response;
    }),
    getInsights: protectedProcedure.input(z2.object({ symbol: z2.string() })).query(async ({ input }) => {
      const response = await callDataApi("YahooFinance/get_stock_insights", {
        query: { symbol: input.symbol }
      });
      return response;
    }),
    getHolders: protectedProcedure.input(z2.object({ symbol: z2.string() })).query(async ({ input }) => {
      const response = await callDataApi("YahooFinance/get_stock_holders", {
        query: { symbol: input.symbol, region: "US", lang: "en-US" }
      });
      return response;
    }),
    // Real-time price endpoints
    getQuote: publicProcedure.input(z2.object({ symbol: z2.string() })).query(async ({ input }) => {
      return getStockQuote(input.symbol);
    }),
    getLivePrice: publicProcedure.input(z2.object({ symbol: z2.string() })).query(async ({ input }) => {
      const cached = getCachedPrice(input.symbol);
      if (cached) return cached;
      return fetchStockPrice(input.symbol);
    }),
    getLivePrices: publicProcedure.input(z2.object({ symbols: z2.array(z2.string()) })).query(async ({ input }) => {
      const results = {};
      for (const symbol of input.symbols) {
        const cached = getCachedPrice(symbol);
        if (cached) {
          results[symbol] = cached;
        } else {
          const price = await fetchStockPrice(symbol);
          if (price) results[symbol] = price;
        }
      }
      return results;
    }),
    getCachedPrices: publicProcedure.query(async () => {
      const cached = getAllCachedPrices();
      const result = {};
      cached.forEach((value, key) => {
        result[key] = value;
      });
      return result;
    }),
    search: publicProcedure.input(z2.object({ query: z2.string() })).query(async ({ input }) => {
      return searchStocks(input.query);
    })
  }),
  // ==================== PORTFOLIO ROUTES ====================
  portfolio: router({
    getSnapshots: protectedProcedure.input(z2.object({ accountId: z2.number(), days: z2.number().default(30) })).query(async ({ ctx, input }) => {
      return getPortfolioSnapshots(input.accountId, ctx.user.id, input.days);
    }),
    getAnalytics: protectedProcedure.input(z2.object({ accountId: z2.number() })).query(async ({ ctx, input }) => {
      const account = await getTradingAccountById(input.accountId, ctx.user.id);
      if (!account) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Account not found" });
      }
      const trades2 = await getAccountTrades(input.accountId, ctx.user.id, 1e3);
      const snapshots = await getPortfolioSnapshots(input.accountId, ctx.user.id, 365);
      const winningTrades = trades2.filter((t2) => parseFloat(t2.pnl?.toString() || "0") > 0);
      const losingTrades = trades2.filter((t2) => parseFloat(t2.pnl?.toString() || "0") <= 0);
      const totalPnl = trades2.reduce((sum2, t2) => sum2 + parseFloat(t2.pnl?.toString() || "0"), 0);
      const winRate = trades2.length > 0 ? winningTrades.length / trades2.length : 0;
      const totalWins = winningTrades.reduce((sum2, t2) => sum2 + parseFloat(t2.pnl?.toString() || "0"), 0);
      const totalLosses = Math.abs(losingTrades.reduce((sum2, t2) => sum2 + parseFloat(t2.pnl?.toString() || "0"), 0));
      const profitFactor = totalLosses > 0 ? totalWins / totalLosses : totalWins > 0 ? Infinity : 0;
      let sharpeRatio = 0;
      if (snapshots.length > 1) {
        const returns = [];
        for (let i = 1; i < snapshots.length; i++) {
          const prevValue = parseFloat(snapshots[i - 1].totalValue.toString());
          const currValue = parseFloat(snapshots[i].totalValue.toString());
          returns.push((currValue - prevValue) / prevValue);
        }
        const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
        const stdReturn = Math.sqrt(returns.reduce((sum2, r) => sum2 + Math.pow(r - avgReturn, 2), 0) / returns.length);
        sharpeRatio = stdReturn > 0 ? avgReturn * 252 / (stdReturn * Math.sqrt(252)) : 0;
      }
      let maxDrawdown = 0;
      let peak = parseFloat(account.initialBalance.toString());
      for (const snapshot of snapshots) {
        const value = parseFloat(snapshot.totalValue.toString());
        if (value > peak) peak = value;
        const drawdown = (peak - value) / peak;
        if (drawdown > maxDrawdown) maxDrawdown = drawdown;
      }
      return {
        totalPnl,
        totalReturn: totalPnl / parseFloat(account.initialBalance.toString()),
        winRate,
        profitFactor,
        sharpeRatio,
        maxDrawdown,
        totalTrades: trades2.length,
        winningTrades: winningTrades.length,
        losingTrades: losingTrades.length
      };
    })
  }),
  // ==================== MARKETPLACE ROUTES ====================
  marketplace: router({
    list: publicProcedure.input(z2.object({ category: z2.string().optional() })).query(async ({ input }) => {
      return getMarketplaceListings(input.category);
    }),
    featured: publicProcedure.query(async () => {
      return getFeaturedListings();
    }),
    leaderboard: publicProcedure.input(z2.object({ limit: z2.number().default(20) })).query(async ({ input }) => {
      return getLeaderboard(input.limit);
    }),
    copyBot: protectedProcedure.input(z2.object({ listingId: z2.number(), accountId: z2.number() })).mutation(async ({ ctx, input }) => {
      const limit = await checkTierLimit(ctx.user.id, "maxBots");
      if (!limit.allowed) {
        throw new TRPCError3({
          code: "FORBIDDEN",
          message: `Bot limit reached. Upgrade your plan for more bots.`
        });
      }
      const listings = await getMarketplaceListings();
      const listing = listings.find((l) => l.id === input.listingId);
      if (!listing) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Listing not found" });
      }
      const originalBot = await getTradingBotById(listing.botId, void 0);
      if (!originalBot) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Original bot not found" });
      }
      const account = await getTradingAccountById(input.accountId, ctx.user.id);
      if (!account) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Trading account not found" });
      }
      const copiedBotId = await createTradingBot({
        userId: ctx.user.id,
        accountId: input.accountId,
        name: `${originalBot.name} (Copy)`,
        description: originalBot.description,
        strategy: originalBot.strategy,
        symbols: originalBot.symbols,
        riskSettings: originalBot.riskSettings
      });
      await createBotCopy({
        originalBotId: listing.botId,
        copiedBotId,
        userId: ctx.user.id,
        listingId: input.listingId
      });
      await updateListingStats(input.listingId, {
        totalCopies: listing.totalCopies + 1
      });
      return { copiedBotId, success: true };
    })
  }),
  // ==================== WATCHLIST ROUTES ====================
  watchlist: router({
    list: protectedProcedure.query(async ({ ctx }) => {
      return getUserWatchlists(ctx.user.id);
    }),
    create: protectedProcedure.input(z2.object({
      name: z2.string().min(1).max(255),
      symbols: z2.array(z2.string())
    })).mutation(async ({ ctx, input }) => {
      const id = await createWatchlist({
        userId: ctx.user.id,
        name: input.name,
        symbols: input.symbols
      });
      return { id, success: true };
    }),
    update: protectedProcedure.input(z2.object({
      id: z2.number(),
      name: z2.string().min(1).max(255).optional(),
      symbols: z2.array(z2.string()).optional()
    })).mutation(async ({ ctx, input }) => {
      const { id, ...data } = input;
      await updateWatchlist(id, ctx.user.id, data);
      return { success: true };
    }),
    delete: protectedProcedure.input(z2.object({ id: z2.number() })).mutation(async ({ ctx, input }) => {
      await deleteWatchlist(input.id, ctx.user.id);
      return { success: true };
    })
  }),
  // ==================== SUBSCRIPTION ROUTES ====================
  subscription: router({
    getTiers: publicProcedure.query(() => {
      return Object.entries(SUBSCRIPTION_TIERS).map(([id, tier]) => ({
        id,
        name: tier.name,
        description: tier.description,
        price: tier.price,
        features: tier.featureList
      }));
    }),
    createCheckout: protectedProcedure.input(z2.object({
      tier: z2.enum(["starter", "pro", "elite"])
    })).mutation(async ({ ctx, input }) => {
      const origin = ctx.req.headers.origin || "http://localhost:3000";
      const { url } = await createCheckoutSession({
        userId: ctx.user.id,
        userEmail: ctx.user.email || "",
        userName: ctx.user.name || "",
        tier: input.tier,
        origin
      });
      return { checkoutUrl: url };
    }),
    getCurrentTier: protectedProcedure.query(async ({ ctx }) => {
      const tier = ctx.user.subscriptionTier || "free";
      return {
        tier,
        ...SUBSCRIPTION_TIERS[tier]
      };
    })
  }),
  // ==================== LLM SETTINGS ROUTES ====================
  llmSettings: router({
    // Get available providers and models
    getProviders: publicProcedure.query(() => {
      return Object.entries(providerMetadata).map(([id, meta]) => ({
        id,
        name: meta.name,
        description: meta.description,
        website: meta.website,
        models: getAvailableModels(id)
      }));
    }),
    // Get user's current LLM settings
    getSettings: protectedProcedure.query(async ({ ctx }) => {
      const settings = await getUserLlmSettings(ctx.user.id);
      if (!settings) {
        return {
          activeProvider: "openai",
          hasOpenaiKey: false,
          hasDeepseekKey: false,
          hasClaudeKey: false,
          hasGeminiKey: false,
          openaiModel: "gpt-4-turbo",
          deepseekModel: "deepseek-reasoner",
          claudeModel: "claude-sonnet-4-20250514",
          geminiModel: "gemini-2.0-flash",
          temperature: 0.7,
          maxTokens: 4096,
          totalTokensUsed: 0
        };
      }
      return {
        activeProvider: settings.activeProvider,
        hasOpenaiKey: !!settings.openaiApiKey,
        hasDeepseekKey: !!settings.deepseekApiKey,
        hasClaudeKey: !!settings.claudeApiKey,
        hasGeminiKey: !!settings.geminiApiKey,
        openaiModel: settings.openaiModel || "gpt-4-turbo",
        deepseekModel: settings.deepseekModel || "deepseek-reasoner",
        claudeModel: settings.claudeModel || "claude-sonnet-4-20250514",
        geminiModel: settings.geminiModel || "gemini-2.0-flash",
        temperature: parseFloat(settings.temperature || "0.7"),
        maxTokens: settings.maxTokens || 4096,
        totalTokensUsed: settings.totalTokensUsed || 0,
        lastUsedAt: settings.lastUsedAt
      };
    }),
    // Update active provider
    setActiveProvider: protectedProcedure.input(z2.object({
      provider: z2.enum(["openai", "deepseek", "claude", "gemini"])
    })).mutation(async ({ ctx, input }) => {
      await upsertUserLlmSettings(ctx.user.id, {
        activeProvider: input.provider
      });
      return { success: true };
    }),
    // Save API key for a provider
    saveApiKey: protectedProcedure.input(z2.object({
      provider: z2.enum(["openai", "deepseek", "claude", "gemini"]),
      apiKey: z2.string().min(1)
    })).mutation(async ({ ctx, input }) => {
      const isValid = await validateApiKey(input.provider, input.apiKey);
      if (!isValid) {
        throw new TRPCError3({
          code: "BAD_REQUEST",
          message: `Invalid ${input.provider} API key. Please check and try again.`
        });
      }
      const encryptedKey = encryptApiKey(input.apiKey);
      const keyField = `${input.provider}ApiKey`;
      await upsertUserLlmSettings(ctx.user.id, {
        [keyField]: encryptedKey,
        activeProvider: input.provider
      });
      return { success: true, message: `${input.provider} API key saved successfully` };
    }),
    // Remove API key for a provider
    removeApiKey: protectedProcedure.input(z2.object({
      provider: z2.enum(["openai", "deepseek", "claude", "gemini"])
    })).mutation(async ({ ctx, input }) => {
      const keyField = `${input.provider}ApiKey`;
      await upsertUserLlmSettings(ctx.user.id, {
        [keyField]: null
      });
      return { success: true };
    }),
    // Update model selection for a provider
    setModel: protectedProcedure.input(z2.object({
      provider: z2.enum(["openai", "deepseek", "claude", "gemini"]),
      model: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const modelField = `${input.provider}Model`;
      await upsertUserLlmSettings(ctx.user.id, {
        [modelField]: input.model
      });
      return { success: true };
    }),
    // Update general settings (temperature, max tokens)
    updateSettings: protectedProcedure.input(z2.object({
      temperature: z2.number().min(0).max(2).optional(),
      maxTokens: z2.number().min(100).max(128e3).optional()
    })).mutation(async ({ ctx, input }) => {
      await upsertUserLlmSettings(ctx.user.id, {
        temperature: input.temperature?.toString(),
        maxTokens: input.maxTokens
      });
      return { success: true };
    }),
    // Test API key connection with detailed feedback
    testConnection: protectedProcedure.input(z2.object({
      provider: z2.enum(["openai", "deepseek", "claude", "gemini"])
    })).mutation(async ({ ctx, input }) => {
      const settings = await getUserLlmSettings(ctx.user.id);
      if (!settings) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: "No LLM settings found. Please save an API key first."
        });
      }
      const keyField = `${input.provider}ApiKey`;
      const encryptedKey = settings[keyField];
      if (!encryptedKey) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: `No API key found for ${input.provider}. Please save one first.`
        });
      }
      const apiKey = decryptApiKey(encryptedKey);
      const result = await validateApiKey(input.provider, apiKey);
      if (!result.valid) {
        throw new TRPCError3({
          code: "BAD_REQUEST",
          message: result.error || `Connection test failed for ${input.provider}.`
        });
      }
      return {
        success: true,
        message: `Successfully connected to ${input.provider}`,
        responseTimeMs: result.responseTimeMs,
        modelsTested: result.modelsTested
      };
    }),
    // Validate API key format (quick check without API call)
    validateKeyFormat: publicProcedure.input(z2.object({
      provider: z2.enum(["openai", "deepseek", "claude", "gemini"]),
      apiKey: z2.string()
    })).query(({ input }) => {
      return validateApiKeyFormat(input.provider, input.apiKey);
    }),
    // Get pricing information for all providers
    getPricing: publicProcedure.query(() => {
      return llmPricing2;
    }),
    // Estimate cost for an analysis
    estimateCost: protectedProcedure.input(z2.object({
      provider: z2.enum(["openai", "deepseek", "claude", "gemini"]),
      model: z2.string(),
      inputLength: z2.number(),
      estimatedOutputTokens: z2.number().default(1e3)
    })).query(({ input }) => {
      const estimate = estimateCost(
        input.provider,
        input.model,
        "x".repeat(input.inputLength),
        input.estimatedOutputTokens
      );
      return {
        ...estimate,
        formattedCost: formatCost(estimate.estimatedCostCents)
      };
    }),
    // Get usage statistics
    getUsageStats: protectedProcedure.input(z2.object({
      days: z2.number().min(1).max(365).default(30)
    })).query(async ({ ctx, input }) => {
      const startDate = /* @__PURE__ */ new Date();
      startDate.setDate(startDate.getDate() - input.days);
      const stats = await getUserUsageStats(ctx.user.id, startDate);
      return {
        ...stats,
        formattedTotalCost: formatCost(stats.totalCostCents),
        formattedTotalTokens: formatTokens(stats.totalTokens)
      };
    }),
    // Get recent usage summary
    getUsageSummary: protectedProcedure.query(async ({ ctx }) => {
      const summary = await getRecentUsageSummary(ctx.user.id, 30);
      return {
        ...summary,
        formattedTotalCost: formatCost(summary.totalCostCents),
        formattedDailyAvgCost: formatCost(summary.dailyAvgCostCents),
        formattedTotalTokens: formatTokens(summary.totalTokens)
      };
    }),
    // Get usage logs
    getUsageLogs: protectedProcedure.input(z2.object({
      limit: z2.number().min(1).max(100).default(20),
      offset: z2.number().min(0).default(0)
    })).query(async ({ ctx, input }) => {
      const logs = await getUserLlmUsageLogs(ctx.user.id, {
        limit: input.limit,
        offset: input.offset
      });
      return logs.map((log) => ({
        ...log,
        formattedCost: formatCost(log.costCents),
        formattedTokens: formatTokens(log.totalTokens)
      }));
    }),
    // Get fallback settings
    getFallbackSettings: protectedProcedure.query(async ({ ctx }) => {
      const settings = await getUserFallbackSettings(ctx.user.id);
      if (!settings) {
        return {
          fallbackEnabled: true,
          fallbackPriority: ["openai", "claude", "deepseek", "gemini"],
          maxRetries: 2,
          retryDelayMs: 1e3,
          notifyOnFallback: true
        };
      }
      return {
        fallbackEnabled: settings.fallbackEnabled,
        fallbackPriority: settings.fallbackPriority || ["openai", "claude", "deepseek", "gemini"],
        maxRetries: settings.maxRetries || 2,
        retryDelayMs: settings.retryDelayMs || 1e3,
        notifyOnFallback: settings.notifyOnFallback
      };
    }),
    // Update fallback settings
    updateFallbackSettings: protectedProcedure.input(z2.object({
      fallbackEnabled: z2.boolean().optional(),
      fallbackPriority: z2.array(z2.enum(["openai", "deepseek", "claude", "gemini"])).optional(),
      maxRetries: z2.number().min(0).max(5).optional(),
      retryDelayMs: z2.number().min(0).max(1e4).optional(),
      notifyOnFallback: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      await upsertUserFallbackSettings(ctx.user.id, input);
      return { success: true };
    }),
    // Get configured providers (which have API keys)
    getConfiguredProviders: protectedProcedure.query(async ({ ctx }) => {
      const settings = await getUserLlmSettings(ctx.user.id);
      if (!settings) return [];
      const configured = [];
      if (settings.openaiApiKey) configured.push("openai");
      if (settings.deepseekApiKey) configured.push("deepseek");
      if (settings.claudeApiKey) configured.push("claude");
      if (settings.geminiApiKey) configured.push("gemini");
      return configured;
    })
  }),
  // ==================== ADMIN ROUTES ====================
  admin: router({
    getStats: adminProcedure2.query(async () => {
      return getAdminStats();
    }),
    getUsers: adminProcedure2.input(z2.object({ limit: z2.number().default(50) })).query(async () => {
      return getAllUsers();
    }),
    listUsers: adminProcedure2.input(z2.object({
      page: z2.number().default(1),
      limit: z2.number().default(20),
      search: z2.string().optional(),
      role: z2.enum(["admin", "user"]).optional(),
      tier: z2.enum(["free", "starter", "pro", "elite"]).optional()
    })).query(async ({ input }) => {
      const allUsers = await getAllUsers();
      let filtered = allUsers;
      if (input.search) {
        const search = input.search.toLowerCase();
        filtered = filtered.filter(
          (u) => u.name?.toLowerCase().includes(search) || u.email?.toLowerCase().includes(search)
        );
      }
      if (input.role) {
        filtered = filtered.filter((u) => u.role === input.role);
      }
      if (input.tier) {
        filtered = filtered.filter((u) => u.subscriptionTier === input.tier);
      }
      const total = filtered.length;
      const start = (input.page - 1) * input.limit;
      const users3 = filtered.slice(start, start + input.limit);
      const verifiedCount = allUsers.filter((u) => u.isEmailVerified).length;
      const adminCount = allUsers.filter((u) => u.role === "admin").length;
      const paidCount = allUsers.filter((u) => u.subscriptionTier !== "free").length;
      return { users: users3, total, verifiedCount, adminCount, paidCount };
    }),
    updateUserRole: adminProcedure2.input(z2.object({
      userId: z2.number(),
      role: z2.enum(["user", "admin"])
    })).mutation(async ({ input }) => {
      await updateUserRole(input.userId, input.role);
      return { success: true };
    }),
    updateUserSubscription: adminProcedure2.input(z2.object({
      userId: z2.number(),
      tier: z2.enum(["free", "starter", "pro", "elite"])
    })).mutation(async ({ input }) => {
      await updateUserSubscription(input.userId, { subscriptionTier: input.tier });
      return { success: true };
    }),
    // Email Configuration
    getEmailConfig: adminProcedure2.query(async () => {
      const config = await getEmailConfig();
      if (!config) {
        return {
          id: null,
          isEnabled: false,
          senderEmail: null,
          senderName: null,
          replyToEmail: null,
          dailyLimit: 1e3,
          testMode: true,
          testEmail: null,
          emailsSentToday: 0,
          hasApiKey: false
        };
      }
      return {
        id: config.id,
        isEnabled: config.isEnabled,
        senderEmail: config.senderEmail,
        senderName: config.senderName,
        replyToEmail: config.replyToEmail,
        dailyLimit: config.dailyLimit,
        testMode: config.testMode,
        testEmail: config.testEmail,
        emailsSentToday: config.emailsSentToday,
        hasApiKey: !!config.sendgridApiKey
      };
    }),
    updateEmailConfig: adminProcedure2.input(z2.object({
      sendgridApiKey: z2.string().optional(),
      senderEmail: z2.string().email().optional(),
      senderName: z2.string().optional(),
      replyToEmail: z2.string().email().optional().nullable(),
      isEnabled: z2.boolean().optional(),
      dailyLimit: z2.number().min(1).max(1e5).optional(),
      testMode: z2.boolean().optional(),
      testEmail: z2.string().email().optional().nullable()
    })).mutation(async ({ ctx, input }) => {
      const data = {
        ...input,
        configuredBy: ctx.user.id
      };
      if (input.sendgridApiKey === void 0) {
        delete data.sendgridApiKey;
      }
      await upsertEmailConfig(data);
      return { success: true };
    }),
    testEmailConnection: adminProcedure2.input(z2.object({
      apiKey: z2.string().optional(),
      testEmail: z2.string().email()
    })).mutation(async ({ input }) => {
      const config = await getEmailConfig();
      const apiKey = input.apiKey || config?.sendgridApiKey;
      if (!apiKey) {
        return { success: false, error: "No SendGrid API key configured" };
      }
      try {
        const result = await testSendGridApiKey(apiKey, input.testEmail);
        return result;
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : "Failed to send test email"
        };
      }
    }),
    getEmailStats: adminProcedure2.query(async () => {
      const config = await getEmailConfig();
      return {
        emailsSentToday: config?.emailsSentToday || 0,
        dailyLimit: config?.dailyLimit || 1e3,
        lastResetAt: config?.lastResetAt,
        isEnabled: config?.isEnabled || false
      };
    })
  }),
  // ==================== PHASE 14: PERFORMANCE TRACKING ====================
  accuracy: router({
    // Get user's prediction accuracy stats
    getStats: protectedProcedure.query(async ({ ctx }) => {
      return getAgentAccuracyStats(ctx.user.id);
    }),
    // Get accuracy records
    getRecords: protectedProcedure.input(z2.object({
      agentType: z2.enum(["technical", "fundamental", "sentiment", "risk", "microstructure", "macro", "quant", "consensus"]).optional(),
      timeframe: z2.enum(["1day", "7day", "30day"]).optional(),
      limit: z2.number().min(1).max(100).default(50)
    })).query(async ({ ctx }) => {
      return getUserPredictionAccuracy(ctx.user.id);
    }),
    // Get price tracking for an analysis
    getPriceTracking: protectedProcedure.input(z2.object({ analysisId: z2.number() })).query(async ({ input }) => {
      return getPriceTrackingByAnalysis(input.analysisId);
    })
  }),
  // ==================== PHASE 15: SAVED COMPARISONS & WATCHLISTS ====================
  savedComparisons: router({
    // List user's saved comparisons
    list: protectedProcedure.query(async ({ ctx }) => {
      return getUserSavedComparisons(ctx.user.id);
    }),
    // Get a specific saved comparison
    get: protectedProcedure.input(z2.object({ id: z2.number() })).query(async ({ ctx, input }) => {
      const comparison = await getSavedComparisonById(input.id, ctx.user.id);
      if (!comparison) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Comparison not found" });
      }
      return comparison;
    }),
    // Create a new saved comparison
    create: protectedProcedure.input(z2.object({
      name: z2.string().min(1).max(255),
      description: z2.string().optional(),
      analysisIds: z2.array(z2.number()).min(1).max(10),
      symbolsIncluded: z2.array(z2.string()).optional(),
      dateRange: z2.object({
        start: z2.string(),
        end: z2.string()
      }).optional()
    })).mutation(async ({ ctx, input }) => {
      const id = await createSavedComparison({
        userId: ctx.user.id,
        name: input.name,
        description: input.description,
        analysisIds: input.analysisIds,
        symbolsIncluded: input.symbolsIncluded,
        dateRange: input.dateRange
      });
      return { id, success: true };
    }),
    // Update a saved comparison
    update: protectedProcedure.input(z2.object({
      id: z2.number(),
      name: z2.string().min(1).max(255).optional(),
      description: z2.string().optional(),
      isPinned: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      await updateSavedComparison(input.id, ctx.user.id, input);
      return { success: true };
    }),
    // Delete a saved comparison
    delete: protectedProcedure.input(z2.object({ id: z2.number() })).mutation(async ({ ctx, input }) => {
      await deleteSavedComparison(input.id, ctx.user.id);
      return { success: true };
    })
  }),
  // Watchlist Alerts
  watchlistAlerts: router({
    // List user's alerts
    list: protectedProcedure.query(async ({ ctx }) => {
      return getUserWatchlistAlerts(ctx.user.id);
    }),
    // Create a new alert
    create: protectedProcedure.input(z2.object({
      symbol: z2.string().min(1).max(20),
      alertOnRecommendationChange: z2.boolean().default(true),
      alertOnConfidenceChange: z2.boolean().default(false),
      confidenceThreshold: z2.number().min(0).max(1).optional(),
      alertOnPriceTarget: z2.boolean().default(false),
      priceTargetHigh: z2.number().optional(),
      priceTargetLow: z2.number().optional(),
      emailNotification: z2.boolean().default(true),
      pushNotification: z2.boolean().default(true)
    })).mutation(async ({ ctx, input }) => {
      const id = await createWatchlistAlert({
        userId: ctx.user.id,
        symbol: input.symbol.toUpperCase(),
        alertOnRecommendationChange: input.alertOnRecommendationChange,
        alertOnConfidenceChange: input.alertOnConfidenceChange,
        confidenceThreshold: input.confidenceThreshold?.toString(),
        alertOnPriceTarget: input.alertOnPriceTarget,
        priceTargetHigh: input.priceTargetHigh?.toString(),
        priceTargetLow: input.priceTargetLow?.toString(),
        emailNotification: input.emailNotification,
        pushNotification: input.pushNotification
      });
      return { id, success: true };
    }),
    // Update an alert
    update: protectedProcedure.input(z2.object({
      id: z2.number(),
      isActive: z2.boolean().optional(),
      alertOnRecommendationChange: z2.boolean().optional(),
      alertOnConfidenceChange: z2.boolean().optional(),
      confidenceThreshold: z2.number().min(0).max(1).optional(),
      alertOnPriceTarget: z2.boolean().optional(),
      priceTargetHigh: z2.number().optional(),
      priceTargetLow: z2.number().optional(),
      emailNotification: z2.boolean().optional(),
      pushNotification: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      const { id, ...data } = input;
      await updateWatchlistAlert(id, ctx.user.id, {
        ...data,
        confidenceThreshold: data.confidenceThreshold?.toString(),
        priceTargetHigh: data.priceTargetHigh?.toString(),
        priceTargetLow: data.priceTargetLow?.toString()
      });
      return { success: true };
    }),
    // Delete an alert
    delete: protectedProcedure.input(z2.object({ id: z2.number() })).mutation(async ({ ctx, input }) => {
      await deleteWatchlistAlert(input.id, ctx.user.id);
      return { success: true };
    }),
    // Get alert history
    getHistory: protectedProcedure.input(z2.object({ limit: z2.number().min(1).max(100).default(50) })).query(async ({ ctx, input }) => {
      return getUserAlertHistory(ctx.user.id, input.limit);
    })
  }),
  // ==================== PHASE 16: NOTIFICATIONS ====================
  notifications: router({
    // Get user's notifications
    list: protectedProcedure.input(z2.object({ unreadOnly: z2.boolean().default(false) })).query(async ({ ctx, input }) => {
      return getUserNotifications(ctx.user.id, input.unreadOnly);
    }),
    // Get unread count
    getUnreadCount: protectedProcedure.query(async ({ ctx }) => {
      return getUnreadNotificationCount(ctx.user.id);
    }),
    // Mark notification as read
    markRead: protectedProcedure.input(z2.object({ id: z2.number() })).mutation(async ({ ctx, input }) => {
      await markNotificationRead(input.id, ctx.user.id);
      return { success: true };
    }),
    // Mark all as read
    markAllRead: protectedProcedure.mutation(async ({ ctx }) => {
      await markAllNotificationsRead(ctx.user.id);
      return { success: true };
    }),
    // Delete notification
    delete: protectedProcedure.input(z2.object({ id: z2.number() })).mutation(async ({ ctx, input }) => {
      await deleteNotification(input.id, ctx.user.id);
      return { success: true };
    })
  }),
  // ==================== PHASE 17: BOT SCHEDULING ====================
  botSchedule: router({
    // Get schedules for a bot
    list: protectedProcedure.input(z2.object({ botId: z2.number() })).query(async ({ ctx, input }) => {
      const bot = await getTradingBotById(input.botId, ctx.user.id);
      if (!bot) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Bot not found" });
      }
      return getBotSchedules(input.botId);
    }),
    // Create a schedule
    create: protectedProcedure.input(z2.object({
      botId: z2.number(),
      name: z2.string().min(1).max(255),
      scheduleType: z2.enum(["once", "daily", "weekly", "monthly", "cron"]),
      cronExpression: z2.string().optional(),
      runTime: z2.string().optional(),
      daysOfWeek: z2.array(z2.number().min(0).max(6)).optional(),
      dayOfMonth: z2.number().min(1).max(31).optional(),
      timezone: z2.string().default("UTC"),
      maxExecutionTime: z2.number().min(60).max(3600).default(300),
      retryOnFailure: z2.boolean().default(true),
      maxRetries: z2.number().min(0).max(5).default(3)
    })).mutation(async ({ ctx, input }) => {
      const bot = await getTradingBotById(input.botId, ctx.user.id);
      if (!bot) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Bot not found" });
      }
      if (!checkTierAccess(ctx.user.subscriptionTier, "starter")) {
        throw new TRPCError3({
          code: "FORBIDDEN",
          message: "Bot scheduling requires Starter tier or higher"
        });
      }
      const id = await createBotSchedule({
        botId: input.botId,
        userId: ctx.user.id,
        name: input.name,
        scheduleType: input.scheduleType,
        cronExpression: input.cronExpression,
        runTime: input.runTime,
        daysOfWeek: input.daysOfWeek,
        dayOfMonth: input.dayOfMonth,
        timezone: input.timezone,
        maxExecutionTime: input.maxExecutionTime,
        retryOnFailure: input.retryOnFailure,
        maxRetries: input.maxRetries
      });
      return { id, success: true };
    }),
    // Update a schedule
    update: protectedProcedure.input(z2.object({
      id: z2.number(),
      name: z2.string().min(1).max(255).optional(),
      isActive: z2.boolean().optional(),
      runTime: z2.string().optional(),
      daysOfWeek: z2.array(z2.number().min(0).max(6)).optional(),
      timezone: z2.string().optional()
    })).mutation(async ({ input }) => {
      const { id, ...data } = input;
      await updateBotSchedule(id, data);
      return { success: true };
    }),
    // Delete a schedule
    delete: protectedProcedure.input(z2.object({ id: z2.number() })).mutation(async ({ input }) => {
      await deleteBotSchedule(input.id);
      return { success: true };
    }),
    // Toggle schedule active status
    toggle: protectedProcedure.input(z2.object({ id: z2.number(), enabled: z2.boolean() })).mutation(async ({ input }) => {
      await updateBotSchedule(input.id, { isActive: input.enabled });
      return { success: true };
    }),
    // Get execution logs
    getExecutionLogs: protectedProcedure.input(z2.object({ botId: z2.number().optional(), limit: z2.number().default(50) })).query(async ({ ctx, input }) => {
      return getBotExecutionLogs(input.botId, ctx.user.id, input.limit);
    })
  }),
  // Bot Risk Rules
  botRiskRules: router({
    // Get risk rules for a bot
    list: protectedProcedure.input(z2.object({ botId: z2.number() })).query(async ({ ctx, input }) => {
      const bot = await getTradingBotById(input.botId, ctx.user.id);
      if (!bot) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Bot not found" });
      }
      return getBotRiskRules(input.botId);
    }),
    // Create a risk rule
    create: protectedProcedure.input(z2.object({
      botId: z2.number(),
      name: z2.string().min(1).max(255),
      ruleType: z2.enum(["stop_loss", "take_profit", "trailing_stop", "max_position", "max_daily_loss", "max_drawdown", "position_sizing"]),
      triggerValue: z2.number(),
      triggerType: z2.enum(["percentage", "absolute", "atr_multiple"]).default("percentage"),
      actionOnTrigger: z2.enum(["close_position", "reduce_position", "pause_bot", "notify_only"]).default("close_position"),
      reduceByPercentage: z2.number().min(0).max(100).optional()
    })).mutation(async ({ ctx, input }) => {
      const bot = await getTradingBotById(input.botId, ctx.user.id);
      if (!bot) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Bot not found" });
      }
      const id = await createBotRiskRule({
        botId: input.botId,
        userId: ctx.user.id,
        name: input.name,
        ruleType: input.ruleType,
        triggerValue: input.triggerValue.toString(),
        triggerType: input.triggerType,
        actionOnTrigger: input.actionOnTrigger,
        reduceByPercentage: input.reduceByPercentage?.toString()
      });
      return { id, success: true };
    }),
    // Update a risk rule
    update: protectedProcedure.input(z2.object({
      id: z2.number(),
      name: z2.string().min(1).max(255).optional(),
      isActive: z2.boolean().optional(),
      triggerValue: z2.number().optional(),
      actionOnTrigger: z2.enum(["close_position", "reduce_position", "pause_bot", "notify_only"]).optional()
    })).mutation(async ({ input }) => {
      const { id, ...data } = input;
      await updateBotRiskRule(id, {
        ...data,
        triggerValue: data.triggerValue?.toString()
      });
      return { success: true };
    }),
    // Delete a risk rule
    delete: protectedProcedure.input(z2.object({ id: z2.number() })).mutation(async ({ input }) => {
      await deleteBotRiskRule(input.id);
      return { success: true };
    })
  }),
  // Bot Execution Logs
  botExecutionLogs: router({
    // Get execution logs for a bot
    list: protectedProcedure.input(z2.object({
      botId: z2.number(),
      limit: z2.number().min(1).max(100).default(50)
    })).query(async ({ ctx, input }) => {
      const bot = await getTradingBotById(input.botId, ctx.user.id);
      if (!bot) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Bot not found" });
      }
      return getBotExecutionLogs(input.botId, input.limit);
    })
  }),
  // Bot Benchmarks
  botBenchmarks: router({
    // Get benchmarks for a bot
    list: protectedProcedure.input(z2.object({ botId: z2.number() })).query(async ({ ctx, input }) => {
      const bot = await getTradingBotById(input.botId, ctx.user.id);
      if (!bot) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Bot not found" });
      }
      return getBotBenchmarks(input.botId);
    }),
    // Get latest benchmark
    getLatest: protectedProcedure.input(z2.object({ botId: z2.number() })).query(async ({ ctx, input }) => {
      const bot = await getTradingBotById(input.botId, ctx.user.id);
      if (!bot) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Bot not found" });
      }
      return getLatestBotBenchmark(input.botId);
    })
  }),
  // ==================== PHASE 18: SOCIAL & COMMUNITY ====================
  profile: router({
    // Get own profile
    get: protectedProcedure.query(async ({ ctx }) => {
      return getUserProfile(ctx.user.id);
    }),
    // Get public profile by user ID
    getPublic: publicProcedure.input(z2.object({ userId: z2.number() })).query(async ({ input }) => {
      return getPublicUserProfile(input.userId);
    }),
    // Update profile
    update: protectedProcedure.input(z2.object({
      displayName: z2.string().min(1).max(100).optional(),
      bio: z2.string().max(500).optional(),
      avatarUrl: z2.string().url().optional(),
      location: z2.string().max(100).optional(),
      website: z2.string().url().optional(),
      twitterHandle: z2.string().max(50).optional(),
      isPublic: z2.boolean().optional(),
      showTradingStats: z2.boolean().optional(),
      showPortfolio: z2.boolean().optional(),
      allowFollowers: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      await upsertUserProfile(ctx.user.id, input);
      return { success: true };
    }),
    // Get top traders
    getTopTraders: publicProcedure.input(z2.object({ limit: z2.number().min(1).max(100).default(20) })).query(async ({ input }) => {
      return getTopTraders(input.limit);
    }),
    // Get user badges
    getBadges: protectedProcedure.query(async ({ ctx }) => {
      return getUserBadges(ctx.user.id);
    }),
    // Get all badge definitions
    getAllBadges: publicProcedure.query(async () => {
      return getAllBadgeDefinitions();
    })
  }),
  // Follow system
  follow: router({
    // Get followers
    getFollowers: protectedProcedure.query(async ({ ctx }) => {
      return getUserFollowers(ctx.user.id);
    }),
    // Get following
    getFollowing: protectedProcedure.query(async ({ ctx }) => {
      return getUserFollowing(ctx.user.id);
    }),
    // Check if following
    isFollowing: protectedProcedure.input(z2.object({ userId: z2.number() })).query(async ({ ctx, input }) => {
      return isFollowing(ctx.user.id, input.userId);
    }),
    // Follow a user
    follow: protectedProcedure.input(z2.object({
      userId: z2.number(),
      notifyOnTrade: z2.boolean().default(false),
      notifyOnAnalysis: z2.boolean().default(true),
      notifyOnStrategy: z2.boolean().default(true)
    })).mutation(async ({ ctx, input }) => {
      if (input.userId === ctx.user.id) {
        throw new TRPCError3({ code: "BAD_REQUEST", message: "Cannot follow yourself" });
      }
      const targetProfile = await getUserProfile(input.userId);
      if (targetProfile && !targetProfile.allowFollowers) {
        throw new TRPCError3({ code: "FORBIDDEN", message: "This user does not allow followers" });
      }
      const alreadyFollowing = await isFollowing(ctx.user.id, input.userId);
      if (alreadyFollowing) {
        throw new TRPCError3({ code: "BAD_REQUEST", message: "Already following this user" });
      }
      await createUserFollow({
        followerId: ctx.user.id,
        followingId: input.userId,
        notifyOnTrade: input.notifyOnTrade,
        notifyOnAnalysis: input.notifyOnAnalysis,
        notifyOnStrategy: input.notifyOnStrategy
      });
      await createActivityFeedItem({
        userId: ctx.user.id,
        activityType: "follow",
        title: "Started following a trader",
        relatedEntityType: "user",
        relatedEntityId: input.userId,
        isPublic: true
      });
      return { success: true };
    }),
    // Unfollow a user
    unfollow: protectedProcedure.input(z2.object({ userId: z2.number() })).mutation(async ({ ctx, input }) => {
      await unfollowUser(ctx.user.id, input.userId);
      return { success: true };
    })
  }),
  // Discussion threads
  discussion: router({
    // Get threads
    list: publicProcedure.input(z2.object({
      threadType: z2.enum(["analysis", "strategy", "bot", "general", "market"]).optional(),
      symbol: z2.string().optional(),
      limit: z2.number().min(1).max(100).default(50),
      offset: z2.number().min(0).default(0)
    })).query(async ({ input }) => {
      return getDiscussionThreads(input);
    }),
    // Get a thread
    get: publicProcedure.input(z2.object({ id: z2.number() })).query(async ({ input }) => {
      const thread = await getDiscussionThreadById(input.id);
      if (!thread) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Thread not found" });
      }
      await incrementThreadViews(input.id);
      return thread;
    }),
    // Create a thread
    create: protectedProcedure.input(z2.object({
      threadType: z2.enum(["analysis", "strategy", "bot", "general", "market"]),
      title: z2.string().min(1).max(255),
      content: z2.string().min(1).max(1e4),
      symbol: z2.string().optional(),
      relatedEntityId: z2.number().optional()
    })).mutation(async ({ ctx, input }) => {
      const id = await createDiscussionThread({
        userId: ctx.user.id,
        threadType: input.threadType,
        title: input.title,
        content: input.content,
        symbol: input.symbol?.toUpperCase(),
        relatedEntityId: input.relatedEntityId
      });
      await createActivityFeedItem({
        userId: ctx.user.id,
        activityType: "comment",
        title: `Started a discussion: ${input.title}`,
        relatedEntityType: "thread",
        relatedEntityId: id,
        symbol: input.symbol?.toUpperCase(),
        isPublic: true
      });
      return { id, success: true };
    }),
    // Update a thread
    update: protectedProcedure.input(z2.object({
      id: z2.number(),
      title: z2.string().min(1).max(255).optional(),
      content: z2.string().min(1).max(1e4).optional()
    })).mutation(async ({ ctx, input }) => {
      const thread = await getDiscussionThreadById(input.id);
      if (!thread || thread.userId !== ctx.user.id) {
        throw new TRPCError3({ code: "FORBIDDEN", message: "Cannot edit this thread" });
      }
      const { id, ...data } = input;
      await updateDiscussionThread(id, data);
      return { success: true };
    }),
    // Get comments for a thread
    getComments: publicProcedure.input(z2.object({ threadId: z2.number() })).query(async ({ input }) => {
      return getThreadComments(input.threadId);
    }),
    // Add a comment
    addComment: protectedProcedure.input(z2.object({
      threadId: z2.number(),
      content: z2.string().min(1).max(5e3),
      parentCommentId: z2.number().optional()
    })).mutation(async ({ ctx, input }) => {
      const id = await createDiscussionComment({
        threadId: input.threadId,
        userId: ctx.user.id,
        content: input.content,
        parentCommentId: input.parentCommentId
      });
      return { id, success: true };
    }),
    // Update a comment
    updateComment: protectedProcedure.input(z2.object({
      id: z2.number(),
      content: z2.string().min(1).max(5e3)
    })).mutation(async ({ ctx, input }) => {
      await updateDiscussionComment(input.id, ctx.user.id, { content: input.content });
      return { success: true };
    }),
    // Delete a comment
    deleteComment: protectedProcedure.input(z2.object({ id: z2.number() })).mutation(async ({ ctx, input }) => {
      await deleteDiscussionComment(input.id, ctx.user.id);
      return { success: true };
    })
  }),
  // Strategy ratings
  strategyRatings: router({
    // Get ratings for a listing
    list: publicProcedure.input(z2.object({ listingId: z2.number() })).query(async ({ input }) => {
      return getStrategyRatings(input.listingId);
    }),
    // Get user's rating for a listing
    getUserRating: protectedProcedure.input(z2.object({ listingId: z2.number() })).query(async ({ ctx, input }) => {
      return getUserStrategyRating(input.listingId, ctx.user.id);
    }),
    // Create or update rating
    rate: protectedProcedure.input(z2.object({
      listingId: z2.number(),
      rating: z2.number().min(1).max(5),
      review: z2.string().max(2e3).optional()
    })).mutation(async ({ ctx, input }) => {
      const existing = await getUserStrategyRating(input.listingId, ctx.user.id);
      if (existing) {
        await updateStrategyRating(existing.id, ctx.user.id, {
          rating: input.rating,
          review: input.review
        });
      } else {
        await createStrategyRating({
          listingId: input.listingId,
          userId: ctx.user.id,
          rating: input.rating,
          review: input.review
        });
      }
      return { success: true };
    })
  }),
  // Activity feed
  activityFeed: router({
    // Get personalized feed (from followed users)
    getFeed: protectedProcedure.input(z2.object({ limit: z2.number().min(1).max(100).default(50) })).query(async ({ ctx, input }) => {
      return getUserActivityFeed(ctx.user.id, input.limit);
    }),
    // Get public feed
    getPublicFeed: publicProcedure.input(z2.object({ limit: z2.number().min(1).max(100).default(50) })).query(async ({ input }) => {
      return getPublicActivityFeed(input.limit);
    })
  }),
  // ==================== BACKTESTING VALIDATION ====================
  backtestValidation: router({
    // Run backtest validation
    run: protectedProcedure.input(z2.object({
      symbol: z2.string().min(1).max(10),
      startDate: z2.string(),
      endDate: z2.string(),
      initialCapital: z2.number().min(1e3).max(1e7),
      strategyType: z2.enum(["standard", "enhanced", "rl", "custom"]),
      strategyConfig: z2.record(z2.string(), z2.unknown()).optional(),
      commission: z2.number().min(0).max(0.1).optional(),
      slippage: z2.number().min(0).max(0.1).optional()
    })).mutation(async ({ ctx, input }) => {
      const config = {
        symbol: input.symbol.toUpperCase(),
        startDate: new Date(input.startDate),
        endDate: new Date(input.endDate),
        initialCapital: input.initialCapital,
        strategyType: input.strategyType,
        strategyConfig: input.strategyConfig,
        commission: input.commission,
        slippage: input.slippage
      };
      return runBacktestValidation(ctx.user.id, config);
    }),
    // Get user's backtest history
    list: protectedProcedure.input(z2.object({ limit: z2.number().min(1).max(100).default(20) })).query(async ({ ctx, input }) => {
      return getUserBacktests2(ctx.user.id, input.limit);
    }),
    // Get specific backtest result
    get: protectedProcedure.input(z2.object({ id: z2.number() })).query(async ({ ctx, input }) => {
      return getBacktestById2(input.id, ctx.user.id);
    })
  }),
  // ==================== REINFORCEMENT LEARNING AGENT ====================
  rlAgent: router({
    // Create and train a new RL agent
    train: protectedProcedure.input(z2.object({
      symbol: z2.string().min(1).max(10),
      name: z2.string().min(1).max(100),
      episodes: z2.number().min(10).max(1e3).default(100),
      config: z2.object({
        learningRate: z2.number().min(1e-5).max(0.1).optional(),
        gamma: z2.number().min(0.5).max(0.999).optional(),
        epsilon: z2.number().min(0).max(1).optional(),
        epsilonDecay: z2.number().min(0.9).max(0.9999).optional(),
        epsilonMin: z2.number().min(0).max(0.5).optional(),
        batchSize: z2.number().min(16).max(256).optional()
      }).optional()
    })).mutation(async ({ ctx, input }) => {
      const agent = new RLTradingAgent(input.config);
      const modelId = await agent.saveModel(
        ctx.user.id,
        input.name,
        input.symbol.toUpperCase()
      );
      return {
        modelId,
        message: "RL agent created successfully. Training will continue in background.",
        stats: agent.getStats()
      };
    }),
    // Get prediction from trained RL agent
    predict: protectedProcedure.input(z2.object({
      modelId: z2.string(),
      state: z2.object({
        priceChange1d: z2.number(),
        priceChange5d: z2.number(),
        priceChange20d: z2.number(),
        volatility: z2.number(),
        rsi: z2.number(),
        macdHistogram: z2.number(),
        bollingerPosition: z2.number(),
        adx: z2.number(),
        atr: z2.number(),
        marketRegime: z2.number(),
        vixLevel: z2.number(),
        currentPosition: z2.number(),
        unrealizedPnl: z2.number(),
        daysInPosition: z2.number()
      })
    })).query(async ({ input }) => {
      const agent = new RLTradingAgent();
      const loaded = await agent.loadModel(input.modelId);
      if (!loaded) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Model not found" });
      }
      const action = agent.getAction(input.state);
      return action;
    }),
    // List user's RL models
    list: protectedProcedure.input(z2.object({ limit: z2.number().min(1).max(50).default(20) })).query(async ({ ctx, input }) => {
      return getUserRLModels(ctx.user.id, input.limit);
    })
  }),
  // ==================== STRATEGY COMPARISON ====================
  strategyComparison: router({
    // Run strategy comparison
    compare: protectedProcedure.input(z2.object({
      symbol: z2.string().min(1).max(10),
      startDate: z2.string(),
      endDate: z2.string(),
      initialCapital: z2.number().min(1e3).max(1e7),
      strategies: z2.array(z2.enum(["standard", "enhanced", "rl"])).min(2).max(4),
      name: z2.string().optional()
    })).mutation(async ({ ctx, input }) => {
      const results = {};
      for (const strategy of input.strategies) {
        const config = {
          symbol: input.symbol.toUpperCase(),
          startDate: new Date(input.startDate),
          endDate: new Date(input.endDate),
          initialCapital: input.initialCapital,
          strategyType: strategy
        };
        const result = await runBacktestValidation(ctx.user.id, config);
        results[strategy] = result;
      }
      let winner = "";
      let bestSharpe = -Infinity;
      for (const [strategy, result] of Object.entries(results)) {
        if (result.metrics.sharpeRatio > bestSharpe) {
          bestSharpe = result.metrics.sharpeRatio;
          winner = strategy;
        }
      }
      const comparison = await saveStrategyComparison({
        userId: ctx.user.id,
        name: input.name || `${input.symbol} Comparison`,
        symbol: input.symbol.toUpperCase(),
        startDate: new Date(input.startDate),
        endDate: new Date(input.endDate),
        initialCapital: input.initialCapital,
        strategies: input.strategies.map((s) => ({ type: s })),
        results,
        winner
      });
      return {
        id: comparison?.id,
        results,
        winner,
        summary: {
          symbol: input.symbol,
          period: `${input.startDate} to ${input.endDate}`,
          strategies: input.strategies,
          metrics: Object.fromEntries(
            Object.entries(results).map(([strategy, result]) => [
              strategy,
              {
                totalReturn: result.metrics.totalReturn,
                sharpeRatio: result.metrics.sharpeRatio,
                maxDrawdown: result.metrics.maxDrawdown,
                winRate: result.metrics.winRate,
                totalTrades: result.metrics.totalTrades
              }
            ])
          )
        }
      };
    }),
    // Get user's comparison history
    list: protectedProcedure.input(z2.object({ limit: z2.number().min(1).max(50).default(20) })).query(async ({ ctx, input }) => {
      return getUserStrategyComparisons(ctx.user.id, input.limit);
    }),
    // Get specific comparison
    get: protectedProcedure.input(z2.object({ id: z2.number() })).query(async ({ ctx, input }) => {
      return getStrategyComparisonById(input.id, ctx.user.id);
    })
  }),
  // ==================== MONTE CARLO SIMULATION ====================
  monteCarlo: router({
    // Run full Monte Carlo simulation
    run: protectedProcedure.input(z2.object({
      symbol: z2.string().min(1).max(10),
      initialCapital: z2.number().min(1e3).max(1e7),
      numSimulations: z2.number().min(100).max(1e4).default(1e3),
      timeHorizonDays: z2.number().min(5).max(504).default(252),
      confidenceLevels: z2.array(z2.number().min(0.5).max(0.99)).default([0.95, 0.99]),
      strategyType: z2.enum(["buy_hold", "momentum", "mean_reversion", "enhanced"]).default("buy_hold"),
      riskFreeRate: z2.number().min(0).max(0.2).default(0.05)
    })).mutation(async ({ input }) => {
      const config = {
        symbol: input.symbol.toUpperCase(),
        initialCapital: input.initialCapital,
        numSimulations: input.numSimulations,
        timeHorizonDays: input.timeHorizonDays,
        confidenceLevels: input.confidenceLevels,
        strategyType: input.strategyType,
        riskFreeRate: input.riskFreeRate
      };
      return runMonteCarloSimulation(config);
    }),
    // Quick simulation for preview
    quick: protectedProcedure.input(z2.object({
      symbol: z2.string().min(1).max(10),
      initialCapital: z2.number().min(1e3).max(1e7).default(1e5),
      timeHorizonDays: z2.number().min(5).max(504).default(252)
    })).query(async ({ input }) => {
      return runQuickSimulation(
        input.symbol.toUpperCase(),
        input.initialCapital,
        input.timeHorizonDays
      );
    })
  }),
  // ==================== WALK-FORWARD OPTIMIZATION ====================
  walkForward: router({
    // Run full walk-forward optimization
    run: protectedProcedure.input(z2.object({
      symbol: z2.string().min(1).max(10),
      totalPeriodDays: z2.number().min(126).max(2520).default(504),
      trainingWindowDays: z2.number().min(21).max(504).default(126),
      testingWindowDays: z2.number().min(5).max(126).default(63),
      stepSizeDays: z2.number().min(5).max(126).default(63),
      optimizationType: z2.enum(["anchored", "rolling"]).default("rolling"),
      strategyType: z2.enum(["rl", "momentum", "mean_reversion", "enhanced"]).default("enhanced"),
      initialCapital: z2.number().min(1e3).max(1e7).default(1e5)
    })).mutation(async ({ input }) => {
      const config = {
        symbol: input.symbol.toUpperCase(),
        totalPeriodDays: input.totalPeriodDays,
        trainingWindowDays: input.trainingWindowDays,
        testingWindowDays: input.testingWindowDays,
        stepSizeDays: input.stepSizeDays,
        optimizationType: input.optimizationType,
        strategyType: input.strategyType,
        initialCapital: input.initialCapital
      };
      return runWalkForwardOptimization(config);
    }),
    // Quick walk-forward analysis
    quick: protectedProcedure.input(z2.object({
      symbol: z2.string().min(1).max(10),
      strategyType: z2.enum(["rl", "momentum", "mean_reversion", "enhanced"]).default("enhanced")
    })).query(async ({ input }) => {
      return runQuickWalkForward(
        input.symbol.toUpperCase(),
        input.strategyType
      );
    })
  }),
  // ==================== PORTFOLIO BACKTESTING ====================
  portfolioBacktest: router({
    // Run full portfolio backtest
    backtest: protectedProcedure.input(z2.object({
      assets: z2.array(z2.object({
        symbol: z2.string().min(1).max(10),
        weight: z2.number().min(0).max(1),
        name: z2.string().optional()
      })).min(2).max(20),
      initialCapital: z2.number().min(1e3).max(1e7).default(1e5),
      startDate: z2.string().optional(),
      endDate: z2.string().optional(),
      rebalanceFrequency: z2.enum(["daily", "weekly", "monthly", "quarterly", "none"]).default("monthly"),
      riskFreeRate: z2.number().min(0).max(0.2).default(0.05),
      benchmarkSymbol: z2.string().default("SPY")
    })).mutation(async ({ input }) => {
      const totalWeight = input.assets.reduce((sum2, a) => sum2 + a.weight, 0);
      const normalizedAssets = input.assets.map((a) => ({
        ...a,
        symbol: a.symbol.toUpperCase(),
        weight: a.weight / totalWeight
      }));
      const config = {
        assets: normalizedAssets,
        initialCapital: input.initialCapital,
        startDate: input.startDate ? new Date(input.startDate) : new Date(Date.now() - 2 * 365 * 24 * 60 * 60 * 1e3),
        endDate: input.endDate ? new Date(input.endDate) : /* @__PURE__ */ new Date(),
        rebalanceFrequency: input.rebalanceFrequency,
        riskFreeRate: input.riskFreeRate,
        benchmarkSymbol: input.benchmarkSymbol.toUpperCase()
      };
      return runPortfolioBacktest(config);
    }),
    // Quick portfolio analysis
    quickAnalysis: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string().min(1).max(10)).min(2).max(20),
      weights: z2.array(z2.number().min(0).max(1)).optional()
    })).query(async ({ input }) => {
      const weights = input.weights || input.symbols.map(() => 1 / input.symbols.length);
      return runQuickPortfolioAnalysis(
        input.symbols.map((s) => s.toUpperCase()),
        weights
      );
    }),
    // Get efficient frontier for assets
    efficientFrontier: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string().min(1).max(10)).min(2).max(10)
    })).query(async ({ input }) => {
      const assets = input.symbols.map((symbol) => ({
        symbol: symbol.toUpperCase(),
        weight: 1 / input.symbols.length
      }));
      const result = await runPortfolioBacktest({
        assets,
        initialCapital: 1e5,
        startDate: new Date(Date.now() - 2 * 365 * 24 * 60 * 60 * 1e3),
        endDate: /* @__PURE__ */ new Date(),
        rebalanceFrequency: "monthly"
      });
      return {
        frontier: result.efficientFrontier,
        correlationMatrix: result.correlationMatrix,
        diversificationMetrics: result.diversificationMetrics
      };
    })
  }),
  // Regime-Switching Models
  regime: router({
    analyze: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      lookbackDays: z2.number().min(30).max(365).default(90)
    })).mutation(async ({ input }) => {
      const config = {
        symbol: input.symbol,
        lookbackDays: input.lookbackDays
      };
      return analyzeMarketRegime(config);
    }),
    quick: protectedProcedure.input(z2.object({ symbol: z2.string() })).query(async ({ input }) => {
      return getQuickRegime(input.symbol);
    })
  }),
  // Options Greeks Calculator
  options: router({
    calculateGreeks: protectedProcedure.input(z2.object({
      underlyingPrice: z2.number().positive(),
      strikePrice: z2.number().positive(),
      timeToExpiry: z2.number().min(0).max(5),
      riskFreeRate: z2.number().min(0).max(1).default(0.05),
      volatility: z2.number().min(0.01).max(5).default(0.25),
      optionType: z2.enum(["call", "put"]),
      dividendYield: z2.number().min(0).max(1).optional()
    })).mutation(async ({ input }) => {
      const optionInput = {
        underlyingPrice: input.underlyingPrice,
        strikePrice: input.strikePrice,
        timeToExpiry: input.timeToExpiry,
        riskFreeRate: input.riskFreeRate,
        volatility: input.volatility,
        optionType: input.optionType,
        dividendYield: input.dividendYield
      };
      const greeks = calculateGreeks(optionInput);
      const visualization = generateGreeksVisualization(optionInput);
      return { greeks, visualization };
    }),
    impliedVolatility: protectedProcedure.input(z2.object({
      marketPrice: z2.number().positive(),
      underlyingPrice: z2.number().positive(),
      strikePrice: z2.number().positive(),
      timeToExpiry: z2.number().min(1e-3).max(5),
      riskFreeRate: z2.number().min(0).max(1).default(0.05),
      optionType: z2.enum(["call", "put"]),
      dividendYield: z2.number().min(0).max(1).optional()
    })).mutation(async ({ input }) => {
      const iv = calculateImpliedVolatility(
        input.marketPrice,
        input.underlyingPrice,
        input.strikePrice,
        input.timeToExpiry,
        input.riskFreeRate,
        input.optionType,
        input.dividendYield || 0
      );
      return { impliedVolatility: iv, annualizedPercent: iv * 100 };
    }),
    optionChain: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      expirationDays: z2.number().min(1).max(365).default(30),
      numStrikes: z2.number().min(5).max(21).default(11)
    })).query(async ({ input }) => {
      return generateOptionChain(input.symbol, input.expirationDays, input.numStrikes);
    }),
    analyzeStrategy: protectedProcedure.input(z2.object({
      legs: z2.array(z2.object({
        optionType: z2.enum(["call", "put"]),
        strikePrice: z2.number().positive(),
        quantity: z2.number(),
        premium: z2.number().min(0)
      })),
      underlyingPrice: z2.number().positive(),
      timeToExpiry: z2.number().min(0).max(5),
      riskFreeRate: z2.number().min(0).max(1).default(0.05),
      volatility: z2.number().min(0.01).max(5).default(0.25)
    })).mutation(async ({ input }) => {
      return analyzeStrategy(
        input.legs,
        input.underlyingPrice,
        input.timeToExpiry,
        input.riskFreeRate,
        input.volatility
      );
    }),
    // Live Options Chain from Alpaca
    liveChain: protectedProcedure.input(z2.object({
      underlying: z2.string(),
      type: z2.enum(["call", "put"]).optional(),
      minStrike: z2.number().optional(),
      maxStrike: z2.number().optional(),
      minDaysToExpiry: z2.number().optional(),
      maxDaysToExpiry: z2.number().optional(),
      limit: z2.number().max(1e3).optional()
    })).query(async ({ input }) => {
      return getOptionsChainWithGreeks(input.underlying, {
        type: input.type,
        minStrike: input.minStrike,
        maxStrike: input.maxStrike,
        minDaysToExpiry: input.minDaysToExpiry,
        maxDaysToExpiry: input.maxDaysToExpiry,
        limit: input.limit
      });
    }),
    // Live Options Analysis
    liveAnalysis: protectedProcedure.input(z2.object({
      underlying: z2.string(),
      spotPrice: z2.number().positive()
    })).query(async ({ input }) => {
      return analyzeLiveOptions(input.underlying, input.spotPrice);
    }),
    // ATM Straddle Pricing
    atmStraddle: protectedProcedure.input(z2.object({
      underlying: z2.string(),
      spotPrice: z2.number().positive(),
      targetDTE: z2.number().min(1).max(365).default(30)
    })).query(async ({ input }) => {
      return getATMStraddle(input.underlying, input.spotPrice, input.targetDTE);
    }),
    // IV Surface Analysis
    ivSurface: protectedProcedure.input(z2.object({
      underlying: z2.string(),
      spotPrice: z2.number().positive()
    })).query(async ({ input }) => {
      return getLiveIVSurface(input.underlying, input.spotPrice);
    }),
    // Full Volatility Surface Analysis
    volatilitySurface: protectedProcedure.input(z2.object({
      underlying: z2.string(),
      spotPrice: z2.number().positive()
    })).query(async ({ input }) => {
      return analyzeLiveVolatilitySurface(input.underlying, input.spotPrice);
    }),
    // IV Rank
    ivRank: protectedProcedure.input(z2.object({
      underlying: z2.string(),
      spotPrice: z2.number().positive()
    })).query(async ({ input }) => {
      return getIVRank(input.underlying, input.spotPrice);
    }),
    // Surface Summary
    surfaceSummary: protectedProcedure.input(z2.object({
      underlying: z2.string(),
      spotPrice: z2.number().positive()
    })).query(async ({ input }) => {
      return getVolatilitySurfaceSummary(input.underlying, input.spotPrice);
    }),
    // Options Alerts
    createAlert: protectedProcedure.input(z2.object({
      underlying: z2.string(),
      condition: z2.enum(["iv_spike", "iv_crush", "unusual_volume", "gamma_squeeze", "delta_threshold"]),
      threshold: z2.number()
    })).mutation(async ({ input }) => {
      return createOptionsAlert(input.underlying, input.condition, input.threshold);
    }),
    getAlerts: protectedProcedure.query(async () => {
      return getActiveAlerts();
    }),
    removeAlert: protectedProcedure.input(z2.object({ alertId: z2.string() })).mutation(async ({ input }) => {
      return removeAlert(input.alertId);
    }),
    // Cache Management
    clearCache: protectedProcedure.input(z2.object({ underlying: z2.string().optional() })).mutation(async ({ input }) => {
      clearOptionsCache(input.underlying);
      return { success: true };
    }),
    cacheStatus: protectedProcedure.query(async () => {
      return getCacheStatus();
    }),
    // Alpaca Options Status
    alpacaStatus: protectedProcedure.query(async () => {
      return getAlpacaOptionsStatus();
    })
  }),
  // Sentiment Analysis
  sentiment: router({
    analyze: protectedProcedure.input(z2.object({ symbol: z2.string() })).mutation(async ({ input }) => {
      return analyzeSentiment(input.symbol);
    }),
    quick: protectedProcedure.input(z2.object({ symbol: z2.string() })).query(async ({ input }) => {
      return getQuickSentiment(input.symbol);
    }),
    batch: protectedProcedure.input(z2.object({ symbols: z2.array(z2.string()).max(10) })).mutation(async ({ input }) => {
      return analyzeBatchSentiment(input.symbols);
    })
  }),
  // Crypto Trading
  crypto: router({
    price: protectedProcedure.input(z2.object({ symbol: z2.string() })).query(async ({ input }) => {
      return getCryptoPrice(input.symbol);
    }),
    prices: protectedProcedure.input(z2.object({ symbols: z2.array(z2.string()).optional() })).query(async ({ input }) => {
      return getCryptoPrices(input.symbols);
    }),
    ohlcv: protectedProcedure.input(z2.object({ symbol: z2.string(), interval: z2.enum(["1h", "4h", "1d", "1w"]).optional(), limit: z2.number().optional() })).query(async ({ input }) => {
      return getCryptoOHLCV(input.symbol, input.interval, input.limit);
    }),
    indicators: protectedProcedure.input(z2.object({ symbol: z2.string() })).query(async ({ input }) => {
      return getCryptoIndicators(input.symbol);
    }),
    analysis: protectedProcedure.input(z2.object({ symbol: z2.string() })).mutation(async ({ input }) => {
      return analyzeCrypto(input.symbol);
    }),
    defiProtocols: protectedProcedure.query(async () => {
      return getDeFiProtocols();
    })
  }),
  // Paper Trading
  paperTrading: router({
    createAccount: protectedProcedure.input(z2.object({
      name: z2.string(),
      initialBalance: z2.number().optional()
    })).mutation(async ({ ctx, input }) => {
      return createPaperAccount(String(ctx.user.id), input.name, input.initialBalance);
    }),
    getAccount: protectedProcedure.input(z2.object({ accountId: z2.string() })).query(async ({ input }) => {
      return getPaperAccount(input.accountId);
    }),
    listAccounts: protectedProcedure.query(async ({ ctx }) => {
      return getUserPaperAccounts(String(ctx.user.id));
    }),
    placeOrder: protectedProcedure.input(z2.object({
      accountId: z2.string(),
      symbol: z2.string(),
      assetType: z2.enum(["stock", "crypto"]),
      side: z2.enum(["buy", "sell"]),
      type: z2.enum(["market", "limit", "stop_loss", "take_profit", "stop_limit"]),
      quantity: z2.number(),
      price: z2.number().optional(),
      stopPrice: z2.number().optional(),
      takeProfitPrice: z2.number().optional(),
      stopLossPrice: z2.number().optional()
    })).mutation(async ({ input }) => {
      return placePaperOrder(
        input.accountId,
        input.symbol,
        input.assetType,
        input.side,
        input.type,
        input.quantity,
        {
          price: input.price,
          stopPrice: input.stopPrice,
          takeProfitPrice: input.takeProfitPrice,
          stopLossPrice: input.stopLossPrice
        }
      );
    }),
    getPositions: protectedProcedure.input(z2.object({ accountId: z2.string() })).query(async ({ input }) => {
      return getAccountPositions(input.accountId);
    }),
    getOrders: protectedProcedure.input(z2.object({ accountId: z2.string(), status: z2.string().optional() })).query(async ({ input }) => {
      return getAccountOrders(input.accountId, input.status);
    }),
    getTradeHistory: protectedProcedure.input(z2.object({ accountId: z2.string() })).query(async ({ input }) => {
      return getTradeHistory(input.accountId);
    }),
    cancelOrder: protectedProcedure.input(z2.object({ orderId: z2.string() })).mutation(async ({ input }) => {
      return cancelOrder(input.orderId);
    }),
    getPerformance: protectedProcedure.input(z2.object({ accountId: z2.string() })).query(async ({ input }) => {
      return calculatePerformanceMetrics(input.accountId);
    }),
    resetAccount: protectedProcedure.input(z2.object({ accountId: z2.string() })).mutation(async ({ input }) => {
      return resetPaperAccount(input.accountId);
    })
  }),
  // Alerts
  alerts: router({
    createPriceAlert: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      assetType: z2.enum(["stock", "crypto"]),
      alertType: z2.enum(["price_above", "price_below", "percent_change", "volume_spike"]),
      targetValue: z2.number(),
      message: z2.string().optional(),
      notifyEmail: z2.boolean().optional(),
      notifyPush: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      return createPriceAlert(
        String(ctx.user.id),
        input.symbol,
        input.assetType,
        input.alertType,
        input.targetValue,
        {
          message: input.message,
          notifyEmail: input.notifyEmail,
          notifyPush: input.notifyPush
        }
      );
    }),
    createRegimeAlert: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      toRegime: z2.enum(["bull", "bear", "sideways", "volatile"]),
      fromRegime: z2.enum(["bull", "bear", "sideways", "volatile"]).optional(),
      notifyEmail: z2.boolean().optional(),
      notifyPush: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      return createRegimeAlert(
        String(ctx.user.id),
        input.symbol,
        input.toRegime,
        {
          fromRegime: input.fromRegime,
          notifyEmail: input.notifyEmail,
          notifyPush: input.notifyPush
        }
      );
    }),
    createSentimentAlert: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      alertType: z2.enum(["sentiment_bullish", "sentiment_bearish", "fear_greed_extreme", "sentiment_shift"]),
      threshold: z2.number().optional(),
      notifyEmail: z2.boolean().optional(),
      notifyPush: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      return createSentimentAlert(
        String(ctx.user.id),
        input.symbol,
        input.alertType,
        {
          threshold: input.threshold,
          notifyEmail: input.notifyEmail,
          notifyPush: input.notifyPush
        }
      );
    }),
    getPriceAlerts: protectedProcedure.query(async ({ ctx }) => {
      return getUserPriceAlerts(String(ctx.user.id));
    }),
    getRegimeAlerts: protectedProcedure.query(async ({ ctx }) => {
      return getUserRegimeAlerts(String(ctx.user.id));
    }),
    getSentimentAlerts: protectedProcedure.query(async ({ ctx }) => {
      return getUserSentimentAlerts(String(ctx.user.id));
    }),
    getHistory: protectedProcedure.input(z2.object({ limit: z2.number().optional() })).query(async ({ ctx, input }) => {
      return getAlertHistory(String(ctx.user.id), input.limit);
    }),
    togglePriceAlert: protectedProcedure.input(z2.object({ alertId: z2.string(), isActive: z2.boolean() })).mutation(async ({ input }) => {
      return togglePriceAlert(input.alertId, input.isActive);
    }),
    toggleRegimeAlert: protectedProcedure.input(z2.object({ alertId: z2.string(), isActive: z2.boolean() })).mutation(async ({ input }) => {
      return toggleRegimeAlert(input.alertId, input.isActive);
    }),
    toggleSentimentAlert: protectedProcedure.input(z2.object({ alertId: z2.string(), isActive: z2.boolean() })).mutation(async ({ input }) => {
      return toggleSentimentAlert(input.alertId, input.isActive);
    }),
    deletePriceAlert: protectedProcedure.input(z2.object({ alertId: z2.string() })).mutation(async ({ input }) => {
      return deletePriceAlert(input.alertId);
    }),
    deleteRegimeAlert: protectedProcedure.input(z2.object({ alertId: z2.string() })).mutation(async ({ input }) => {
      return deleteRegimeAlert(input.alertId);
    }),
    deleteSentimentAlert: protectedProcedure.input(z2.object({ alertId: z2.string() })).mutation(async ({ input }) => {
      return deleteSentimentAlert(input.alertId);
    }),
    markAsRead: protectedProcedure.input(z2.object({ alertHistoryId: z2.string() })).mutation(async ({ input }) => {
      return markAlertAsRead(input.alertHistoryId);
    }),
    getSummary: protectedProcedure.query(async ({ ctx }) => {
      return getAlertSummary(String(ctx.user.id));
    })
  }),
  // Copy Trading Router
  copyTrading: router({
    getTopTraders: protectedProcedure.input(z2.object({
      sortBy: z2.enum(["return", "winRate", "followers", "sharpe"]).optional(),
      limit: z2.number().optional()
    }).optional()).query(async ({ input }) => {
      return getTopTraders2(input?.sortBy, input?.limit);
    }),
    getTrader: protectedProcedure.input(z2.object({ traderId: z2.string() })).query(async ({ input }) => {
      return getTraderById(input.traderId);
    }),
    follow: protectedProcedure.input(z2.object({
      traderId: z2.string(),
      settings: z2.object({
        allocationMode: z2.enum(["fixed", "percentage", "proportional"]).default("fixed"),
        allocationAmount: z2.number().default(1e3),
        maxPositionSize: z2.number().optional(),
        maxDailyLoss: z2.number().optional(),
        copyStopLoss: z2.boolean().optional(),
        copyTakeProfit: z2.boolean().optional(),
        excludeSymbols: z2.array(z2.string()).optional()
      })
    })).mutation(async ({ ctx, input }) => {
      return startCopyTrading(String(ctx.user.id), input.traderId, input.settings);
    }),
    unfollow: protectedProcedure.input(z2.object({ copySettingsId: z2.string() })).mutation(async ({ input }) => {
      return stopCopyTrading(input.copySettingsId);
    }),
    getFollowed: protectedProcedure.query(async ({ ctx }) => {
      return getUserCopySettings(String(ctx.user.id));
    }),
    getSettings: protectedProcedure.input(z2.object({ copySettingsId: z2.string() })).query(async ({ input }) => {
      return getCopySettingsById(input.copySettingsId);
    }),
    updateSettings: protectedProcedure.input(z2.object({
      copySettingsId: z2.string(),
      settings: z2.object({
        allocationMode: z2.enum(["fixed", "percentage", "proportional"]).optional(),
        allocationAmount: z2.number().optional(),
        maxPositionSize: z2.number().optional(),
        maxDailyLoss: z2.number().optional(),
        copyStopLoss: z2.boolean().optional(),
        copyTakeProfit: z2.boolean().optional(),
        excludeSymbols: z2.array(z2.string()).optional()
      })
    })).mutation(async ({ input }) => {
      return updateCopySettings(input.copySettingsId, input.settings);
    }),
    getHistory: protectedProcedure.input(z2.object({
      limit: z2.number().optional()
    }).optional()).query(async ({ ctx, input }) => {
      return getUserCopyTrades(String(ctx.user.id), input?.limit);
    }),
    getStats: protectedProcedure.query(async ({ ctx }) => {
      return getCopyPerformance(String(ctx.user.id));
    }),
    pause: protectedProcedure.input(z2.object({ copySettingsId: z2.string() })).mutation(async ({ input }) => {
      return pauseCopyTrading(input.copySettingsId);
    }),
    resume: protectedProcedure.input(z2.object({ copySettingsId: z2.string() })).mutation(async ({ input }) => {
      return resumeCopyTrading(input.copySettingsId);
    })
  }),
  // Trading Journal Router
  journal: router({
    create: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      side: z2.enum(["long", "short"]),
      entryPrice: z2.number(),
      exitPrice: z2.number().optional(),
      quantity: z2.number(),
      entryDate: z2.date(),
      exitDate: z2.date().optional(),
      setup: z2.enum(["breakout", "pullback", "reversal", "trend_following", "range_bound", "news_based", "technical", "fundamental", "other"]),
      emotionBefore: z2.enum(["confident", "anxious", "greedy", "fearful", "neutral", "excited", "frustrated", "calm"]),
      emotionDuring: z2.enum(["confident", "anxious", "greedy", "fearful", "neutral", "excited", "frustrated", "calm"]).optional(),
      emotionAfter: z2.enum(["confident", "anxious", "greedy", "fearful", "neutral", "excited", "frustrated", "calm"]).optional(),
      confidenceLevel: z2.number().min(1).max(10),
      planFollowed: z2.boolean(),
      notes: z2.string(),
      lessonsLearned: z2.string().optional(),
      mistakes: z2.array(z2.string()).optional(),
      tags: z2.array(z2.string()),
      screenshots: z2.array(z2.string()).optional(),
      tradeId: z2.string().optional()
    })).mutation(async ({ ctx, input }) => {
      return createJournalEntry(String(ctx.user.id), input);
    }),
    update: protectedProcedure.input(z2.object({
      entryId: z2.string(),
      updates: z2.object({
        exitPrice: z2.number().optional(),
        exitDate: z2.date().optional(),
        emotionDuring: z2.enum(["confident", "anxious", "greedy", "fearful", "neutral", "excited", "frustrated", "calm"]).optional(),
        emotionAfter: z2.enum(["confident", "anxious", "greedy", "fearful", "neutral", "excited", "frustrated", "calm"]).optional(),
        notes: z2.string().optional(),
        lessonsLearned: z2.string().optional(),
        mistakes: z2.array(z2.string()).optional(),
        tags: z2.array(z2.string()).optional()
      })
    })).mutation(async ({ ctx, input }) => {
      return updateJournalEntry(String(ctx.user.id), input.entryId, input.updates);
    }),
    delete: protectedProcedure.input(z2.object({ entryId: z2.string() })).mutation(async ({ ctx, input }) => {
      return deleteJournalEntry(String(ctx.user.id), input.entryId);
    }),
    getById: protectedProcedure.input(z2.object({ entryId: z2.string() })).query(async ({ ctx, input }) => {
      return getJournalEntryById(String(ctx.user.id), input.entryId);
    }),
    list: protectedProcedure.input(z2.object({
      filters: z2.object({
        symbol: z2.string().optional(),
        setup: z2.enum(["breakout", "pullback", "reversal", "trend_following", "range_bound", "news_based", "technical", "fundamental", "other"]).optional(),
        emotion: z2.enum(["confident", "anxious", "greedy", "fearful", "neutral", "excited", "frustrated", "calm"]).optional(),
        outcome: z2.enum(["win", "loss", "breakeven", "open"]).optional(),
        tags: z2.array(z2.string()).optional(),
        startDate: z2.date().optional(),
        endDate: z2.date().optional(),
        minPnL: z2.number().optional(),
        maxPnL: z2.number().optional()
      }).optional(),
      limit: z2.number().optional(),
      offset: z2.number().optional()
    }).optional()).query(async ({ ctx, input }) => {
      return getUserJournalEntries(String(ctx.user.id), input?.filters, input?.limit, input?.offset);
    }),
    getByDate: protectedProcedure.input(z2.object({ year: z2.number(), month: z2.number() })).query(async ({ ctx, input }) => {
      return getJournalEntriesByDate(String(ctx.user.id), input.year, input.month);
    }),
    getStats: protectedProcedure.input(z2.object({
      startDate: z2.date().optional(),
      endDate: z2.date().optional()
    }).optional()).query(async ({ ctx, input }) => {
      const timeframe = input?.startDate && input?.endDate ? { startDate: input.startDate, endDate: input.endDate } : void 0;
      return getJournalStats(String(ctx.user.id), timeframe);
    }),
    getEmotionCorrelations: protectedProcedure.query(async ({ ctx }) => {
      return getEmotionCorrelations(String(ctx.user.id));
    }),
    getPatterns: protectedProcedure.query(async ({ ctx }) => {
      return detectTradingPatterns(String(ctx.user.id));
    }),
    getTags: protectedProcedure.query(async ({ ctx }) => {
      return getUserTags(String(ctx.user.id));
    }),
    search: protectedProcedure.input(z2.object({ query: z2.string() })).query(async ({ ctx, input }) => {
      return searchJournalEntries(String(ctx.user.id), input.query);
    })
  }),
  // Exchange Integration Router
  exchange: router({
    getAvailable: publicProcedure.query(async () => {
      return getAvailableExchanges();
    }),
    getInfo: publicProcedure.input(z2.object({ exchange: z2.enum(["binance", "coinbase", "alpaca", "interactive_brokers"]) })).query(async ({ input }) => {
      return getExchangeInfo(input.exchange);
    }),
    connect: protectedProcedure.input(z2.object({
      exchange: z2.enum(["binance", "coinbase", "alpaca", "interactive_brokers"]),
      credentials: z2.object({
        apiKey: z2.string(),
        apiSecret: z2.string(),
        passphrase: z2.string().optional(),
        accountId: z2.string().optional()
      })
    })).mutation(async ({ ctx, input }) => {
      return connectExchange(String(ctx.user.id), input.exchange, input.credentials);
    }),
    disconnect: protectedProcedure.input(z2.object({ connectionId: z2.string() })).mutation(async ({ ctx, input }) => {
      return disconnectExchange(String(ctx.user.id), input.connectionId);
    }),
    getConnections: protectedProcedure.query(async ({ ctx }) => {
      return getUserConnections(String(ctx.user.id));
    }),
    getConnection: protectedProcedure.input(z2.object({ connectionId: z2.string() })).query(async ({ ctx, input }) => {
      return getConnectionById(String(ctx.user.id), input.connectionId);
    }),
    getBalances: protectedProcedure.input(z2.object({ connectionId: z2.string() })).query(async ({ input }) => {
      return getExchangeBalances(input.connectionId);
    }),
    getPositions: protectedProcedure.input(z2.object({ connectionId: z2.string() })).query(async ({ input }) => {
      return getExchangePositions(input.connectionId);
    }),
    placeOrder: protectedProcedure.input(z2.object({
      connectionId: z2.string(),
      order: z2.object({
        symbol: z2.string(),
        side: z2.enum(["buy", "sell"]),
        type: z2.enum(["market", "limit", "stop", "stop_limit"]),
        quantity: z2.number(),
        price: z2.number().optional(),
        stopPrice: z2.number().optional()
      })
    })).mutation(async ({ input }) => {
      return placeExchangeOrder(input.connectionId, input.order);
    }),
    cancelOrder: protectedProcedure.input(z2.object({ connectionId: z2.string(), orderId: z2.string() })).mutation(async ({ input }) => {
      return cancelExchangeOrder(input.connectionId, input.orderId);
    }),
    getOrderHistory: protectedProcedure.input(z2.object({ connectionId: z2.string(), limit: z2.number().optional() })).query(async ({ input }) => {
      return getOrderHistory(input.connectionId, input.limit);
    }),
    sync: protectedProcedure.input(z2.object({ connectionId: z2.string() })).mutation(async ({ ctx, input }) => {
      return syncExchangeData(String(ctx.user.id), input.connectionId);
    }),
    getOAuthUrl: protectedProcedure.input(z2.object({
      exchange: z2.enum(["binance", "coinbase", "alpaca", "interactive_brokers"]),
      redirectUri: z2.string()
    })).query(async ({ input }) => {
      const state = Math.random().toString(36).substring(7);
      return { url: getOAuthUrl(input.exchange, input.redirectUri, state), state };
    }),
    handleOAuth: protectedProcedure.input(z2.object({
      exchange: z2.enum(["binance", "coinbase", "alpaca", "interactive_brokers"]),
      code: z2.string()
    })).mutation(async ({ ctx, input }) => {
      return handleOAuthCallback(String(ctx.user.id), input.exchange, input.code);
    }),
    testConnection: protectedProcedure.input(z2.object({ connectionId: z2.string() })).query(async ({ input }) => {
      return testConnection(input.connectionId);
    })
  }),
  // Production Broker Integration Router
  broker: router({
    // Get available brokers
    getAvailableBrokers: publicProcedure.query(async () => {
      return getAvailableBrokers();
    }),
    // Get broker info
    getBrokerInfo: publicProcedure.input(z2.object({
      brokerType: z2.enum(["alpaca", "interactive_brokers"])
    })).query(async ({ input }) => {
      return BROKER_INFO[input.brokerType];
    }),
    // Start OAuth flow for Alpaca
    startAlpacaOAuth: protectedProcedure.input(z2.object({
      isPaper: z2.boolean().default(true),
      redirectUri: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const clientId = process.env.ALPACA_CLIENT_ID;
      const clientSecret = process.env.ALPACA_CLIENT_SECRET;
      if (!clientId || !clientSecret) {
        throw new TRPCError3({
          code: "PRECONDITION_FAILED",
          message: "Alpaca API credentials not configured. Please add ALPACA_CLIENT_ID and ALPACA_CLIENT_SECRET."
        });
      }
      const adapter = new AlpacaAdapter({
        clientId,
        clientSecret,
        redirectUri: input.redirectUri,
        isPaper: input.isPaper
      });
      const oauthState = await createOAuthState(
        String(ctx.user.id),
        "alpaca" /* ALPACA */,
        input.isPaper
      );
      const authUrl = adapter.getAuthorizationUrl(oauthState.state, input.isPaper);
      return {
        authUrl,
        state: oauthState.state
      };
    }),
    // Start OAuth flow for Interactive Brokers (OAuth 2.0)
    startIBKROAuth: protectedProcedure.input(z2.object({
      isPaper: z2.boolean().default(true),
      redirectUri: z2.string(),
      authMethod: z2.enum(["oauth2", "oauth1"]).default("oauth2")
    })).mutation(async ({ ctx, input }) => {
      const clientId = process.env.IBKR_CLIENT_ID;
      const clientSecret = process.env.IBKR_CLIENT_SECRET;
      const consumerKey = process.env.IBKR_CONSUMER_KEY;
      const privateKey = process.env.IBKR_PRIVATE_KEY;
      const realm = process.env.IBKR_REALM || "limited_poa";
      const useOAuth2 = input.authMethod === "oauth2" && clientId;
      if (useOAuth2) {
        const adapter = new IBKRAdapter({
          clientId,
          clientSecret,
          redirectUri: input.redirectUri,
          isPaper: input.isPaper,
          authMethod: "oauth2"
        });
        const oauthState = await createOAuthState(
          String(ctx.user.id),
          "interactive_brokers" /* INTERACTIVE_BROKERS */,
          input.isPaper
        );
        const authUrl = adapter.getAuthorizationUrl(oauthState.state, input.isPaper);
        return {
          authUrl,
          state: oauthState.state,
          authMethod: "oauth2"
        };
      } else if (consumerKey && privateKey) {
        const adapter = new IBKRAdapter({
          consumerKey,
          privateKey,
          realm,
          redirectUri: input.redirectUri,
          isPaper: input.isPaper,
          authMethod: "oauth1"
        });
        const requestTokenResult = await adapter.getRequestToken();
        const oauthState = await createOAuthState(
          String(ctx.user.id),
          "interactive_brokers" /* INTERACTIVE_BROKERS */,
          input.isPaper,
          void 0,
          requestTokenResult.token,
          requestTokenResult.tokenSecret
        );
        const authUrl = adapter.getAuthorizationUrl(oauthState.state, input.isPaper);
        return {
          authUrl,
          state: oauthState.state,
          authMethod: "oauth1"
        };
      } else {
        throw new TRPCError3({
          code: "PRECONDITION_FAILED",
          message: "Interactive Brokers API credentials not configured. Please add IBKR_CLIENT_ID for OAuth 2.0 or IBKR_CONSUMER_KEY and IBKR_PRIVATE_KEY for OAuth 1.0a."
        });
      }
    }),
    // Handle OAuth callback for Alpaca
    handleAlpacaCallback: protectedProcedure.input(z2.object({
      code: z2.string(),
      state: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const oauthState = await getOAuthState(input.state);
      if (!oauthState || oauthState.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "BAD_REQUEST",
          message: "Invalid or expired OAuth state"
        });
      }
      const clientId = process.env.ALPACA_CLIENT_ID;
      const clientSecret = process.env.ALPACA_CLIENT_SECRET;
      const redirectUri = process.env.ALPACA_REDIRECT_URI || `${process.env.VITE_APP_URL || ""}/broker/alpaca/callback`;
      const adapter = new AlpacaAdapter({
        clientId,
        clientSecret,
        redirectUri,
        isPaper: oauthState.isPaper
      });
      const tokens = await adapter.handleOAuthCallback(input.code, input.state);
      await adapter.initialize({
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken
      });
      const accounts = await adapter.getAccounts();
      const account = accounts[0];
      const connection = await createBrokerConnection(
        String(ctx.user.id),
        "alpaca" /* ALPACA */,
        oauthState.isPaper,
        {
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken,
          expiresAt: tokens.expiresIn ? new Date(Date.now() + tokens.expiresIn * 1e3) : void 0
        },
        {
          accountId: account.id,
          accountNumber: account.accountNumber,
          accountType: account.accountType
        }
      );
      await deleteOAuthState(input.state);
      return {
        success: true,
        connectionId: connection.id,
        account: {
          id: account.id,
          accountNumber: account.accountNumber,
          accountType: account.accountType,
          isPaper: oauthState.isPaper
        }
      };
    }),
    // Handle OAuth callback for Interactive Brokers (OAuth 2.0)
    handleIBKRCallback: protectedProcedure.input(z2.object({
      // OAuth 2.0 uses code, OAuth 1.0a uses oauthToken/oauthVerifier
      code: z2.string().optional(),
      oauthToken: z2.string().optional(),
      oauthVerifier: z2.string().optional(),
      state: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const oauthState = await getOAuthState(input.state);
      if (!oauthState || oauthState.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "BAD_REQUEST",
          message: "Invalid or expired OAuth state"
        });
      }
      const isOAuth2 = !!input.code;
      let tokens;
      let adapter;
      if (isOAuth2) {
        const clientId = process.env.IBKR_CLIENT_ID;
        const clientSecret = process.env.IBKR_CLIENT_SECRET;
        const privateKey = process.env.IBKR_PRIVATE_KEY;
        const redirectUri = process.env.IBKR_REDIRECT_URI || `${process.env.VITE_APP_URL || ""}/broker/ibkr/callback`;
        adapter = new IBKRAdapter({
          clientId,
          clientSecret,
          privateKey,
          redirectUri,
          isPaper: oauthState.isPaper,
          authMethod: "oauth2"
        });
        tokens = await adapter.handleOAuthCallback(input.code, input.state);
      } else {
        if (!oauthState.requestToken || !oauthState.requestTokenSecret) {
          throw new TRPCError3({
            code: "BAD_REQUEST",
            message: "Missing request token for OAuth1 flow"
          });
        }
        if (!input.oauthVerifier) {
          throw new TRPCError3({
            code: "BAD_REQUEST",
            message: "Missing OAuth verifier for OAuth1 flow"
          });
        }
        const consumerKey = process.env.IBKR_CONSUMER_KEY;
        const privateKey = process.env.IBKR_PRIVATE_KEY;
        const realm = process.env.IBKR_REALM || "limited_poa";
        const redirectUri = process.env.IBKR_REDIRECT_URI || `${process.env.VITE_APP_URL || ""}/broker/ibkr/callback`;
        adapter = new IBKRAdapter({
          consumerKey,
          privateKey,
          realm,
          redirectUri,
          isPaper: oauthState.isPaper,
          authMethod: "oauth1"
        });
        tokens = await adapter.handleOAuthCallback(
          input.oauthVerifier,
          oauthState.requestToken,
          input.oauthVerifier
        );
      }
      await adapter.initialize({
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken
      });
      const accounts = await adapter.getAccounts();
      const account = accounts[0];
      const connection = await createBrokerConnection(
        String(ctx.user.id),
        "interactive_brokers" /* INTERACTIVE_BROKERS */,
        oauthState.isPaper,
        {
          accessToken: tokens.accessToken,
          refreshToken: tokens.refreshToken
        },
        {
          accountId: account.id,
          accountNumber: account.accountNumber,
          accountType: account.accountType
        }
      );
      await deleteOAuthState(input.state);
      return {
        success: true,
        connectionId: connection.id,
        account: {
          id: account.id,
          accountNumber: account.accountNumber,
          accountType: account.accountType,
          isPaper: oauthState.isPaper
        }
      };
    }),
    // Get user's broker connections
    getConnections: protectedProcedure.query(async ({ ctx }) => {
      const connections = await getUserBrokerConnections(String(ctx.user.id));
      return connections.map((conn) => ({
        id: conn.id,
        brokerType: conn.brokerType,
        isPaper: conn.isPaper,
        isActive: conn.isActive,
        accountId: conn.accountId,
        accountNumber: conn.accountNumber,
        accountType: conn.accountType,
        lastConnectedAt: conn.lastConnectedAt,
        lastSyncAt: conn.lastSyncAt,
        connectionError: conn.connectionError,
        createdAt: conn.createdAt
      }));
    }),
    // Disconnect a broker
    disconnect: protectedProcedure.input(z2.object({ connectionId: z2.string() })).mutation(async ({ ctx, input }) => {
      const connection = await getBrokerConnection(input.connectionId);
      if (!connection || connection.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: "Connection not found"
        });
      }
      await deleteBrokerConnection(input.connectionId);
      return { success: true };
    }),
    // Get account balance
    getBalance: protectedProcedure.input(z2.object({ connectionId: z2.string() })).query(async ({ ctx, input }) => {
      const connection = await getBrokerConnection(input.connectionId);
      if (!connection || connection.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: "Connection not found"
        });
      }
      const config = {
        alpaca: process.env.ALPACA_CLIENT_ID ? {
          clientId: process.env.ALPACA_CLIENT_ID,
          clientSecret: process.env.ALPACA_CLIENT_SECRET,
          redirectUri: process.env.ALPACA_REDIRECT_URI || ""
        } : void 0,
        ibkr: process.env.IBKR_CONSUMER_KEY ? {
          consumerKey: process.env.IBKR_CONSUMER_KEY,
          privateKey: process.env.IBKR_PRIVATE_KEY,
          realm: process.env.IBKR_REALM || "limited_poa",
          redirectUri: process.env.IBKR_REDIRECT_URI || ""
        } : void 0
      };
      const adapter = await initializeBrokerAdapter(connection, config);
      const balance = await adapter.getAccountBalance();
      await updateBrokerConnection(input.connectionId, { lastSyncAt: /* @__PURE__ */ new Date() });
      return balance;
    }),
    // Get positions
    getPositions: protectedProcedure.input(z2.object({ connectionId: z2.string() })).query(async ({ ctx, input }) => {
      const connection = await getBrokerConnection(input.connectionId);
      if (!connection || connection.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: "Connection not found"
        });
      }
      const config = {
        alpaca: process.env.ALPACA_CLIENT_ID ? {
          clientId: process.env.ALPACA_CLIENT_ID,
          clientSecret: process.env.ALPACA_CLIENT_SECRET,
          redirectUri: process.env.ALPACA_REDIRECT_URI || ""
        } : void 0,
        ibkr: process.env.IBKR_CONSUMER_KEY ? {
          consumerKey: process.env.IBKR_CONSUMER_KEY,
          privateKey: process.env.IBKR_PRIVATE_KEY,
          realm: process.env.IBKR_REALM || "limited_poa",
          redirectUri: process.env.IBKR_REDIRECT_URI || ""
        } : void 0
      };
      const adapter = await initializeBrokerAdapter(connection, config);
      const positions = await adapter.getPositions();
      await syncBrokerPositions(
        input.connectionId,
        String(ctx.user.id),
        positions.map((pos) => ({
          symbol: pos.symbol,
          quantity: pos.quantity,
          side: pos.side,
          avgEntryPrice: pos.avgEntryPrice,
          marketValue: pos.marketValue,
          costBasis: pos.costBasis,
          unrealizedPL: pos.unrealizedPL,
          unrealizedPLPercent: pos.unrealizedPLPercent,
          currentPrice: pos.currentPrice
        }))
      );
      return positions;
    }),
    // Place order
    placeOrder: protectedProcedure.input(z2.object({
      connectionId: z2.string(),
      symbol: z2.string(),
      side: z2.enum(["buy", "sell"]),
      orderType: z2.enum(["market", "limit", "stop", "stop_limit", "trailing_stop"]),
      quantity: z2.number().positive(),
      price: z2.number().optional(),
      stopPrice: z2.number().optional(),
      trailPercent: z2.number().optional(),
      timeInForce: z2.enum(["day", "gtc", "ioc", "fok"]).default("day"),
      extendedHours: z2.boolean().default(false)
    })).mutation(async ({ ctx, input }) => {
      const connection = await getBrokerConnection(input.connectionId);
      if (!connection || connection.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: "Connection not found"
        });
      }
      const config = {
        alpaca: process.env.ALPACA_CLIENT_ID ? {
          clientId: process.env.ALPACA_CLIENT_ID,
          clientSecret: process.env.ALPACA_CLIENT_SECRET,
          redirectUri: process.env.ALPACA_REDIRECT_URI || ""
        } : void 0,
        ibkr: process.env.IBKR_CONSUMER_KEY ? {
          consumerKey: process.env.IBKR_CONSUMER_KEY,
          privateKey: process.env.IBKR_PRIVATE_KEY,
          realm: process.env.IBKR_REALM || "limited_poa",
          redirectUri: process.env.IBKR_REDIRECT_URI || ""
        } : void 0
      };
      const adapter = await initializeBrokerAdapter(connection, config);
      const dbOrder = await createBrokerOrder(
        input.connectionId,
        String(ctx.user.id),
        {
          symbol: input.symbol,
          side: input.side === "buy" ? "buy" /* BUY */ : "sell" /* SELL */,
          orderType: input.orderType.toUpperCase(),
          timeInForce: input.timeInForce.toUpperCase(),
          quantity: input.quantity,
          price: input.price,
          stopPrice: input.stopPrice,
          trailPercent: input.trailPercent,
          extendedHours: input.extendedHours
        }
      );
      try {
        const orderResponse = await adapter.placeOrder({
          symbol: input.symbol,
          side: input.side === "buy" ? "buy" /* BUY */ : "sell" /* SELL */,
          type: input.orderType.toUpperCase(),
          timeInForce: input.timeInForce.toUpperCase(),
          quantity: input.quantity,
          price: input.price,
          stopPrice: input.stopPrice,
          trailPercent: input.trailPercent,
          extendedHours: input.extendedHours,
          clientOrderId: dbOrder.clientOrderId || void 0
        });
        await updateBrokerOrder(dbOrder.id, {
          brokerOrderId: orderResponse.id,
          status: orderResponse.status
        });
        return {
          success: true,
          orderId: dbOrder.id,
          brokerOrderId: orderResponse.id,
          status: orderResponse.status
        };
      } catch (error) {
        await updateBrokerOrder(dbOrder.id, {
          status: "rejected"
        });
        throw new TRPCError3({
          code: "INTERNAL_SERVER_ERROR",
          message: error instanceof Error ? error.message : "Failed to place order"
        });
      }
    }),
    // Cancel order
    cancelOrder: protectedProcedure.input(z2.object({
      connectionId: z2.string(),
      orderId: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const connection = await getBrokerConnection(input.connectionId);
      if (!connection || connection.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: "Connection not found"
        });
      }
      const order = await getBrokerOrder(input.orderId);
      if (!order || order.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: "Order not found"
        });
      }
      const config = {
        alpaca: process.env.ALPACA_CLIENT_ID ? {
          clientId: process.env.ALPACA_CLIENT_ID,
          clientSecret: process.env.ALPACA_CLIENT_SECRET,
          redirectUri: process.env.ALPACA_REDIRECT_URI || ""
        } : void 0,
        ibkr: process.env.IBKR_CONSUMER_KEY ? {
          consumerKey: process.env.IBKR_CONSUMER_KEY,
          privateKey: process.env.IBKR_PRIVATE_KEY,
          realm: process.env.IBKR_REALM || "limited_poa",
          redirectUri: process.env.IBKR_REDIRECT_URI || ""
        } : void 0
      };
      const adapter = await initializeBrokerAdapter(connection, config);
      await adapter.cancelOrder(order.brokerOrderId || input.orderId);
      await updateBrokerOrder(input.orderId, {
        status: "cancelled",
        cancelledAt: /* @__PURE__ */ new Date()
      });
      return { success: true };
    }),
    // Get orders
    getOrders: protectedProcedure.input(z2.object({
      connectionId: z2.string().optional(),
      limit: z2.number().default(50)
    })).query(async ({ ctx, input }) => {
      return getUserBrokerOrders(String(ctx.user.id), input.connectionId, input.limit);
    }),
    // Get cached positions from database
    getCachedPositions: protectedProcedure.input(z2.object({ connectionId: z2.string().optional() })).query(async ({ ctx, input }) => {
      return getUserBrokerPositions(String(ctx.user.id), input.connectionId);
    }),
    // Test broker connection
    testBrokerConnection: protectedProcedure.input(z2.object({ connectionId: z2.string() })).query(async ({ ctx, input }) => {
      const connection = await getBrokerConnection(input.connectionId);
      if (!connection || connection.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: "Connection not found"
        });
      }
      const config = {
        alpaca: process.env.ALPACA_CLIENT_ID ? {
          clientId: process.env.ALPACA_CLIENT_ID,
          clientSecret: process.env.ALPACA_CLIENT_SECRET,
          redirectUri: process.env.ALPACA_REDIRECT_URI || ""
        } : void 0,
        ibkr: process.env.IBKR_CONSUMER_KEY ? {
          consumerKey: process.env.IBKR_CONSUMER_KEY,
          privateKey: process.env.IBKR_PRIVATE_KEY,
          realm: process.env.IBKR_REALM || "limited_poa",
          redirectUri: process.env.IBKR_REDIRECT_URI || ""
        } : void 0
      };
      try {
        const adapter = await initializeBrokerAdapter(connection, config);
        const isConnected2 = await adapter.testConnection();
        if (isConnected2) {
          await updateBrokerConnection(input.connectionId, {
            connectionError: null
          });
        }
        return { connected: isConnected2 };
      } catch (error) {
        await updateBrokerConnection(input.connectionId, {
          connectionError: error instanceof Error ? error.message : "Connection test failed"
        });
        return { connected: false, error: error instanceof Error ? error.message : "Unknown error" };
      }
    }),
    // Verify broker credentials (for wizard)
    verifyCredentials: protectedProcedure.input(z2.object({
      brokerType: z2.enum(["alpaca", "interactive_brokers", "binance", "coinbase", "schwab"]),
      apiKey: z2.string(),
      apiSecret: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const formatValidation = {
        alpaca: { key: /^[A-Z0-9]{20}$/, secret: /^[A-Za-z0-9]{40}$/ },
        interactive_brokers: { key: /^[A-Za-z0-9_-]{10,50}$/, secret: /^[A-Za-z0-9_-]{20,100}$/ },
        binance: { key: /^[A-Za-z0-9]{64}$/, secret: /^[A-Za-z0-9]{64}$/ },
        coinbase: { key: /^[a-z0-9-]{36}$/, secret: /^[A-Za-z0-9+/=]{88}$/ },
        schwab: { key: /^[A-Za-z0-9_-]{10,50}$/, secret: /^[A-Za-z0-9_-]{20,100}$/ }
      };
      const validation = formatValidation[input.brokerType];
      if (validation) {
        if (!validation.key.test(input.apiKey)) {
          throw new TRPCError3({
            code: "BAD_REQUEST",
            message: "Invalid API key format"
          });
        }
        if (!validation.secret.test(input.apiSecret)) {
          throw new TRPCError3({
            code: "BAD_REQUEST",
            message: "Invalid API secret format"
          });
        }
      }
      const brokerNames = {
        alpaca: "Alpaca",
        interactive_brokers: "IB",
        binance: "Binance",
        coinbase: "Coinbase",
        schwab: "Schwab"
      };
      const mockAccountInfo = {
        accountId: `${input.brokerType.toUpperCase()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`,
        accountName: `${brokerNames[input.brokerType] || input.brokerType} Account`,
        balance: input.brokerType === "alpaca" || input.brokerType === "interactive_brokers" || input.brokerType === "schwab" ? 1e5 : 1e4,
        currency: input.brokerType === "binance" || input.brokerType === "coinbase" ? "USDT" : "USD",
        isPaper: input.brokerType === "alpaca" || input.brokerType === "interactive_brokers"
      };
      return {
        success: true,
        accountInfo: mockAccountInfo
      };
    }),
    // Connect broker with API credentials (for wizard)
    connect: protectedProcedure.input(z2.object({
      brokerType: z2.enum(["alpaca", "interactive_brokers", "binance", "coinbase", "schwab"]),
      apiKey: z2.string(),
      apiSecret: z2.string(),
      accountName: z2.string(),
      isPaper: z2.boolean().default(true),
      enableAutoSync: z2.boolean().default(true),
      syncIntervalMinutes: z2.number().min(1).max(60).default(5)
    })).mutation(async ({ ctx, input }) => {
      const connectionId = `conn-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const brokerTypeMap = {
        alpaca: "alpaca" /* ALPACA */,
        interactive_brokers: "interactive_brokers" /* INTERACTIVE_BROKERS */,
        binance: "binance" /* BINANCE */,
        coinbase: "coinbase" /* COINBASE */,
        schwab: "schwab" /* SCHWAB */
      };
      const brokerTypeEnum = brokerTypeMap[input.brokerType] || "alpaca" /* ALPACA */;
      const connection = await createBrokerConnection(
        String(ctx.user.id),
        brokerTypeEnum,
        input.isPaper,
        {
          accessToken: input.apiKey,
          refreshToken: input.apiSecret,
          expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1e3)
          // 1 year
        },
        {
          accountId: `${input.brokerType.toUpperCase()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`,
          accountNumber: `ACC-${Math.random().toString(36).substr(2, 9).toUpperCase()}`,
          accountType: input.isPaper ? "paper" : "live"
        }
      );
      return {
        success: true,
        connectionId: connection.id,
        accountId: connection.accountId
      };
    }),
    // Sync positions for a connection
    syncPositions: protectedProcedure.input(z2.object({ connectionId: z2.string() })).mutation(async ({ ctx, input }) => {
      const connection = await getBrokerConnection(input.connectionId);
      if (!connection || connection.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: "Connection not found"
        });
      }
      const { syncConnectionPositions: syncConnectionPositions2 } = await Promise.resolve().then(() => (init_positionSync(), positionSync_exports));
      const result = await syncConnectionPositions2(input.connectionId);
      return result;
    }),
    // Sync all positions for user
    syncAllPositions: protectedProcedure.mutation(async ({ ctx }) => {
      const { syncUserPositions: syncUserPositions2 } = await Promise.resolve().then(() => (init_positionSync(), positionSync_exports));
      const result = await syncUserPositions2(String(ctx.user.id));
      return result;
    }),
    // Get sync status for all connections
    getSyncStatus: protectedProcedure.query(async ({ ctx }) => {
      const { getUserSyncStatus: getUserSyncStatus2 } = await Promise.resolve().then(() => (init_positionSync(), positionSync_exports));
      const status = await getUserSyncStatus2(String(ctx.user.id));
      return status;
    }),
    // Get aggregated positions across all brokers
    getAggregatedPositions: protectedProcedure.query(async ({ ctx }) => {
      const { getAggregatedPositions: getAggregatedPositions2 } = await Promise.resolve().then(() => (init_positionSync(), positionSync_exports));
      const result = await getAggregatedPositions2(String(ctx.user.id));
      return result;
    }),
    // Start auto-sync for a connection
    startAutoSync: protectedProcedure.input(z2.object({
      connectionId: z2.string(),
      intervalMinutes: z2.number().min(1).max(60).default(5)
    })).mutation(async ({ ctx, input }) => {
      const connection = await getBrokerConnection(input.connectionId);
      if (!connection || connection.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: "Connection not found"
        });
      }
      const { startAutoSync: startAutoSync2 } = await Promise.resolve().then(() => (init_positionSync(), positionSync_exports));
      startAutoSync2(input.connectionId, input.intervalMinutes);
      return { success: true };
    }),
    // Stop auto-sync for a connection
    stopAutoSync: protectedProcedure.input(z2.object({ connectionId: z2.string() })).mutation(async ({ ctx, input }) => {
      const connection = await getBrokerConnection(input.connectionId);
      if (!connection || connection.userId !== String(ctx.user.id)) {
        throw new TRPCError3({
          code: "NOT_FOUND",
          message: "Connection not found"
        });
      }
      const { stopAutoSync: stopAutoSync2 } = await Promise.resolve().then(() => (init_positionSync(), positionSync_exports));
      stopAutoSync2(input.connectionId);
      return { success: true };
    }),
    // ==================== ORDER HISTORY ====================
    // Get order execution history
    getOrderHistory: protectedProcedure.input(z2.object({
      connectionId: z2.string().optional(),
      symbol: z2.string().optional(),
      side: z2.enum(["buy", "sell"]).optional(),
      startDate: z2.string().optional(),
      endDate: z2.string().optional(),
      isClosingTrade: z2.boolean().optional(),
      limit: z2.number().min(1).max(100).default(50),
      offset: z2.number().min(0).default(0)
    })).query(async ({ ctx, input }) => {
      const { getOrderHistory: getOrderHistory3 } = await Promise.resolve().then(() => (init_orderHistory(), orderHistory_exports));
      return getOrderHistory3({
        userId: String(ctx.user.id),
        connectionId: input.connectionId,
        symbol: input.symbol,
        side: input.side,
        startDate: input.startDate ? new Date(input.startDate) : void 0,
        endDate: input.endDate ? new Date(input.endDate) : void 0,
        isClosingTrade: input.isClosingTrade,
        limit: input.limit,
        offset: input.offset
      });
    }),
    // Get P&L summary
    getPnLSummary: protectedProcedure.input(z2.object({
      connectionId: z2.string().optional(),
      startDate: z2.string().optional(),
      endDate: z2.string().optional()
    })).query(async ({ ctx, input }) => {
      const { getPnLSummary: getPnLSummary2 } = await Promise.resolve().then(() => (init_orderHistory(), orderHistory_exports));
      return getPnLSummary2(
        String(ctx.user.id),
        input.connectionId,
        input.startDate ? new Date(input.startDate) : void 0,
        input.endDate ? new Date(input.endDate) : void 0
      );
    }),
    // Get symbol P&L breakdown
    getSymbolPnLBreakdown: protectedProcedure.input(z2.object({
      connectionId: z2.string().optional(),
      startDate: z2.string().optional(),
      endDate: z2.string().optional()
    })).query(async ({ ctx, input }) => {
      const { getSymbolPnLBreakdown: getSymbolPnLBreakdown2 } = await Promise.resolve().then(() => (init_orderHistory(), orderHistory_exports));
      return getSymbolPnLBreakdown2(
        String(ctx.user.id),
        input.connectionId,
        input.startDate ? new Date(input.startDate) : void 0,
        input.endDate ? new Date(input.endDate) : void 0
      );
    }),
    // Get daily P&L for charting
    getDailyPnL: protectedProcedure.input(z2.object({
      connectionId: z2.string().optional(),
      days: z2.number().min(1).max(365).default(30)
    })).query(async ({ ctx, input }) => {
      const { getDailyPnL: getDailyPnL2 } = await Promise.resolve().then(() => (init_orderHistory(), orderHistory_exports));
      return getDailyPnL2(String(ctx.user.id), input.connectionId, input.days);
    }),
    // ==================== BROKER ANALYTICS ====================
    // Record account snapshot
    recordSnapshot: protectedProcedure.input(z2.object({
      connectionId: z2.string(),
      equity: z2.number(),
      cash: z2.number(),
      buyingPower: z2.number(),
      portfolioValue: z2.number(),
      marginUsed: z2.number().optional(),
      marginAvailable: z2.number().optional(),
      dayPL: z2.number().optional(),
      totalPL: z2.number().optional(),
      positionsCount: z2.number().optional()
    })).mutation(async ({ ctx, input }) => {
      const connection = await getBrokerConnection(input.connectionId);
      if (!connection || connection.userId !== String(ctx.user.id)) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Connection not found" });
      }
      const { recordAccountSnapshot: recordAccountSnapshot2 } = await Promise.resolve().then(() => (init_brokerAnalytics(), brokerAnalytics_exports));
      return recordAccountSnapshot2({
        ...input,
        userId: String(ctx.user.id)
      });
    }),
    // Get account snapshots
    getAccountSnapshots: protectedProcedure.input(z2.object({
      connectionId: z2.string(),
      days: z2.number().min(1).max(365).default(30)
    })).query(async ({ ctx, input }) => {
      const { getAccountSnapshots: getAccountSnapshots2 } = await Promise.resolve().then(() => (init_brokerAnalytics(), brokerAnalytics_exports));
      return getAccountSnapshots2(input.connectionId, String(ctx.user.id), input.days);
    }),
    // Get latest snapshot
    getLatestSnapshot: protectedProcedure.input(z2.object({ connectionId: z2.string() })).query(async ({ ctx, input }) => {
      const { getLatestSnapshot: getLatestSnapshot2 } = await Promise.resolve().then(() => (init_brokerAnalytics(), brokerAnalytics_exports));
      return getLatestSnapshot2(input.connectionId, String(ctx.user.id));
    }),
    // Calculate performance metrics
    calculateMetrics: protectedProcedure.input(z2.object({
      connectionId: z2.string(),
      periodType: z2.enum(["daily", "weekly", "monthly", "yearly", "all_time"])
    })).mutation(async ({ ctx, input }) => {
      const connection = await getBrokerConnection(input.connectionId);
      if (!connection || connection.userId !== String(ctx.user.id)) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Connection not found" });
      }
      const { calculatePerformanceMetrics: calculatePerformanceMetrics3 } = await Promise.resolve().then(() => (init_brokerAnalytics(), brokerAnalytics_exports));
      return calculatePerformanceMetrics3(input.connectionId, String(ctx.user.id), input.periodType);
    }),
    // Get performance metrics
    getPerformanceMetrics: protectedProcedure.input(z2.object({
      connectionId: z2.string(),
      periodType: z2.enum(["daily", "weekly", "monthly", "yearly", "all_time"]).optional()
    })).query(async ({ ctx, input }) => {
      const { getPerformanceMetrics: getPerformanceMetrics2 } = await Promise.resolve().then(() => (init_brokerAnalytics(), brokerAnalytics_exports));
      return getPerformanceMetrics2(input.connectionId, String(ctx.user.id), input.periodType);
    }),
    // Get aggregated analytics
    getAggregatedAnalytics: protectedProcedure.query(async ({ ctx }) => {
      const { getAggregatedAnalytics: getAggregatedAnalytics2 } = await Promise.resolve().then(() => (init_brokerAnalytics(), brokerAnalytics_exports));
      return getAggregatedAnalytics2(String(ctx.user.id));
    }),
    // Get buying power history
    getBuyingPowerHistory: protectedProcedure.input(z2.object({
      connectionId: z2.string(),
      days: z2.number().min(1).max(365).default(30)
    })).query(async ({ ctx, input }) => {
      const { getBuyingPowerHistory: getBuyingPowerHistory2 } = await Promise.resolve().then(() => (init_brokerAnalytics(), brokerAnalytics_exports));
      return getBuyingPowerHistory2(input.connectionId, String(ctx.user.id), input.days);
    }),
    // Get trade frequency analysis
    getTradeFrequency: protectedProcedure.input(z2.object({
      connectionId: z2.string(),
      days: z2.number().min(1).max(365).default(30)
    })).query(async ({ ctx, input }) => {
      const { getTradeFrequency: getTradeFrequency2 } = await Promise.resolve().then(() => (init_brokerAnalytics(), brokerAnalytics_exports));
      return getTradeFrequency2(input.connectionId, String(ctx.user.id), input.days);
    }),
    // ==================== PORTFOLIO REBALANCING ====================
    // Create allocation
    createAllocation: protectedProcedure.input(z2.object({
      name: z2.string().min(1).max(100),
      description: z2.string().max(500).optional(),
      targetAllocations: z2.array(z2.object({
        symbol: z2.string(),
        targetPercent: z2.number().min(0).max(100)
      })),
      rebalanceThreshold: z2.number().min(1).max(50).default(5),
      rebalanceFrequency: z2.enum(["manual", "daily", "weekly", "monthly", "quarterly"]).default("manual"),
      preferredBrokers: z2.array(z2.string()).optional()
    })).mutation(async ({ ctx, input }) => {
      const { createAllocation: createAllocation2 } = await Promise.resolve().then(() => (init_portfolioRebalancing(), portfolioRebalancing_exports));
      return createAllocation2({
        userId: String(ctx.user.id),
        ...input
      });
    }),
    // Update allocation
    updateAllocation: protectedProcedure.input(z2.object({
      allocationId: z2.string(),
      name: z2.string().min(1).max(100).optional(),
      description: z2.string().max(500).optional(),
      targetAllocations: z2.array(z2.object({
        symbol: z2.string(),
        targetPercent: z2.number().min(0).max(100)
      })).optional(),
      rebalanceThreshold: z2.number().min(1).max(50).optional(),
      rebalanceFrequency: z2.enum(["manual", "daily", "weekly", "monthly", "quarterly"]).optional(),
      preferredBrokers: z2.array(z2.string()).optional()
    })).mutation(async ({ ctx, input }) => {
      const { updateAllocation: updateAllocation2 } = await Promise.resolve().then(() => (init_portfolioRebalancing(), portfolioRebalancing_exports));
      const { allocationId, ...updates } = input;
      return updateAllocation2(allocationId, String(ctx.user.id), updates);
    }),
    // Get allocation
    getAllocation: protectedProcedure.input(z2.object({ allocationId: z2.string() })).query(async ({ ctx, input }) => {
      const { getAllocation: getAllocation2 } = await Promise.resolve().then(() => (init_portfolioRebalancing(), portfolioRebalancing_exports));
      return getAllocation2(input.allocationId, String(ctx.user.id));
    }),
    // Get user allocations
    getUserAllocations: protectedProcedure.query(async ({ ctx }) => {
      const { getUserAllocations: getUserAllocations2 } = await Promise.resolve().then(() => (init_portfolioRebalancing(), portfolioRebalancing_exports));
      return getUserAllocations2(String(ctx.user.id));
    }),
    // Delete allocation
    deleteAllocation: protectedProcedure.input(z2.object({ allocationId: z2.string() })).mutation(async ({ ctx, input }) => {
      const { deleteAllocation: deleteAllocation2 } = await Promise.resolve().then(() => (init_portfolioRebalancing(), portfolioRebalancing_exports));
      await deleteAllocation2(input.allocationId, String(ctx.user.id));
      return { success: true };
    }),
    // Calculate rebalancing suggestions
    getRebalanceSuggestions: protectedProcedure.input(z2.object({ allocationId: z2.string() })).query(async ({ ctx, input }) => {
      const { calculateRebalanceSuggestions: calculateRebalanceSuggestions2 } = await Promise.resolve().then(() => (init_portfolioRebalancing(), portfolioRebalancing_exports));
      return calculateRebalanceSuggestions2(input.allocationId, String(ctx.user.id));
    }),
    // Execute rebalancing
    executeRebalancing: protectedProcedure.input(z2.object({
      allocationId: z2.string(),
      tradesToExecute: z2.array(z2.string()).optional()
    })).mutation(async ({ ctx, input }) => {
      const { executeRebalancing: executeRebalancing2 } = await Promise.resolve().then(() => (init_portfolioRebalancing(), portfolioRebalancing_exports));
      return executeRebalancing2(input.allocationId, String(ctx.user.id), input.tradesToExecute);
    }),
    // Get rebalancing history
    getRebalancingHistory: protectedProcedure.input(z2.object({
      allocationId: z2.string().optional(),
      limit: z2.number().min(1).max(100).default(20)
    })).query(async ({ ctx, input }) => {
      const { getRebalancingHistory: getRebalancingHistory2 } = await Promise.resolve().then(() => (init_portfolioRebalancing(), portfolioRebalancing_exports));
      return getRebalancingHistory2(String(ctx.user.id), input.allocationId, input.limit);
    }),
    // ==================== TRADE SIMULATOR ====================
    // Simulate trades and get impact analysis
    simulateTrades: protectedProcedure.input(z2.object({
      trades: z2.array(z2.object({
        symbol: z2.string(),
        side: z2.enum(["buy", "sell"]),
        quantity: z2.number().positive(),
        estimatedPrice: z2.number().positive(),
        brokerType: z2.string().optional()
      })),
      scenarioName: z2.string().default("Default Scenario"),
      currentPositions: z2.array(z2.object({
        symbol: z2.string(),
        quantity: z2.number(),
        avgCost: z2.number(),
        currentPrice: z2.number(),
        marketValue: z2.number(),
        unrealizedPL: z2.number(),
        unrealizedPLPercent: z2.number(),
        weight: z2.number()
      })).optional(),
      currentCash: z2.number().optional()
    })).mutation(async ({ ctx, input }) => {
      const { simulateTrades: simulateTrades2 } = await Promise.resolve().then(() => (init_tradeSimulator(), tradeSimulator_exports));
      return simulateTrades2(
        String(ctx.user.id),
        input.trades,
        input.scenarioName,
        input.currentPositions,
        input.currentCash
      );
    }),
    // Compare multiple scenarios
    compareScenarios: protectedProcedure.input(z2.object({
      scenarios: z2.array(z2.object({
        name: z2.string(),
        trades: z2.array(z2.object({
          symbol: z2.string(),
          side: z2.enum(["buy", "sell"]),
          quantity: z2.number().positive(),
          estimatedPrice: z2.number().positive(),
          brokerType: z2.string().optional()
        }))
      })),
      currentPositions: z2.array(z2.object({
        symbol: z2.string(),
        quantity: z2.number(),
        avgCost: z2.number(),
        currentPrice: z2.number(),
        marketValue: z2.number(),
        unrealizedPL: z2.number(),
        unrealizedPLPercent: z2.number(),
        weight: z2.number()
      })).optional(),
      currentCash: z2.number().optional()
    })).mutation(async ({ ctx, input }) => {
      const { compareScenarios: compareScenarios2 } = await Promise.resolve().then(() => (init_tradeSimulator(), tradeSimulator_exports));
      return compareScenarios2(
        String(ctx.user.id),
        input.scenarios,
        input.currentPositions,
        input.currentCash
      );
    }),
    // Generate optimized trades for target allocation
    generateOptimizedTrades: protectedProcedure.input(z2.object({
      targetAllocations: z2.array(z2.object({
        symbol: z2.string(),
        targetPercent: z2.number().min(0).max(100)
      })),
      currentPositions: z2.array(z2.object({
        symbol: z2.string(),
        quantity: z2.number(),
        avgCost: z2.number(),
        currentPrice: z2.number(),
        marketValue: z2.number(),
        unrealizedPL: z2.number(),
        unrealizedPLPercent: z2.number(),
        weight: z2.number()
      })),
      currentCash: z2.number(),
      constraints: z2.object({
        maxTradesPerSymbol: z2.number().optional(),
        minTradeValue: z2.number().optional(),
        maxConcentration: z2.number().optional(),
        preserveCash: z2.number().optional()
      }).optional()
    })).mutation(async ({ ctx, input }) => {
      const { generateOptimizedTrades: generateOptimizedTrades2 } = await Promise.resolve().then(() => (init_tradeSimulator(), tradeSimulator_exports));
      return generateOptimizedTrades2(
        String(ctx.user.id),
        input.targetAllocations,
        input.currentPositions,
        input.currentCash,
        input.constraints
      );
    }),
    // Get sample positions for demo
    getSamplePositions: publicProcedure.query(async () => {
      const { getSamplePositions: getSamplePositions2 } = await Promise.resolve().then(() => (init_tradeSimulator(), tradeSimulator_exports));
      return {
        positions: getSamplePositions2(),
        cash: 15e3
      };
    }),
    // Get all simulation templates
    getTemplates: publicProcedure.query(async () => {
      const { getAllTemplates: getAllTemplates2 } = await Promise.resolve().then(() => (init_simulationTemplates(), simulationTemplates_exports));
      return getAllTemplates2();
    }),
    // Get template by ID
    getTemplateById: publicProcedure.input(z2.object({ id: z2.string() })).query(async ({ input }) => {
      const { getTemplateById: getTemplateById2 } = await Promise.resolve().then(() => (init_simulationTemplates(), simulationTemplates_exports));
      return getTemplateById2(input.id);
    }),
    // Get templates by category
    getTemplatesByCategory: publicProcedure.input(z2.object({
      category: z2.enum(["sector_rotation", "dividend_growth", "momentum", "value", "defensive", "growth", "balanced", "custom"])
    })).query(async ({ input }) => {
      const { getTemplatesByCategory: getTemplatesByCategory2 } = await Promise.resolve().then(() => (init_simulationTemplates(), simulationTemplates_exports));
      return getTemplatesByCategory2(input.category);
    }),
    // Search templates
    searchTemplates: publicProcedure.input(z2.object({ query: z2.string() })).query(async ({ input }) => {
      const { searchTemplates: searchTemplates2 } = await Promise.resolve().then(() => (init_simulationTemplates(), simulationTemplates_exports));
      return searchTemplates2(input.query);
    }),
    // Generate trades from template
    generateTradesFromTemplate: protectedProcedure.input(z2.object({
      templateId: z2.string(),
      portfolioValue: z2.number().positive(),
      currentPositions: z2.array(z2.object({
        symbol: z2.string(),
        quantity: z2.number(),
        currentPrice: z2.number()
      })),
      currentCash: z2.number()
    })).mutation(async ({ input }) => {
      const { getTemplateById: getTemplateById2, generateTradesFromTemplate: generateTradesFromTemplate2 } = await Promise.resolve().then(() => (init_simulationTemplates(), simulationTemplates_exports));
      const template = getTemplateById2(input.templateId);
      if (!template) {
        throw new TRPCError3({ code: "NOT_FOUND", message: "Template not found" });
      }
      return generateTradesFromTemplate2(
        template,
        input.portfolioValue,
        input.currentPositions,
        input.currentCash
      );
    }),
    // Execute trades through broker
    executeTrades: protectedProcedure.input(z2.object({
      connectionId: z2.string(),
      trades: z2.array(z2.object({
        symbol: z2.string(),
        side: z2.enum(["buy", "sell"]),
        quantity: z2.number().positive(),
        estimatedPrice: z2.number().positive(),
        orderType: z2.enum(["market", "limit", "stop", "stop_limit"]).optional(),
        limitPrice: z2.number().optional(),
        stopPrice: z2.number().optional(),
        timeInForce: z2.enum(["day", "gtc", "ioc", "fok"]).optional()
      })),
      simulationId: z2.string().optional(),
      dryRun: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      const { executeTrades: executeTrades2 } = await Promise.resolve().then(() => (init_tradeExecution(), tradeExecution_exports));
      return executeTrades2({
        userId: String(ctx.user.id),
        connectionId: input.connectionId,
        trades: input.trades,
        simulationId: input.simulationId,
        dryRun: input.dryRun
      });
    }),
    // Validate trades before execution
    validateTrades: protectedProcedure.input(z2.object({
      trades: z2.array(z2.object({
        symbol: z2.string(),
        side: z2.enum(["buy", "sell"]),
        quantity: z2.number(),
        estimatedPrice: z2.number(),
        orderType: z2.enum(["market", "limit", "stop", "stop_limit"]).optional(),
        limitPrice: z2.number().optional(),
        stopPrice: z2.number().optional()
      }))
    })).query(async ({ input }) => {
      const { validateTrades: validateTrades2 } = await Promise.resolve().then(() => (init_tradeExecution(), tradeExecution_exports));
      return validateTrades2(input.trades);
    }),
    // Get execution history
    getExecutionHistory: protectedProcedure.input(z2.object({
      connectionId: z2.string().optional(),
      symbol: z2.string().optional(),
      limit: z2.number().optional(),
      offset: z2.number().optional()
    }).optional()).query(async ({ ctx, input }) => {
      const { getExecutionHistory: getExecutionHistory2 } = await Promise.resolve().then(() => (init_tradeExecution(), tradeExecution_exports));
      return getExecutionHistory2(String(ctx.user.id), input || {});
    }),
    // === Scenario Sharing Routes ===
    // Share a scenario with the community
    shareScenario: protectedProcedure.input(z2.object({
      name: z2.string(),
      description: z2.string().optional(),
      trades: z2.array(z2.object({
        symbol: z2.string(),
        side: z2.enum(["buy", "sell"]),
        quantity: z2.number(),
        estimatedPrice: z2.number()
      })),
      positions: z2.array(z2.object({
        symbol: z2.string(),
        quantity: z2.number(),
        avgCost: z2.number(),
        currentPrice: z2.number()
      })).optional(),
      cash: z2.number().optional(),
      category: z2.string().optional(),
      tags: z2.array(z2.string()).optional(),
      isPublic: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      const { shareScenario: shareScenario2 } = await Promise.resolve().then(() => (init_scenarioSharing(), scenarioSharing_exports));
      return shareScenario2(ctx.user.id, input);
    }),
    // Get community scenarios
    getCommunityScenarios: publicProcedure.input(z2.object({
      category: z2.string().optional(),
      search: z2.string().optional(),
      sortBy: z2.enum(["likes", "imports", "recent"]).optional(),
      limit: z2.number().optional(),
      offset: z2.number().optional()
    }).optional()).query(async ({ input }) => {
      const { getCommunityScenarios: getCommunityScenarios2 } = await Promise.resolve().then(() => (init_scenarioSharing(), scenarioSharing_exports));
      return getCommunityScenarios2(input || {});
    }),
    // Get scenario by ID
    getScenarioById: publicProcedure.input(z2.object({ scenarioId: z2.number() })).query(async ({ input }) => {
      const { getScenarioById: getScenarioById2 } = await Promise.resolve().then(() => (init_scenarioSharing(), scenarioSharing_exports));
      return getScenarioById2(input.scenarioId);
    }),
    // Like a scenario
    likeScenario: protectedProcedure.input(z2.object({ scenarioId: z2.number() })).mutation(async ({ ctx, input }) => {
      const { likeScenario: likeScenario2 } = await Promise.resolve().then(() => (init_scenarioSharing(), scenarioSharing_exports));
      return likeScenario2(input.scenarioId, ctx.user.id);
    }),
    // Import a scenario
    importScenario: protectedProcedure.input(z2.object({ scenarioId: z2.number() })).mutation(async ({ ctx, input }) => {
      const { importScenario: importScenario2 } = await Promise.resolve().then(() => (init_scenarioSharing(), scenarioSharing_exports));
      return importScenario2(input.scenarioId, ctx.user.id);
    }),
    // Get user's shared scenarios
    getUserScenarios: protectedProcedure.query(async ({ ctx }) => {
      const { getUserScenarios: getUserScenarios2 } = await Promise.resolve().then(() => (init_scenarioSharing(), scenarioSharing_exports));
      return getUserScenarios2(ctx.user.id);
    }),
    // Delete a shared scenario
    deleteScenario: protectedProcedure.input(z2.object({ scenarioId: z2.number() })).mutation(async ({ ctx, input }) => {
      const { deleteScenario: deleteScenario2 } = await Promise.resolve().then(() => (init_scenarioSharing(), scenarioSharing_exports));
      return deleteScenario2(input.scenarioId, ctx.user.id);
    }),
    // Check if user has liked a scenario
    hasUserLiked: protectedProcedure.input(z2.object({ scenarioId: z2.number() })).query(async ({ ctx, input }) => {
      const { hasUserLiked: hasUserLiked2 } = await Promise.resolve().then(() => (init_scenarioSharing(), scenarioSharing_exports));
      return hasUserLiked2(input.scenarioId, ctx.user.id);
    }),
    // Get scenario categories
    getScenarioCategories: publicProcedure.query(async () => {
      const { getScenarioCategories: getScenarioCategories2 } = await Promise.resolve().then(() => (init_scenarioSharing(), scenarioSharing_exports));
      return getScenarioCategories2();
    }),
    // === Monte Carlo Visualization Routes ===
    // Generate Monte Carlo visualization data
    getMonteCarloVisualization: protectedProcedure.input(z2.object({
      simulationResults: z2.array(z2.number()),
      initialValue: z2.number(),
      numBins: z2.number().optional(),
      pathData: z2.array(z2.array(z2.number())).optional()
    })).query(async ({ input }) => {
      const { generateVisualizationData: generateVisualizationData2, generateRiskSummary: generateRiskSummary2, formatForChartJS: formatForChartJS2 } = await Promise.resolve().then(() => (init_monteCarloVisualization(), monteCarloVisualization_exports));
      const visualizationData = generateVisualizationData2(
        input.simulationResults,
        input.initialValue,
        input.numBins || 50,
        10,
        input.pathData
      );
      const riskSummary = generateRiskSummary2(visualizationData, input.initialValue);
      const chartData = formatForChartJS2(visualizationData, input.initialValue);
      return { visualizationData, riskSummary, chartData };
    }),
    // === Template Performance Tracking Routes ===
    // Get template performance
    getTemplatePerformance: publicProcedure.input(z2.object({
      templateId: z2.string(),
      period: z2.enum(["1m", "3m", "6m", "1y", "ytd"]).optional()
    })).query(async ({ input }) => {
      const { calculateTemplatePerformance: calculateTemplatePerformance2 } = await Promise.resolve().then(() => (init_templatePerformanceTracking(), templatePerformanceTracking_exports));
      const endDate = /* @__PURE__ */ new Date();
      let startDate;
      switch (input.period || "1y") {
        case "1m":
          startDate = new Date(endDate.getTime() - 30 * 24 * 60 * 60 * 1e3);
          break;
        case "3m":
          startDate = new Date(endDate.getTime() - 90 * 24 * 60 * 60 * 1e3);
          break;
        case "6m":
          startDate = new Date(endDate.getTime() - 180 * 24 * 60 * 60 * 1e3);
          break;
        case "ytd":
          startDate = new Date(endDate.getFullYear(), 0, 1);
          break;
        default:
          startDate = new Date(endDate.getTime() - 365 * 24 * 60 * 60 * 1e3);
      }
      return calculateTemplatePerformance2(input.templateId, startDate, endDate);
    }),
    // Get template rankings
    getTemplateRankings: publicProcedure.input(z2.object({
      period: z2.enum(["1m", "3m", "6m", "1y", "ytd"]).optional(),
      sortBy: z2.enum(["return", "sharpe", "drawdown"]).optional()
    }).optional()).query(async ({ input }) => {
      const { getTemplateRankings: getTemplateRankings2 } = await Promise.resolve().then(() => (init_templatePerformanceTracking(), templatePerformanceTracking_exports));
      return getTemplateRankings2(input?.period || "1y", input?.sortBy || "return");
    }),
    // Compare template performance
    compareTemplatePerformance: publicProcedure.input(z2.object({
      templateIds: z2.array(z2.string()),
      period: z2.enum(["1m", "3m", "6m", "1y"]).optional()
    })).query(async ({ input }) => {
      const { compareTemplatePerformance: compareTemplatePerformance2 } = await Promise.resolve().then(() => (init_templatePerformanceTracking(), templatePerformanceTracking_exports));
      return compareTemplatePerformance2(input.templateIds, input.period || "1y");
    }),
    // Get template performance summary
    getTemplatePerformanceSummary: publicProcedure.input(z2.object({ templateId: z2.string() })).query(async ({ input }) => {
      const { getTemplatePerformanceSummary: getTemplatePerformanceSummary2 } = await Promise.resolve().then(() => (init_templatePerformanceTracking(), templatePerformanceTracking_exports));
      return getTemplatePerformanceSummary2(input.templateId);
    }),
    // === Enhanced AI Agent Routes ===
    // Analyze asset with 7 AI agents
    analyzeWithAgents: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      assetType: z2.enum(["stock", "crypto"]),
      priceHistory: z2.array(z2.object({
        timestamp: z2.number(),
        open: z2.number(),
        high: z2.number(),
        low: z2.number(),
        close: z2.number(),
        volume: z2.number()
      })),
      currentPrice: z2.number(),
      portfolioValue: z2.number(),
      availableCash: z2.number(),
      riskTolerance: z2.enum(["conservative", "moderate", "aggressive"]).optional(),
      currentPosition: z2.object({
        quantity: z2.number(),
        averagePrice: z2.number(),
        unrealizedPnL: z2.number()
      }).optional()
    })).mutation(async ({ input }) => {
      const { agentOrchestrator: agentOrchestrator2 } = await Promise.resolve().then(() => (init_AgentOrchestrator(), AgentOrchestrator_exports));
      const marketData = {
        symbol: input.symbol,
        assetType: input.assetType,
        currentPrice: input.currentPrice,
        priceHistory: input.priceHistory
      };
      const portfolio = {
        portfolioValue: input.portfolioValue,
        availableCash: input.availableCash,
        riskTolerance: input.riskTolerance || "moderate",
        maxDrawdown: 0.15,
        currentDrawdown: 0,
        currentPosition: input.currentPosition
      };
      return agentOrchestrator2.orchestrate(marketData, portfolio);
    }),
    // Get enhanced AI analysis with LLM reasoning
    getEnhancedAgentAnalysis: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      assetType: z2.enum(["stock", "crypto"]),
      currentPrice: z2.number(),
      consensusDecision: z2.object({
        finalSignal: z2.string(),
        overallConfidence: z2.number(),
        riskApproved: z2.boolean(),
        reasoning: z2.string(),
        agentVotes: z2.array(z2.object({
          agentType: z2.string(),
          signal: z2.string(),
          confidence: z2.number(),
          reasoning: z2.string()
        }))
      })
    })).mutation(async ({ input }) => {
      const { agentOrchestrator: agentOrchestrator2 } = await Promise.resolve().then(() => (init_AgentOrchestrator(), AgentOrchestrator_exports));
      const marketData = {
        symbol: input.symbol,
        assetType: input.assetType,
        currentPrice: input.currentPrice,
        priceHistory: []
      };
      const consensusDecision = {
        ...input.consensusDecision,
        suggestedAction: { action: "hold", urgency: "normal" }
      };
      return agentOrchestrator2.getEnhancedAnalysis(marketData, consensusDecision);
    }),
    // Analyze crypto with specialized agents
    analyzeCryptoWithAgents: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      metrics: z2.object({
        activeAddresses: z2.number(),
        transactionCount: z2.number(),
        averageTransactionValue: z2.number(),
        exchangeInflow: z2.number(),
        exchangeOutflow: z2.number(),
        exchangeReserves: z2.number(),
        whaleTransactions: z2.number(),
        topHolderConcentration: z2.number(),
        hashRate: z2.number().optional(),
        stakingRatio: z2.number().optional(),
        totalValueLocked: z2.number().optional(),
        liquidityDepth: z2.number().optional(),
        yieldRate: z2.number().optional(),
        fundingRate: z2.number().optional(),
        openInterest: z2.number().optional(),
        longShortRatio: z2.number().optional()
      }),
      tokenomics: z2.object({
        totalSupply: z2.number(),
        circulatingSupply: z2.number(),
        maxSupply: z2.number().optional(),
        inflationRate: z2.number(),
        burnRate: z2.number().optional()
      }).optional()
    })).mutation(async ({ input }) => {
      const { cryptoCoordinator: cryptoCoordinator2 } = await Promise.resolve().then(() => (init_CryptoAgent(), CryptoAgent_exports));
      return cryptoCoordinator2.analyzeComprehensive(
        input.symbol,
        input.metrics,
        input.tokenomics
      );
    }),
    // Create trading bot
    createTradingBot: protectedProcedure.input(z2.object({
      name: z2.string(),
      assetType: z2.enum(["stock", "crypto", "both"]),
      symbols: z2.array(z2.string()),
      riskTolerance: z2.enum(["conservative", "moderate", "aggressive"]),
      maxDrawdown: z2.number(),
      maxPositionSize: z2.number(),
      minConfidenceThreshold: z2.number(),
      consensusRequirement: z2.enum(["majority", "supermajority", "unanimous"]),
      enableAutoTrade: z2.boolean()
    })).mutation(async ({ ctx, input }) => {
      const { createTradingBot: createTradingBot3, BotPresets: BotPresets2 } = await Promise.resolve().then(() => (init_AgenticTradingBot(), AgenticTradingBot_exports));
      const config = {
        ...input,
        userId: String(ctx.user.id),
        ...BotPresets2[input.riskTolerance]
      };
      const bot = createTradingBot3(config);
      return {
        config: bot.getConfig(),
        state: bot.getState(),
        statistics: bot.getStatistics()
      };
    }),
    // Get bot presets
    getBotPresets: publicProcedure.query(async () => {
      const { BotPresets: BotPresets2 } = await Promise.resolve().then(() => (init_AgenticTradingBot(), AgenticTradingBot_exports));
      return BotPresets2;
    }),
    // Calculate technical indicators
    calculateIndicators: publicProcedure.input(z2.object({
      candles: z2.array(z2.object({
        timestamp: z2.number(),
        open: z2.number(),
        high: z2.number(),
        low: z2.number(),
        close: z2.number(),
        volume: z2.number()
      }))
    })).query(async ({ input }) => {
      const { calculateAllIndicators: calculateAllIndicators2 } = await Promise.resolve().then(() => (init_TechnicalIndicators(), TechnicalIndicators_exports));
      return calculateAllIndicators2(input.candles);
    }),
    // Detect candlestick patterns
    detectPatterns: publicProcedure.input(z2.object({
      candles: z2.array(z2.object({
        timestamp: z2.number(),
        open: z2.number(),
        high: z2.number(),
        low: z2.number(),
        close: z2.number(),
        volume: z2.number()
      }))
    })).query(async ({ input }) => {
      const { detectCandlestickPatterns: detectCandlestickPatterns2 } = await Promise.resolve().then(() => (init_TechnicalIndicators(), TechnicalIndicators_exports));
      return detectCandlestickPatterns2(input.candles);
    }),
    // Run Monte Carlo stress test
    runStressTest: protectedProcedure.input(z2.object({
      positions: z2.array(z2.object({
        symbol: z2.string(),
        quantity: z2.number(),
        currentPrice: z2.number(),
        avgCost: z2.number(),
        annualizedVolatility: z2.number().optional(),
        expectedReturn: z2.number().optional(),
        beta: z2.number().optional()
      })),
      trades: z2.array(z2.object({
        symbol: z2.string(),
        side: z2.enum(["buy", "sell"]),
        quantity: z2.number(),
        estimatedPrice: z2.number()
      })),
      cash: z2.number(),
      config: z2.object({
        numSimulations: z2.number().optional(),
        timeHorizonDays: z2.number().optional(),
        confidenceLevel: z2.number().optional(),
        volatilityMultiplier: z2.number().optional(),
        correlationModel: z2.enum(["historical", "stressed", "uncorrelated"]).optional()
      }).optional()
    })).mutation(async ({ input }) => {
      const { runMonteCarloSimulation: runMonteCarloSimulation4 } = await Promise.resolve().then(() => (init_monteCarloSimulation(), monteCarloSimulation_exports));
      return runMonteCarloSimulation4({
        symbol: input.positions[0]?.symbol || "SPY",
        initialCapital: input.cash + input.positions.reduce((sum2, p) => sum2 + p.quantity * p.currentPrice, 0),
        numSimulations: input.config?.numSimulations || 5e3,
        timeHorizonDays: input.config?.timeHorizonDays || 252,
        confidenceLevels: [0.95, 0.99],
        strategyType: "buy_hold"
      });
    }),
    // Agent Explainability
    getAgentExplanation: protectedProcedure.input(z2.object({
      symbol: z2.string()
    })).query(async ({ input }) => {
      const agentExplanations = [
        {
          agentName: "Technical Analysis Agent",
          agentType: "technical",
          finalSignal: "buy",
          confidence: 75,
          reasoning: "Based on RSI oversold conditions and MACD bullish crossover",
          indicatorContributions: [
            { name: "RSI", value: 28, signal: "bullish", weight: 0.15, contribution: 0.8, explanation: "RSI at 28 indicates oversold conditions" },
            { name: "MACD", value: 1.5, signal: "bullish", weight: 0.12, contribution: 0.6, explanation: "MACD histogram positive and increasing" }
          ],
          patternContributions: [],
          dataPointInfluences: [],
          bullishFactors: 4,
          bearishFactors: 1,
          neutralFactors: 2,
          dominantFactor: "RSI",
          decisionPath: [],
          featureImportance: [
            { feature: "RSI", importance: 0.25, direction: "positive", category: "technical" },
            { feature: "MACD", importance: 0.2, direction: "positive", category: "technical" }
          ],
          counterfactuals: []
        },
        {
          agentName: "Fundamental Analysis Agent",
          agentType: "fundamental",
          finalSignal: "buy",
          confidence: 68,
          reasoning: "Strong fundamentals with low P/E and high ROE",
          indicatorContributions: [
            { name: "P/E Ratio", value: 15.2, signal: "bullish", weight: 0.15, contribution: 0.6, explanation: "P/E of 15.2 suggests undervaluation" }
          ],
          patternContributions: [],
          dataPointInfluences: [],
          bullishFactors: 3,
          bearishFactors: 1,
          neutralFactors: 1,
          dominantFactor: "P/E Ratio",
          decisionPath: [],
          featureImportance: [
            { feature: "P/E Ratio", importance: 0.3, direction: "positive", category: "fundamental" }
          ],
          counterfactuals: []
        },
        {
          agentName: "Sentiment Analysis Agent",
          agentType: "sentiment",
          finalSignal: "hold",
          confidence: 55,
          reasoning: "Mixed sentiment signals from news and social media",
          indicatorContributions: [],
          patternContributions: [],
          dataPointInfluences: [
            { category: "News", name: "News Sentiment", value: "Neutral", impact: "medium", direction: "neutral", explanation: "Recent news coverage is balanced" }
          ],
          bullishFactors: 2,
          bearishFactors: 2,
          neutralFactors: 3,
          dominantFactor: "News Sentiment",
          decisionPath: [],
          featureImportance: [],
          counterfactuals: []
        },
        {
          agentName: "Risk Management Agent",
          agentType: "risk",
          finalSignal: "buy",
          confidence: 70,
          reasoning: "Acceptable risk levels with good risk/reward ratio",
          indicatorContributions: [],
          patternContributions: [],
          dataPointInfluences: [
            { category: "Risk", name: "Volatility", value: "22%", impact: "medium", direction: "neutral", explanation: "Volatility within acceptable range" }
          ],
          bullishFactors: 3,
          bearishFactors: 1,
          neutralFactors: 2,
          dominantFactor: "Risk/Reward",
          decisionPath: [],
          featureImportance: [],
          counterfactuals: []
        }
      ];
      return {
        symbol: input.symbol,
        assetType: "stock",
        finalDecision: "buy",
        overallConfidence: 72,
        agentExplanations,
        votingBreakdown: {
          buyVotes: 3,
          sellVotes: 0,
          holdVotes: 1,
          consensusMethod: "weighted",
          consensusReached: true,
          dissenterAgents: ["Sentiment Analysis Agent"]
        },
        topBullishFactors: [
          { category: "Technical", name: "RSI Oversold", value: 28, impact: "high", direction: "bullish", explanation: "Strong buy signal" },
          { category: "Fundamental", name: "Low P/E", value: 15.2, impact: "high", direction: "bullish", explanation: "Undervalued" }
        ],
        topBearishFactors: [],
        conflictingSignals: [],
        riskFactors: [
          { name: "Market Volatility", severity: "medium", description: "Elevated market volatility", mitigation: "Use position sizing" }
        ],
        overallRiskLevel: "medium"
      };
    }),
    // Strategy Backtester
    runAgentBacktest: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      startDate: z2.string(),
      endDate: z2.string(),
      initialCapital: z2.number(),
      positionSizing: z2.enum(["fixed", "percent"]),
      positionSize: z2.number(),
      stopLoss: z2.number(),
      takeProfit: z2.number(),
      useAgentWeights: z2.boolean()
    })).mutation(async ({ input }) => {
      const { runAgentBacktest: runAgentBacktest2 } = await Promise.resolve().then(() => (init_StrategyBacktester(), StrategyBacktester_exports));
      return runAgentBacktest2({
        symbol: input.symbol,
        startDate: input.startDate,
        endDate: input.endDate,
        initialCapital: input.initialCapital,
        positionSizing: input.positionSizing,
        positionSize: input.positionSize,
        maxPositionSize: input.initialCapital,
        stopLoss: input.stopLoss,
        takeProfit: input.takeProfit,
        transactionCost: 0.1,
        slippage: 0.05,
        useAgentWeights: input.useAgentWeights,
        rebalanceFrequency: "daily",
        benchmark: input.symbol.includes("BTC") ? "BTC" : "SPY"
      });
    }),
    // Prediction Tracking
    recordPrediction: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      assetType: z2.enum(["stock", "crypto"]),
      predictionSignal: z2.enum(["buy", "sell", "hold"]),
      confidence: z2.number(),
      entryPrice: z2.number(),
      targetPrice: z2.number().optional(),
      stopLoss: z2.number().optional(),
      agentVotes: z2.record(z2.string(), z2.enum(["buy", "sell", "hold"])),
      consensusMethod: z2.string(),
      marketRegime: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const { recordPrediction: recordPrediction2, initializeSampleData: initializeSampleData2 } = await Promise.resolve().then(() => (init_PredictionTracking(), PredictionTracking_exports));
      initializeSampleData2(ctx.user.openId);
      return recordPrediction2({
        userId: ctx.user.openId,
        ...input
      });
    }),
    updatePredictionOutcome: protectedProcedure.input(z2.object({
      predictionId: z2.number(),
      actualExitPrice: z2.number()
    })).mutation(async ({ input }) => {
      const { updatePredictionOutcome: updatePredictionOutcome2 } = await Promise.resolve().then(() => (init_PredictionTracking(), PredictionTracking_exports));
      return updatePredictionOutcome2({
        predictionId: input.predictionId,
        actualExitPrice: input.actualExitPrice,
        outcomeTimestamp: /* @__PURE__ */ new Date()
      });
    }),
    getPredictionStats: protectedProcedure.input(z2.object({
      days: z2.number().optional().default(30)
    })).query(async ({ ctx, input }) => {
      const { getPredictionStats: getPredictionStats2, initializeSampleData: initializeSampleData2 } = await Promise.resolve().then(() => (init_PredictionTracking(), PredictionTracking_exports));
      initializeSampleData2(ctx.user.openId);
      return getPredictionStats2(ctx.user.openId, input.days);
    }),
    getWeightHistory: protectedProcedure.input(z2.object({
      days: z2.number().optional().default(30)
    })).query(async ({ ctx, input }) => {
      const { getWeightHistory: getWeightHistory2, initializeSampleData: initializeSampleData2 } = await Promise.resolve().then(() => (init_PredictionTracking(), PredictionTracking_exports));
      initializeSampleData2(ctx.user.openId);
      return getWeightHistory2(ctx.user.openId, input.days);
    }),
    getCurrentWeights: protectedProcedure.query(async ({ ctx }) => {
      const { getCurrentWeights: getCurrentWeights2, initializeSampleData: initializeSampleData2 } = await Promise.resolve().then(() => (init_PredictionTracking(), PredictionTracking_exports));
      initializeSampleData2(ctx.user.openId);
      return getCurrentWeights2(ctx.user.openId);
    }),
    getPendingPredictions: protectedProcedure.query(async ({ ctx }) => {
      const { getPendingPredictions: getPendingPredictions2 } = await Promise.resolve().then(() => (init_PredictionTracking(), PredictionTracking_exports));
      return getPendingPredictions2(ctx.user.openId);
    }),
    getAllPredictions: protectedProcedure.query(async ({ ctx }) => {
      const { getAllPredictions: getAllPredictions2, initializeSampleData: initializeSampleData2 } = await Promise.resolve().then(() => (init_PredictionTracking(), PredictionTracking_exports));
      initializeSampleData2(ctx.user.openId);
      return getAllPredictions2(ctx.user.openId);
    }),
    // Backtest Comparison
    getBacktestRuns: protectedProcedure.query(async ({ ctx }) => {
      const { getUserBacktestRuns: getUserBacktestRuns2, initializeSampleBacktests: initializeSampleBacktests2 } = await Promise.resolve().then(() => (init_BacktestComparison(), BacktestComparison_exports));
      initializeSampleBacktests2(ctx.user.openId);
      return getUserBacktestRuns2(ctx.user.openId);
    }),
    saveBacktestRun: protectedProcedure.input(z2.object({
      name: z2.string(),
      symbol: z2.string(),
      startDate: z2.string(),
      endDate: z2.string(),
      config: z2.object({
        initialCapital: z2.number(),
        transactionCost: z2.number(),
        slippage: z2.number(),
        useAgentWeights: z2.boolean(),
        rebalanceFrequency: z2.string(),
        agentWeights: z2.record(z2.string(), z2.number()).optional()
      }),
      results: z2.any()
    })).mutation(async ({ ctx, input }) => {
      const { saveBacktestRun: saveBacktestRun2 } = await Promise.resolve().then(() => (init_BacktestComparison(), BacktestComparison_exports));
      return saveBacktestRun2(ctx.user.openId, input);
    }),
    deleteBacktestRun: protectedProcedure.input(z2.object({
      runId: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const { deleteBacktestRun: deleteBacktestRun2 } = await Promise.resolve().then(() => (init_BacktestComparison(), BacktestComparison_exports));
      return deleteBacktestRun2(ctx.user.openId, input.runId);
    }),
    compareBacktests: protectedProcedure.input(z2.object({
      runIds: z2.array(z2.string())
    })).query(async ({ ctx, input }) => {
      const { compareBacktests: compareBacktests2, initializeSampleBacktests: initializeSampleBacktests2 } = await Promise.resolve().then(() => (init_BacktestComparison(), BacktestComparison_exports));
      initializeSampleBacktests2(ctx.user.openId);
      return compareBacktests2(ctx.user.openId, input.runIds);
    }),
    // Weight Optimization Wizard
    getWizardSteps: protectedProcedure.query(async () => {
      const { getWizardSteps: getWizardSteps2 } = await Promise.resolve().then(() => (init_WeightOptimizationWizard(), WeightOptimizationWizard_exports));
      return getWizardSteps2();
    }),
    calculateRiskProfile: protectedProcedure.input(z2.object({
      responses: z2.array(z2.object({
        questionId: z2.string(),
        selectedValue: z2.string()
      }))
    })).mutation(async ({ ctx, input }) => {
      const { calculateRiskProfile: calculateRiskProfile2, getOptimizedWeights: getOptimizedWeights2 } = await Promise.resolve().then(() => (init_WeightOptimizationWizard(), WeightOptimizationWizard_exports));
      const profile = calculateRiskProfile2(ctx.user.openId, input.responses);
      return getOptimizedWeights2(profile);
    }),
    saveOptimizedWeights: protectedProcedure.input(z2.object({
      weights: z2.object({
        technical: z2.number(),
        fundamental: z2.number(),
        sentiment: z2.number(),
        risk: z2.number(),
        regime: z2.number(),
        execution: z2.number(),
        coordinator: z2.number()
      })
    })).mutation(async ({ ctx, input }) => {
      return { success: true, weights: input.weights };
    }),
    getPresetConfigurations: protectedProcedure.query(async () => {
      const { getPresetConfigurations: getPresetConfigurations2 } = await Promise.resolve().then(() => (init_WeightOptimizationWizard(), WeightOptimizationWizard_exports));
      return getPresetConfigurations2();
    }),
    // Prediction Alerts
    createPredictionAlert: protectedProcedure.input(z2.object({
      predictionId: z2.number(),
      symbol: z2.string(),
      targetPrice: z2.number().optional(),
      stopLossPrice: z2.number().optional(),
      trailingStopPct: z2.number().optional(),
      breakoutThresholdPct: z2.number().optional(),
      volatilityThreshold: z2.number().optional(),
      channels: z2.array(z2.enum(["in_app", "email", "push", "sms"])).optional(),
      expiresInHours: z2.number().optional()
    })).mutation(async ({ ctx, input }) => {
      const { createAlert: createAlert3 } = await Promise.resolve().then(() => (init_PredictionAlerts(), PredictionAlerts_exports));
      return createAlert3({
        userId: ctx.user.openId,
        predictionId: input.predictionId,
        symbol: input.symbol,
        targetPrice: input.targetPrice,
        stopLossPrice: input.stopLossPrice,
        trailingStopPct: input.trailingStopPct,
        breakoutThresholdPct: input.breakoutThresholdPct,
        volatilityThreshold: input.volatilityThreshold,
        channels: input.channels || ["in_app"],
        expiresInHours: input.expiresInHours
      });
    }),
    getPredictionAlerts: protectedProcedure.query(async ({ ctx }) => {
      const { getUserAlerts: getUserAlerts3 } = await Promise.resolve().then(() => (init_PredictionAlerts(), PredictionAlerts_exports));
      return getUserAlerts3(ctx.user.openId);
    }),
    cancelPredictionAlert: protectedProcedure.input(z2.object({ alertId: z2.number() })).mutation(async ({ ctx, input }) => {
      const { deleteAlert: deleteAlert3 } = await Promise.resolve().then(() => (init_PredictionAlerts(), PredictionAlerts_exports));
      return deleteAlert3(input.alertId, ctx.user.openId);
    }),
    // Backtest Export
    exportBacktestCSV: protectedProcedure.input(z2.object({
      title: z2.string(),
      backtestIds: z2.array(z2.string()),
      includeTradeDetails: z2.boolean().optional()
    })).query(async ({ ctx, input }) => {
      const { generateSampleExportData: generateSampleExportData2, generateCSVExport: generateCSVExport2, getExportFileName: getExportFileName2 } = await Promise.resolve().then(() => (init_BacktestExport(), BacktestExport_exports));
      const data = generateSampleExportData2(ctx.user.openId);
      data.title = input.title;
      const csv = generateCSVExport2(data, {
        includeTradeDetails: input.includeTradeDetails ?? true,
        includeAgentWeights: true,
        delimiter: ",",
        dateFormat: "ISO"
      });
      return {
        content: csv,
        filename: getExportFileName2(input.title, "csv"),
        mimeType: "text/csv"
      };
    }),
    exportBacktestPDF: protectedProcedure.input(z2.object({
      title: z2.string(),
      backtestIds: z2.array(z2.string()),
      includeTradeLog: z2.boolean().optional()
    })).query(async ({ ctx, input }) => {
      const { generateSampleExportData: generateSampleExportData2, generatePDFContent: generatePDFContent2, getExportFileName: getExportFileName2 } = await Promise.resolve().then(() => (init_BacktestExport(), BacktestExport_exports));
      const data = generateSampleExportData2(ctx.user.openId);
      data.title = input.title;
      const html = generatePDFContent2(data, {
        includeCharts: true,
        includeTradeLog: input.includeTradeLog ?? true,
        includeDisclaimer: true,
        paperSize: "A4",
        orientation: "portrait"
      });
      return {
        content: html,
        filename: getExportFileName2(input.title, "pdf"),
        mimeType: "text/html"
      };
    }),
    // Agent Communication Hub - Real-time agent discussions
    startAgentDiscussion: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      assetType: z2.enum(["stock", "crypto", "forex", "commodity"]),
      topic: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const { startDiscussion: startDiscussion2 } = await Promise.resolve().then(() => (init_AgentCommunicationHub(), AgentCommunicationHub_exports));
      return startDiscussion2(input.symbol, input.assetType, input.topic);
    }),
    runAgentDebate: protectedProcedure.input(z2.object({
      threadId: z2.string(),
      rounds: z2.number().min(1).max(5).optional()
    })).mutation(async ({ ctx, input }) => {
      const { generateDebate: generateDebate2, getDiscussion: getDiscussion2 } = await Promise.resolve().then(() => (init_AgentCommunicationHub(), AgentCommunicationHub_exports));
      const messages = await generateDebate2(input.threadId, input.rounds ?? 1);
      return { messages, thread: getDiscussion2(input.threadId) };
    }),
    conductAgentVoting: protectedProcedure.input(z2.object({
      threadId: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const { conductVoting: conductVoting2, getDiscussion: getDiscussion2 } = await Promise.resolve().then(() => (init_AgentCommunicationHub(), AgentCommunicationHub_exports));
      const consensus = await conductVoting2(input.threadId);
      return { consensus, thread: getDiscussion2(input.threadId) };
    }),
    getDiscussionThread: protectedProcedure.input(z2.object({
      threadId: z2.string()
    })).query(async ({ ctx, input }) => {
      const { getDiscussion: getDiscussion2 } = await Promise.resolve().then(() => (init_AgentCommunicationHub(), AgentCommunicationHub_exports));
      return getDiscussion2(input.threadId);
    }),
    // Market Regime Auto-Adaptation
    getRegimeAdaptationConfig: protectedProcedure.query(async ({ ctx }) => {
      const { getUserConfig: getUserConfig2 } = await Promise.resolve().then(() => (init_MarketRegimeAutoAdaptation(), MarketRegimeAutoAdaptation_exports));
      return getUserConfig2(ctx.user.openId);
    }),
    updateRegimeAdaptationConfig: protectedProcedure.input(z2.object({
      enabled: z2.boolean().optional(),
      sensitivity: z2.enum(["low", "medium", "high"]).optional(),
      minConfidenceThreshold: z2.number().min(0).max(100).optional(),
      cooldownPeriodMs: z2.number().min(0).optional(),
      maxWeightChange: z2.number().min(0).max(1).optional(),
      notifyOnChange: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      const { updateUserConfig: updateUserConfig2 } = await Promise.resolve().then(() => (init_MarketRegimeAutoAdaptation(), MarketRegimeAutoAdaptation_exports));
      return updateUserConfig2(ctx.user.openId, input);
    }),
    detectMarketRegime: protectedProcedure.input(z2.object({
      prices: z2.array(z2.number()),
      volumes: z2.array(z2.number()),
      highs: z2.array(z2.number()),
      lows: z2.array(z2.number()),
      symbol: z2.string().optional()
    })).mutation(async ({ ctx, input }) => {
      const { detectRegime: detectRegime3 } = await Promise.resolve().then(() => (init_MarketRegimeAutoAdaptation(), MarketRegimeAutoAdaptation_exports));
      return detectRegime3(input);
    }),
    autoAdaptWeights: protectedProcedure.input(z2.object({
      currentWeights: z2.object({
        technical: z2.number(),
        fundamental: z2.number(),
        sentiment: z2.number(),
        risk: z2.number(),
        regime: z2.number(),
        execution: z2.number()
      }),
      marketData: z2.object({
        prices: z2.array(z2.number()),
        volumes: z2.array(z2.number()),
        highs: z2.array(z2.number()),
        lows: z2.array(z2.number())
      })
    })).mutation(async ({ ctx, input }) => {
      const { autoAdaptWeights: autoAdaptWeights2 } = await Promise.resolve().then(() => (init_MarketRegimeAutoAdaptation(), MarketRegimeAutoAdaptation_exports));
      return autoAdaptWeights2(ctx.user.openId, input.currentWeights, input.marketData);
    }),
    getRegimeHistory: protectedProcedure.query(async ({ ctx }) => {
      const { getRegimeHistory: getRegimeHistory2 } = await Promise.resolve().then(() => (init_MarketRegimeAutoAdaptation(), MarketRegimeAutoAdaptation_exports));
      return getRegimeHistory2();
    }),
    getRegimeStatistics: protectedProcedure.query(async ({ ctx }) => {
      const { getRegimeStatistics: getRegimeStatistics2 } = await Promise.resolve().then(() => (init_MarketRegimeAutoAdaptation(), MarketRegimeAutoAdaptation_exports));
      return getRegimeStatistics2();
    }),
    getRegimePresets: protectedProcedure.query(async ({ ctx }) => {
      const { getAllRegimePresets: getAllRegimePresets2 } = await Promise.resolve().then(() => (init_MarketRegimeAutoAdaptation(), MarketRegimeAutoAdaptation_exports));
      return getAllRegimePresets2();
    }),
    enhanceRegimeAnalysis: protectedProcedure.input(z2.object({
      regime: z2.string(),
      indicators: z2.object({
        volatility: z2.number(),
        trend: z2.number(),
        momentum: z2.number(),
        sentiment: z2.number(),
        volume: z2.number()
      }),
      symbol: z2.string().optional()
    })).mutation(async ({ ctx, input }) => {
      const { enhanceRegimeAnalysis: enhanceRegimeAnalysis2 } = await Promise.resolve().then(() => (init_MarketRegimeAutoAdaptation(), MarketRegimeAutoAdaptation_exports));
      return enhanceRegimeAnalysis2(input.regime, input.indicators, input.symbol);
    }),
    // Multi-Asset Correlation Engine
    getCorrelationAssets: protectedProcedure.query(async ({ ctx }) => {
      const { getDefaultAssets: getDefaultAssets2 } = await Promise.resolve().then(() => (init_MultiAssetCorrelationEngine(), MultiAssetCorrelationEngine_exports));
      return getDefaultAssets2();
    }),
    calculateCorrelationMatrix: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string()),
      period: z2.string().optional()
    })).mutation(async ({ ctx, input }) => {
      const { calculateCorrelationMatrix: calculateCorrelationMatrix5, generateSamplePriceData: generateSamplePriceData2, getDefaultAssets: getDefaultAssets2 } = await Promise.resolve().then(() => (init_MultiAssetCorrelationEngine(), MultiAssetCorrelationEngine_exports));
      const allAssets = getDefaultAssets2();
      const selectedAssets = allAssets.filter((a) => input.symbols.includes(a.symbol));
      const priceData = generateSamplePriceData2(input.symbols);
      return calculateCorrelationMatrix5(selectedAssets, priceData, input.period || "1Y");
    }),
    analyzeCrossAssetCorrelations: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string())
    })).mutation(async ({ ctx, input }) => {
      const { analyzeCrossAssetCorrelations: analyzeCrossAssetCorrelations2, generateSamplePriceData: generateSamplePriceData2, getDefaultAssets: getDefaultAssets2 } = await Promise.resolve().then(() => (init_MultiAssetCorrelationEngine(), MultiAssetCorrelationEngine_exports));
      const allAssets = getDefaultAssets2();
      const selectedAssets = allAssets.filter((a) => input.symbols.includes(a.symbol));
      const priceData = generateSamplePriceData2(input.symbols);
      return analyzeCrossAssetCorrelations2(selectedAssets, priceData);
    }),
    findUncorrelatedAssets: protectedProcedure.input(z2.object({
      currentSymbols: z2.array(z2.string()),
      maxCorrelation: z2.number().optional()
    })).mutation(async ({ ctx, input }) => {
      const { findUncorrelatedAssets: findUncorrelatedAssets2, generateSamplePriceData: generateSamplePriceData2, getDefaultAssets: getDefaultAssets2 } = await Promise.resolve().then(() => (init_MultiAssetCorrelationEngine(), MultiAssetCorrelationEngine_exports));
      const allAssets = getDefaultAssets2();
      const currentAssets = allAssets.filter((a) => input.currentSymbols.includes(a.symbol));
      const candidateAssets = allAssets.filter((a) => !input.currentSymbols.includes(a.symbol));
      const priceData = generateSamplePriceData2(allAssets.map((a) => a.symbol));
      return findUncorrelatedAssets2(currentAssets, candidateAssets, priceData, input.maxCorrelation || 0.3);
    }),
    calculateRollingCorrelation: protectedProcedure.input(z2.object({
      symbol1: z2.string(),
      symbol2: z2.string(),
      windowSize: z2.number().optional()
    })).mutation(async ({ ctx, input }) => {
      const { calculateRollingCorrelation: calculateRollingCorrelation2, generateSamplePriceData: generateSamplePriceData2, getDefaultAssets: getDefaultAssets2 } = await Promise.resolve().then(() => (init_MultiAssetCorrelationEngine(), MultiAssetCorrelationEngine_exports));
      const allAssets = getDefaultAssets2();
      const asset1 = allAssets.find((a) => a.symbol === input.symbol1);
      const asset2 = allAssets.find((a) => a.symbol === input.symbol2);
      if (!asset1 || !asset2) return null;
      const priceData = generateSamplePriceData2([input.symbol1, input.symbol2]);
      const prices1 = priceData.get(input.symbol1) || [];
      const prices2 = priceData.get(input.symbol2) || [];
      return calculateRollingCorrelation2(asset1, prices1, asset2, prices2, input.windowSize || 30);
    }),
    // Social Sentiment Integration
    getSymbolSentiment: protectedProcedure.input(z2.object({
      symbol: z2.string()
    })).query(async ({ ctx, input }) => {
      const { getSymbolSentiment: getSymbolSentiment2 } = await Promise.resolve().then(() => (init_SocialSentimentIntegration(), SocialSentimentIntegration_exports));
      return getSymbolSentiment2(input.symbol);
    }),
    getTrendingSentiment: protectedProcedure.query(async ({ ctx }) => {
      const { getTrendingSymbols: getTrendingSymbols2 } = await Promise.resolve().then(() => (init_SocialSentimentIntegration(), SocialSentimentIntegration_exports));
      return getTrendingSymbols2(10);
    }),
    getSentimentAlerts: protectedProcedure.input(z2.object({
      symbol: z2.string()
    })).query(async ({ ctx, input }) => {
      const { getSymbolSentiment: getSymbolSentiment2, generateSentimentAlerts: generateSentimentAlerts2 } = await Promise.resolve().then(() => (init_SocialSentimentIntegration(), SocialSentimentIntegration_exports));
      const currentSentiment = getSymbolSentiment2(input.symbol);
      return generateSentimentAlerts2(input.symbol, null, currentSentiment);
    }),
    getSentimentHeatmap: protectedProcedure.query(async ({ ctx }) => {
      const { getSentimentHeatmap: getSentimentHeatmap2 } = await Promise.resolve().then(() => (init_SocialSentimentIntegration(), SocialSentimentIntegration_exports));
      return getSentimentHeatmap2();
    }),
    analyzeSentimentText: protectedProcedure.input(z2.object({
      text: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const { analyzeSentimentText: analyzeSentimentText2 } = await Promise.resolve().then(() => (init_SocialSentimentIntegration(), SocialSentimentIntegration_exports));
      return analyzeSentimentText2(input.text);
    }),
    // Portfolio Stress Testing
    getStressScenarios: protectedProcedure.query(async ({ ctx }) => {
      const { getAvailableScenarios: getAvailableScenarios2 } = await Promise.resolve().then(() => (init_PortfolioStressTesting(), PortfolioStressTesting_exports));
      return getAvailableScenarios2();
    }),
    runMonteCarloStress: protectedProcedure.input(z2.object({
      simulations: z2.number().optional(),
      timeHorizon: z2.number().optional(),
      confidenceLevel: z2.number().optional()
    })).mutation(async ({ ctx, input }) => {
      const { runMonteCarloSimulation: runMonteCarloSimulation4, getSamplePortfolio: getSamplePortfolio2 } = await Promise.resolve().then(() => (init_PortfolioStressTesting(), PortfolioStressTesting_exports));
      const portfolio = getSamplePortfolio2();
      return runMonteCarloSimulation4(portfolio, {
        simulations: input.simulations || 1e3,
        timeHorizon: input.timeHorizon || 30,
        confidenceLevel: input.confidenceLevel || 0.95,
        volatilityMultiplier: 1
      });
    }),
    runHistoricalStress: protectedProcedure.input(z2.object({
      scenario: z2.string()
    })).mutation(async ({ ctx, input }) => {
      const { runHistoricalScenario: runHistoricalScenario2, getSamplePortfolio: getSamplePortfolio2 } = await Promise.resolve().then(() => (init_PortfolioStressTesting(), PortfolioStressTesting_exports));
      const portfolio = getSamplePortfolio2();
      return runHistoricalScenario2(portfolio, input.scenario);
    }),
    runSensitivityAnalysis: protectedProcedure.input(z2.object({
      factors: z2.array(z2.string())
    })).mutation(async ({ ctx, input }) => {
      const { runSensitivityAnalysis: runSensitivityAnalysis2, getSamplePortfolio: getSamplePortfolio2 } = await Promise.resolve().then(() => (init_PortfolioStressTesting(), PortfolioStressTesting_exports));
      const portfolio = getSamplePortfolio2();
      return runSensitivityAnalysis2(portfolio, input.factors);
    }),
    calculatePortfolioVaR: protectedProcedure.query(async ({ ctx }) => {
      const { calculateVaR: calculateVaR2, getSamplePortfolio: getSamplePortfolio2 } = await Promise.resolve().then(() => (init_PortfolioStressTesting(), PortfolioStressTesting_exports));
      const portfolio = getSamplePortfolio2();
      return calculateVaR2(portfolio, 0.95, 1);
    }),
    // Agent Performance Leaderboard
    getAgentLeaderboard: protectedProcedure.input(z2.object({
      timeFrame: z2.string(),
      marketCondition: z2.string().optional(),
      agentType: z2.string().optional(),
      minSignals: z2.number().optional()
    })).query(async ({ ctx, input }) => {
      const { getLeaderboard: getLeaderboard3 } = await Promise.resolve().then(() => (init_AgentPerformanceLeaderboard(), AgentPerformanceLeaderboard_exports));
      return getLeaderboard3({
        timeFrame: input.timeFrame,
        marketCondition: input.marketCondition,
        agentType: input.agentType,
        minSignals: input.minSignals
      });
    }),
    getLeaderboardStats: protectedProcedure.query(async ({ ctx }) => {
      const { getLeaderboardStats: getLeaderboardStats2 } = await Promise.resolve().then(() => (init_AgentPerformanceLeaderboard(), AgentPerformanceLeaderboard_exports));
      return getLeaderboardStats2();
    }),
    getMarketConditions: protectedProcedure.query(async ({ ctx }) => {
      const { getMarketConditions: getMarketConditions2 } = await Promise.resolve().then(() => (init_AgentPerformanceLeaderboard(), AgentPerformanceLeaderboard_exports));
      return getMarketConditions2();
    }),
    getAgentTypes: protectedProcedure.query(async ({ ctx }) => {
      const { getAgentTypes: getAgentTypes2 } = await Promise.resolve().then(() => (init_AgentPerformanceLeaderboard(), AgentPerformanceLeaderboard_exports));
      return getAgentTypes2();
    }),
    getAllBadges: protectedProcedure.query(async ({ ctx }) => {
      const { getAllBadges: getAllBadges2 } = await Promise.resolve().then(() => (init_AgentPerformanceLeaderboard(), AgentPerformanceLeaderboard_exports));
      return getAllBadges2();
    }),
    getAgentDetails: protectedProcedure.input(z2.object({
      agentId: z2.string(),
      timeFrame: z2.string().optional()
    })).query(async ({ ctx, input }) => {
      const { getAgentDetails: getAgentDetails2 } = await Promise.resolve().then(() => (init_AgentPerformanceLeaderboard(), AgentPerformanceLeaderboard_exports));
      return getAgentDetails2(input.agentId, input.timeFrame || "1m");
    }),
    compareAgents: protectedProcedure.input(z2.object({
      agentIds: z2.array(z2.string()),
      timeFrame: z2.string().optional()
    })).query(async ({ ctx, input }) => {
      const { compareAgents: compareAgents2 } = await Promise.resolve().then(() => (init_AgentPerformanceLeaderboard(), AgentPerformanceLeaderboard_exports));
      return compareAgents2(input.agentIds, input.timeFrame || "1m");
    }),
    // ==================== AUTOMATED STRATEGY GENERATION ====================
    // Get strategy questionnaire
    getStrategyQuestionnaire: publicProcedure.query(async () => {
      const { getQuestionnaire: getQuestionnaire2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      return getQuestionnaire2();
    }),
    // Get strategy templates
    getStrategyTemplates: publicProcedure.query(async () => {
      const { getStrategyTemplates: getStrategyTemplates2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      return getStrategyTemplates2();
    }),
    // Create risk profile from questionnaire responses
    createRiskProfile: protectedProcedure.input(z2.object({
      responses: z2.array(z2.object({
        questionId: z2.string(),
        answer: z2.union([z2.string(), z2.number(), z2.array(z2.string())])
      }))
    })).mutation(async ({ ctx, input }) => {
      const { createRiskProfile: createRiskProfile2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      return createRiskProfile2(ctx.user.openId, input.responses);
    }),
    // Generate strategy based on risk profile
    generateStrategy: protectedProcedure.input(z2.object({
      profileId: z2.string(),
      preferredType: z2.string().optional()
    })).mutation(async ({ ctx, input }) => {
      const { createRiskProfile: createRiskProfile2, generateStrategy: generateStrategy2, getQuestionnaire: getQuestionnaire2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      const defaultResponses = [
        { questionId: "q1_risk_tolerance", answer: "hold" },
        { questionId: "q2_investment_horizon", answer: "medium_term" },
        { questionId: "q3_trading_style", answer: "swing_trading" },
        { questionId: "q4_max_drawdown", answer: 20 },
        { questionId: "q5_target_return", answer: 15 },
        { questionId: "q6_asset_classes", answer: ["stocks"] },
        { questionId: "q7_capital", answer: 1e4 },
        { questionId: "q8_experience", answer: "intermediate" },
        { questionId: "q9_time_availability", answer: "part_time" },
        { questionId: "q10_emotional_tolerance", answer: 5 }
      ];
      const profile = createRiskProfile2(ctx.user.openId, defaultResponses);
      return generateStrategy2(profile, input.preferredType);
    }),
    // Optimize existing strategy
    optimizeStrategy: protectedProcedure.input(z2.object({
      strategyId: z2.string(),
      optimizationGoal: z2.enum(["win_rate", "risk_reward", "sharpe", "drawdown"])
    })).mutation(async ({ ctx, input }) => {
      const { optimizeStrategy: optimizeStrategy2, generateStrategy: generateStrategy2, createRiskProfile: createRiskProfile2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      const defaultResponses = [
        { questionId: "q1_risk_tolerance", answer: "hold" },
        { questionId: "q2_investment_horizon", answer: "medium_term" },
        { questionId: "q3_trading_style", answer: "swing_trading" },
        { questionId: "q4_max_drawdown", answer: 20 },
        { questionId: "q5_target_return", answer: 15 },
        { questionId: "q6_asset_classes", answer: ["stocks"] },
        { questionId: "q7_capital", answer: 1e4 },
        { questionId: "q8_experience", answer: "intermediate" },
        { questionId: "q9_time_availability", answer: "part_time" },
        { questionId: "q10_emotional_tolerance", answer: 5 }
      ];
      const profile = createRiskProfile2(ctx.user.openId, defaultResponses);
      const strategy = generateStrategy2(profile);
      return optimizeStrategy2(strategy, input.optimizationGoal);
    }),
    // Get suitable templates for a risk profile
    getSuitableTemplates: protectedProcedure.input(z2.object({
      riskTolerance: z2.enum(["conservative", "moderate", "aggressive", "very_aggressive"]),
      preferredAssets: z2.array(z2.string())
    })).query(async ({ ctx, input }) => {
      const { getSuitableTemplates: getSuitableTemplates2, createRiskProfile: createRiskProfile2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      const mockProfile = {
        id: "temp",
        userId: ctx.user.openId,
        riskTolerance: input.riskTolerance,
        investmentHorizon: "medium_term",
        tradingStyle: "swing_trading",
        maxDrawdownTolerance: 20,
        targetAnnualReturn: 15,
        preferredAssetClasses: input.preferredAssets,
        capitalAllocation: 1e4,
        maxPositionSize: 10,
        maxOpenPositions: 10,
        tradingFrequency: "medium",
        experienceLevel: "intermediate",
        emotionalTolerance: 5,
        timeAvailability: "part_time",
        createdAt: Date.now(),
        updatedAt: Date.now()
      };
      return getSuitableTemplates2(mockProfile);
    }),
    // Generate multiple strategy variations
    generateStrategyVariations: protectedProcedure.input(z2.object({
      count: z2.number().min(1).max(5).optional()
    })).mutation(async ({ ctx, input }) => {
      const { generateStrategyVariations: generateStrategyVariations2, createRiskProfile: createRiskProfile2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      const defaultResponses = [
        { questionId: "q1_risk_tolerance", answer: "hold" },
        { questionId: "q2_investment_horizon", answer: "medium_term" },
        { questionId: "q3_trading_style", answer: "swing_trading" },
        { questionId: "q4_max_drawdown", answer: 20 },
        { questionId: "q5_target_return", answer: 15 },
        { questionId: "q6_asset_classes", answer: ["stocks", "crypto"] },
        { questionId: "q7_capital", answer: 1e4 },
        { questionId: "q8_experience", answer: "intermediate" },
        { questionId: "q9_time_availability", answer: "part_time" },
        { questionId: "q10_emotional_tolerance", answer: 5 }
      ];
      const profile = createRiskProfile2(ctx.user.openId, defaultResponses);
      return generateStrategyVariations2(profile, input.count || 3);
    }),
    // Compare multiple strategies
    compareStrategies: protectedProcedure.input(z2.object({
      strategyIds: z2.array(z2.string())
    })).query(async ({ ctx, input }) => {
      const { compareStrategies: compareStrategies2, generateStrategyVariations: generateStrategyVariations2, createRiskProfile: createRiskProfile2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      const defaultResponses = [
        { questionId: "q1_risk_tolerance", answer: "hold" },
        { questionId: "q2_investment_horizon", answer: "medium_term" },
        { questionId: "q3_trading_style", answer: "swing_trading" },
        { questionId: "q4_max_drawdown", answer: 20 },
        { questionId: "q5_target_return", answer: 15 },
        { questionId: "q6_asset_classes", answer: ["stocks", "crypto"] },
        { questionId: "q7_capital", answer: 1e4 },
        { questionId: "q8_experience", answer: "intermediate" },
        { questionId: "q9_time_availability", answer: "part_time" },
        { questionId: "q10_emotional_tolerance", answer: 5 }
      ];
      const profile = createRiskProfile2(ctx.user.openId, defaultResponses);
      const strategies = generateStrategyVariations2(profile, 3);
      return compareStrategies2(strategies);
    }),
    // Validate a strategy
    validateStrategy: protectedProcedure.input(z2.object({
      strategyId: z2.string()
    })).query(async ({ ctx, input }) => {
      const { validateStrategy: validateStrategy2, generateStrategy: generateStrategy2, createRiskProfile: createRiskProfile2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      const defaultResponses = [
        { questionId: "q1_risk_tolerance", answer: "hold" },
        { questionId: "q2_investment_horizon", answer: "medium_term" },
        { questionId: "q3_trading_style", answer: "swing_trading" },
        { questionId: "q4_max_drawdown", answer: 20 },
        { questionId: "q5_target_return", answer: 15 },
        { questionId: "q6_asset_classes", answer: ["stocks"] },
        { questionId: "q7_capital", answer: 1e4 },
        { questionId: "q8_experience", answer: "intermediate" },
        { questionId: "q9_time_availability", answer: "part_time" },
        { questionId: "q10_emotional_tolerance", answer: 5 }
      ];
      const profile = createRiskProfile2(ctx.user.openId, defaultResponses);
      const strategy = generateStrategy2(profile);
      return validateStrategy2(strategy);
    }),
    // Export strategy as JSON
    exportStrategy: protectedProcedure.input(z2.object({
      strategyId: z2.string()
    })).query(async ({ ctx, input }) => {
      const { exportStrategy: exportStrategy2, generateStrategy: generateStrategy2, createRiskProfile: createRiskProfile2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      const defaultResponses = [
        { questionId: "q1_risk_tolerance", answer: "hold" },
        { questionId: "q2_investment_horizon", answer: "medium_term" },
        { questionId: "q3_trading_style", answer: "swing_trading" },
        { questionId: "q4_max_drawdown", answer: 20 },
        { questionId: "q5_target_return", answer: 15 },
        { questionId: "q6_asset_classes", answer: ["stocks"] },
        { questionId: "q7_capital", answer: 1e4 },
        { questionId: "q8_experience", answer: "intermediate" },
        { questionId: "q9_time_availability", answer: "part_time" },
        { questionId: "q10_emotional_tolerance", answer: 5 }
      ];
      const profile = createRiskProfile2(ctx.user.openId, defaultResponses);
      const strategy = generateStrategy2(profile);
      return { json: exportStrategy2(strategy), filename: `${strategy.name.replace(/\s+/g, "_")}.json` };
    }),
    // Strategy Backtesting Integration
    runStrategyBacktest: protectedProcedure.input(z2.object({
      strategyId: z2.string(),
      symbol: z2.string(),
      startDate: z2.number(),
      endDate: z2.number(),
      initialCapital: z2.number().default(1e5),
      commissionRate: z2.number().default(1e-3)
    })).mutation(async ({ input }) => {
      const { runBacktest: runBacktest3 } = await Promise.resolve().then(() => (init_StrategyBacktestingIntegration(), StrategyBacktestingIntegration_exports));
      const { generateStrategy: generateStrategy2, createRiskProfile: createRiskProfile2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      const defaultResponses = [
        { questionId: "q1_risk_tolerance", answer: 3 },
        { questionId: "q2_investment_horizon", answer: "medium_term" },
        { questionId: "q3_loss_reaction", answer: "hold" },
        { questionId: "q4_income_stability", answer: "stable" },
        { questionId: "q5_investment_goal", answer: "growth" },
        { questionId: "q6_market_knowledge", answer: "intermediate" },
        { questionId: "q7_portfolio_allocation", answer: "balanced" },
        { questionId: "q8_experience", answer: "intermediate" },
        { questionId: "q9_time_availability", answer: "part_time" },
        { questionId: "q10_emotional_tolerance", answer: 5 }
      ];
      const profile = createRiskProfile2("backtest-user", defaultResponses);
      const strategy = generateStrategy2(profile);
      return runBacktest3(strategy, {
        strategyId: input.strategyId,
        symbol: input.symbol,
        startDate: input.startDate,
        endDate: input.endDate,
        initialCapital: input.initialCapital,
        commission: input.commissionRate,
        slippage: 1e-3,
        useMarginTrading: false,
        maxLeverage: 1
      });
    }),
    getBacktestSummary: protectedProcedure.input(z2.object({ backtestId: z2.string() })).query(async ({ input }) => {
      const { runBacktest: runBacktest3, getBacktestSummary: getBacktestSummary2 } = await Promise.resolve().then(() => (init_StrategyBacktestingIntegration(), StrategyBacktestingIntegration_exports));
      const { generateStrategy: generateStrategy2, createRiskProfile: createRiskProfile2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      const defaultResponses = [
        { questionId: "q1_risk_tolerance", answer: 3 },
        { questionId: "q2_investment_horizon", answer: "medium_term" },
        { questionId: "q3_loss_reaction", answer: "hold" },
        { questionId: "q4_income_stability", answer: "stable" },
        { questionId: "q5_investment_goal", answer: "growth" },
        { questionId: "q6_market_knowledge", answer: "intermediate" },
        { questionId: "q7_portfolio_allocation", answer: "balanced" },
        { questionId: "q8_experience", answer: "intermediate" },
        { questionId: "q9_time_availability", answer: "part_time" },
        { questionId: "q10_emotional_tolerance", answer: 5 }
      ];
      const profile = createRiskProfile2("backtest-user", defaultResponses);
      const strategy = generateStrategy2(profile);
      const mockResult = runBacktest3(strategy, {
        strategyId: input.backtestId,
        symbol: "AAPL",
        startDate: Date.now() - 365 * 24 * 60 * 60 * 1e3,
        endDate: Date.now(),
        initialCapital: 1e5,
        commission: 1e-3,
        slippage: 1e-3,
        useMarginTrading: false,
        maxLeverage: 1
      });
      return getBacktestSummary2(mockResult);
    }),
    compareBacktestResults: protectedProcedure.input(z2.object({ backtestIds: z2.array(z2.string()) })).query(async ({ input }) => {
      const { runBacktest: runBacktest3, compareBacktestResults: compareBacktestResults2 } = await Promise.resolve().then(() => (init_StrategyBacktestingIntegration(), StrategyBacktestingIntegration_exports));
      const { generateStrategy: generateStrategy2, createRiskProfile: createRiskProfile2 } = await Promise.resolve().then(() => (init_AutomatedStrategyGeneration(), AutomatedStrategyGeneration_exports));
      const results = input.backtestIds.map((id, idx) => {
        const defaultResponses = [
          { questionId: "q1_risk_tolerance", answer: 1 + idx },
          { questionId: "q2_investment_horizon", answer: "medium_term" },
          { questionId: "q3_loss_reaction", answer: "hold" },
          { questionId: "q4_income_stability", answer: "stable" },
          { questionId: "q5_investment_goal", answer: "growth" },
          { questionId: "q6_market_knowledge", answer: "intermediate" },
          { questionId: "q7_portfolio_allocation", answer: "balanced" },
          { questionId: "q8_experience", answer: "intermediate" },
          { questionId: "q9_time_availability", answer: "part_time" },
          { questionId: "q10_emotional_tolerance", answer: 5 }
        ];
        const profile = createRiskProfile2(`backtest-${id}`, defaultResponses);
        const strategy = generateStrategy2(profile);
        return runBacktest3(strategy, {
          strategyId: id,
          symbol: "AAPL",
          startDate: Date.now() - 365 * 24 * 60 * 60 * 1e3,
          endDate: Date.now(),
          initialCapital: 1e5,
          commission: 1e-3,
          slippage: 1e-3,
          useMarginTrading: false,
          maxLeverage: 1
        });
      });
      return compareBacktestResults2(results);
    }),
    // Strategy Alerts
    getAlerts: protectedProcedure.input(z2.object({
      status: z2.enum(["active", "triggered", "expired", "cancelled"]).optional(),
      type: z2.string().optional(),
      symbol: z2.string().optional()
    }).optional()).query(async ({ ctx, input }) => {
      const { getUserAlerts: getUserAlerts3 } = await Promise.resolve().then(() => (init_StrategyAlerts(), StrategyAlerts_exports));
      return getUserAlerts3(ctx.user.openId, input);
    }),
    getAlertTemplates: publicProcedure.input(z2.object({ category: z2.enum(["entry", "exit", "risk", "opportunity"]).optional() }).optional()).query(async ({ input }) => {
      const { getAlertTemplates: getAlertTemplates2 } = await Promise.resolve().then(() => (init_StrategyAlerts(), StrategyAlerts_exports));
      return getAlertTemplates2(input?.category);
    }),
    getAlertSummary: protectedProcedure.query(async ({ ctx }) => {
      const { getAlertSummary: getAlertSummary4 } = await Promise.resolve().then(() => (init_StrategyAlerts(), StrategyAlerts_exports));
      return getAlertSummary4(ctx.user.openId);
    }),
    getRecentTriggers: protectedProcedure.input(z2.object({ limit: z2.number().default(20) })).query(async ({ ctx, input }) => {
      const { getRecentTriggers: getRecentTriggers2 } = await Promise.resolve().then(() => (init_StrategyAlerts(), StrategyAlerts_exports));
      return getRecentTriggers2(ctx.user.openId, input.limit);
    }),
    createAlert: protectedProcedure.input(z2.object({
      strategyId: z2.string(),
      strategyName: z2.string(),
      symbol: z2.string(),
      type: z2.enum(["entry_signal", "exit_signal", "price_target", "stop_loss", "indicator_crossover", "volume_spike", "volatility_alert", "custom"]),
      priority: z2.enum(["low", "medium", "high", "critical"]).default("medium"),
      conditions: z2.array(z2.object({
        type: z2.enum(["price", "indicator", "volume", "volatility", "time", "custom"]),
        indicator: z2.string().optional(),
        operator: z2.enum(["above", "below", "crosses_above", "crosses_below", "equals", "between", "change_percent"]),
        value: z2.union([z2.number(), z2.tuple([z2.number(), z2.number()])])
      })),
      conditionLogic: z2.enum(["all", "any"]).default("all"),
      message: z2.string().optional(),
      notificationChannels: z2.array(z2.string()).default(["in_app"]),
      cooldownMinutes: z2.number().default(30)
    })).mutation(async ({ ctx, input }) => {
      const { createAlert: createAlert3 } = await Promise.resolve().then(() => (init_StrategyAlerts(), StrategyAlerts_exports));
      return createAlert3(ctx.user.openId, input.strategyId, input.strategyName, input.symbol, {
        type: input.type,
        priority: input.priority,
        conditions: input.conditions,
        conditionLogic: input.conditionLogic,
        message: input.message,
        notificationChannels: input.notificationChannels,
        cooldownMinutes: input.cooldownMinutes
      });
    }),
    createAlertFromTemplate: protectedProcedure.input(z2.object({
      templateId: z2.string(),
      strategyId: z2.string(),
      strategyName: z2.string(),
      symbol: z2.string(),
      priority: z2.enum(["low", "medium", "high", "critical"]).optional(),
      notificationChannels: z2.array(z2.string()).optional()
    })).mutation(async ({ ctx, input }) => {
      const { createAlertFromTemplate: createAlertFromTemplate2 } = await Promise.resolve().then(() => (init_StrategyAlerts(), StrategyAlerts_exports));
      return createAlertFromTemplate2(
        ctx.user.openId,
        input.strategyId,
        input.strategyName,
        input.symbol,
        input.templateId,
        {
          priority: input.priority,
          notificationChannels: input.notificationChannels
        }
      );
    }),
    cancelAlert: protectedProcedure.input(z2.object({ alertId: z2.string() })).mutation(async ({ input }) => {
      const { cancelAlert: cancelAlert2 } = await Promise.resolve().then(() => (init_StrategyAlerts(), StrategyAlerts_exports));
      return cancelAlert2(input.alertId);
    }),
    deleteAlert: protectedProcedure.input(z2.object({ alertId: z2.string() })).mutation(async ({ input }) => {
      const { deleteAlert: deleteAlert3 } = await Promise.resolve().then(() => (init_StrategyAlerts(), StrategyAlerts_exports));
      return deleteAlert3(input.alertId);
    }),
    acknowledgeTrigger: protectedProcedure.input(z2.object({ triggerId: z2.string() })).mutation(async ({ input }) => {
      const { acknowledgeTrigger: acknowledgeTrigger2 } = await Promise.resolve().then(() => (init_StrategyAlerts(), StrategyAlerts_exports));
      return acknowledgeTrigger2(input.triggerId);
    }),
    processAlerts: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      price: z2.number(),
      volume: z2.number(),
      change: z2.number(),
      changePercent: z2.number()
    })).mutation(async ({ input }) => {
      const { processAlerts: processAlerts2, simulateMarketSnapshot: simulateMarketSnapshot2 } = await Promise.resolve().then(() => (init_StrategyAlerts(), StrategyAlerts_exports));
      const snapshot = {
        ...simulateMarketSnapshot2(input.symbol),
        price: input.price,
        volume: input.volume,
        change: input.change,
        changePercent: input.changePercent
      };
      return processAlerts2(input.symbol, snapshot);
    })
  }),
  // ==================== ALPACA BROKER INTEGRATION ====================
  alpaca: router({
    // Market Data - Real-time Quotes
    getQuote: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      feed: z2.enum(["iex", "sip"]).optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getQuote(input.symbol);
    }),
    getQuotes: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string()),
      feed: z2.enum(["iex", "sip"]).optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      const quotes = await Promise.all(input.symbols.map((s) => adapter.getQuote(s)));
      return Object.fromEntries(input.symbols.map((s, i) => [s, quotes[i]]));
    }),
    // Market Data - Historical Bars
    getBars: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      timeframe: z2.enum(["1Min", "5Min", "15Min", "30Min", "1Hour", "4Hour", "1Day", "1Week", "1Month"]),
      start: z2.string().optional(),
      end: z2.string().optional(),
      limit: z2.number().max(1e4).optional(),
      feed: z2.enum(["iex", "sip"]).optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getBars({
        symbol: input.symbol,
        timeframe: input.timeframe,
        start: input.start ? new Date(input.start) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
        end: input.end ? new Date(input.end) : void 0,
        limit: input.limit
      });
    }),
    getMultiBars: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string()),
      timeframe: z2.enum(["1Min", "5Min", "15Min", "30Min", "1Hour", "4Hour", "1Day", "1Week", "1Month"]),
      start: z2.string().optional(),
      end: z2.string().optional(),
      limit: z2.number().max(1e4).optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      const results = {};
      for (const symbol of input.symbols) {
        results[symbol] = await adapter.getBars({
          symbol,
          timeframe: input.timeframe,
          start: input.start ? new Date(input.start) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3),
          end: input.end ? new Date(input.end) : void 0,
          limit: input.limit
        });
      }
      return results;
    }),
    // Market Data - Trades
    getTrades: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      start: z2.string().optional(),
      end: z2.string().optional(),
      limit: z2.number().max(1e4).optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getTrades(
        input.symbol,
        input.start ? new Date(input.start) : new Date(Date.now() - 24 * 60 * 60 * 1e3),
        input.end ? new Date(input.end) : void 0,
        input.limit
      );
    }),
    // Market Data - Snapshot
    getSnapshot: protectedProcedure.input(z2.object({
      symbol: z2.string()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getSnapshot(input.symbol);
    }),
    getSnapshots: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string())
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getSnapshots(input.symbols);
    }),
    // Options Trading
    getOptionsChain: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      expirationDate: z2.string().optional(),
      strikePrice: z2.number().optional(),
      optionType: z2.enum(["call", "put"]).optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getOptionsChain({
        underlyingSymbol: input.symbol,
        expirationDate: input.expirationDate ? new Date(input.expirationDate) : void 0,
        strikePrice: input.strikePrice,
        type: input.optionType
      });
    }),
    getOptionContract: protectedProcedure.input(z2.object({
      contractId: z2.string()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getOptionContract(input.contractId);
    }),
    // Crypto Trading
    getCryptoQuote: protectedProcedure.input(z2.object({
      symbol: z2.string()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getCryptoQuote(input.symbol);
    }),
    getCryptoBars: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      timeframe: z2.enum(["1Min", "5Min", "15Min", "30Min", "1Hour", "4Hour", "1Day", "1Week", "1Month"]),
      start: z2.string().optional(),
      end: z2.string().optional(),
      limit: z2.number().max(1e4).optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getCryptoBars(input.symbol, input.timeframe, {
        start: input.start,
        end: input.end,
        limit: input.limit
      });
    }),
    getCryptoTrades: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      start: z2.string().optional(),
      end: z2.string().optional(),
      limit: z2.number().max(1e4).optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getCryptoTrades(input.symbol, {
        start: input.start,
        end: input.end,
        limit: input.limit
      });
    }),
    getCryptoSnapshot: protectedProcedure.input(z2.object({
      symbol: z2.string()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getCryptoSnapshot(input.symbol);
    }),
    // News Feed
    getNews: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string()).optional(),
      start: z2.string().optional(),
      end: z2.string().optional(),
      limit: z2.number().max(50).optional(),
      includeContent: z2.boolean().optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getNews(input.symbols, input.limit);
    }),
    // AI-Powered News Sentiment Analysis
    analyzeNewsSentiment: protectedProcedure.input(z2.object({
      articles: z2.array(z2.object({
        id: z2.string(),
        headline: z2.string()
      }))
    })).mutation(async ({ input }) => {
      const { analyzeNewsBatchSentiment: analyzeNewsBatchSentiment2 } = await Promise.resolve().then(() => (init_newsSentimentAnalysis(), newsSentimentAnalysis_exports));
      return analyzeNewsBatchSentiment2(input.articles);
    }),
    // Quick keyword-based sentiment (no LLM, instant)
    getQuickSentiment: publicProcedure.input(z2.object({
      headline: z2.string()
    })).query(async ({ input }) => {
      const { analyzeKeywordSentiment: analyzeKeywordSentiment2 } = await Promise.resolve().then(() => (init_newsSentimentAnalysis(), newsSentimentAnalysis_exports));
      return analyzeKeywordSentiment2(input.headline);
    }),
    // Sentiment Trend Data
    getSentimentTrend: protectedProcedure.input(z2.object({
      period: z2.enum(["24h", "7d"])
    })).query(async ({ input }) => {
      const { getSentimentTrendWithFallback: getSentimentTrendWithFallback2 } = await Promise.resolve().then(() => (init_sentimentTrendService(), sentimentTrendService_exports));
      return getSentimentTrendWithFallback2(input.period);
    }),
    // Record sentiment for trend tracking
    recordSentimentForTrend: protectedProcedure.input(z2.object({
      articles: z2.array(z2.object({
        id: z2.string(),
        sentiment: z2.enum(["bullish", "bearish", "neutral"]),
        timestamp: z2.number().optional()
      }))
    })).mutation(async ({ input }) => {
      const { recordSentimentBatch: recordSentimentBatch2 } = await Promise.resolve().then(() => (init_sentimentTrendService(), sentimentTrendService_exports));
      recordSentimentBatch2(input.articles);
      return { success: true, recorded: input.articles.length };
    }),
    // Trading - Orders
    placeOrder: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      quantity: z2.number(),
      side: z2.enum(["buy", "sell"]),
      type: z2.enum(["market", "limit", "stop", "stop_limit", "trailing_stop"]),
      timeInForce: z2.enum(["day", "gtc", "opg", "cls", "ioc", "fok"]),
      limitPrice: z2.number().optional(),
      stopPrice: z2.number().optional(),
      trailPercent: z2.number().optional(),
      trailPrice: z2.number().optional(),
      extendedHours: z2.boolean().optional(),
      clientOrderId: z2.string().optional()
    })).mutation(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.placeOrder({
        symbol: input.symbol,
        quantity: input.quantity,
        side: input.side,
        type: input.type,
        timeInForce: input.timeInForce,
        price: input.limitPrice,
        stopPrice: input.stopPrice,
        trailPercent: input.trailPercent,
        extendedHours: input.extendedHours,
        clientOrderId: input.clientOrderId
      });
    }),
    placeBracketOrder: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      quantity: z2.number(),
      side: z2.enum(["buy", "sell"]),
      type: z2.enum(["market", "limit"]),
      timeInForce: z2.enum(["day", "gtc"]),
      limitPrice: z2.number().optional(),
      takeProfitLimitPrice: z2.number(),
      stopLossStopPrice: z2.number(),
      stopLossLimitPrice: z2.number().optional()
    })).mutation(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.placeBracketOrder(input);
    }),
    placeOCOOrder: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      quantity: z2.number(),
      side: z2.enum(["buy", "sell"]),
      takeProfitLimitPrice: z2.number(),
      stopLossStopPrice: z2.number(),
      stopLossLimitPrice: z2.number().optional()
    })).mutation(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.placeOCOOrder(input);
    }),
    modifyOrder: protectedProcedure.input(z2.object({
      orderId: z2.string(),
      quantity: z2.number().optional(),
      limitPrice: z2.number().optional(),
      stopPrice: z2.number().optional(),
      trailPercent: z2.number().optional(),
      timeInForce: z2.enum(["day", "gtc", "opg", "cls", "ioc", "fok"]).optional()
    })).mutation(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.modifyOrder({ orderId: input.orderId, quantity: input.quantity, price: input.limitPrice, stopPrice: input.stopPrice, trailPercent: input.trailPercent, timeInForce: input.timeInForce });
    }),
    cancelOrder: protectedProcedure.input(z2.object({
      orderId: z2.string()
    })).mutation(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.cancelOrder(input.orderId);
    }),
    cancelAllOrders: protectedProcedure.mutation(async () => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.cancelAllOrders();
    }),
    getOrder: protectedProcedure.input(z2.object({
      orderId: z2.string()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getOrder(input.orderId);
    }),
    getOrders: protectedProcedure.input(z2.object({
      connectionId: z2.string().optional(),
      status: z2.enum(["open", "closed", "all"]).optional(),
      limit: z2.number().max(500).optional(),
      after: z2.string().optional(),
      until: z2.string().optional(),
      direction: z2.enum(["asc", "desc"]).optional(),
      symbols: z2.array(z2.string()).optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getOrders(input.status, input.limit, input.after ? new Date(input.after) : void 0);
    }),
    // Trading - Positions
    getPosition: protectedProcedure.input(z2.object({
      symbol: z2.string()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getPosition(input.symbol);
    }),
    getPositions: protectedProcedure.input(z2.object({ connectionId: z2.string().optional() })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getPositions();
    }),
    closePosition: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      quantity: z2.number().optional(),
      percentage: z2.number().optional()
    })).mutation(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.closePosition(input.symbol, input.quantity, input.percentage);
    }),
    closeAllPositions: protectedProcedure.input(z2.object({
      cancelOrders: z2.boolean().optional()
    })).mutation(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.closeAllPositions();
    }),
    // Account
    getAccount: protectedProcedure.input(z2.object({ connectionId: z2.string() })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getAccount();
    }),
    getAccountBalance: protectedProcedure.query(async () => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getAccountBalance();
    }),
    getPortfolioHistory: protectedProcedure.input(z2.object({
      period: z2.enum(["1D", "1W", "1M", "3M", "6M", "1A", "all"]).optional(),
      timeframe: z2.enum(["1Min", "5Min", "15Min", "1H", "1D"]).optional(),
      dateEnd: z2.string().optional(),
      extendedHours: z2.boolean().optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getPortfolioHistory(input.period, input.timeframe);
    }),
    // Assets
    getAsset: protectedProcedure.input(z2.object({
      symbol: z2.string()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getAsset(input.symbol);
    }),
    getAssets: protectedProcedure.input(z2.object({
      status: z2.enum(["active", "inactive"]).optional(),
      assetClass: z2.enum(["us_equity", "crypto"]).optional(),
      exchange: z2.string().optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getAssets(input.assetClass);
    }),
    // Calendar & Clock
    getClock: protectedProcedure.query(async () => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getClock();
    }),
    getCalendar: protectedProcedure.input(z2.object({
      start: z2.string().optional(),
      end: z2.string().optional()
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getCalendar(input.start, input.end);
    }),
    // Last Closing Prices (for when market is closed)
    getLastClosingPrices: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string())
    })).query(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      const results = await Promise.all(
        input.symbols.map(async (symbol) => {
          try {
            const startDate = /* @__PURE__ */ new Date();
            startDate.setDate(startDate.getDate() - 7);
            const bars = await adapter.getBars({
              symbol,
              timeframe: "1Day",
              start: startDate,
              limit: 5
              // Get last 5 days to ensure we have enough data
            });
            if (bars.length >= 1) {
              const latestBar = bars[bars.length - 1];
              const previousBar = bars.length >= 2 ? bars[bars.length - 2] : null;
              const close = latestBar.close;
              const previousClose = previousBar?.close || latestBar.open;
              const change = close - previousClose;
              const changePercent = previousClose ? change / previousClose * 100 : 0;
              return {
                symbol: symbol.toUpperCase(),
                close,
                previousClose,
                change,
                changePercent,
                volume: latestBar.volume,
                timestamp: latestBar.timestamp
              };
            }
            return null;
          } catch (error) {
            console.error(`Error fetching closing price for ${symbol}:`, error);
            return null;
          }
        })
      );
      return results.filter((r) => r !== null);
    }),
    // Watchlists
    getWatchlists: protectedProcedure.query(async () => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getWatchlists();
    }),
    createWatchlist: protectedProcedure.input(z2.object({
      name: z2.string(),
      symbols: z2.array(z2.string()).optional()
    })).mutation(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.createWatchlist(input.name, input.symbols);
    }),
    updateWatchlist: protectedProcedure.input(z2.object({
      watchlistId: z2.string(),
      name: z2.string().optional(),
      symbols: z2.array(z2.string()).optional()
    })).mutation(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.updateWatchlist(input.watchlistId, input.name, input.symbols);
    }),
    deleteWatchlist: protectedProcedure.input(z2.object({
      watchlistId: z2.string()
    })).mutation(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.deleteWatchlist(input.watchlistId);
    }),
    // Broker Capabilities
    getCapabilities: protectedProcedure.query(async () => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      return adapter.getCapabilities();
    }),
    // Connection Test
    testConnection: protectedProcedure.input(z2.object({ connectionId: z2.string() })).mutation(async ({ input }) => {
      const { AlpacaBrokerAdapter: AlpacaBrokerAdapter2 } = await Promise.resolve().then(() => (init_AlpacaBrokerAdapter(), AlpacaBrokerAdapter_exports));
      const adapter = new AlpacaBrokerAdapter2();
      const result = await adapter.testConnection();
      return { success: result.success, error: result.success ? void 0 : result.message };
    })
  }),
  // ==================== ORDER ROUTING PREFERENCES ====================
  routing: router({
    // Get user's routing preferences
    getPreferences: protectedProcedure.query(async ({ ctx }) => {
      const { getDb: getDb2 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const { userRoutingPreferences: userRoutingPreferences2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq18 } = await import("drizzle-orm");
      const db = await getDb2();
      if (!db) throw new Error("Database not available");
      const prefs = await db.select().from(userRoutingPreferences2).where(eq18(userRoutingPreferences2.userId, String(ctx.user.id))).limit(1);
      if (prefs.length === 0) {
        return {
          enableSmartRouting: true,
          preferredStockBroker: null,
          preferredCryptoBroker: null,
          preferredForexBroker: null,
          preferredOptionsBroker: null,
          allowFallback: true,
          prioritizeLowFees: false,
          prioritizeFastExecution: false
        };
      }
      return prefs[0];
    }),
    // Save user's routing preferences
    savePreferences: protectedProcedure.input(z2.object({
      smartRoutingEnabled: z2.boolean(),
      preferredStockBroker: z2.string().nullable().optional(),
      preferredCryptoBroker: z2.string().nullable().optional(),
      preferredForexBroker: z2.string().nullable().optional(),
      preferredOptionsBroker: z2.string().nullable().optional(),
      preferredFuturesBroker: z2.string().nullable().optional(),
      fallbackEnabled: z2.boolean().optional(),
      costOptimization: z2.boolean().optional(),
      speedPriority: z2.boolean().optional()
    })).mutation(async ({ ctx, input }) => {
      const { getDb: getDb2 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const { userRoutingPreferences: userRoutingPreferences2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq18 } = await import("drizzle-orm");
      const db = await getDb2();
      if (!db) throw new Error("Database not available");
      const existing = await db.select().from(userRoutingPreferences2).where(eq18(userRoutingPreferences2.userId, String(ctx.user.id))).limit(1);
      const now = /* @__PURE__ */ new Date();
      if (existing.length === 0) {
        await db.insert(userRoutingPreferences2).values({
          userId: String(ctx.user.id),
          enableSmartRouting: input.smartRoutingEnabled ?? true,
          preferredStockBroker: input.preferredStockBroker || null,
          preferredCryptoBroker: input.preferredCryptoBroker || null,
          preferredForexBroker: input.preferredForexBroker || null,
          preferredOptionsBroker: input.preferredOptionsBroker || null,
          allowFallback: input.fallbackEnabled ?? true,
          prioritizeLowFees: input.costOptimization ?? false,
          prioritizeFastExecution: input.speedPriority ?? false,
          createdAt: now,
          updatedAt: now
        });
      } else {
        await db.update(userRoutingPreferences2).set({
          enableSmartRouting: input.smartRoutingEnabled ?? true,
          preferredStockBroker: input.preferredStockBroker || null,
          preferredCryptoBroker: input.preferredCryptoBroker || null,
          preferredForexBroker: input.preferredForexBroker || null,
          preferredOptionsBroker: input.preferredOptionsBroker || null,
          allowFallback: input.fallbackEnabled ?? true,
          prioritizeLowFees: input.costOptimization ?? false,
          prioritizeFastExecution: input.speedPriority ?? false,
          updatedAt: now
        }).where(eq18(userRoutingPreferences2.userId, String(ctx.user.id)));
      }
      return { success: true };
    }),
    // Get routing recommendation for a symbol
    getRecommendation: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      orderType: z2.enum(["market", "limit", "stop", "stop_limit"]).optional()
    })).query(async ({ ctx, input }) => {
      const { orderRouter: orderRouter2, detectAssetClass: detectAssetClass2 } = await Promise.resolve().then(() => (init_OrderRouter(), OrderRouter_exports));
      const { getDb: getDb2 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const { brokerConnections: brokerConnections2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq18 } = await import("drizzle-orm");
      const db = await getDb2();
      if (!db) return { selectedBroker: null, confidence: 0, reason: "Database not available", assetClass: "unknown", connectedBrokers: [] };
      const connections = await db.select().from(brokerConnections2).where(eq18(brokerConnections2.userId, String(ctx.user.id)));
      const assetClass = detectAssetClass2(input.symbol);
      const recommendation = orderRouter2.selectBroker(
        input.symbol,
        {
          enableSmartRouting: true,
          allowFallback: true,
          prioritizeLowFees: false,
          prioritizeFastExecution: true
        }
      );
      return {
        ...recommendation,
        assetClass,
        connectedBrokers: connections.map((c) => ({
          id: String(c.id),
          brokerType: c.brokerType,
          isActive: c.isActive
        }))
      };
    }),
    // Get available brokers for each asset class
    getAvailableBrokers: protectedProcedure.query(async ({ ctx }) => {
      const { getDb: getDb2 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const { brokerConnections: brokerConnections2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq18 } = await import("drizzle-orm");
      const db = await getDb2();
      if (!db) return { stocks: [], crypto: [], forex: [], options: [], futures: [] };
      const connections = await db.select().from(brokerConnections2).where(eq18(brokerConnections2.userId, String(ctx.user.id)));
      const brokerCapabilities = {
        alpaca: ["stocks", "crypto"],
        interactive_brokers: ["stocks", "options", "futures", "forex"],
        binance: ["crypto"],
        coinbase: ["crypto"]
      };
      const result = {
        stocks: [],
        crypto: [],
        forex: [],
        options: [],
        futures: []
      };
      for (const conn of connections) {
        const capabilities = brokerCapabilities[conn.brokerType] || [];
        for (const cap of capabilities) {
          if (result[cap]) {
            result[cap].push({
              id: String(conn.id),
              brokerType: conn.brokerType,
              isActive: conn.isActive
            });
          }
        }
      }
      return result;
    })
  }),
  // ==================== MULTI-ASSET ANALYSIS ====================
  multiAsset: router({
    // Analyze any asset type (stock, crypto, options, forex, commodity)
    analyze: protectedProcedure.input(z2.object({
      symbol: z2.string(),
      assetType: z2.enum(["stock", "crypto", "options", "forex", "commodity"]),
      currentPrice: z2.number(),
      priceChange24h: z2.number(),
      priceChange7d: z2.number().optional(),
      volume24h: z2.number(),
      marketCap: z2.number().optional(),
      stockData: z2.object({
        sector: z2.string(),
        industry: z2.string(),
        peRatio: z2.number().optional(),
        earningsGrowth: z2.number().optional(),
        dividendYield: z2.number().optional()
      }).optional(),
      cryptoData: z2.object({
        symbol: z2.string(),
        category: z2.enum(["layer1", "layer2", "defi", "nft", "gaming", "meme", "stablecoin", "unknown"]),
        currentPrice: z2.number(),
        priceChange24h: z2.number(),
        priceChange7d: z2.number(),
        volume24h: z2.number(),
        marketCap: z2.number()
      }).optional(),
      optionsData: z2.object({
        symbol: z2.string(),
        underlyingPrice: z2.number(),
        greeks: z2.object({
          delta: z2.number(),
          gamma: z2.number(),
          theta: z2.number(),
          vega: z2.number(),
          rho: z2.number(),
          impliedVolatility: z2.number(),
          historicalVolatility: z2.number(),
          ivRank: z2.number(),
          ivPercentile: z2.number(),
          openInterest: z2.number(),
          volume: z2.number(),
          bid: z2.number(),
          ask: z2.number(),
          lastPrice: z2.number(),
          bidAskSpread: z2.number(),
          strikePrice: z2.number(),
          underlyingPrice: z2.number(),
          daysToExpiry: z2.number(),
          optionType: z2.enum(["call", "put"])
        })
      }).optional(),
      forexData: z2.object({
        baseCurrency: z2.string(),
        quoteCurrency: z2.string(),
        interestRateDiff: z2.number(),
        centralBankBias: z2.enum(["hawkish", "neutral", "dovish"]),
        cotPositioning: z2.number()
      }).optional(),
      commodityData: z2.object({
        commodityType: z2.enum(["energy", "metals", "agriculture", "livestock"]),
        inventoryLevels: z2.number(),
        seasonalPattern: z2.number(),
        supplyDisruption: z2.boolean()
      }).optional()
    })).mutation(async ({ input }) => {
      const { UnifiedMultiAssetOrchestrator: UnifiedMultiAssetOrchestrator2 } = await Promise.resolve().then(() => (init_UnifiedMultiAssetOrchestrator(), UnifiedMultiAssetOrchestrator_exports));
      const orchestrator = new UnifiedMultiAssetOrchestrator2();
      return orchestrator.analyze(input);
    }),
    // Analyze portfolio across multiple asset types
    analyzePortfolio: protectedProcedure.input(z2.object({
      assets: z2.array(z2.object({
        symbol: z2.string(),
        assetType: z2.enum(["stock", "crypto", "options", "forex", "commodity"]),
        currentPrice: z2.number(),
        priceChange24h: z2.number(),
        priceChange7d: z2.number().optional(),
        volume24h: z2.number(),
        marketCap: z2.number().optional()
      }))
    })).mutation(async ({ input }) => {
      const { UnifiedMultiAssetOrchestrator: UnifiedMultiAssetOrchestrator2 } = await Promise.resolve().then(() => (init_UnifiedMultiAssetOrchestrator(), UnifiedMultiAssetOrchestrator_exports));
      const orchestrator = new UnifiedMultiAssetOrchestrator2();
      return orchestrator.analyzePortfolio(input.assets);
    }),
    // Detect asset type from symbol
    detectAssetType: publicProcedure.input(z2.object({ symbol: z2.string() })).query(async ({ input }) => {
      const { detectAssetType: detectAssetType2 } = await Promise.resolve().then(() => (init_UnifiedMultiAssetOrchestrator(), UnifiedMultiAssetOrchestrator_exports));
      return { assetType: detectAssetType2(input.symbol) };
    })
  }),
  // Real-time price feed router
  realtimePrices: router({
    // Get current price for a single symbol
    getPrice: publicProcedure.input(z2.object({
      symbol: z2.string()
    })).query(async ({ input }) => {
      const { realtimePriceFeed: realtimePriceFeed2, detectAssetTypeFromSymbol: detectAssetTypeFromSymbol2, generateSimulatedPrice: generateSimulatedPrice2 } = await Promise.resolve().then(() => (init_realtimePriceFeed(), realtimePriceFeed_exports));
      const price = realtimePriceFeed2.getPrice(input.symbol);
      if (price) return price;
      const assetType = detectAssetTypeFromSymbol2(input.symbol);
      const { generateSimulatedPrice: genPrice } = await Promise.resolve().then(() => (init_realtimePriceFeed(), realtimePriceFeed_exports));
      return genPrice(input.symbol, assetType);
    }),
    // Get prices for multiple symbols
    getPrices: publicProcedure.input(z2.object({
      symbols: z2.array(z2.string())
    })).query(async ({ input }) => {
      const { getAggregatedPrices: getAggregatedPrices2, detectAssetTypeFromSymbol: detectAssetTypeFromSymbol2 } = await Promise.resolve().then(() => (init_realtimePriceFeed(), realtimePriceFeed_exports));
      const grouped = {
        stocks: [],
        crypto: [],
        forex: [],
        commodities: []
      };
      input.symbols.forEach((symbol) => {
        const assetType = detectAssetTypeFromSymbol2(symbol);
        switch (assetType) {
          case "stock":
            grouped.stocks.push(symbol);
            break;
          case "crypto":
            grouped.crypto.push(symbol);
            break;
          case "forex":
            grouped.forex.push(symbol);
            break;
          case "commodity":
            grouped.commodities.push(symbol);
            break;
        }
      });
      const aggregated = getAggregatedPrices2(grouped);
      return {
        prices: [
          ...aggregated.stocks,
          ...aggregated.crypto,
          ...aggregated.forex,
          ...aggregated.commodities
        ],
        timestamp: aggregated.timestamp
      };
    }),
    // Get aggregated prices by asset type
    getAggregatedPrices: publicProcedure.input(z2.object({
      stocks: z2.array(z2.string()).optional(),
      crypto: z2.array(z2.string()).optional(),
      forex: z2.array(z2.string()).optional(),
      commodities: z2.array(z2.string()).optional()
    })).query(async ({ input }) => {
      const { getAggregatedPrices: getAggregatedPrices2 } = await Promise.resolve().then(() => (init_realtimePriceFeed(), realtimePriceFeed_exports));
      return getAggregatedPrices2(input);
    }),
    // Get default watchlist
    getDefaultWatchlist: publicProcedure.query(async () => {
      const { DEFAULT_WATCHLIST: DEFAULT_WATCHLIST2 } = await Promise.resolve().then(() => (init_realtimePriceFeed(), realtimePriceFeed_exports));
      return DEFAULT_WATCHLIST2;
    }),
    // Subscribe to price updates (initializes the feed)
    subscribe: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string())
    })).mutation(async ({ input }) => {
      const { realtimePriceFeed: realtimePriceFeed2, detectAssetTypeFromSymbol: detectAssetTypeFromSymbol2 } = await Promise.resolve().then(() => (init_realtimePriceFeed(), realtimePriceFeed_exports));
      input.symbols.forEach((symbol) => {
        const assetType = detectAssetTypeFromSymbol2(symbol);
        realtimePriceFeed2.subscribe({ symbol, assetType });
      });
      return { subscribed: input.symbols, status: "active" };
    }),
    // Unsubscribe from price updates
    unsubscribe: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string())
    })).mutation(async ({ input }) => {
      const { realtimePriceFeed: realtimePriceFeed2 } = await Promise.resolve().then(() => (init_realtimePriceFeed(), realtimePriceFeed_exports));
      input.symbols.forEach((symbol) => {
        realtimePriceFeed2.unsubscribe(symbol);
      });
      return { unsubscribed: input.symbols };
    }),
    // Get feed service status
    getStatus: publicProcedure.query(async () => {
      const { realtimePriceFeed: realtimePriceFeed2 } = await Promise.resolve().then(() => (init_realtimePriceFeed(), realtimePriceFeed_exports));
      return realtimePriceFeed2.getStatus();
    }),
    // Force refresh price for a symbol
    refreshPrice: publicProcedure.input(z2.object({ symbol: z2.string() })).mutation(async ({ input }) => {
      const { realtimePriceFeed: realtimePriceFeed2 } = await Promise.resolve().then(() => (init_realtimePriceFeed(), realtimePriceFeed_exports));
      return realtimePriceFeed2.refreshPrice(input.symbol);
    })
  }),
  // Cross-Asset Correlation Router
  correlation: router({
    // Get correlation matrix for specified assets
    getMatrix: publicProcedure.input(z2.object({
      symbols: z2.array(z2.string()).min(2).max(20),
      assetTypes: z2.array(z2.enum(["stock", "crypto", "forex", "commodity", "option"])).optional(),
      period: z2.enum(["24h", "7d", "30d"]).default("7d")
    })).query(async ({ input }) => {
      const correlationService = await Promise.resolve().then(() => (init_correlationService(), correlationService_exports));
      const assets = input.symbols.map((symbol, index) => {
        const assetType = input.assetTypes?.[index] || "stock";
        let history = correlationService.getPriceHistory(symbol, assetType);
        if (!history) {
          const basePrice = assetType === "crypto" ? 1e3 + Math.random() * 5e4 : 100 + Math.random() * 400;
          const volatility = assetType === "crypto" ? 0.03 : 0.015;
          history = correlationService.generateSimulatedPriceHistory(symbol, assetType, basePrice, volatility);
        }
        return history;
      });
      return correlationService.calculateCorrelationMatrix(assets, input.period);
    }),
    // Get correlation between two specific assets
    getPairCorrelation: publicProcedure.input(z2.object({
      asset1: z2.object({
        symbol: z2.string(),
        assetType: z2.enum(["stock", "crypto", "forex", "commodity", "option"])
      }),
      asset2: z2.object({
        symbol: z2.string(),
        assetType: z2.enum(["stock", "crypto", "forex", "commodity", "option"])
      }),
      period: z2.enum(["24h", "7d", "30d"]).default("7d")
    })).query(async ({ input }) => {
      const correlationService = await Promise.resolve().then(() => (init_correlationService(), correlationService_exports));
      let history1 = correlationService.getPriceHistory(input.asset1.symbol, input.asset1.assetType);
      let history2 = correlationService.getPriceHistory(input.asset2.symbol, input.asset2.assetType);
      if (!history1) {
        const basePrice = input.asset1.assetType === "crypto" ? 1e4 : 150;
        history1 = correlationService.generateSimulatedPriceHistory(
          input.asset1.symbol,
          input.asset1.assetType,
          basePrice,
          0.02
        );
      }
      if (!history2) {
        const basePrice = input.asset2.assetType === "crypto" ? 1e4 : 150;
        history2 = correlationService.generateSimulatedPriceHistory(
          input.asset2.symbol,
          input.asset2.assetType,
          basePrice,
          0.02
        );
      }
      return correlationService.calculateAssetCorrelation(history1, history2, input.period);
    }),
    // Seed demo correlation data
    seedDemoData: publicProcedure.mutation(async () => {
      const correlationService = await Promise.resolve().then(() => (init_correlationService(), correlationService_exports));
      correlationService.seedDemoCorrelationData();
      return { success: true, message: "Demo correlation data seeded successfully" };
    }),
    // Get available assets with price history
    getAvailableAssets: publicProcedure.query(async () => {
      const correlationService = await Promise.resolve().then(() => (init_correlationService(), correlationService_exports));
      const assets = correlationService.getCachedAssets();
      return assets.map((a) => ({
        symbol: a.symbol,
        assetType: a.assetType,
        dataPoints: a.prices.length,
        latestPrice: a.prices[a.prices.length - 1]?.price || 0,
        oldestTimestamp: a.prices[0]?.timestamp || 0,
        newestTimestamp: a.prices[a.prices.length - 1]?.timestamp || 0
      }));
    }),
    // Get correlation color for visualization
    getCorrelationColor: publicProcedure.input(z2.object({ correlation: z2.number().min(-1).max(1) })).query(async ({ input }) => {
      const correlationService = await Promise.resolve().then(() => (init_correlationService(), correlationService_exports));
      return {
        color: correlationService.getCorrelationColor(input.correlation),
        strength: correlationService.getCorrelationStrength(input.correlation)
      };
    }),
    // Clear correlation cache
    clearCache: protectedProcedure.mutation(async () => {
      const correlationService = await Promise.resolve().then(() => (init_correlationService(), correlationService_exports));
      correlationService.clearPriceHistoryCache();
      return { success: true, message: "Correlation cache cleared" };
    })
  }),
  // Portfolio Optimizer Router
  portfolioOptimizer: router({
    // Get sample assets for optimization
    getSampleAssets: publicProcedure.query(async () => {
      const optimizer = await Promise.resolve().then(() => (init_portfolioOptimizer(), portfolioOptimizer_exports));
      return optimizer.generateSampleAssets();
    }),
    // Optimize portfolio based on risk profile
    optimize: protectedProcedure.input(z2.object({
      assets: z2.array(z2.object({
        symbol: z2.string(),
        name: z2.string(),
        assetType: z2.enum(["stock", "crypto", "forex", "commodity", "bond"]),
        expectedReturn: z2.number(),
        volatility: z2.number(),
        currentPrice: z2.number()
      })),
      riskProfile: z2.enum(["conservative", "moderate", "balanced", "growth", "aggressive"]),
      iterations: z2.number().optional().default(1e4)
    })).mutation(async ({ input }) => {
      const optimizer = await Promise.resolve().then(() => (init_portfolioOptimizer(), portfolioOptimizer_exports));
      return optimizer.optimizePortfolio(input.assets, input.riskProfile, input.iterations);
    }),
    // Generate efficient frontier
    getEfficientFrontier: protectedProcedure.input(z2.object({
      assets: z2.array(z2.object({
        symbol: z2.string(),
        name: z2.string(),
        assetType: z2.enum(["stock", "crypto", "forex", "commodity", "bond"]),
        expectedReturn: z2.number(),
        volatility: z2.number(),
        currentPrice: z2.number()
      })),
      points: z2.number().optional().default(50)
    })).mutation(async ({ input }) => {
      const optimizer = await Promise.resolve().then(() => (init_portfolioOptimizer(), portfolioOptimizer_exports));
      return optimizer.generateEfficientFrontier(input.assets, input.points);
    }),
    // Run Monte Carlo simulation
    runMonteCarloSimulation: protectedProcedure.input(z2.object({
      expectedReturn: z2.number(),
      expectedVolatility: z2.number(),
      initialValue: z2.number(),
      yearsToProject: z2.number().optional().default(5),
      simulations: z2.number().optional().default(1e4),
      targetReturn: z2.number().optional()
    })).mutation(async ({ input }) => {
      const optimizer = await Promise.resolve().then(() => (init_portfolioOptimizer(), portfolioOptimizer_exports));
      const portfolio = {
        allocations: [],
        expectedReturn: input.expectedReturn,
        expectedVolatility: input.expectedVolatility,
        sharpeRatio: 0,
        riskProfile: "balanced",
        diversificationScore: 0,
        efficientFrontierPosition: "optimal"
      };
      return optimizer.runMonteCarloSimulation(
        portfolio,
        input.initialValue,
        input.yearsToProject,
        input.simulations,
        input.targetReturn
      );
    }),
    // Calculate rebalancing recommendations
    getRebalancingRecommendations: protectedProcedure.input(z2.object({
      currentAllocations: z2.array(z2.object({
        symbol: z2.string(),
        weight: z2.number()
      })),
      targetAllocations: z2.array(z2.object({
        symbol: z2.string(),
        name: z2.string(),
        assetType: z2.string(),
        weight: z2.number(),
        expectedContribution: z2.number()
      })),
      threshold: z2.number().optional().default(0.05)
    })).mutation(async ({ input }) => {
      const optimizer = await Promise.resolve().then(() => (init_portfolioOptimizer(), portfolioOptimizer_exports));
      return optimizer.calculateRebalancing(
        input.currentAllocations,
        input.targetAllocations,
        input.threshold
      );
    }),
    // Get risk profile description
    getRiskProfileDescription: publicProcedure.input(z2.object({
      profile: z2.enum(["conservative", "moderate", "balanced", "growth", "aggressive"])
    })).query(async ({ input }) => {
      const optimizer = await Promise.resolve().then(() => (init_portfolioOptimizer(), portfolioOptimizer_exports));
      return optimizer.getRiskProfileDescription(input.profile);
    }),
    // Get all risk profiles
    getAllRiskProfiles: publicProcedure.query(async () => {
      const optimizer = await Promise.resolve().then(() => (init_portfolioOptimizer(), portfolioOptimizer_exports));
      const profiles = ["conservative", "moderate", "balanced", "growth", "aggressive"];
      return profiles.map((p) => ({
        id: p,
        ...optimizer.getRiskProfileDescription(p)
      }));
    })
  }),
  // ==================== EARNINGS SENTIMENT BACKTESTING ====================
  earningsBacktest: router({
    // Run a full backtest on earnings sentiment vs price movements
    runBacktest: protectedProcedure.input(z2.object({
      symbols: z2.array(z2.string().min(1).max(10)).min(1).max(50),
      startDate: z2.string().regex(/^\d{4}-\d{2}-\d{2}$/),
      endDate: z2.string().regex(/^\d{4}-\d{2}-\d{2}$/),
      minSampleSize: z2.number().min(5).max(1e3).default(10),
      confidenceLevel: z2.number().min(0.8).max(0.99).default(0.95),
      timeframes: z2.array(z2.enum(["1d", "3d", "5d", "10d", "30d"])).default(["1d", "3d", "5d", "10d", "30d"])
    })).mutation(async ({ input }) => {
      const { EarningsSentimentBacktester: EarningsSentimentBacktester2 } = await Promise.resolve().then(() => (init_EarningsSentimentBacktester(), EarningsSentimentBacktester_exports));
      const backtester = new EarningsSentimentBacktester2();
      return backtester.runBacktest({
        symbols: input.symbols,
        startDate: input.startDate,
        endDate: input.endDate,
        minimumSampleSize: input.minSampleSize,
        confidenceLevel: input.confidenceLevel,
        timeframes: input.timeframes,
        includeSectorAnalysis: false,
        includeMarketCapAnalysis: false,
        benchmarkSymbol: "SPY"
      });
    }),
    // Get correlation analysis for a single symbol
    analyzeSymbol: protectedProcedure.input(z2.object({
      symbol: z2.string().min(1).max(10),
      startDate: z2.string().regex(/^\d{4}-\d{2}-\d{2}$/),
      endDate: z2.string().regex(/^\d{4}-\d{2}-\d{2}$/)
    })).mutation(async ({ input }) => {
      const { EarningsSentimentBacktester: EarningsSentimentBacktester2 } = await Promise.resolve().then(() => (init_EarningsSentimentBacktester(), EarningsSentimentBacktester_exports));
      const backtester = new EarningsSentimentBacktester2();
      return backtester.runBacktest({
        symbols: [input.symbol],
        startDate: input.startDate,
        endDate: input.endDate,
        minimumSampleSize: 5,
        confidenceLevel: 0.95,
        timeframes: ["1d", "3d", "5d", "10d", "30d"],
        includeSectorAnalysis: false,
        includeMarketCapAnalysis: false,
        benchmarkSymbol: "SPY"
      });
    }),
    // Get demo backtest results (pre-computed for demonstration)
    getDemoResults: publicProcedure.query(async () => {
      return {
        summary: {
          totalEarningsEvents: 156,
          symbolsAnalyzed: 10,
          dateRange: { start: "2023-01-01", end: "2025-12-31" },
          overallCorrelation: 0.42,
          bestTimeframe: "3d",
          predictionAccuracy: 0.68
        },
        correlationMatrix: {
          factors: ["overall", "managementOptimism", "managementConfidence", "analystSatisfaction", "guidanceStrength"],
          timeframes: ["1d", "3d", "5d", "10d", "30d"],
          correlations: [
            [0.35, 0.42, 0.38, 0.32, 0.28],
            [0.38, 0.45, 0.41, 0.35, 0.3],
            [0.32, 0.4, 0.36, 0.3, 0.25],
            [0.28, 0.35, 0.32, 0.27, 0.22],
            [0.4, 0.48, 0.44, 0.38, 0.32]
          ],
          pValues: [
            [0.02, 0.01, 0.02, 0.04, 0.08],
            [0.01, 5e-3, 0.01, 0.03, 0.06],
            [0.03, 0.02, 0.02, 0.05, 0.1],
            [0.05, 0.03, 0.04, 0.07, 0.12],
            [0.01, 3e-3, 8e-3, 0.02, 0.05]
          ]
        },
        signalPerformance: {
          bullishSignals: { count: 62, accuracy: 0.72, avgReturn: 4.2 },
          bearishSignals: { count: 48, accuracy: 0.65, avgReturn: -3.8 },
          neutralSignals: { count: 46, accuracy: 0.58, avgReturn: 0.8 }
        },
        topPredictors: [
          { factor: "guidanceStrength", correlation: 0.48, pValue: 3e-3, significance: "high" },
          { factor: "managementOptimism", correlation: 0.45, pValue: 5e-3, significance: "high" },
          { factor: "overall", correlation: 0.42, pValue: 0.01, significance: "high" },
          { factor: "managementConfidence", correlation: 0.4, pValue: 0.02, significance: "medium" },
          { factor: "analystSatisfaction", correlation: 0.35, pValue: 0.03, significance: "medium" }
        ],
        sampleResults: [
          { symbol: "AAPL", date: "2024-10-31", sentiment: 0.72, return1d: 2.1, return3d: 4.5, return5d: 3.8 },
          { symbol: "MSFT", date: "2024-10-22", sentiment: 0.68, return1d: 1.8, return3d: 3.2, return5d: 2.9 },
          { symbol: "GOOGL", date: "2024-10-29", sentiment: 0.55, return1d: -0.5, return3d: 1.2, return5d: 0.8 },
          { symbol: "NVDA", date: "2024-11-20", sentiment: 0.85, return1d: 5.2, return3d: 8.1, return5d: 7.5 },
          { symbol: "META", date: "2024-10-30", sentiment: 0.78, return1d: 3.5, return3d: 5.8, return5d: 4.9 },
          { symbol: "AMZN", date: "2024-10-31", sentiment: 0.62, return1d: 1.2, return3d: 2.5, return5d: 2.1 },
          { symbol: "TSLA", date: "2024-10-23", sentiment: 0.45, return1d: -2.8, return3d: -4.2, return5d: -3.5 },
          { symbol: "AMD", date: "2024-10-29", sentiment: 0.58, return1d: 0.8, return3d: 1.5, return5d: 1.2 }
        ],
        insights: [
          "Guidance strength shows the strongest predictive power for 3-day returns (r=0.48, p<0.01)",
          "Management optimism is a reliable indicator, especially for tech stocks",
          "Bearish signals have lower accuracy but higher magnitude returns",
          "The 3-day timeframe consistently shows the strongest correlations",
          "Analyst satisfaction has weaker predictive power than management tone"
        ]
      };
    }),
    // Calculate correlation between two arrays
    calculateCorrelation: protectedProcedure.input(z2.object({
      sentimentScores: z2.array(z2.number()).min(3),
      priceReturns: z2.array(z2.number()).min(3)
    })).mutation(async ({ input }) => {
      const { SentimentPriceCorrelation: SentimentPriceCorrelation3 } = await Promise.resolve().then(() => (init_SentimentPriceCorrelation(), SentimentPriceCorrelation_exports));
      const engine = new SentimentPriceCorrelation3();
      return engine.calculateCorrelation(input.sentimentScores, input.priceReturns);
    })
  }),
  // ==================== SEC EDGAR FILINGS ====================
  secFilings: router({
    // List SEC filings for a ticker
    list: protectedProcedure.input(z2.object({
      ticker: z2.string().min(1).max(10),
      limit: z2.number().min(1).max(50).default(20)
    })).query(async ({ input }) => {
      return enhancedFundamentalAnalyst.listFilings(input.ticker, input.limit);
    }),
    // Get filing summary
    getSummary: protectedProcedure.input(z2.object({
      ticker: z2.string().min(1).max(10),
      filingType: z2.enum(["10-K", "10-Q"]).default("10-K")
    })).query(async ({ input }) => {
      return enhancedFundamentalAnalyst.getFilingSummary(input.ticker, input.filingType);
    }),
    // Get XBRL financial metrics
    getMetrics: protectedProcedure.input(z2.object({
      ticker: z2.string().min(1).max(10)
    })).query(async ({ input }) => {
      return enhancedFundamentalAnalyst.getFinancialMetrics(input.ticker);
    }),
    // Ask a question about filings
    askQuestion: protectedProcedure.input(z2.object({
      ticker: z2.string().min(1).max(10),
      question: z2.string().min(1).max(500)
    })).mutation(async ({ input }) => {
      return enhancedFundamentalAnalyst.askQuestion(input.ticker, input.question);
    }),
    // Run enhanced fundamental analysis
    analyze: protectedProcedure.input(z2.object({
      ticker: z2.string().min(1).max(10)
    })).mutation(async ({ input }) => {
      return enhancedFundamentalAnalyst.analyze(input.ticker);
    }),
    // Run deep dive analysis
    deepDive: protectedProcedure.input(z2.object({
      ticker: z2.string().min(1).max(10),
      focusAreas: z2.array(z2.enum(["risk_factors", "mda", "business", "financials", "compensation"])).optional(),
      compareYoY: z2.boolean().optional(),
      specificQuestions: z2.array(z2.string()).optional()
    })).mutation(async ({ input }) => {
      return enhancedFundamentalAnalyst.deepDive({
        ticker: input.ticker,
        focusAreas: input.focusAreas,
        compareYoY: input.compareYoY,
        specificQuestions: input.specificQuestions
      });
    }),
    // Get company info from SEC
    getCompanyInfo: protectedProcedure.input(z2.object({
      ticker: z2.string().min(1).max(10)
    })).query(async ({ input }) => {
      const cik = await secEdgarService.getCIKByTicker(input.ticker);
      if (!cik) return null;
      const submissions = await secEdgarService.getCompanySubmissions(cik);
      return submissions?.companyInfo || null;
    })
  }),
  // ==================== AI COMMAND CENTER ====================
  commandCenter: router({
    // Get summary dashboard data
    getSummary: protectedProcedure.query(async () => {
      return commandCenterDataService.getSummary();
    }),
    // Get all agent statuses
    getAgentStatuses: protectedProcedure.query(async () => {
      return commandCenterDataService.getAgentStatuses();
    }),
    // Get aggregated signals with optional filters
    getSignals: protectedProcedure.input(z2.object({
      assetClass: z2.string().optional(),
      direction: z2.enum(["bullish", "bearish", "neutral"]).optional(),
      minConfidence: z2.number().min(0).max(100).optional(),
      source: z2.string().optional()
    }).optional()).query(async ({ input }) => {
      return commandCenterDataService.getAggregatedSignals(input);
    }),
    // Get portfolio metrics
    getPortfolioMetrics: protectedProcedure.query(async () => {
      return commandCenterDataService.getPortfolioMetrics();
    }),
    // Get pending actions
    getPendingActions: protectedProcedure.query(async () => {
      return commandCenterDataService.getPendingActions();
    }),
    // Execute a signal
    executeSignal: protectedProcedure.input(z2.object({
      signalId: z2.string(),
      size: z2.enum(["small", "medium", "large"]).optional(),
      orderType: z2.enum(["market", "limit"]).optional(),
      limitPrice: z2.number().optional()
    })).mutation(async ({ input }) => {
      return commandCenterDataService.executeSignal(input.signalId, {
        size: input.size,
        orderType: input.orderType,
        limitPrice: input.limitPrice
      });
    }),
    // Process voice command
    processVoiceCommand: protectedProcedure.input(z2.object({
      command: z2.string().min(1).max(500)
    })).mutation(async ({ input }) => {
      return commandCenterDataService.processVoiceCommand(input.command);
    }),
    // Approve pending action
    approveAction: protectedProcedure.input(z2.object({
      actionId: z2.string()
    })).mutation(async ({ input }) => {
      return commandCenterDataService.approveAction(input.actionId);
    }),
    // Reject pending action
    rejectAction: protectedProcedure.input(z2.object({
      actionId: z2.string(),
      reason: z2.string().optional()
    })).mutation(async ({ input }) => {
      return commandCenterDataService.rejectAction(input.actionId, input.reason);
    })
  })
});

// server/_core/context.ts
async function createContext(opts) {
  let user = null;
  try {
    user = await sdk.authenticateRequest(opts.req);
  } catch (error) {
    user = null;
  }
  return {
    req: opts.req,
    res: opts.res,
    user
  };
}

// server/_core/vite.ts
import express from "express";
import fs from "fs";
import { nanoid } from "nanoid";
import path2 from "path";
import { createServer as createViteServer } from "vite";

// vite.config.ts
import { jsxLocPlugin } from "@builder.io/vite-plugin-jsx-loc";
import tailwindcss from "@tailwindcss/vite";
import react from "@vitejs/plugin-react";
import path from "path";
import { defineConfig } from "vite";
import { vitePluginManusRuntime } from "vite-plugin-manus-runtime";
var plugins = [react(), tailwindcss(), jsxLocPlugin(), vitePluginManusRuntime()];
var vite_config_default = defineConfig({
  plugins,
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  envDir: path.resolve(import.meta.dirname),
  root: path.resolve(import.meta.dirname, "client"),
  publicDir: path.resolve(import.meta.dirname, "client", "public"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    host: true,
    allowedHosts: [
      ".manuspre.computer",
      ".manus.computer",
      ".manus-asia.computer",
      ".manuscomputer.ai",
      ".manusvm.computer",
      "localhost",
      "127.0.0.1"
    ],
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/_core/vite.ts
async function setupVite(app, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    server: serverOptions,
    appType: "custom"
  });
  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "../..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app) {
  const distPath = process.env.NODE_ENV === "development" ? path2.resolve(import.meta.dirname, "../..", "dist", "public") : path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    console.error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app.use(express.static(distPath));
  app.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/_core/index.ts
init_websocket();

// server/services/jobScheduler.ts
init_db();
init_schema();
import { eq as eq17, and as and17, lte as lte9, desc as desc14 } from "drizzle-orm";

// server/services/emailService.ts
init_db();
init_schema();
import { eq as eq15, and as and15, lte as lte7 } from "drizzle-orm";
var defaultTemplates = {
  bot_execution_complete: {
    subject: "\u2705 Bot Execution Complete: {{botName}}",
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #22c55e;">Bot Execution Complete</h2>
        <p>Your trading bot <strong>{{botName}}</strong> has completed its scheduled execution.</p>
        <div style="background: #f3f4f6; padding: 16px; border-radius: 8px; margin: 16px 0;">
          <p><strong>Execution Time:</strong> {{executionTime}}</p>
          <p><strong>Trades Executed:</strong> {{tradesExecuted}}</p>
          <p><strong>Profit/Loss:</strong> {{profitLoss}}</p>
          <p><strong>Status:</strong> {{status}}</p>
        </div>
        <a href="{{dashboardUrl}}" style="display: inline-block; background: #22c55e; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px;">View Details</a>
      </div>
    `,
    text: "Bot Execution Complete: {{botName}}\n\nYour trading bot has completed its scheduled execution.\n\nExecution Time: {{executionTime}}\nTrades Executed: {{tradesExecuted}}\nProfit/Loss: {{profitLoss}}\nStatus: {{status}}\n\nView details at: {{dashboardUrl}}",
    variables: ["botName", "executionTime", "tradesExecuted", "profitLoss", "status", "dashboardUrl"]
  },
  bot_execution_error: {
    subject: "\u26A0\uFE0F Bot Execution Error: {{botName}}",
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #ef4444;">Bot Execution Error</h2>
        <p>Your trading bot <strong>{{botName}}</strong> encountered an error during execution.</p>
        <div style="background: #fef2f2; padding: 16px; border-radius: 8px; margin: 16px 0; border-left: 4px solid #ef4444;">
          <p><strong>Error:</strong> {{errorMessage}}</p>
          <p><strong>Time:</strong> {{errorTime}}</p>
        </div>
        <p>Please review your bot configuration and try again.</p>
        <a href="{{dashboardUrl}}" style="display: inline-block; background: #ef4444; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px;">Review Bot</a>
      </div>
    `,
    text: "Bot Execution Error: {{botName}}\n\nYour trading bot encountered an error during execution.\n\nError: {{errorMessage}}\nTime: {{errorTime}}\n\nPlease review your bot configuration at: {{dashboardUrl}}",
    variables: ["botName", "errorMessage", "errorTime", "dashboardUrl"]
  },
  price_target_alert: {
    subject: "\u{1F3AF} Price Alert: {{symbol}} hit {{targetType}} target",
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #3b82f6;">Price Target Alert</h2>
        <p><strong>{{symbol}}</strong> has hit your {{targetType}} price target!</p>
        <div style="background: #eff6ff; padding: 16px; border-radius: 8px; margin: 16px 0;">
          <p><strong>Current Price:</strong> $" + "{{currentPrice}}</p>
          <p><strong>Target Price:</strong> $" + "{{targetPrice}}</p>
          <p><strong>Change:</strong> {{priceChange}}%</p>
        </div>
        <a href="{{analysisUrl}}" style="display: inline-block; background: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px;">View Analysis</a>
      </div>
    `,
    text: "Price Target Alert: {{symbol}}\n\n{{symbol}} has hit your {{targetType}} price target!\n\nCurrent Price: ${{currentPrice}}\nTarget Price: ${{targetPrice}}\nChange: {{priceChange}}%\n\nView analysis at: {{analysisUrl}}",
    variables: ["symbol", "targetType", "currentPrice", "targetPrice", "priceChange", "analysisUrl"]
  },
  recommendation_change: {
    subject: "\u{1F4CA} Recommendation Change: {{symbol}} - {{newRecommendation}}",
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #8b5cf6;">AI Recommendation Changed</h2>
        <p>The AI consensus for <strong>{{symbol}}</strong> has changed.</p>
        <div style="background: #f5f3ff; padding: 16px; border-radius: 8px; margin: 16px 0;">
          <p><strong>Previous:</strong> {{previousRecommendation}} ({{previousConfidence}}% confidence)</p>
          <p><strong>New:</strong> {{newRecommendation}} ({{newConfidence}}% confidence)</p>
        </div>
        <p>Key factors:</p>
        <ul>
          {{#factors}}
          <li>{{.}}</li>
          {{/factors}}
        </ul>
        <a href="{{analysisUrl}}" style="display: inline-block; background: #8b5cf6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px;">View Full Analysis</a>
      </div>
    `,
    text: "AI Recommendation Changed: {{symbol}}\n\nPrevious: {{previousRecommendation}} ({{previousConfidence}}% confidence)\nNew: {{newRecommendation}} ({{newConfidence}}% confidence)\n\nView full analysis at: {{analysisUrl}}",
    variables: ["symbol", "previousRecommendation", "previousConfidence", "newRecommendation", "newConfidence", "factors", "analysisUrl"]
  },
  weekly_report: {
    subject: "\u{1F4C8} Your Weekly Trading Report - {{weekRange}}",
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #22c55e;">Weekly Performance Report</h2>
        <p>Here's your trading performance for {{weekRange}}</p>
        <div style="background: #f0fdf4; padding: 16px; border-radius: 8px; margin: 16px 0;">
          <h3>Performance Summary</h3>
          <p><strong>Total Trades:</strong> {{totalTrades}}</p>
          <p><strong>Win Rate:</strong> {{winRate}}%</p>
          <p><strong>Net P/L:</strong> {{netProfitLoss}}</p>
          <p><strong>Return:</strong> {{percentReturn}}%</p>
        </div>
        <div style="background: #f3f4f6; padding: 16px; border-radius: 8px; margin: 16px 0;">
          <h3>AI Accuracy</h3>
          <p><strong>Predictions:</strong> {{totalPredictions}}</p>
          <p><strong>Accuracy:</strong> {{predictionAccuracy}}%</p>
        </div>
        <a href="{{reportUrl}}" style="display: inline-block; background: #22c55e; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px;">View Full Report</a>
      </div>
    `,
    text: "Weekly Performance Report - {{weekRange}}\n\nTotal Trades: {{totalTrades}}\nWin Rate: {{winRate}}%\nNet P/L: {{netProfitLoss}}\nReturn: {{percentReturn}}%\n\nAI Accuracy: {{predictionAccuracy}}%\n\nView full report at: {{reportUrl}}",
    variables: ["weekRange", "totalTrades", "winRate", "netProfitLoss", "percentReturn", "totalPredictions", "predictionAccuracy", "reportUrl"]
  },
  monthly_report: {
    subject: "\u{1F4CA} Your Monthly Trading Report - {{monthYear}}",
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #3b82f6;">Monthly Performance Report</h2>
        <p>Here's your trading performance for {{monthYear}}</p>
        <div style="background: #eff6ff; padding: 16px; border-radius: 8px; margin: 16px 0;">
          <h3>Performance Summary</h3>
          <p><strong>Total Trades:</strong> {{totalTrades}}</p>
          <p><strong>Win Rate:</strong> {{winRate}}%</p>
          <p><strong>Net P/L:</strong> {{netProfitLoss}}</p>
          <p><strong>Return:</strong> {{percentReturn}}%</p>
          <p><strong>vs S&P 500:</strong> {{benchmarkComparison}}</p>
        </div>
        <div style="background: #f3f4f6; padding: 16px; border-radius: 8px; margin: 16px 0;">
          <h3>AI Performance</h3>
          <p><strong>Predictions:</strong> {{totalPredictions}}</p>
          <p><strong>Accuracy:</strong> {{predictionAccuracy}}%</p>
          <p><strong>Best Agent:</strong> {{bestAgent}}</p>
        </div>
        <a href="{{reportUrl}}" style="display: inline-block; background: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px;">View Full Report</a>
      </div>
    `,
    text: "Monthly Performance Report - {{monthYear}}\n\nTotal Trades: {{totalTrades}}\nWin Rate: {{winRate}}%\nNet P/L: {{netProfitLoss}}\nReturn: {{percentReturn}}%\nvs S&P 500: {{benchmarkComparison}}\n\nAI Accuracy: {{predictionAccuracy}}%\nBest Agent: {{bestAgent}}\n\nView full report at: {{reportUrl}}",
    variables: ["monthYear", "totalTrades", "winRate", "netProfitLoss", "percentReturn", "benchmarkComparison", "totalPredictions", "predictionAccuracy", "bestAgent", "reportUrl"]
  },
  welcome: {
    subject: "\u{1F680} Welcome to TradoVerse!",
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #22c55e;">Welcome to TradoVerse!</h2>
        <p>Hi {{userName}},</p>
        <p>Welcome to the future of AI-powered trading! You now have access to our 7-agent AI consensus system.</p>
        <div style="background: #f0fdf4; padding: 16px; border-radius: 8px; margin: 16px 0;">
          <h3>Getting Started</h3>
          <ol>
            <li>Run your first AI analysis</li>
            <li>Create a trading bot</li>
            <li>Set up price alerts</li>
            <li>Explore the marketplace</li>
          </ol>
        </div>
        <a href="{{dashboardUrl}}" style="display: inline-block; background: #22c55e; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px;">Go to Dashboard</a>
      </div>
    `,
    text: "Welcome to TradoVerse!\n\nHi {{userName}},\n\nWelcome to the future of AI-powered trading!\n\nGetting Started:\n1. Run your first AI analysis\n2. Create a trading bot\n3. Set up price alerts\n4. Explore the marketplace\n\nGo to dashboard: {{dashboardUrl}}",
    variables: ["userName", "dashboardUrl"]
  },
  password_reset: {
    subject: "\u{1F510} Reset Your TradoVerse Password",
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #3b82f6;">Password Reset Request</h2>
        <p>We received a request to reset your password.</p>
        <a href="{{resetUrl}}" style="display: inline-block; background: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px;">Reset Password</a>
        <p style="margin-top: 16px; color: #6b7280; font-size: 14px;">This link expires in 1 hour. If you didn't request this, please ignore this email.</p>
      </div>
    `,
    text: "Password Reset Request\n\nWe received a request to reset your password.\n\nReset your password at: {{resetUrl}}\n\nThis link expires in 1 hour. If you didn't request this, please ignore this email.",
    variables: ["resetUrl"]
  }
};
function replaceVariables(template, variables) {
  let result = template;
  for (const [key, value] of Object.entries(variables)) {
    if (Array.isArray(value)) {
      const listHtml = value.map((item) => `<li>${item}</li>`).join("");
      result = result.replace(new RegExp(`{{#${key}}}[\\s\\S]*?{{/${key}}}`, "g"), listHtml);
    } else {
      result = result.replace(new RegExp(`{{${key}}}`, "g"), String(value));
    }
  }
  return result;
}
var EmailService = class {
  // Get user email preferences
  async getUserPreferences(userId) {
    const db = await getDb();
    if (!db) throw new Error("Database not available");
    const [prefs] = await db.select().from(userEmailPreferences).where(eq15(userEmailPreferences.userId, userId));
    if (!prefs) {
      const [newPrefs] = await db.insert(userEmailPreferences).values({ userId }).$returningId();
      return {
        id: newPrefs.id,
        userId,
        botExecutionComplete: true,
        botExecutionError: true,
        priceTargetAlert: true,
        recommendationChange: true,
        weeklyReport: true,
        monthlyReport: true,
        marketingEmails: false,
        digestFrequency: "immediate",
        quietHoursStart: null,
        quietHoursEnd: null,
        timezone: "UTC",
        isUnsubscribed: false
      };
    }
    return prefs;
  }
  // Update user email preferences
  async updateUserPreferences(userId, updates) {
    const db = await getDb();
    if (!db) throw new Error("Database not available");
    await db.update(userEmailPreferences).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq15(userEmailPreferences.userId, userId));
  }
  // Queue an email
  async queueEmail(params) {
    const template = defaultTemplates[params.templateKey];
    if (!template) {
      throw new Error(`Unknown email template: ${params.templateKey}`);
    }
    const subject = replaceVariables(template.subject, params.variables);
    const htmlContent = replaceVariables(template.html, params.variables);
    const textContent = replaceVariables(template.text, params.variables);
    const db = await getDb();
    if (!db) throw new Error("Database not available");
    const [result] = await db.insert(emailQueue).values({
      userId: params.userId,
      toEmail: params.toEmail,
      subject,
      htmlContent,
      textContent,
      templateVariables: params.variables,
      priority: params.priority || "normal",
      scheduledAt: params.scheduledAt || /* @__PURE__ */ new Date(),
      status: "pending"
    }).$returningId();
    return result.id;
  }
  // Send bot execution complete notification
  async sendBotExecutionComplete(params) {
    const prefs = await this.getUserPreferences(params.userId);
    if (!prefs.botExecutionComplete || prefs.isUnsubscribed) return;
    return this.queueEmail({
      userId: params.userId,
      toEmail: params.userEmail,
      templateKey: "bot_execution_complete",
      variables: {
        botName: params.botName,
        executionTime: params.executionTime,
        tradesExecuted: params.tradesExecuted,
        profitLoss: params.profitLoss,
        status: params.status,
        dashboardUrl: params.dashboardUrl
      },
      priority: "normal"
    });
  }
  // Send bot execution error notification
  async sendBotExecutionError(params) {
    const prefs = await this.getUserPreferences(params.userId);
    if (!prefs.botExecutionError || prefs.isUnsubscribed) return;
    return this.queueEmail({
      userId: params.userId,
      toEmail: params.userEmail,
      templateKey: "bot_execution_error",
      variables: {
        botName: params.botName,
        errorMessage: params.errorMessage,
        errorTime: params.errorTime,
        dashboardUrl: params.dashboardUrl
      },
      priority: "high"
    });
  }
  // Send price target alert
  async sendPriceTargetAlert(params) {
    const prefs = await this.getUserPreferences(params.userId);
    if (!prefs.priceTargetAlert || prefs.isUnsubscribed) return;
    const db = await getDb();
    if (!db) throw new Error("Database not available");
    await db.insert(alertHistory).values({
      userId: params.userId,
      alertId: 0,
      // System-generated alert
      alertType: "price_target",
      symbol: params.symbol,
      title: `Price ${params.targetType} target hit for ${params.symbol}`,
      message: `${params.symbol} hit your ${params.targetType} price target of $${params.targetPrice}. Current price: $${params.currentPrice}`,
      previousValue: String(params.targetPrice),
      newValue: String(params.currentPrice),
      emailSent: true
    });
    return this.queueEmail({
      userId: params.userId,
      toEmail: params.userEmail,
      templateKey: "price_target_alert",
      variables: {
        symbol: params.symbol,
        targetType: params.targetType,
        currentPrice: params.currentPrice.toFixed(2),
        targetPrice: params.targetPrice.toFixed(2),
        priceChange: params.priceChange.toFixed(2),
        analysisUrl: params.analysisUrl
      },
      priority: "high"
    });
  }
  // Send recommendation change alert
  async sendRecommendationChange(params) {
    const prefs = await this.getUserPreferences(params.userId);
    if (!prefs.recommendationChange || prefs.isUnsubscribed) return;
    const db2 = await getDb();
    if (!db2) throw new Error("Database not available");
    await db2.insert(alertHistory).values({
      userId: params.userId,
      alertId: 0,
      // System-generated alert
      alertType: "recommendation_change",
      symbol: params.symbol,
      title: `Recommendation changed for ${params.symbol}`,
      message: `AI recommendation for ${params.symbol} changed from ${params.previousRecommendation} to ${params.newRecommendation}`,
      previousValue: params.previousRecommendation,
      newValue: params.newRecommendation,
      emailSent: true
    });
    return this.queueEmail({
      userId: params.userId,
      toEmail: params.userEmail,
      templateKey: "recommendation_change",
      variables: {
        symbol: params.symbol,
        previousRecommendation: params.previousRecommendation,
        previousConfidence: Math.round(params.previousConfidence * 100),
        newRecommendation: params.newRecommendation,
        newConfidence: Math.round(params.newConfidence * 100),
        factors: params.factors,
        analysisUrl: params.analysisUrl
      },
      priority: "normal"
    });
  }
  // Process email queue (called by background job)
  async processEmailQueue(batchSize = 10) {
    const db = await getDb();
    if (!db) throw new Error("Database not available");
    const now = /* @__PURE__ */ new Date();
    const pendingEmails = await db.select().from(emailQueue).where(
      and15(
        eq15(emailQueue.status, "pending"),
        lte7(emailQueue.scheduledAt, now)
      )
    ).limit(batchSize);
    const results = [];
    for (const email of pendingEmails) {
      try {
        await db.update(emailQueue).set({ status: "processing", lastAttemptAt: now }).where(eq15(emailQueue.id, email.id));
        const sent = await notifyOwner({
          title: `Email: ${email.subject}`,
          content: email.textContent || email.htmlContent
        });
        if (sent) {
          await db.update(emailQueue).set({
            status: "sent",
            sentAt: now,
            attempts: email.attempts + 1
          }).where(eq15(emailQueue.id, email.id));
          results.push({ id: email.id, status: "sent" });
        } else {
          throw new Error("Failed to send notification");
        }
      } catch (error) {
        const attempts = email.attempts + 1;
        const status = attempts >= email.maxAttempts ? "failed" : "pending";
        await db.update(emailQueue).set({
          status,
          attempts,
          lastAttemptAt: now,
          errorMessage: error instanceof Error ? error.message : "Unknown error"
        }).where(eq15(emailQueue.id, email.id));
        results.push({ id: email.id, status, error: error instanceof Error ? error.message : "Unknown error" });
      }
    }
    return results;
  }
  // Get email queue status
  async getQueueStatus() {
    const db = await getDb();
    if (!db) return { pending: 0, processing: 0, failed: 0 };
    const { count: count2 } = await import("drizzle-orm");
    const [pending] = await db.select({ count: count2() }).from(emailQueue).where(eq15(emailQueue.status, "pending"));
    const [processing] = await db.select({ count: count2() }).from(emailQueue).where(eq15(emailQueue.status, "processing"));
    const [failed] = await db.select({ count: count2() }).from(emailQueue).where(eq15(emailQueue.status, "failed"));
    return {
      pending: pending?.count || 0,
      processing: processing?.count || 0,
      failed: failed?.count || 0
    };
  }
};
var emailService = new EmailService();

// server/services/jobScheduler.ts
var jobProcessors = {
  bot_execution: async (payload) => {
    const db = await getDb();
    if (!db) return { success: false, message: "Database not available" };
    const { botId, userId, scheduleId } = payload;
    if (!botId || !userId) {
      return { success: false, message: "Missing botId or userId" };
    }
    const [bot] = await db.select().from(tradingBots).where(eq17(tradingBots.id, botId));
    if (!bot) {
      return { success: false, message: "Bot not found" };
    }
    const [logEntry] = await db.insert(botExecutionLogs).values({
      botId,
      userId,
      scheduleId: scheduleId || null,
      executionType: scheduleId ? "scheduled" : "manual",
      status: "running",
      startedAt: /* @__PURE__ */ new Date()
    }).$returningId();
    try {
      const executionResult = await executeBotLogic(bot);
      await db.update(botExecutionLogs).set({
        status: "completed",
        completedAt: /* @__PURE__ */ new Date(),
        tradesExecuted: executionResult.tradesExecuted,
        pnlResult: String(executionResult.profitLoss),
        analysisResults: executionResult.details
      }).where(eq17(botExecutionLogs.id, logEntry.id));
      const [user] = await db.select().from(users).where(eq17(users.id, userId));
      if (user?.email) {
        await emailService.sendBotExecutionComplete({
          userId,
          userEmail: user.email,
          botName: bot.name,
          executionTime: (/* @__PURE__ */ new Date()).toISOString(),
          tradesExecuted: executionResult.tradesExecuted,
          profitLoss: `$${executionResult.profitLoss.toFixed(2)}`,
          status: "completed",
          dashboardUrl: "/dashboard/bots"
        });
      }
      return {
        success: true,
        message: `Bot ${bot.name} executed successfully`,
        data: executionResult,
        itemsProcessed: executionResult.tradesExecuted
      };
    } catch (error) {
      await db.update(botExecutionLogs).set({
        status: "failed",
        completedAt: /* @__PURE__ */ new Date(),
        errorMessage: error instanceof Error ? error.message : "Unknown error"
      }).where(eq17(botExecutionLogs.id, logEntry.id));
      const [user] = await db.select().from(users).where(eq17(users.id, userId));
      if (user?.email) {
        await emailService.sendBotExecutionError({
          userId,
          userEmail: user.email,
          botName: bot.name,
          errorMessage: error instanceof Error ? error.message : "Unknown error",
          errorTime: (/* @__PURE__ */ new Date()).toISOString(),
          dashboardUrl: "/dashboard/bots"
        });
      }
      return {
        success: false,
        message: error instanceof Error ? error.message : "Bot execution failed"
      };
    }
  },
  price_tracking: async (_payload) => {
    const { runPriceTrackingJob: runPriceTrackingJob2 } = await Promise.resolve().then(() => (init_priceTrackingService(), priceTrackingService_exports));
    const result = await runPriceTrackingJob2();
    return {
      success: result.success,
      message: result.details.join("; "),
      itemsProcessed: result.tracked
    };
  },
  accuracy_calculation: async (_payload) => {
    const { calculatePredictionAccuracy: calculatePredictionAccuracy2 } = await Promise.resolve().then(() => (init_priceTrackingService(), priceTrackingService_exports));
    const result = await calculatePredictionAccuracy2();
    return {
      success: result.success,
      message: result.details.join("; "),
      itemsProcessed: result.tracked
    };
  },
  weekly_report: async (payload) => {
    const db = await getDb();
    if (!db) return { success: false, message: "Database not available" };
    const { userId } = payload;
    if (!userId) {
      return { success: false, message: "Missing userId" };
    }
    const weekAgo = /* @__PURE__ */ new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);
    const [user] = await db.select().from(users).where(eq17(users.id, userId));
    if (!user) {
      return { success: false, message: "User not found" };
    }
    const report = {
      totalTrades: Math.floor(Math.random() * 50),
      winRate: 0.5 + Math.random() * 0.3,
      netProfitLoss: (Math.random() - 0.5) * 1e4,
      percentReturn: (Math.random() - 0.5) * 20,
      totalPredictions: Math.floor(Math.random() * 100),
      predictionAccuracy: 0.6 + Math.random() * 0.3
    };
    const [reportEntry] = await db.insert(performanceReports).values({
      userId,
      reportType: "weekly",
      periodStart: weekAgo,
      periodEnd: /* @__PURE__ */ new Date(),
      totalTrades: report.totalTrades,
      winningTrades: Math.floor(report.totalTrades * report.winRate),
      losingTrades: Math.floor(report.totalTrades * (1 - report.winRate)),
      winRate: String(report.winRate),
      totalProfitLoss: String(report.netProfitLoss),
      percentageReturn: String(report.percentReturn),
      totalPredictions: report.totalPredictions,
      correctPredictions: Math.floor(report.totalPredictions * report.predictionAccuracy),
      predictionAccuracy: String(report.predictionAccuracy)
    }).$returningId();
    if (user.email) {
      await emailService.queueEmail({
        userId,
        toEmail: user.email,
        templateKey: "weekly_report",
        variables: {
          weekRange: `${weekAgo.toLocaleDateString()} - ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`,
          totalTrades: report.totalTrades,
          winRate: (report.winRate * 100).toFixed(1),
          netProfitLoss: `$${report.netProfitLoss.toFixed(2)}`,
          percentReturn: report.percentReturn.toFixed(2),
          totalPredictions: report.totalPredictions,
          predictionAccuracy: (report.predictionAccuracy * 100).toFixed(1),
          reportUrl: `/reports/${reportEntry.id}`
        }
      });
    }
    return {
      success: true,
      message: "Weekly report generated",
      data: { reportId: reportEntry.id },
      itemsProcessed: 1
    };
  },
  monthly_report: async (payload) => {
    const db = await getDb();
    if (!db) return { success: false, message: "Database not available" };
    const { userId } = payload;
    if (!userId) {
      return { success: false, message: "Missing userId" };
    }
    const monthAgo = /* @__PURE__ */ new Date();
    monthAgo.setMonth(monthAgo.getMonth() - 1);
    const [user] = await db.select().from(users).where(eq17(users.id, userId));
    if (!user) {
      return { success: false, message: "User not found" };
    }
    const report = {
      totalTrades: Math.floor(Math.random() * 200),
      winRate: 0.5 + Math.random() * 0.3,
      netProfitLoss: (Math.random() - 0.5) * 5e4,
      percentReturn: (Math.random() - 0.5) * 50,
      totalPredictions: Math.floor(Math.random() * 400),
      predictionAccuracy: 0.6 + Math.random() * 0.3,
      benchmarkReturn: (Math.random() - 0.5) * 10
    };
    const [reportEntry] = await db.insert(performanceReports).values({
      userId,
      reportType: "monthly",
      periodStart: monthAgo,
      periodEnd: /* @__PURE__ */ new Date(),
      totalTrades: report.totalTrades,
      winningTrades: Math.floor(report.totalTrades * report.winRate),
      losingTrades: Math.floor(report.totalTrades * (1 - report.winRate)),
      winRate: String(report.winRate),
      totalProfitLoss: String(report.netProfitLoss),
      percentageReturn: String(report.percentReturn),
      totalPredictions: report.totalPredictions,
      correctPredictions: Math.floor(report.totalPredictions * report.predictionAccuracy),
      predictionAccuracy: String(report.predictionAccuracy),
      benchmarkReturn: String(report.benchmarkReturn),
      alphaGenerated: String(report.percentReturn - report.benchmarkReturn)
    }).$returningId();
    if (user.email) {
      await emailService.queueEmail({
        userId,
        toEmail: user.email,
        templateKey: "monthly_report",
        variables: {
          monthYear: monthAgo.toLocaleDateString("en-US", { month: "long", year: "numeric" }),
          totalTrades: report.totalTrades,
          winRate: (report.winRate * 100).toFixed(1),
          netProfitLoss: `$${report.netProfitLoss.toFixed(2)}`,
          percentReturn: report.percentReturn.toFixed(2),
          benchmarkComparison: `${report.percentReturn > report.benchmarkReturn ? "+" : ""}${(report.percentReturn - report.benchmarkReturn).toFixed(2)}%`,
          totalPredictions: report.totalPredictions,
          predictionAccuracy: (report.predictionAccuracy * 100).toFixed(1),
          bestAgent: "Technical Analyst",
          reportUrl: `/reports/${reportEntry.id}`
        }
      });
    }
    return {
      success: true,
      message: "Monthly report generated",
      data: { reportId: reportEntry.id },
      itemsProcessed: 1
    };
  },
  watchlist_check: async (payload) => {
    return { success: true, message: "Watchlist check completed", itemsProcessed: 0 };
  },
  email_send: async () => {
    const results = await emailService.processEmailQueue(10);
    return {
      success: true,
      message: `Processed ${results.length} emails`,
      itemsProcessed: results.length
    };
  },
  cleanup: async () => {
    const db = await getDb();
    if (!db) return { success: false, message: "Database not available" };
    const thirtyDaysAgo = /* @__PURE__ */ new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    await db.delete(jobHistory).where(lte9(jobHistory.createdAt, thirtyDaysAgo));
    return { success: true, message: "Cleanup completed", itemsProcessed: 1 };
  }
};
async function executeBotLogic(bot) {
  const tradesExecuted = Math.floor(Math.random() * 5);
  const profitLoss = (Math.random() - 0.5) * 1e3;
  return {
    tradesExecuted,
    profitLoss,
    details: {
      strategy: bot.strategy,
      symbols: bot.symbols,
      executedAt: (/* @__PURE__ */ new Date()).toISOString()
    }
  };
}
var JobScheduler = class {
  isRunning = false;
  pollInterval = null;
  workerId;
  constructor() {
    this.workerId = `worker-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  // Start the job scheduler
  start(intervalMs = 1e4) {
    if (this.isRunning) return;
    this.isRunning = true;
    console.log(`[JobScheduler] Starting with worker ID: ${this.workerId}`);
    this.pollInterval = setInterval(() => {
      this.processJobs();
    }, intervalMs);
    this.processJobs();
  }
  // Stop the job scheduler
  stop() {
    this.isRunning = false;
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = null;
    }
    console.log("[JobScheduler] Stopped");
  }
  // Process pending jobs
  async processJobs() {
    const db = await getDb();
    if (!db) return;
    const now = /* @__PURE__ */ new Date();
    const pendingJobs = await db.select().from(backgroundJobs).where(
      and17(
        eq17(backgroundJobs.status, "pending"),
        lte9(backgroundJobs.scheduledAt, now)
      )
    ).orderBy(backgroundJobs.priority, backgroundJobs.scheduledAt).limit(5);
    for (const job of pendingJobs) {
      await this.executeJob(job);
    }
    await this.checkScheduledBots();
  }
  // Execute a single job
  async executeJob(job) {
    const db = await getDb();
    if (!db) return;
    const startTime = Date.now();
    try {
      await db.update(backgroundJobs).set({
        status: "running",
        startedAt: /* @__PURE__ */ new Date(),
        workerId: this.workerId,
        attempts: job.attempts + 1
      }).where(eq17(backgroundJobs.id, job.id));
      const processor = jobProcessors[job.jobType];
      if (!processor) {
        throw new Error(`Unknown job type: ${job.jobType}`);
      }
      const result = await processor(job.payload);
      await db.update(backgroundJobs).set({
        status: "completed",
        completedAt: /* @__PURE__ */ new Date(),
        result
      }).where(eq17(backgroundJobs.id, job.id));
      await db.insert(jobHistory).values({
        jobId: job.id,
        jobType: job.jobType,
        status: "completed",
        startedAt: new Date(startTime),
        completedAt: /* @__PURE__ */ new Date(),
        durationMs: Date.now() - startTime,
        payload: job.payload,
        result,
        itemsProcessed: result.itemsProcessed || 0
      });
      console.log(`[JobScheduler] Job ${job.id} (${job.jobType}) completed in ${Date.now() - startTime}ms`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      const shouldRetry = job.attempts + 1 < job.maxAttempts;
      await db.update(backgroundJobs).set({
        status: shouldRetry ? "pending" : "failed",
        completedAt: shouldRetry ? null : /* @__PURE__ */ new Date(),
        errorMessage
      }).where(eq17(backgroundJobs.id, job.id));
      await db.insert(jobHistory).values({
        jobId: job.id,
        jobType: job.jobType,
        status: "failed",
        startedAt: new Date(startTime),
        completedAt: /* @__PURE__ */ new Date(),
        durationMs: Date.now() - startTime,
        payload: job.payload,
        errorMessage,
        itemsProcessed: 0
      });
      console.error(`[JobScheduler] Job ${job.id} (${job.jobType}) failed: ${errorMessage}`);
    }
  }
  // Check for scheduled bot executions
  async checkScheduledBots() {
    const db = await getDb();
    if (!db) return;
    const now = /* @__PURE__ */ new Date();
    const dueSchedules = await db.select().from(botSchedules).where(
      and17(
        eq17(botSchedules.isActive, true),
        lte9(botSchedules.nextRunAt, now)
      )
    );
    for (const schedule of dueSchedules) {
      await this.scheduleJob("bot_execution", {
        botId: schedule.botId,
        userId: schedule.userId,
        scheduleId: schedule.id
      });
      const nextRun = this.calculateNextRun(schedule);
      await db.update(botSchedules).set({
        lastRunAt: now,
        nextRunAt: nextRun,
        totalRuns: schedule.totalRuns + 1
      }).where(eq17(botSchedules.id, schedule.id));
    }
  }
  // Calculate next run time based on schedule frequency
  calculateNextRun(schedule) {
    const now = /* @__PURE__ */ new Date();
    switch (schedule.scheduleType) {
      case "once":
        return new Date(now.getTime() + 100 * 365 * 24 * 60 * 60 * 1e3);
      // Far future
      // Note: hourly is not in schema, using daily as fallback
      case "daily":
        const dailyNext = new Date(now);
        dailyNext.setDate(dailyNext.getDate() + 1);
        if (schedule.runTime) {
          const [hours, minutes] = schedule.runTime.split(":").map(Number);
          dailyNext.setHours(hours, minutes, 0, 0);
        }
        return dailyNext;
      case "weekly":
        const weeklyNext = new Date(now);
        weeklyNext.setDate(weeklyNext.getDate() + 7);
        if (schedule.runTime) {
          const [hours, minutes] = schedule.runTime.split(":").map(Number);
          weeklyNext.setHours(hours, minutes, 0, 0);
        }
        return weeklyNext;
      case "monthly":
        const monthlyNext = new Date(now);
        monthlyNext.setMonth(monthlyNext.getMonth() + 1);
        if (schedule.runTime) {
          const [hours, minutes] = schedule.runTime.split(":").map(Number);
          monthlyNext.setHours(hours, minutes, 0, 0);
        }
        return monthlyNext;
      case "cron":
        return new Date(now.getTime() + 24 * 60 * 60 * 1e3);
      default:
        return new Date(now.getTime() + 24 * 60 * 60 * 1e3);
    }
  }
  // Schedule a new job
  async scheduleJob(jobType, payload, options = {}) {
    const db = await getDb();
    if (!db) return null;
    const [result] = await db.insert(backgroundJobs).values({
      jobType,
      payload,
      scheduledAt: options.scheduledAt || /* @__PURE__ */ new Date(),
      priority: options.priority || 5,
      maxAttempts: options.maxAttempts || 3,
      status: "pending"
    }).$returningId();
    return result.id;
  }
  // Get job status
  async getJobStatus(jobId) {
    const db = await getDb();
    if (!db) return null;
    const [job] = await db.select().from(backgroundJobs).where(eq17(backgroundJobs.id, jobId));
    return job;
  }
  // Get recent job history
  async getJobHistory(limit = 50) {
    const db = await getDb();
    if (!db) return [];
    return db.select().from(jobHistory).orderBy(desc14(jobHistory.createdAt)).limit(limit);
  }
};
var jobScheduler = new JobScheduler();

// server/_core/index.ts
function isPortAvailable(port) {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.listen(port, () => {
      server.close(() => resolve(true));
    });
    server.on("error", () => resolve(false));
  });
}
async function findAvailablePort(startPort = 3e3) {
  for (let port = startPort; port < startPort + 20; port++) {
    if (await isPortAvailable(port)) {
      return port;
    }
  }
  throw new Error(`No available port found starting from ${startPort}`);
}
async function startServer() {
  const app = express2();
  const server = createServer(app);
  app.use(express2.json({ limit: "50mb" }));
  app.use(express2.urlencoded({ limit: "50mb", extended: true }));
  registerOAuthRoutes(app);
  app.use(
    "/api/trpc",
    createExpressMiddleware({
      router: appRouter,
      createContext
    })
  );
  if (process.env.NODE_ENV === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  initializeWebSocket(server);
  startMarketDataService();
  initializeAlpacaStream();
  const jobScheduler2 = new JobScheduler();
  jobScheduler2.start(6e4);
  console.log("[Server] Background job scheduler started");
  const preferredPort = parseInt(process.env.PORT || "3000");
  const port = await findAvailablePort(preferredPort);
  if (port !== preferredPort) {
    console.log(`Port ${preferredPort} is busy, using port ${port} instead`);
  }
  server.listen(port, () => {
    console.log(`Server running on http://localhost:${port}/`);
  });
}
startServer().catch(console.error);
